<!DOCTYPE html><html lang="en" theme-mode="auto"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>南大《软件分析》课程笔记 | RacerZ</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light' || window.matchMedia('(prefers-color-scheme:light)').matches) document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark' || window.matchMedia('(prefers-color-scheme:dark)').matches) document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><div id="shadow-header"></div><article><div id="post-bg"><div id="post-title"><h1>南大《软件分析》课程笔记</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-01-03T16:00:00.000Z" id="date"> 2023-01-04</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-01-18T08:01:47.532Z" id="updated"> 2023-01-18</time></div></span></div></div><hr><div id="post-content"><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>准备系统的看一下南大《软件分析》课程，系统的入门一下静态分析，好为之后的自动化漏洞挖掘搭好基础，加油坚持</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221205225142826.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221205225142826.png" alt="image-20221205225142826"></p>
<h4 id="01-Introduction"><a href="#01-Introduction" class="headerlink" title="01-Introduction"></a>01-Introduction</h4><p>静态分析：在编译时刻去检验程序存在的相关问题</p>
<p>可以解决的问题</p>
<ol>
<li>程序的可靠性、安全性</li>
<li>编译优化（后端）</li>
<li>帮助程序的理解 -&gt; IDE提示</li>
</ol>
<ul>
<li><p>含义：<strong>想要在程序运行前分析程序，去了解其中的特征和和是否符合一些性质</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221205212225161.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221205212225161.png" alt="image-20221205212225161"></p>
</li>
</ul>
<p>不存在方法可以<strong>准确</strong>的判断程序的性质。换言之，任何递归可枚举语言（现在正常的编程语言）的<code>non-trivial</code>性质都无法判断。</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221205212343653.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221205212343653.png" alt="image-20221205212343653"></p>
<blockquote>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221205212509030.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221205212509030.png" alt="image-20221205212509030"></p>
<p>non-trivial性质：有趣的性质，也就是和程序运行时某些行为相关的</p>
</blockquote>
<ul>
<li><p>完美的静态分析</p>
<ul>
<li>Sound 类似过拟合（包含Truth的情况</li>
<li>Truth 实际真实的特征（例如有10个空指针异常</li>
<li>Complete 存在的肯定在Truth里头</li>
</ul>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221205213014980.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221205213014980.png" alt="image-20221205213014980"></p>
</li>
<li><p>Useful静态分析</p>
<ul>
<li>妥协 sound 会产生漏报</li>
<li>妥协 complete 会产生误报（实际绝大多数方法都是这样）</li>
</ul>
<p><strong>Soundness的必要性</strong></p>
<p>Soundess 对编译优化和程序验证是必不可少的，要考虑所有情况</p>
</li>
</ul>
<p>  <strong>确保或靠近soundness作为前提，在精度和速度之间做有效的平衡</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221205214803070.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221205214803070.png" alt="image-20221205214803070"></p>
<ul>
<li><p>需要什么样的技术</p>
<p>抽象 + Over-approximation(近似)</p>
<ul>
<li><p>抽象</p>
<p>将每一个具体的域值映射到抽象域（分析关注的符号值）中</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221205215555969.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221205215555969.png" alt="image-20221205215555969"></p>
</li>
<li><p>近似 Transfer Function</p>
<p><strong>针对每一个程序语句基于抽象值作转换规则</strong></p>
<p>规则的定义：</p>
<ul>
<li><strong>基于分析的目标，以及程序语句分析的语义</strong></li>
</ul>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221205215932448.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221205215932448.png" alt="image-20221205215932448"></p>
<ul>
<li><p><strong>控制流图</strong></p>
<p>汇聚点要针对语义进行合并（因为不可能枚举所有路径）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="02-Intermediate-Representation"><a href="#02-Intermediate-Representation" class="headerlink" title="02-Intermediate Representation"></a>02-Intermediate Representation</h4><ul>
<li><p>编译器和静态分析器的关系</p>
<p>首先是编译器，先经过词法分析生成记号流（用到正则表达式做规则），进入解析器进行语法分析（上下文无关文法），生成抽象语法树。进而进行语义分析（只能做简单的检查，例如类型检查）。如果还要做代码优化，就需要通过转换器产生IR（通常是三地址码表示），这里也就是静态分析的部分的应用，最终生成机器码交给环境去执行。</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207001709608.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207001709608.png" alt="image-20221207001709608"></p>
</li>
<li><p>AST vs. IR</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221206222933664.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221206222933664.png" alt="image-20221206222933664"></p>
<p>IR特点在于与高级程序语言的无关性，不依赖与语言的特性；并且不存在冗余的信息；<strong>包含控制流的信息</strong></p>
</li>
</ul>
<p><strong>IR</strong></p>
<ul>
<li><p>三地址码 <strong>3AC</strong></p>
<p><strong>定义：</strong>在指令的右侧最多一个操作符</p>
<p>常见指令的3AC</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221206225041587.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221206225041587.png" alt="image-20221206225041587"></p>
</li>
<li><p>Soot</p>
<ul>
<li><p>JVM 四种指令</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221206230941357.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221206230941357.png" alt="image-20221206230941357"></p>
</li>
<li><p>Method Signature：一般包含方法声明所在类，返回值类型（或void），方法名字，参数类型</p>
</li>
<li><p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221206231144192.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221206231144192.png" alt="image-20221206231144192"></p>
</li>
<li><p>clinit： 类的静态的初始化函数。在引用一个变量的时候，会把这个变量加载进来</p>
</li>
</ul>
</li>
</ul>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221206232155025.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221206232155025.png" alt="image-20221206232155025"></p>
<ul>
<li><p>SSA （另一种IR里面的转换格式）</p>
<p>给每一个定义新的name，<strong>每个变量都有一个精确的定义</strong>。专门定义一个函数来作为变量的选择，并作为新的变量名</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221206234209041.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221206234209041.png" alt="image-20221206234209041"></p>
</li>
<li><p>控制流分析 <strong>CFG</strong></p>
<p>给定输入是三字节码</p>
<ul>
<li><p><strong>结点：Basic Blocks</strong></p>
<p>特征定义：满足下列性质的最大的连续三地址码指令</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221206234919212.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221206234919212.png" alt="image-20221206234919212"></p>
<p><strong>如何建立呢？</strong></p>
<p>一个jump的<strong>目标的指令</strong>应该作为一个BB的入口（反证法就会有两个入口）</p>
<p>一条指令<strong>紧跟着jump指令</strong>后头，它应该也作为BB的入口（反证法就会有两个出口）</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221206235707374.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221206235707374.png" alt="image-20221206235707374"></p>
</li>
<li><p><strong>怎样在BB的基础上添加边？</strong></p>
<p>对于有条件跳转的情况，下一条紧跟的BB也要练；无条件的不需要</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207000644095.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207000644095.png" alt="image-20221207000644095"></p>
<p>直接将跳转的<strong>指令标签替换成所在的BB</strong>即可，因为两者的含量信息是一致的</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207001043532.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207001043532.png" alt="image-20221207001043532"></p>
<p>进而产生前趋和后继的概念，之后还要加两个特殊结点（方便程序设计时初始化），可以有多个入边和出边</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207001121541.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207001121541.png" alt="image-20221207001121541"></p>
</li>
</ul>
</li>
</ul>
<h4 id="03-Data-Flow-Analysis-I"><a href="#03-Data-Flow-Analysis-I" class="headerlink" title="03-Data Flow Analysis I"></a>03-Data Flow Analysis I</h4><ul>
<li><p>Data Flow Analysis </p>
<p>Data是如何在CFG上进行流动的？</p>
<p>对于绝大多数的静态分析，我们都尽可能以sound为标准</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207231540410.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207231540410.png" alt="image-20221207231540410"></p>
<p>但是对某些特定分析，需要达到must analysis</p>
</li>
</ul>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207231644790.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207231644790.png" alt="image-20221207231644790"></p>
<p>因此统一称作不同标准对应的safe approximation</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207232433243.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207232433243.png" alt="image-20221207232433243"></p>
<ul>
<li><p>Input and Outout States</p>
<p><code>^</code>代表meet汇聚符号</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207232711358.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207232711358.png" alt="image-20221207232711358"></p>
<p>我们给每个点都关联一个值。该值时程序<strong>状态</strong>的<strong>抽象集合</strong>（我们关注的）</p>
<p>抽象指的是定义能否到达该点的抽象表示（位向量）</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207233709274.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207233709274.png" alt="image-20221207233709274"></p>
<p>值域domain</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207233820605.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207233820605.png" alt="image-20221207233820605"></p>
<p><strong>数据流分析的定义</strong></p>
<p>不停的运用transfer functions 和 控制流在IN 和OUT上，直至找到一个符合safe-approximations标准的解决方案</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207233930626.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207233930626.png" alt="image-20221207233930626"></p>
</li>
<li><p>Transfer functions ‘s constraints</p>
<ul>
<li><p>前向分析</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207234038122.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207234038122.png" alt="image-20221207234038122"></p>
</li>
<li><p>反向分析</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207234114310.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207234114310.png" alt="image-20221207234114310"></p>
</li>
</ul>
</li>
<li><p>control flow’s constraints</p>
<ul>
<li><p>BB块内，每一个statements 顺序执行</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207234407095.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207234407095.png" alt="image-20221207234407095"></p>
</li>
<li><p>BB之间</p>
<p>首先B的transfer function 由每一个内部的statements迭代调用各自的transfer function构成规则；</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207234527197.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207234527197.png" alt="image-20221207234527197"></p>
<p>反向操作</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207234844059.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207234844059.png" alt="image-20221207234844059"></p>
</li>
</ul>
</li>
<li><p>Reaching Definitions Analysis</p>
<p>处理的程序不涉及方法调用以及别名</p>
<p>简单来说就是定义v的地方p，到q可以有条路径，但不能有v的新定义</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207235501147.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221207235501147.png" alt="image-20221207235501147"></p>
<p>这里应该是以may-analysis为标准，实际运行中可能会有多个路径但只有一条可达。所以我们需要考虑到全部的可达性。</p>
<ul>
<li><p>如何做抽象和约束规则</p>
<p><strong>抽象</strong></p>
<p>我们把定义值抽象成比特位的形式，从左数第i位对应的就是Di的定义，0代表该点定义不可达</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221208094634125.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221208094634125.png" alt="image-20221208094634125"></p>
<p><strong>约束规则</strong></p>
<p>针对每一个语句块而言，生成新的定义，同时kill掉其他定义v的地方；但是对于其他输入的定义x 和 y 不受影响</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221208095113970.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221208095113970.png" alt="image-20221208095113970"></p>
<p><strong>符号形式表示</strong></p>
<p>BB</p>
<p><strong>转移函数</strong>：生成语句块中生成的定义，同时kill掉之后二次定义（已生成定义）的地方</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221208095310297.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221208095310297.png" alt="image-20221208095310297"></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221208095434138.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221208095434138.png" alt="image-20221208095434138"></p>
<p><strong>控制流</strong>： may-analysis -&gt; over approximation</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221208095747383.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221208095747383.png" alt="image-20221208095747383"></p>
</li>
<li><p>算法</p>
<p>按照语义来理解，初始置OUT[entry]为空，也就是说当前并没有定义流到entry的OUT处；</p>
<p>这个算法针对所有数据流分析模型都是一样的，所以初始化值entry不一定为空；</p>
<p>BB初始化为空是针对may analysis，对于must analysis一般是top;</p>
<p>循环体中就是针对BB不停的做规则定义的约束；</p>
<p>循环如何结束？</p>
<p><strong>如果IN不变，则输出也不会变化</strong> kill是个常量（statememts不会变）</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221208100700587.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221208100700587.png" alt="image-20221208100700587"></p>
<p>example</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221208102138622.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221208102138622.png" alt="image-20221208102138622"></p>
<p>迭代为什么会停？有没有可能不会停？</p>
<p>关键点：<strong>transfer function</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221208111908632.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221208111908632.png" alt="image-20221208111908632" style="zoom:67%;"></p>
<script type="math/tex; mode=display">
OUT[S] = gen_S \ U\ (IN[S] -kill_S)</script><p>1不会变成0，只要定义进入到OUT中，就不会在变回0（该kill的在transfer function时已经被kill掉）；但是OUT增长会有限，也就是存在一次迭代OUT不会再变化；而OUT不会变的话，在transfer function中，根据</p>
<script type="math/tex; mode=display">
IN[B]=U_{P predecessor of B}\ OUT[P]</script><p>可知，IN也不会变。从而再下一次迭代中同理OUT也不会再变，也就意味着程序状态达到了一个不动点，（和程序的单调性有关）作为程序的分析结果</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221208112035312.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221208112035312.png" alt="image-20221208112035312"></p>
</li>
</ul>
</li>
</ul>
<h5 id="04-Data-Flow-Analysis-II"><a href="#04-Data-Flow-Analysis-II" class="headerlink" title="04-Data Flow Analysis II"></a>04-Data Flow Analysis II</h5><ul>
<li><p><strong>Live Variable Analysis</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221209233847440.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221209233847440.png" alt="image-20221209233847440"></p>
</li>
</ul>
<p><strong>从v到被使用的地方存在这么一条路径，同时v在这中途没有被重定义，我们就说v在program p点是live的</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221209233913837.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221209233913837.png" alt="image-20221209233913837"></p>
<ul>
<li><p>Data怎么抽象？</p>
<p>Data是什么？<strong>程序中所有的变量</strong></p>
<p>同样可以用比特位来表示</p>
</li>
<li><p>如何设计transfer function? backward的设计方式比较方便<br>已知OUT[B]求IN[B]？</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210085431418.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210085431418.png" alt="image-20221210085431418"></p>
<p>通过一个应用场景来说明，可以看到如何判断是否是live的其实就是看OUT[B]中有无使用v，或者在被redefined之前use了v</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210090327196.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210090327196.png" alt="image-20221210090327196"></p>
<script type="math/tex; mode=display">
IN[B]=use_B\ U\ (OUT[B]-def_B)</script><p>def指的是v被redefined的情况，也就是减去redefined的情况，但也有可能是live的。如情况4和6，在redefined之前被use了，就要把他们加回来</p>
</li>
<li><p>算法</p>
<p>一般情况下，may analysis的初始化为空；must analysis的初始化为all.循环中不停迭代，直至所有的IN都不再变化</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210090931288.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210090931288.png" alt="image-20221210090931288"></p>
<p>exp</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210091330616.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210091330616.png" alt="image-20221210091330616"></p>
</li>
</ul>
<p>同理，kill和g都是固定的，因此OUT不变，所以IN也不会变</p>
<ul>
<li><p>Available Expression Analysis (must analysis)</p>
<p>从entry开始，到p的所有path都要经过执行x op y的值，各自path的表达式x op y之后，没有再出现重定义</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210094633459.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210094633459.png" alt="image-20221210094633459"></p>
<ul>
<li><p>数据抽象 针对的是expression</p>
<p>利用比特位来表示，0代表不available，1相反</p>
</li>
<li><p>transfer function</p>
<p>针对 must analysis，gen部分加入新生成的expression，同时kill部分去掉被重定义的变量对应的表达式</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210095142955.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210095142955.png" alt="image-20221210095142955"></p>
<script type="math/tex; mode=display">
OUT[B]=gen_B\ U\ (IN[B]-kill_B)</script><p>因为所有的path都得有表达式 x op y，不能仅有一条有</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210100022900.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210100022900.png" alt="image-20221210100022900"></p>
<p>可能会有漏报，但是也可以认为是safe approximation的</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210100742318.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210100742318.png" alt="image-20221210100742318"></p>
</li>
<li><p>算法</p>
<p>这里有个细节就是初始化时OUT[B]全为1。在循环当中迭代运行，直至没有OUT变化</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210101631647.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210101631647.png" alt="image-20221210101631647"></p>
</li>
</ul>
</li>
<li><p>分析对比</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210104332109.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210104332109.png" alt="image-20221210104332109"></p>
</li>
</ul>
<ul>
<li><p><strong>HomeWork1 活跃变量分析和迭代求解器</strong> <a target="_blank" rel="noopener" href="https://tai-e.pascal-lab.net/pa1.html#_2-%E5%AE%9E%E7%8E%B0%E6%B4%BB%E8%B7%83%E5%8F%98%E9%87%8F%E5%88%86%E6%9E%90">https://tai-e.pascal-lab.net/pa1.html#_2-%E5%AE%9E%E7%8E%B0%E6%B4%BB%E8%B7%83%E5%8F%98%E9%87%8F%E5%88%86%E6%9E%90</a></p>
<ul>
<li><p>前置知识</p>
</li>
<li><p>用到了Java的一些特性</p>
<ul>
<li><p><strong>Optional特性：isPresent() 和 get()的使用</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210221430916.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210221430916.png" alt="image-20221210221430916"></p>
</li>
<li><p><strong>泛型特性</strong></p>
</li>
</ul>
<p><code>pascal.taie.analysis.dataflow.analysis.DataflowAnalysis</code></p>
<p>五个关键API：分析方向、边界条件、初始条件、meet操作、transfer函数</p>
<p><code>pascal.taie.ir.exp.Exp</code></p>
<p>这是 Tai-e 的 IR 中的一个关键接口，用于表示程序中的所有表达式。其中有很多继承类，本次作业只需关注Var类</p>
<p><code>pascal.taie.ir.stmt.Stmt</code></p>
<p>为了实现活跃变量分析，你需要获得某条语句中<strong>定义或使用的所有表达式中的变量</strong></p>
<p><code>pascal.taie.analysis.dataflow.fact.SetFact&lt;Var&gt;</code></p>
<p>它提供了各种集合操作，如添加、删除元素，取交集、并集等</p>
<p><code>pascal.taie.analysis.dataflow.analysis.LiveVariableAnalysis</code></p>
<p>实现 <code>DataflowAnalysis</code> 的接口来定义具体的活跃变量分析</p>
</li>
<li><p>函数实现</p>
<ol>
<li><p><code>public SetFact&lt;Var&gt; newBoundaryFact(CFG&lt;Stmt&gt; cfg)</code></p>
<blockquote>
<p>new fact in boundary conditions, i.e., the fact for<br>entry (exit) node in forward (backward) analysis</p>
</blockquote>
<p>在这里想了好久，后来再看注释原来就是返回一个fact用于exit结点的。所有的实际操作应该是在solver中实现</p>
</li>
<li><p><code>public SetFact&lt;Var&gt; newInitialFact()</code></p>
<blockquote>
<p>new initial fact for non-boundary nodes</p>
</blockquote>
<p>同理也是返回fact</p>
</li>
<li><p><code>void meetInto(Fact fact, Fact target)</code></p>
<blockquote>
<p>Meets a fact into another (target) fact. This function will be used to handle control-flow confluences.</p>
</blockquote>
<p>这里对应算法当中并集处理IN到OUT当中，在实现上，实验文档说明了避免通过生成一个新的fact来实现合并的功能，所以是利用对每一个IN的fact集迭代合并到OUT当中，来优化程序</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210214832419.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210214832419.png" alt="image-20221210214832419"></p>
<p>所以我们这里也应该注意一下union和unionWith方法的区别</p>
</li>
<li><p><code>ublic boolean transferNode(Stmt stmt, SetFact&lt;Var&gt; in, SetFact&lt;Var&gt; out)</code></p>
<blockquote>
<p>The function transfers data-flow from in (out) fact to out (in) fact. for forward (backward) analysis.<br>@return true if the transfer changed the out (in) fact, otherwise false.</p>
</blockquote>
<p>实验中为了简化，将BB视为了一条条statements</p>
<p>依照算法</p>
<script type="math/tex; mode=display">
IN[B] = use_B\ U\ (OUT[B]-def_B);</script><p>实现上的思路就是，复制OUT集合中的fact到新集合，然后针对其中的定义变量作生成和删改操作，最后与输入参数中的IN集合作比对看是否出现变化</p>
<ul>
<li><p>针对fact集的复制，可以利用进行深拷贝</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210220821948.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221210220821948.png" alt="image-20221210220821948"></p>
</li>
<li><p><code>stmt.getUses()</code> 返回的是一个 <code>List&lt;RValue&gt;</code>。在 <code>RValue</code> 下，有立即数也有变量。怎么判断一个 <code>RValue</code> 变量是不是指向了一个 <code>Var</code> 对象呢？Java 里的解决方法就是 <code>instanceof</code> 关键字。</p>
</li>
<li><p>依然是那个问题，<code>SetFact&lt;Var&gt;</code> 储存的是 <code>Var</code>，如何把 <code>RValue use</code> 内的对象放进去呢？方法就是强制类型转换 <code>(Var) use;</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LiveVariableAnalysis</span> <span class="hljs-keyword">extends</span><br>        <span class="hljs-title class_">AbstractDataflowAnalysis</span>&lt;Stmt, SetFact&lt;Var&gt;&gt; &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;livevar&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LiveVariableAnalysis</span><span class="hljs-params">(AnalysisConfig config)</span> &#123;<br>        <span class="hljs-built_in">super</span>(config);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isForward</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> SetFact&lt;Var&gt; <span class="hljs-title function_">newBoundaryFact</span><span class="hljs-params">(CFG&lt;Stmt&gt; cfg)</span> &#123;<br>        <span class="hljs-comment">// 边界结点对应exit 这里意思就是返回一个 fact</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SetFact</span>&lt;Var&gt;();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> SetFact&lt;Var&gt; <span class="hljs-title function_">newInitialFact</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 返回非边界结点的fact</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SetFact</span>&lt;Var&gt;();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetInto</span><span class="hljs-params">(SetFact&lt;Var&gt; fact, SetFact&lt;Var&gt; target)</span> &#123;<br>        <span class="hljs-comment">// 这里做并集</span><br>        target.union(fact);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferNode</span><span class="hljs-params">(Stmt stmt, SetFact&lt;Var&gt; in, SetFact&lt;Var&gt; out)</span> &#123;<br>        <span class="hljs-comment">// 先作复制OUT集中的内容</span><br>        SetFact&lt;Var&gt; newInFact = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SetFact</span>&lt;Var&gt;();<br>        newInFact.set(out);<br><br>        <span class="hljs-comment">// 运用算法修改 先删除</span><br>        Optional&lt;LValue&gt; leftValue = stmt.getDef();<br>        <span class="hljs-keyword">if</span>(leftValue.isPresent()) &#123;<br>            <span class="hljs-type">LValue</span> <span class="hljs-variable">lValue</span> <span class="hljs-operator">=</span> leftValue.get();<br>            <span class="hljs-keyword">if</span> (lValue <span class="hljs-keyword">instanceof</span> Var) &#123;<br>                newInFact.remove((Var)lValue);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 再添加新定义的变量</span><br>        List&lt;RValue&gt; rightValues = stmt.getUses();<br>        <span class="hljs-keyword">for</span> (RValue rightValue : rightValues) &#123;<br>            <span class="hljs-keyword">if</span>(rightValue <span class="hljs-keyword">instanceof</span> Var) &#123;<br>                newInFact.add((Var)rightValue);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 最后判断修改的In和上一轮的IN是否相同</span><br><br>        <span class="hljs-keyword">if</span>(!newInFact.equals(in)) &#123;<br>            <span class="hljs-comment">// 记得将修改内容赋给 输入的 in</span><br>            in.set(newInFact);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>  <strong>实现迭代求解器</strong></p>
<ul>
<li><p>前置知识</p>
<p><code>pascal.taie.analysis.dataflow.fact.DataflowResult</code></p>
<p>该类对象用于维护数据流分析的 CFG 中的 fact。你可以通过它的 API 获取、设置 CFG 节点的 <code>IN facts</code> 和 <code>OUT facts</code>。</p>
<p><code>pascal.taie.analysis.graph.cfg.CFG</code></p>
<p>表示程序中方法的控制流图，可迭代</p>
</li>
<li><p>实现</p>
<p><strong>方法1</strong>：<code>protected void initializeBackward(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</code> </p>
<p>这里对应算法核心的迭代之前的初始化操作</p>
<p><strong>细节</strong></p>
<p><code>Solver</code> 是一个抽象的分析框架，因此 <code>Node</code> 和 <code>Fact</code> 都是未确定的，不能做 <code>new Node()</code> 这样的操作。这里实际上要利用前面分析器的接口方法，还是多看注释源码</p>
<p>为了实现上面所说的 meet 策略，你需要在初始化阶段给每条语句的 <code>OUT[S]</code> 赋上和 <code>IN[S]</code> 一样的初值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializeBackward</span><span class="hljs-params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;<br>        <span class="hljs-comment">// 初始化 OUT[exit] = 空集</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">exit</span> <span class="hljs-operator">=</span> cfg.getExit();<br>        result.setOutFact(exit, analysis.newBoundaryFact(cfg));<br>        result.setInFact(exit, analysis.newBoundaryFact(cfg));<br><br>        <span class="hljs-keyword">for</span> (Node node : cfg) &#123;<br>            <span class="hljs-comment">// 不对exit重复初始化</span><br>            <span class="hljs-keyword">if</span> (!cfg.isExit(node)) &#123;<br>                result.setInFact(node, analysis.newInitialFact());<br>                result.setOutFact(node, analysis.newInitialFact());<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><strong>方法2：</strong><code>IterativeSolver.doSolveBackward(CFG,DataflowResult)</code></p>
</li>
</ul>
<h5 id="05-Data-Flow-Analysis-Foundations-I"><a href="#05-Data-Flow-Analysis-Foundations-I" class="headerlink" title="05-Data Flow Analysis - Foundations I"></a>05-Data Flow Analysis - Foundations I</h5><ul>
<li><p>另一个角度理解迭代算法</p>
<p>每次迭代更新结点中的OUT值</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211232714155.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211232714155.png" alt="image-20221211232714155"></p>
<p>每次迭代可以视为一次动作F，也就是包含了transfer function和CFG，对应$V^k$到$V^k$的映射</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211232814785.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211232814785.png" alt="image-20221211232814785"></p>
<p>停止条件：最后一次迭代的k元组值与上一个最后迭代值相等</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211232937542.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211232937542.png" alt="image-20221211232937542"></p>
<p><strong>图示表示：</strong></p>
<p>初始化元组各项为<strong>bottom</strong>，第i+1次迭代和第i次迭代结果相同</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211233249598.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211233249598.png" alt="image-20221211233249598"></p>
<p>关注最后两个式子</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211233514971.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211233514971.png" alt="image-20221211233514971"></p>
<p>由此引出X不动点的定义</p>
</li>
<li><p>那么算法是否能保证得到一个不动点嘛？或者说是否一定能为数据流分析给出一个solution</p>
</li>
<li><p><strong>相关数学概念</strong></p>
<ol>
<li><p>Partial Order</p>
<p>偏序集满足的性质</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211234254488.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211234254488.png" alt="image-20221211234254488"></p>
<p><strong>偏序的意义</strong>：集合中两个元素可以不满足偏序关系</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211234659887.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211234659887.png" alt="image-20221211234659887"></p>
</li>
<li><p>Upper and Lower Bounds 上下界</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211235105295.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211235105295.png" alt="image-20221211235105295"></p>
<p>最小上界和最大下界的概念</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211235553018.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211235553018.png" alt="image-20221211235553018"></p>
<p>最小上界和最大下界的另一种表示，当S值包含两个元素时</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211235819068.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211235819068.png" alt="image-20221211235819068"></p>
<p><strong>相关性质</strong>：</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211235929077.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221211235929077.png" alt="image-20221211235929077"></p>
<p><strong>证明：</strong>利用了偏序的反对称性</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212000108775.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212000108775.png" alt="image-20221212000108775"></p>
</li>
</ol>
</li>
<li><p><strong>Lattice</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212000303504.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212000303504.png" alt="image-20221212000303504"></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212000558943.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212000558943.png" alt="image-20221212000558943"></p>
<p>定义<strong>Semilattice</strong></p>
<p>最小上界和最大下界只存在其一</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212000630330.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212000630330.png" alt="image-20221212000630330"></p>
<p>定义<strong>Complete Lattice</strong>，不再是针对两个元素的子集，而是任意的子集</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212000722023.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212000722023.png" alt="image-20221212000722023"></p>
<p>由此引出<strong>bottom和top</strong>的含义。</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212001124530.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212001124530.png" alt="image-20221212001124530"></p>
<p>只有你的lattice是有穷的，则它一定是<strong>complete lattice</strong>；反之不一定成立</p>
<p><strong>Product Lattice</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212091500344.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212091500344.png" alt="image-20221212091500344"></p>
<p>最小上界上最下下界</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212091542799.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212091542799.png" alt="image-20221212091542799"></p>
<p>两个性质</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212091607310.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212091607310.png" alt="image-20221212091607310"></p>
</li>
<li><p>用Lattice来表达数据流分析框架</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212094756453.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212094756453.png" alt="image-20221212094756453"></p>
<p>exp:s1 和 s3的join操作，实际上右面的Lattice从下往上升（may analysis）</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212094855164.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212094855164.png" alt="image-20221212094855164"></p>
</li>
</ul>
<ul>
<li><p>Lattice函数单调性（回答data flow analysis是否能到不动点）</p>
<p>Lattice上定义函数单调性及不动点定理</p>
<p>针对不动点定理，前提是complete lattice，所以需要加一个条件即L是有限的</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212100127938.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212100127938.png" alt="image-20221212100127938"></p>
<p>这里给出了最小不动点和最大不动点的方法，证明如下（最小不动点）</p>
<p>充分利用bottom的定义和单调性定义、有限性</p>
<p>这里也就是说明了上升链有限，最终能达到不动点</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212100853435.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212100853435.png" alt="image-20221212100853435"></p>
<p>接下来证明得到的一定是最小不动点</p>
<p>利用数学归纳法</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212101206151.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212101206151.png" alt="image-20221212101206151"></p>
<p>得到的最小不动点一定是唯一的<br>最大不动点的证明同理</p>
</li>
<li><p>有Lattice上的函数不动点定理引申到迭代算法上是否也满足不动点的性质？换句话说，两者怎么关联上？</p>
</li>
</ul>
<h5 id="06-Data-Flow-Analysis-Foundation"><a href="#06-Data-Flow-Analysis-Foundation" class="headerlink" title="06 - Data Flow Analysis - Foundation"></a>06 - Data Flow Analysis - Foundation</h5><ul>
<li><p>迭代算法与固定点定理相结合</p>
<p>针对第二个已知条件：L有限</p>
<p>在一个迭代算法中每一个OUT的值域实际上就是对应一个Lattice，整个就构成一个product lattice</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212232547851.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212232547851.png" alt="image-20221212232547851"></p>
<p>针对第一个已知条件：函数f满足单调性</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212232653887.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212232653887.png" alt="image-20221212232653887"></p>
<p>大写的F包含两部分，每个结点施加transfer function；在控制流图中针对汇聚点采用join或meet方法合并。那么F是否是单调的？</p>
<p>首先对于第一个transfer function我们已经在迭代算法中知道了当kill固定时和gen固定时，OUT/IN不变，那么IN/OUT也不会变，也就是说它是只增不减的，因此是单调的</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212233357663.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212233357663.png" alt="image-20221212233357663"></p>
<p>对于join/meet，我们以join为例，证明如下</p>
<p>利用最小上界的定义</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212234440536.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212234440536.png" alt="image-20221212234440536"></p>
</li>
<li><p>迭代算法什么时候能达到不动点，复杂度问题</p>
<p>lattice的高度</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212234732926.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212234732926.png" alt="image-20221212234732926"></p>
<p>什么时候能达到不动点，也就是求最大迭代次数</p>
<p>考虑最坏情况，每一次迭代，只有一个结点的一个值变化</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212235037851.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221212235037851.png" alt="image-20221212235037851"></p>
<p>如果lattice的高度为h，且CFG中的结点数为k，则最大迭代次数为</p>
<script type="math/tex; mode=display">
i=h*k</script></li>
<li><p><strong>May and Must Analysis</strong> </p>
<p>对于<strong>May analysis</strong>来讲，bottom就意味着unsafe result，（没有定义可以到达，也就是所有定义都已经初始化过）；而top意味着所有的定义都可达，也就是说肯定能保证正确但是无用。</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213095309537.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213095309537.png" alt="image-20221213095309537"></p>
<p>从bottom到top，自下而上需要一个truth点作为边界，如何辨别是否safe，或者说到达不动点取决于算法的safe approximation的策略</p>
<p>自下而上，不动点越往上精度越差，因此达到最小不动点是最好的</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213100107348.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213100107348.png" alt="image-20221213100107348"></p>
<p>而对于<strong>must analysis</strong>，有一个误报可能都会导致程序分析的错误</p>
<p>所以其是从top往下走，直至最大不动点将会达到精度最高的safe点</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213102118632.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213102118632.png" alt="image-20221213102118632"></p>
<p><strong>Path Function</strong> 精度问题</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213105905441.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213105905441.png" alt="image-20221213105905441"></p>
<p>MOP 枚举所有path，应用Path Function</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213105953381.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213105953381.png" alt="image-20221213105953381"></p>
<p>当然这只是概念上的一种形式，实际上枚举起来非常困难</p>
<p>那么迭代算法结果和MOP的关系？</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213110728146.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213110728146.png" alt="image-20221213110728146"></p>
<p>实际上就是join的位置不太一样</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213110823066.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213110823066.png" alt="image-20221213110823066"></p>
<p><strong>证明：</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213111036598.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213111036598.png" alt="image-20221213111036598"></p>
<p>结果在lattice上满足偏序关系，MOP是更准的。</p>
<p>特殊情况下，如果F满足分配律</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213111245473.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213111245473.png" alt="image-20221213111245473"></p>
</li>
<li><p>Constant Propagation （函数不满足分配律）</p>
<p>must analysis 满足前向传播</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213111801336.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213111801336.png" alt="image-20221213111801336"></p>
<p>Lattice下</p>
<ul>
<li><p>Domain of the values V </p>
<p>特殊点在初始化时v的值是undefined（虽然初始化时从top开始）</p>
</li>
<li><p>Meet Operator</p>
<p>特别地，这里不关注未初始化变量的问题，也就是只要有path到达，就是已初始化变量</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213145416163.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213145416163.png" alt="image-20221213145416163"></p>
</li>
</ul>
<p><strong>transfer function</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213150052085.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213150052085.png" alt="image-20221213150052085"></p>
<p>在val(x)最后一种情况，如果一个常量+undefined值，则transfer function将不满足单调性</p>
<p><strong>它的非分配律特性</strong></p>
<p>当两边均是NAC时，join后就是NAC</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213150533114.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213150533114.png" alt="image-20221213150533114"></p>
</li>
<li><p>Worklist Algorithm(迭代算法的优化)</p>
<p><strong>核心：</strong>只需遍历有变化的地方施加transfer function，而非整体再迭代一遍</p>
<p>只计算IN变的，OUT才有可能会变；因此当OUT变时只需关注它的所有后继BB即可</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213151341899.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213151341899.png" alt="image-20221213151341899"></p>
</li>
</ul>
<h5 id="实验2-常量传播和-Worklist-求解器"><a href="#实验2-常量传播和-Worklist-求解器" class="headerlink" title="实验2 常量传播和 Worklist 求解器"></a>实验2 常量传播和 Worklist 求解器</h5><p>需要了解的类</p>
<p><code>pascal.taie.ir.IR</code></p>
<p>IR 的核心数据结构。它的每个实例储存了一个 <strong>Java 方法的各种信息，例如变量、参数、语句等等</strong></p>
<p><code>pascal.taie.ir.exp.Exp</code>类型接口</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213232709169.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213232709169.png" alt="image-20221213232709169"></p>
<p>Var第一个实验我们已经用过</p>
<p><code>pascal.taie.ir.exp.IntLiteral</code> 整数字面量</p>
<p><code>pascal.taie.ir.exp.BinaryExp</code> 二元表达式</p>
<p>这个类代表程序中的二元表达式。这个类的各个子类对应了表 1 中的不同种类的二元表达式，并且每个子类中都有一个<strong>内部枚举类型</strong>用于表示该类支持的运算符。</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213233050531.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213233050531.png" alt="image-20221213233050531"></p>
<p>作者提到了二元表达式的操作数均设计成立变量的形式，也就是说</p>
<blockquote>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213233233932.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213233233932.png" alt="image-20221213233233932"></p>
</blockquote>
<p><code>pascal.taie.ir.stmt.DefinitionStmt</code></p>
<p>这是 <code>Stmt</code> 的一个子类。它表示了程序中所有的赋值语句</p>
<p><code>pascal.taie.analysis.dataflow.analysis.DataflowAnalysis</code></p>
<p>这是具体数据流分析算法需要实现的接口(实现类为<code>pascal.taie.analysis.dataflow.analysis.constprop.ConstantPropagation</code>)，之后会被求解器调用。本次实验关注前5个API</p>
<p><code>pascal.taie.analysis.dataflow.analysis.constprop.Value</code></p>
<p>这个类表示了常量分析中<strong>格上的抽象值</strong></p>
<p>用下列的<strong>静态方法</strong>获取格上抽象值（即该类的实例）</p>
<ul>
<li><code>Value getNAC()</code>: 返回 <code>NAC</code></li>
<li><code>Value getUndef()</code>: 返回 <code>UNDEF</code></li>
<li><code>Value makeConstant(int)</code>: 返回给定整数在格上对应的抽象值</li>
</ul>
<p><code>pascal.taie.analysis.dataflow.analysis.constprop.CPFact</code></p>
<p>这个类表示常量传播中的 <strong>data facts</strong>，即一个从<strong>变量（<code>Var</code>）到格上抽象值（<code>Value</code>）</strong>的映射。该类提供了各种 <code>map</code> 相关的操作，例如键值对的查询、更新等等</p>
<p><strong>实现常量传播</strong></p>
<p><strong>API I : newBoundaryFact()</strong></p>
<p>在实现 <code>newBoundaryFact()</code> 的时候，你<strong>要小心地处理每个会被分析的方法的参数</strong>。具体来说，你要将它们的值初始化为 <code>NAC</code>，为了满足must analysis的top 符合safe approximation.同时这里还涉及到需要考虑方法参数类型是否在本实验的范围内，对于不在范围的直接忽略即可。</p>
<p>这里在实现时就是先从图里取出所有的方法，然后获取IR语义信息中的参数进行初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> CPFact <span class="hljs-title function_">newBoundaryFact</span><span class="hljs-params">(CFG&lt;Stmt&gt; cfg)</span> &#123;<br>        <span class="hljs-comment">// 针对方法中的每一个参数都要考虑，并且需要考虑参数类型是否在本实验范围</span><br>        <span class="hljs-type">CPFact</span> <span class="hljs-variable">cpFact</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CPFact</span>();<br><br>        <span class="hljs-keyword">for</span> (Var <span class="hljs-keyword">var</span> : cfg.getMethod().getIR().getParams()) &#123;<br>            <span class="hljs-keyword">if</span> (canHoldInt(<span class="hljs-keyword">var</span>)) &#123;<br>                cpFact.update(<span class="hljs-keyword">var</span>, Value.getNAC());<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> cpFact;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><strong>API II : newInitialFact()</strong></p>
<p>这里没啥好说的，就是正常返回一个空fact</p>
<p><strong>API III : meetInto()</strong></p>
<p>原理参照：</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213233740568.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213233740568.png" alt="image-20221213233740568" style="zoom:67%;"></p>
<p>这里利用到了一个辅助函数<code>Value meetValue(Value,Value)</code>对应的是格上的meet操作，我们先实现格上的</p>
<p>这里需要注意一点的就是要返回常数的话需要先调用一个Value的<code>makeConstant</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Value <span class="hljs-title function_">meetValue</span><span class="hljs-params">(Value v1, Value v2)</span> &#123;<br><br>    <span class="hljs-keyword">if</span>(v1.isNAC() || v2.isNAC())&#123;<br>        <span class="hljs-keyword">return</span> Value.getNAC();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v1.isUndef()) &#123;<br>        <span class="hljs-keyword">if</span> (v2.isConstant()) &#123;<br>            <span class="hljs-keyword">return</span> Value.makeConstant(v2.getConstant());<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v2.isUndef()) &#123;<br>            <span class="hljs-keyword">return</span> Value.getUndef();<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v2.isUndef()) &#123;<br>        <span class="hljs-keyword">if</span> (v1.isConstant()) &#123;<br>            <span class="hljs-keyword">return</span> Value.makeConstant(v1.getConstant());<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(v1.isUndef()) &#123;<br>            <span class="hljs-keyword">return</span> Value.getUndef();<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v1.isConstant() &amp;&amp; v2.isConstant()) &#123;<br>        <span class="hljs-keyword">return</span> Value.getNAC();<br>    &#125;<br><br>    System.out.println(<span class="hljs-string">&quot;meetValue error&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后就是实现<code>meetInto()</code></p>
<p>这里也就是需要遍历fact map中的变量将其依次合并到target map上（meet时利用格上的合并方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetInto</span><span class="hljs-params">(CPFact fact, CPFact target)</span> &#123;<br>    <span class="hljs-comment">// TODO - finish me</span><br>    fact.forEach((key, value)-&gt;&#123;<br>        target.update(key, meetValue(value, target.get(key)));<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>API IV : transferNode()</strong></p>
<p>首先先实现<code>Value evaluate(Exp,CPFact)</code></p>
<p>这个方法会计算表达式（<code>Exp</code>）的值（<code>Value</code>）。当然，此处的值是格上的抽象值。</p>
<p>原理参考</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213234548035.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221213234548035.png" alt="image-20221213234548035" style="zoom:67%;"></p>
<p>也就是我们需要按照不同的表达式类型来作不同处理，对于非赋值型语句，采用直接复制的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Value <span class="hljs-title function_">evaluate</span><span class="hljs-params">(Exp exp, CPFact in)</span> &#123;<br>       <span class="hljs-comment">// TODO - finish me</span><br>       <span class="hljs-keyword">if</span> (exp <span class="hljs-keyword">instanceof</span> Var) &#123;<br>           <span class="hljs-type">Var</span> <span class="hljs-variable">temExp</span> <span class="hljs-operator">=</span> (Var)exp;<br>           <span class="hljs-keyword">if</span> (canHoldInt(temExp)) &#123;<br>               <span class="hljs-keyword">return</span> in.get(temExp);<br>           &#125;<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(exp <span class="hljs-keyword">instanceof</span> IntLiteral) &#123;<br>           <span class="hljs-type">IntLiteral</span> <span class="hljs-variable">temExp</span> <span class="hljs-operator">=</span> (IntLiteral) exp;<br>           <span class="hljs-keyword">return</span> Value.makeConstant(temExp.getValue());<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exp <span class="hljs-keyword">instanceof</span> BinaryExp) &#123;<br>           <span class="hljs-comment">// 进一步判断子类</span><br>           <span class="hljs-keyword">if</span>(exp <span class="hljs-keyword">instanceof</span> ArithmeticExp) &#123;<br>               <span class="hljs-type">ArithmeticExp</span> <span class="hljs-variable">temExp</span> <span class="hljs-operator">=</span> (ArithmeticExp) exp;<br>               <span class="hljs-type">Var</span> <span class="hljs-variable">operand1</span> <span class="hljs-operator">=</span> temExp.getOperand1();<br>               <span class="hljs-type">Var</span> <span class="hljs-variable">operand2</span> <span class="hljs-operator">=</span> temExp.getOperand2();<br><br>               <span class="hljs-keyword">if</span> (canHoldInt(operand1) &amp;&amp; canHoldInt(operand2)) &#123;<br>                   <span class="hljs-type">Value</span> <span class="hljs-variable">operandValue1</span> <span class="hljs-operator">=</span> in.get(operand1);<br>                   <span class="hljs-type">Value</span> <span class="hljs-variable">operandValue2</span> <span class="hljs-operator">=</span> in.get(operand2);<br><br>                   <span class="hljs-comment">// exp1 均为常数</span><br>                   <span class="hljs-keyword">if</span> (operandValue1.isConstant() &amp;&amp; operandValue2.isConstant()) &#123;<br>                       <span class="hljs-comment">// + - * / %</span><br>                       ArithmeticExp.<span class="hljs-type">Op</span> <span class="hljs-variable">operator</span> <span class="hljs-operator">=</span> temExp.getOperator();<br>                       <span class="hljs-keyword">if</span> (ArithmeticExp.Op.ADD == operator) &#123;<br>                           <span class="hljs-keyword">return</span> Value.makeConstant(operandValue1.getConstant() + operandValue2.getConstant());<br>                       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ArithmeticExp.Op.SUB == operator) &#123;<br>                           <span class="hljs-keyword">return</span> Value.makeConstant(operandValue1.getConstant() - operandValue2.getConstant());<br>                       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ArithmeticExp.Op.MUL == operator) &#123;<br>                           <span class="hljs-keyword">return</span> Value.makeConstant(operandValue1.getConstant() * operandValue2.getConstant());<br>                       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ArithmeticExp.Op.DIV == operator) &#123;<br>                           <span class="hljs-comment">// 考虑除0</span><br>                           <span class="hljs-keyword">if</span> (operandValue2.getConstant() == <span class="hljs-number">0</span>) &#123;<br>                               <span class="hljs-keyword">return</span> Value.getUndef();<br>                           &#125;<span class="hljs-keyword">else</span> &#123;<br>                               <span class="hljs-keyword">return</span> Value.makeConstant(operandValue1.getConstant() / operandValue2.getConstant());<br>                           &#125;<br>                       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ArithmeticExp.Op.REM == operator) &#123;<br>                           <span class="hljs-keyword">if</span> (operandValue2.getConstant() == <span class="hljs-number">0</span>) &#123;<br>                               <span class="hljs-keyword">return</span> Value.getUndef();<br>                           &#125;<span class="hljs-keyword">else</span> &#123;<br>                               <span class="hljs-keyword">return</span> Value.makeConstant(operandValue1.getConstant() % operandValue2.getConstant());<br>                           &#125;<br>                       &#125;<br>                       <span class="hljs-comment">// NAC情况</span><br>                   &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(operandValue1.isNAC() || operandValue2.isNAC()) &#123;<br>                       <span class="hljs-comment">// 这种情况仍然需要考虑 NAC/0的情况是UDF</span><br>                       <span class="hljs-keyword">if</span> (operandValue1.isNAC() &amp;&amp; operandValue2.isConstant() &amp;&amp; operandValue2.getConstant()==<span class="hljs-number">0</span>) &#123;<br>                           ArithmeticExp.<span class="hljs-type">Op</span> <span class="hljs-variable">operator</span> <span class="hljs-operator">=</span> temExp.getOperator();<br>                           <span class="hljs-keyword">if</span> (ArithmeticExp.Op.DIV == operator || ArithmeticExp.Op.REM == operator) &#123;<br>                               <span class="hljs-keyword">return</span> Value.getUndef();<br>                           &#125;<br>                       &#125;<br>                       <span class="hljs-keyword">return</span> Value.getNAC();<br>                   &#125;<span class="hljs-keyword">else</span> &#123;<br>                       <span class="hljs-comment">// otherwise return Undef</span><br>                       <span class="hljs-keyword">return</span> Value.getUndef();<br>                   &#125;<br>               &#125;<br>           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(exp <span class="hljs-keyword">instanceof</span> ConditionExp) &#123;<br>               <span class="hljs-comment">// == != &lt; &gt; &lt;= &gt;=</span><br>               <span class="hljs-comment">// 返回值由 01 表示</span><br>               <span class="hljs-type">ConditionExp</span> <span class="hljs-variable">conditionExp</span> <span class="hljs-operator">=</span> (ConditionExp) exp;<br>               <span class="hljs-type">Var</span> <span class="hljs-variable">operand1</span> <span class="hljs-operator">=</span> conditionExp.getOperand1();<br>               <span class="hljs-type">Var</span> <span class="hljs-variable">operand2</span> <span class="hljs-operator">=</span> conditionExp.getOperand2();<br>               <span class="hljs-keyword">if</span> (canHoldInt(operand1) &amp;&amp; canHoldInt(operand2)) &#123;<br>                   <span class="hljs-type">Value</span> <span class="hljs-variable">operandValue1</span> <span class="hljs-operator">=</span> in.get(operand1);<br>                   <span class="hljs-type">Value</span> <span class="hljs-variable">operandValue2</span> <span class="hljs-operator">=</span> in.get(operand2);<br><br>                   <span class="hljs-comment">// constant</span><br>                   <span class="hljs-keyword">if</span> (operandValue1.isConstant() &amp;&amp; operandValue2.isConstant()) &#123;<br>                       ConditionExp.<span class="hljs-type">Op</span> <span class="hljs-variable">operator</span> <span class="hljs-operator">=</span> conditionExp.getOperator();<br><br>                       <span class="hljs-keyword">if</span> (ConditionExp.Op.EQ == operator) &#123;<br>                           <span class="hljs-keyword">if</span> (operandValue1.getConstant() == operandValue2.getConstant()) &#123;<br>                               <span class="hljs-keyword">return</span> Value.makeConstant(<span class="hljs-number">1</span>);<br>                           &#125;<span class="hljs-keyword">else</span> &#123;<br>                               <span class="hljs-keyword">return</span> Value.makeConstant(<span class="hljs-number">0</span>);<br>                           &#125;<br>                       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ConditionExp.Op.GE == operator) &#123;<br>                           <span class="hljs-keyword">if</span> (operandValue1.getConstant() &gt;= operandValue2.getConstant()) &#123;<br>                               <span class="hljs-keyword">return</span> Value.makeConstant(<span class="hljs-number">1</span>);<br>                           &#125;<span class="hljs-keyword">else</span> &#123;<br>                               <span class="hljs-keyword">return</span> Value.makeConstant(<span class="hljs-number">0</span>);<br>                           &#125;<br>                       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ConditionExp.Op.NE == operator) &#123;<br>                           <span class="hljs-keyword">if</span> (operandValue1.getConstant() != operandValue2.getConstant()) &#123;<br>                               <span class="hljs-keyword">return</span> Value.makeConstant(<span class="hljs-number">1</span>);<br>                           &#125;<span class="hljs-keyword">else</span> &#123;<br>                               <span class="hljs-keyword">return</span> Value.makeConstant(<span class="hljs-number">0</span>);<br>                           &#125;<br>                       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ConditionExp.Op.LT == operator) &#123;<br>                           <span class="hljs-keyword">if</span> (operandValue1.getConstant() &lt; operandValue2.getConstant()) &#123;<br>                               <span class="hljs-keyword">return</span> Value.makeConstant(<span class="hljs-number">1</span>);<br>                           &#125;<span class="hljs-keyword">else</span> &#123;<br>                               <span class="hljs-keyword">return</span> Value.makeConstant(<span class="hljs-number">0</span>);<br>                           &#125;<br>                       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ConditionExp.Op.GT == operator) &#123;<br>                           <span class="hljs-keyword">if</span> (operandValue1.getConstant() &gt; operandValue2.getConstant()) &#123;<br>                               <span class="hljs-keyword">return</span> Value.makeConstant(<span class="hljs-number">1</span>);<br>                           &#125;<span class="hljs-keyword">else</span> &#123;<br>                               <span class="hljs-keyword">return</span> Value.makeConstant(<span class="hljs-number">0</span>);<br>                           &#125;<br>                       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ConditionExp.Op.LE == operator) &#123;<br>                           <span class="hljs-keyword">if</span> (operandValue1.getConstant() &lt;= operandValue2.getConstant()) &#123;<br>                               <span class="hljs-keyword">return</span> Value.makeConstant(<span class="hljs-number">1</span>);<br>                           &#125;<span class="hljs-keyword">else</span> &#123;<br>                               <span class="hljs-keyword">return</span> Value.makeConstant(<span class="hljs-number">0</span>);<br>                           &#125;<br>                       &#125;<br>                       <span class="hljs-comment">// NAC</span><br>                   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(operandValue1.isNAC() || operandValue2.isNAC()) &#123;<br>                       <span class="hljs-keyword">return</span> Value.getNAC();<br>                   &#125; <span class="hljs-keyword">else</span> &#123;<br>                       <span class="hljs-keyword">return</span> Value.getUndef();<br>                   &#125;<br>               &#125;<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exp <span class="hljs-keyword">instanceof</span> ShiftExp) &#123;<br>               <span class="hljs-type">ShiftExp</span> <span class="hljs-variable">shiftExp</span> <span class="hljs-operator">=</span> (ShiftExp) exp;<br>               <span class="hljs-type">Var</span> <span class="hljs-variable">operand1</span> <span class="hljs-operator">=</span> shiftExp.getOperand1();<br>               <span class="hljs-type">Var</span> <span class="hljs-variable">operand2</span> <span class="hljs-operator">=</span> shiftExp.getOperand2();<br><br>               <span class="hljs-keyword">if</span> (canHoldInt(operand1) &amp;&amp; canHoldInt(operand2)) &#123;<br>                   <span class="hljs-type">Value</span> <span class="hljs-variable">operandValue1</span> <span class="hljs-operator">=</span> in.get(operand1);<br>                   <span class="hljs-type">Value</span> <span class="hljs-variable">operandValue2</span> <span class="hljs-operator">=</span> in.get(operand2);<br><br>                   <span class="hljs-keyword">if</span> (operandValue1.isConstant() &amp;&amp; operandValue2.isConstant()) &#123;<br>                       ShiftExp.<span class="hljs-type">Op</span> <span class="hljs-variable">operator</span> <span class="hljs-operator">=</span> shiftExp.getOperator();<br>                       <span class="hljs-keyword">if</span>(ShiftExp.Op.SHL == operator) &#123;<br>                           <span class="hljs-keyword">return</span> Value.makeConstant(operandValue1.getConstant() &lt;&lt; operandValue2.getConstant());<br>                       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ShiftExp.Op.SHR == operator) &#123;<br>                           <span class="hljs-keyword">return</span> Value.makeConstant(operandValue1.getConstant() &gt;&gt; operandValue2.getConstant());<br>                       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ShiftExp.Op.USHR == operator) &#123;<br>                           <span class="hljs-keyword">return</span> Value.makeConstant(operandValue1.getConstant() &gt;&gt;&gt; operandValue2.getConstant());<br>                       &#125;<br>                   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operandValue1.isNAC() || operandValue2.isNAC()) &#123;<br>                       <span class="hljs-keyword">return</span> Value.getNAC();<br>                   &#125; <span class="hljs-keyword">else</span> &#123;<br>                       <span class="hljs-keyword">return</span> Value.getUndef();<br>                   &#125;<br>               &#125;<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exp <span class="hljs-keyword">instanceof</span> BitwiseExp) &#123;<br>               <span class="hljs-type">BitwiseExp</span> <span class="hljs-variable">bitwiseExp</span> <span class="hljs-operator">=</span> (BitwiseExp) exp;<br>               <span class="hljs-type">Var</span> <span class="hljs-variable">operand1</span> <span class="hljs-operator">=</span> bitwiseExp.getOperand1();<br>               <span class="hljs-type">Var</span> <span class="hljs-variable">operand2</span> <span class="hljs-operator">=</span> bitwiseExp.getOperand2();<br><br>               <span class="hljs-keyword">if</span> (canHoldInt(operand1) &amp;&amp; canHoldInt(operand2)) &#123;<br>                   <span class="hljs-type">Value</span> <span class="hljs-variable">operandValue1</span> <span class="hljs-operator">=</span> in.get(operand1);<br>                   <span class="hljs-type">Value</span> <span class="hljs-variable">operandValue2</span> <span class="hljs-operator">=</span> in.get(operand2);<br><br>                   <span class="hljs-keyword">if</span> (operandValue1.isConstant() &amp;&amp; operandValue2.isConstant()) &#123;<br>                       BitwiseExp.<span class="hljs-type">Op</span> <span class="hljs-variable">operator</span> <span class="hljs-operator">=</span> bitwiseExp.getOperator();<br>                       <span class="hljs-keyword">if</span> (BitwiseExp.Op.AND == operator) &#123;<br>                           <span class="hljs-keyword">return</span> Value.makeConstant(operandValue1.getConstant() &amp; operandValue2.getConstant());<br>                       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (BitwiseExp.Op.OR == operator) &#123;<br>                           <span class="hljs-keyword">return</span> Value.makeConstant(operandValue1.getConstant() | operandValue2.getConstant());<br>                       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (BitwiseExp.Op.XOR == operator) &#123;<br>                           <span class="hljs-keyword">return</span> Value.makeConstant(operandValue1.getConstant() ^ operandValue2.getConstant());<br>                       &#125;<br>                   &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operandValue1.isNAC() || operandValue2.isNAC()) &#123;<br>                       <span class="hljs-keyword">return</span> Value.getNAC();<br>                   &#125;<span class="hljs-keyword">else</span> &#123;<br>                       <span class="hljs-keyword">return</span> Value.getUndef();<br>                   &#125;<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-comment">// 其他情况暂不考虑 直接返回NAC</span><br>       <span class="hljs-keyword">return</span> Value.getNAC();<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>接下来实现<code>transferNode()</code>，利用</p>
<script type="math/tex; mode=display">
OUT[S] = gen\ U\ (IN[S]\{(x,\_)\})</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferNode</span><span class="hljs-params">(Stmt stmt, CPFact in, CPFact out)</span> &#123;<br>        <span class="hljs-comment">// TODO - finish me</span><br>        <span class="hljs-keyword">if</span> (in == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// ???</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 关注等号左侧为变量且右侧只能是如下几类表达式的 定义为EXP类型的表达式</span><br>        <span class="hljs-keyword">if</span> (stmt <span class="hljs-keyword">instanceof</span> DefinitionStmt) &#123;<br>            <span class="hljs-type">DefinitionStmt</span> <span class="hljs-variable">definitionStmt</span> <span class="hljs-operator">=</span> (DefinitionStmt) stmt;<br>            <span class="hljs-type">LValue</span> <span class="hljs-variable">lValue</span> <span class="hljs-operator">=</span> definitionStmt.getLValue();<br>            <span class="hljs-type">RValue</span> <span class="hljs-variable">rValue</span> <span class="hljs-operator">=</span> definitionStmt.getRValue();<br><br>            <span class="hljs-comment">// 检查左边变量是否需要被kill掉</span><br>            <span class="hljs-type">Var</span> <span class="hljs-variable">tmpVar</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span>(lValue <span class="hljs-keyword">instanceof</span> Var) &#123;<br>                tmpVar = (Var) lValue;<br>                in.remove(tmpVar);<br>            &#125;<br><br>            <span class="hljs-comment">// 检查右侧表达式新生成的Value并添加进OUT中</span><br>            <span class="hljs-type">Exp</span> <span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span> (rValue <span class="hljs-keyword">instanceof</span> Exp) &#123;<br>                expression = (Exp) rValue;<br>            &#125;<br>            <span class="hljs-type">Value</span> <span class="hljs-variable">newResult</span> <span class="hljs-operator">=</span> evaluate(expression, in);<br><br>            <span class="hljs-type">CPFact</span> <span class="hljs-variable">tmpFact</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CPFact</span>();<br>            <span class="hljs-comment">// 深度copy</span><br>            tmpFact.copyFrom(in);<br>            <span class="hljs-keyword">if</span> (tmpVar!=<span class="hljs-literal">null</span> &amp;&amp; canHoldInt(tmpVar)) &#123;<br>                tmpFact.update(tmpVar, newResult);<br>            &#125;<br>            <span class="hljs-comment">// true if this fact changed as a result of the call, otherwise false.</span><br>            <span class="hljs-keyword">return</span> out.copyFrom(tmpFact);<br><br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 非赋值语句直接采用复制的操作</span><br>            <span class="hljs-keyword">return</span> out.copyFrom(in);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><strong>实现 Worklist 求解器</strong></p>
<ul>
<li><p>需要知道的类</p>
<p><code>pascal.taie.analysis.dataflow.solver.WorkListSolver</code></p>
<p>原理按照如图分两部分实现</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221214140120613.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221214140120613.png" alt="image-20221214140120613"></p>
<p>对于方法<code>Solver.initializeForward(CFG,DataflowResult)</code>实现基本和实验1一致，就是初始化为空。只是注意IN和OUT都要做相同的初始化处理</p>
<p>对于方法<code>WorkListSolver.doSolveForward(CFG,DataflowResult)</code>，这里注意区别在于当OUT出现变化时，并不是将所有的结点再遍历一次，而是将改变的结点及其后继结点加到worklist当中</p>
</li>
</ul>
<h5 id="07-Interprocedural-Analysis"><a href="#07-Interprocedural-Analysis" class="headerlink" title="07- Interprocedural Analysis"></a>07- Interprocedural Analysis</h5><p>以往在过程内调用静态分析方法遇到方法调用时往往采用最保守的方式，也就是返回值一定是个NAC（以常数传播为例）</p>
<ul>
<li><p>如何构建程序的调用图</p>
<p>CALL Graph 程序中调用关系的集合</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215000101481.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215000101481.png" alt="image-20221215000101481"></p>
<p>当前构建的算法，越往下精度越高，同时速度也会相对下降</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215000312764.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215000312764.png" alt="image-20221215000312764"></p>
<p>JAVA语言中方法调用的类型，其中virtual call主要是为了实现OO语言的多态特性，因此目标方法只有在运行时才能够确定，所以调用图的关键就是如何处理这个调用类型</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215000522727.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215000522727.png" alt="image-20221215000522727"></p>
</li>
<li><p><strong>Method Dispatch of Virtual Calls</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215000733234.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215000733234.png" alt="image-20221215000733234"></p>
<p>签名的定义如下（soot 采用格式），用于唯一确定方法</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215000835398.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215000835398.png" alt="image-20221215000835398"></p>
<p><strong>Dispatch的函数定义</strong>，模拟动态运行时具体调用目标方法的过程</p>
<p>涉及两个参数：调用者类型和方法的签名</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215001117767.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215001117767.png" alt="image-20221215001117767"></p>
</li>
<li><p>Class Hierarchy Analysis</p>
<p>核心思想：<strong>根据声明类型去求解目标方法</strong></p>
<p>去查找A类及其整个继承结构的目标方法</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215090352130.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215090352130.png" alt="image-20221215090352130"></p>
<p>算法：</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215091055761.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215091055761.png" alt="image-20221215091055761"></p>
<p>对于virtual call部分，c和c的所有子类都会去调用dispatch方法，并将结果加入到目标方法</p>
<p><strong>特征</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215092413462.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215092413462.png" alt="image-20221215092413462"></p>
</li>
<li><p>如何用CHA构造整个调用图</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215095820861.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215095820861.png" alt="image-20221215095820861"></p>
<p>具体算法：</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215100453338.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215100453338.png" alt="image-20221215100453338"></p>
<p>exp：</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215101314807.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215101314807.png" alt="image-20221215101314807"></p>
</li>
<li><p>Interprocedural Control-Flow Graph</p>
<p>表示整个程序的结构，作过程间分析</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215101524644.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215101524644.png" alt="image-20221215101524644"></p>
<p>return site指的是紧跟着调用方法语句的下一个语句</p>
</li>
<li><p>Interprocedural Data-Flow Analysis 过程间数据流分析</p>
<p>在transfer function之外增加edge transfer</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215102157024.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215102157024.png" alt="image-20221215102157024"></p>
<p><strong>过程间常量传播</strong>（这里仅考虑值传递）</p>
<p>这里有个细节就是方法调用和返回之间仍存在一条边，便于我们去<strong>传递本地的数据流</strong>（没有的话则需要在外部调用方法时仍然得保留形参的数据流信息，影响性能）</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215103215647.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215103215647.png" alt="image-20221215103215647"></p>
<p>对于每一个call node，都需要kill掉左边的变量，因为其值会顺着return边重新流回来</p>
<p>如果不kill掉则会影响精度问题，这里就是将会导致b结果变成NAC</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215103909956.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221215103909956.png" alt="image-20221215103909956"></p>
</li>
</ul>
<h5 id="实验4-类层次结构分析与过程间常量传播"><a href="#实验4-类层次结构分析与过程间常量传播" class="headerlink" title="实验4 类层次结构分析与过程间常量传播"></a>实验4 类层次结构分析与过程间常量传播</h5><p>需要了解的类</p>
<ul>
<li><p>pascal.taie.analysis.graph.callgraph.DefaultCallGraph</p>
<p>该类代表了<strong>程序的调用图</strong>。它提供了多样的 API（继承自类 <code>AbstractCallGraph</code>）来获取到调用图的信息。另外，它还提供了一些修改调用图的 API，你可以借此来建立调用图。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Stream&lt;Invoke&gt; callSitesIn(JMethod)`：返回给定方法 `JMethod` 中的所有 `call sites<br>boolean contains(JMethod): 返回当前调用图是否含有给定的方法，即给定方法 JMethod 在当前调用图中是否可达。<br>boolean addReachableMethod(JMethod): 向当前调用图中添加方法 JMethod 并将方法标记成可达的<br>boolean addEdge(Edge&lt;Invoke,JMethod&gt;): 向当前调用图中添加一条调用边<br></code></pre></td></tr></table></figure>
</li>
<li><p>pascal.taie.analysis.graph.callgraph.CallKind</p>
<p>该枚举类型表示调用图中边的种类，包括 <code>INTERFACE</code>、<code>VIRTUAL</code>、<code>SPECIAL</code> 和 <code>STATIC</code></p>
</li>
<li><p>pascal.taie.analysis.graph.callgraph.Edge<Invoke,JMethod></Invoke,JMethod></p>
<p>该类表示调用图中的边。每一条边从调用点（call site，Tai-e 中为 <code>Invoke</code> 类型）出发，指向被调用方法（callee method，类型为 <code>JMethod</code>）。在创建一条边的时候，你需要向构造方法提供调用类型、调用点和被调用方法的信息</p>
</li>
<li><p><code>pascal.taie.ir.stmt.Invoke</code> (subclass of <code>Stmt</code>)</p>
<p>该类表示程序中的方法调用（举个例子：<code>x = o.m(a1,a2,…)</code>）以及调用图中的调用点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">你需要使用 getMethodRef() 来获取目标方法的签名信息<br></code></pre></td></tr></table></figure>
</li>
<li><p>pascal.taie.ir.proginfo.MethodRef</p>
<p>Tai-e 中的<strong>目标方法引用</strong>，如调用点的目标方法。它包含了调用点所调用的目标方法的<strong>签名信息</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">JClass getDeclaringClass()：返回该方法签名的声明类，即声明该方法的类<br>Subsignature getSubsignature()：返回被调用方法的子签名（subsignature）<br></code></pre></td></tr></table></figure>
</li>
<li><p>pascal.taie.language.classes.JMethod</p>
<p>该类表示 Tai-e 中的 Java 方法。每个 <code>JMethod</code> 的实例关联着一个方法并包含该方法的各种信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">boolean isAbstract(): 如果该 JMethod 是一个没有方法体的抽象方法，则返回 true，否则返回 false；<br></code></pre></td></tr></table></figure>
</li>
<li><p>pascal.taie.language.classes.JClass</p>
<p>该类表示 Tai-e 中的 Java 类。每个 <code>JClass</code> 的实例关联着一个类并包含该类的各种信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">JClass getSuperClass(): 返回该类的父类。如果这个类在类层次结构的顶端（没有父类），比如 java.lang.Object，则返回 null。<br>JMethod getDeclaredMethod(Subsignature): 根据子签名返回该类中声明的对应方法。如果该类中没有该子签名对应的方法，则返回 null。<br>boolean isInterface(): 返回该类是否是一个接口<br></code></pre></td></tr></table></figure>
</li>
<li><p>pascal.taie.language.classes.Subsignature</p>
<p>该类表示 Tai-e 中的子签名。一个方法的子签名只包含它的方法名和方法签名的描述符</p>
</li>
<li><p>pascal.taie.language.classes.ClassHierarchy</p>
<p>该类提供了类层次结构的相关信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Collection&lt;JClass&gt; getDirectSubclassesOf(JClass): 对于给定类，返回直接继承该类的子类<br>Collection&lt;JClass&gt; getDirectSubinterfacesOf(JClass) 对于一个给定接口，返回直接继承该接口的子接口。<br>Collection&lt;JClass&gt; getDirectImplementorsOf(JClass): 对于一个给定接口，返回直接实现了该接口的类<br></code></pre></td></tr></table></figure>
</li>
<li><p>需要实现 pascal.taie.analysis.graph.callgraph.CHABuilder 通过CHA 建立调用图</p>
<ul>
<li><p>dispatch</p>
<p>原理如下</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221224163905706.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221224163905706.png" alt="image-20221224163905706"></p>
<p>实现上采用循环的形式，每次都根据签名判断方法是否存在且是否为非抽象方法</p>
</li>
<li><p>resolve </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">你可以使用 CallGraphs.getCallKind(Invoke) 来获得调用点的调用类型<br></code></pre></td></tr></table></figure>
<p>原理如下</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221224165513040.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221224165513040.png" alt="image-20221224165513040"></p>
<p>对于前两者调用方法类型，直接dispatch即可；对于后面virtual call，需要先找出当前类的所有子方法和子接口及子接口实现，然后调用dispatch</p>
</li>
<li><p>buildCallGraph</p>
<p>算法伪代码如下</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221224173222724.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221224173222724.png" alt="image-20221224173222724"></p>
<p>这里不好实现的点在获取方法中的所有调用点，因为Stream<Invoke> callSitesIn(JMethod) 这个方法返回的结果没法遍历，一种解决方法是直接拿到method中的IR，然后对IR中的stmt进行逐行判断，如果其类型为<code>Invoke</code>，那就可以说明其是一个call site 然后进行resolve,返回的方法集加入调用图当中即可</Invoke></p>
</li>
</ul>
<p><strong>实现过程间常量传播</strong></p>
<ol>
<li><p>解决 Edge Transfer</p>
<p>为了计算第 4 条语句的 IN fact，也就是方法 <code>addOne()</code> 的 entry 节点的 IN fact，我们需要对 2→4 这条边应用 <strong>edge transfer</strong>，这样使得第 2 条语句的 OUT fact（a=6）转换为 x=6，并最终 meet 结果 x=6 到第四条语句的 IN fact中。</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221224194301265.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221224194301265.png" alt="image-20221224194301265"></p>
<p>定义 <code>transferEdge(edge, fact)</code>方法</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221224194440841.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221224194440841.png" alt="image-20221224194440841"></p>
<p>处理边的种类</p>
<ul>
<li><strong>Normal edge </strong>一般是与过程间调用无关的边。<em>transferEdge</em>(<em>edge</em>, <em>fact</em>) = <em>fact</em></li>
<li><strong>Call-to-return edge</strong> 对于方法调用 <code>x = m(…)</code> edge transfer 函数会把等号左侧的变量（在这个例子里也就是 <code>x</code>）和它的值从 fact 中 kill 掉。而对于等号左侧没有变量的调用，则视作恒等函数4</li>
<li><strong>Call edge</strong>  对于这种边，edge transfer 函数会将<strong>实参</strong>（argument）在调用点中的值传递给<strong>被调用函数的形参</strong>（parameter）。具体来说，edge transfer 首先从调用点的 <strong>OUT fact 中获取实参的值</strong>，然后返回一个新的 fact，这个 fact 把形参映射到它对应的实参的值。edge transfer 函数的返回值应该仅包含<strong>被调用函数的形参的值</strong></li>
<li><strong>Return edge</strong> 被调用方法的返回值传递给调用点等号左侧的变量。返回的结果应该仅包含调用点等号左侧变量的值。如果该调用点等号左侧没有变量，那么 edge transfer 函数仅会返回一个空 fact。</li>
</ul>
<p>需要了解的类</p>
<ul>
<li><p>pascal.taie.analysis.graph.icfg.ICFGEdge </p>
<p>有四个子类关联上述的边</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pascal.taie.analysis.graph.icfg.NormalEdge<br>pascal.taie.analysis.graph.icfg.CallToReturnEdge<br>pascal.taie.analysis.graph.icfg.CallEdge<br>pascal.taie.analysis.graph.icfg.ReturnEdge<br></code></pre></td></tr></table></figure>
</li>
<li><p>pascal.taie.analysis.dataflow.inter.InterDataflowAnalysis</p>
</li>
<li><p>pascal.taie.analysis.dataflow.inter.AbstractInterDataflowAnalysis</p>
<p>它把 ICFG 中不同的点和边分派给对应 transfer 方法</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221224195919505.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221224195919505.png" alt="image-20221224195919505"></p>
</li>
<li><p>pascal.taie.ir.exp.InvokeExp</p>
<p>程序中的方法调用表达式。它包含了被调用的方法引用和传入的各个参数</p>
</li>
</ul>
<p>首先要熟悉这几个类型</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221224201841194.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221224201841194.png" alt="image-20221224201841194"></p>
<p>按照每种类型的进行实现即可，特别说明</p>
<p>call-to-return edges 其首先需要kill掉调用点左边的变量，获取方式可以利用Invoke类的getResult方法</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221224203509359.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221224203509359.png" alt="image-20221224203509359"></p>
<p>对于 Return edges </p>
<p>首先要对返回的结果做一次meetValue</p>
<blockquote>
<p><code>edge.returnVars()</code> 里面有多个值，这是因为整个方法里的 return 语句都会指向 exit，再从 exit 连接单条 return edge 回上层方法</p>
</blockquote>
<p>然后再将值传回给调用点左边的变量，当然如果没有的话就返回一个空 fact</p>
</li>
</ol>
<p><strong>实现过程间 Worklist 求解器</strong></p>
<p>与实验二基本一致，不同点：</p>
<ul>
<li><p>在计算一个节点的 IN fact 时，过程间求解器需要对传入的 edge 和前驱们的 OUT facts 应用 edge transfer 函数（<em>transferEdge</em>）</p>
</li>
<li><p>但你仅需要对 ICFG 的 entry 方法（比如 main 方法）的 entry 节点设置 boundary fact</p>
</li>
</ul>
</li>
</ul>
<h5 id="08-Pointer-Analysis"><a href="#08-Pointer-Analysis" class="headerlink" title="08 - Pointer Analysis"></a>08 - Pointer Analysis</h5><ul>
<li><p>指针分析</p>
<p>对于OO语言，指针分析回答了变量可以指向程序中的哪些对象 may-analysis</p>
<p>输入程序，经过指针分析得到各个指向关系</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216101233036.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216101233036.png" alt="image-20221216101233036"></p>
</li>
<li><p>影响指针分析的关键要素</p>
<p><strong>指标</strong>：<strong>精度和速度</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216101856582.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216101856582.png" alt="image-20221216101856582"></p>
<p><strong>堆抽象</strong>：如何对内存进行建模</p>
<p>保证指针分析可以终止，避免受到死循环等场景的影响。通过将无穷的对象抽象成有限的（符合某些共性的抽象成一个）</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216102102568.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216102102568.png" alt="image-20221216102102568"></p>
<p>主要技术流派，这里学习<strong>Allocation sites</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216102150276.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216102150276.png" alt="image-20221216102150276"></p>
<p><strong>Allocation sites</strong></p>
<p>在对象创建点（下标表示创建对象的位置）抽象对象来表示动态运行时所创建的对象。因为程序当中的创建点个数一定是有限的，所以可以保证静态分析中抽象对象时有限的</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216102407778.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216102407778.png" alt="image-20221216102407778"></p>
<p><strong>上下文敏感 context sensitivity</strong></p>
<p>如何对上下文调用进行建模</p>
<p>​    <img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216102807475.png" alt="image-20221216102807475"></p>
<p>流敏感 Flow Sensitivity</p>
<p>如何对控制流进行建模</p>
<p>控制流敏感的会遵循程序执行的顺序，并对<strong>每一个执行点维护一个指向关系的映射</strong>；而对于非敏感，会忽略掉程序执行的顺序，对整个程序<strong>只维护一个指向关系的映射</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216103601189.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216103601189.png" alt="image-20221216103601189"></p>
<p>exp</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216104142208.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216104142208.png" alt="image-20221216104142208"></p>
<p><strong>Analysis Scope</strong></p>
<p>应该分析程序中的哪些部分</p>
<p>前者分析的结果可以适用于所有可能的应用；而对于后者按照需求进行指针分析，得到的结果适用于特定的应用</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216104401360.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216104401360.png" alt="image-20221216104401360"></p>
</li>
<li><p>关注的语句 </p>
<p>只关注<strong>直接影响指针指向</strong>的语句</p>
<p>对于数组比较特殊，通常是忽略下标的区别，建模成只有一个单个Field arr，所有的指向关系都存在这里</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216111240261.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216111240261.png" alt="image-20221216111240261"></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216111405128.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216111405128.png" alt="image-20221216111405128"></p>
<p>因此只专注于局部变量以及实例的属性，浓缩成下面的语句</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216111740334.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216111740334.png" alt="image-20221216111740334"></p>
<p>调用Call时特别关注Virtual call的情况</p>
</li>
</ul>
<h5 id="09-Pointer-Analysis-Foundations-I"><a href="#09-Pointer-Analysis-Foundations-I" class="headerlink" title="09 - Pointer Analysis Foundations(I)"></a>09 - Pointer Analysis Foundations(I)</h5><ul>
<li><p>指针分析的规则</p>
<p>Domains and Notations 域及其记号</p>
<p>指针由两部分组成 所有变量以及Field</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216112827420.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216112827420.png" alt="image-20221216112827420"></p>
<p>幂集对应指针的集合</p>
<p><strong>处理四种语句的规则</strong></p>
<p>横线之上表示前提条件，只要上面的条件满足就可以推导出横线下的语句；没有写表示不需前提条件</p>
<ol>
<li><p><strong>New</strong> 将对象$o_i$加入到变量x的指针集当中，箭头表示新的指向关系</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216113337265.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216113337265.png" alt="image-20221216113337265"></p>
</li>
<li><p><strong>Assign</strong> 对象$o_i$如果原先属于y的指针集的话，在赋值规则中也会将其加入到x变量的指针集当中</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216113800542.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216113800542.png" alt="image-20221216113800542"></p>
</li>
<li><p><strong>Store</strong> 如果x变量指向$o_i$，变量y指向$o_j$，则将Field $o_i.f$指向$0_j$</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216113930855.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216113930855.png" alt="image-20221216113930855"></p>
</li>
<li><p><strong>Load</strong> 如果变量x指向$o_i$，且Field $o_i.f$指向 $o_j$，那么就让变量y指向 $o_j$对象</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216114120547.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221216114120547.png" alt="image-20221216114120547"></p>
</li>
</ol>
</li>
</ul>
<h5 id="09-Pointer-Analysis-Foundations-I-1"><a href="#09-Pointer-Analysis-Foundations-I-1" class="headerlink" title="09 - Pointer Analysis - Foundations I"></a>09 - Pointer Analysis - Foundations I</h5><ul>
<li><p>如何实现指针分析</p>
<p>指针分析本质就是在指针之间互相传播指向信息</p>
<p>可以看作之间满足某种包含约束关系</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217204352002.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217204352002.png" alt="image-20221217204352002"></p>
<p>关键点：变量x的指针集更新时，要把变化的信息传播给和x关联的其他指针，如何传播？？</p>
<p>利用图的数据结构</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217204803237.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217204803237.png" alt="image-20221217204803237"></p>
<p><strong>Pointer Flow Graph 指针流图</strong></p>
<p>结点注意对象指的是抽象对象，流动关系都是may的关系</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217204951747.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217204951747.png" alt="image-20221217204951747"></p>
<p>如何构建边？</p>
<p>基于程序的语句和对应的规则</p>
<p>exp</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217211415357.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217211415357.png" alt="image-20221217211415357"></p>
<p>通过PFG，指针分析就可以转换为求解图上的传递闭包关系（利用图的可达性信息）</p>
<p>构建PFG与在其上进行指向信息的传播两者是相互依赖的，PFG在指针分析过程中是动态更新的</p>
</li>
<li><p><strong>指针分析算法</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217212153333.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217212153333.png" alt="image-20221217212153333"></p>
<p><strong>worklist</strong></p>
<p>WL的元素为指针变量和其对应的指针项（要加入到变量的指针集中），表示需要被处理的指向信息</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217212258508.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217212258508.png" alt="image-20221217212258508"></p>
<p><strong>先简化看</strong> 只看new和赋值语句</p>
<p>这里注意在赋值语句AddEdge方法中，如果s存在指向关系集，也需要将加入到对应t的指向关系集当中（这里就是加入到worklist中）</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217212839181.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217212839181.png" alt="image-20221217212839181"></p>
<p><strong>处理worklist当中的东西</strong></p>
<p>这里注意到有个减法操作，表示我们要先将已有的指向关系去重，只添加新增的指向关系</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217213132956.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217213132956.png" alt="image-20221217213132956"></p>
<p>指针集的变化真正是发生在算法第二行处，之后还需要将pts传给n的后继结点</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217213422595.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217213422595.png" alt="image-20221217213422595"></p>
<p>有个细节就是集合操作为什么也需要去重操作？</p>
<p>指针集中已有的元素已经被传播到对应指针的后继当中了，所以就不需要再去传播一遍，采用差异传播的方式来进行</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217215755980.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217215755980.png" alt="image-20221217215755980"></p>
<p>接下来<strong>处理store 和 load</strong></p>
<p>新的指向信息可能引入新的PFG边，可能的意思是指存在多个变量指向同一个对象$o_j$，其他变量在处理时可能已经构建过这条边</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217220751636.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217220751636.png" alt="image-20221217220751636"></p>
<p>exp（分析基于流不敏感，不关心语句的顺序）</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217223227730.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221217223227730.png" alt="image-20221217223227730"></p>
</li>
</ul>
<h5 id="实验3-死代码检测"><a href="#实验3-死代码检测" class="headerlink" title="实验3 死代码检测"></a>实验3 死代码检测</h5><ol>
<li><p>控制流不可达</p>
<p>检测方法：遍历所在方法的控制流图并标记可达语句</p>
</li>
<li><p>分支不可达</p>
<ul>
<li>if 语句的条件值是一个常数（利用常量传播得知）</li>
<li>switch语句<br>预先对被检测代码应用<strong>常量传播分析</strong></li>
</ul>
</li>
<li><p>无用赋值</p>
<p>一个局部变量在一条语句中被赋值，但再也没有被该语句后面的语句读取、</p>
<p>检测方式：</p>
<ol>
<li>我们需要预先对被检测代码施用<strong>活跃变量分析</strong>。对于一个赋值语句，如果它等号<strong>左侧的变量（LHS 变量）是一个无用变量</strong>（换句话说，not live），那么我们可以把它标记为一个无用赋值。</li>
</ol>
<p><strong>需要利用的类</strong></p>
<p><code>pascal.taie.analysis.graph.cfg.Edge</code></p>
<p>本次实验需要考虑四种边的种类 <code>IF_TRUE</code>、<code>IF_FALSE</code>、<code>SWITCH_CASE</code> 和 <code>SWITCH_DEFAULT</code></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221218182835824.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221218182835824.png" alt="image-20221218182835824"></p>
<p>如何获取和检查边的种类？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Edge&lt;Stmt&gt; edge = ...;<br><span class="hljs-keyword">if</span> (edge.getKind() == Edge.Kind.IF_TRUE) &#123; ... &#125;<br></code></pre></td></tr></table></figure>
<p>对于 <code>SWITCH_CASE</code> 边，可以通过 <code>getCaseValue()</code> 方法来获取它们对应的 case 分支的条件值</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221218183256092.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221218183256092.png" alt="image-20221218183256092"></p>
<p><code>pascal.taie.ir.stmt.If</code>(Stmt的子类)</p>
<p>表示程序中的 if 语句</p>
<p><code>pascal.taie.ir.stmt.SwitchStmt</code>（<code>Stmt</code> 的子类）</p>
<p><code>pascal.taie.ir.stmt.AssignStmt</code></p>
<p>继承关系如下，所以对于方法调用这种情况的赋值语句我们本次实验不关注，仅关注    AssignStmt这个类即可</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221218183908577.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221218183908577.png" alt="image-20221218183908577"></p>
<p>思路：这里首先遍历整个控制流图，对于未标记的语句即为不可达代码。遍历方式可以采用DFS或BFS</p>
<p>在遍历 CFG 时，你需要对当前正在访问的节点使用 <code>CFG.getOutEdgesOf()</code> 来帮助获得之后要被访问的后继节点</p>
<p>控制流不可达</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">TreeSet&lt;Stmt&gt; unreachedStmts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(Comparator.comparing(Stmt::getIndex));<br>        <span class="hljs-keyword">for</span> (Stmt stmt : cfg) &#123;<br>            unreachedStmts.add(stmt);<br>        &#125;<br><br>        TreeSet&lt;Stmt&gt; reachedStmts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(Comparator.comparing(Stmt::getIndex));<br>        <span class="hljs-type">Stmt</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> cfg.getEntry();<br>        BFS(cfg, reachedStmts, entry);<br>        <span class="hljs-keyword">for</span> (Stmt reachedStmt : reachedStmts) &#123;<br>            unreachedStmts.remove(reachedStmt);<br>        &#125;<br>        <span class="hljs-comment">// 控制流不可达</span><br>        <span class="hljs-keyword">for</span> (Stmt unreachedStmt : unreachedStmts) &#123;<br>            deadCode.add(unreachedStmt);<br>        &#125;<br>---<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">(CFG&lt;Stmt&gt; cfg, Set&lt;Stmt&gt; stmts, Stmt curStmt)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!stmts.contains(curStmt)) &#123;<br>            stmts.add(curStmt);<br><br>            cfg.getOutEdgesOf(curStmt).forEach(outEdge -&gt; &#123;<br>                BFS(cfg, stmts, outEdge.getTarget());<br>            &#125;);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>对于分支不可达，我们需要预先对被检测代码应用常量传播分析，通过它来告诉我们条件值是否为常量，然后在遍历 CFG 时，<strong>我们不进入相应的不可达分支</strong></p>
<p>条件值的获取利用常量传播分析得到的结果，调用的API为<code>constants.getOutFact()</code></p>
<p>通过得到的变量进一步判断是否为常数。你需要对当前正在访问的节点使用 <code>CFG.getOutEdgesOf()</code> 来帮助获得之后要被访问的后继节点。这个 API 返回给定节点在 CFG 上的出边，用它进一步判断是否是经过常量判断可达的出边。这里有一点需要注意，Edge类边本身并不代表表达式类型，而是一种连接关系，想要获得其可以延伸到哪一个结点，调用<code>getTarget()</code>进一步判断</p>
<p>对于赋值语句，首先只用考虑<code>AssignStmt</code>类，在<strong>左边变量存在</strong>的情况下，利用活跃变量分析的结果去晒出所有非活跃变量且右边赋值无副作用影响的表达式，即为死代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无用赋值检测</span><br>        <span class="hljs-keyword">for</span> (Stmt stmt : cfg) &#123;<br>            <span class="hljs-keyword">if</span> (stmt <span class="hljs-keyword">instanceof</span> AssignStmt) &#123;<br>                <span class="hljs-type">AssignStmt</span> <span class="hljs-variable">assignStmt</span> <span class="hljs-operator">=</span> (AssignStmt) stmt;<br>                <span class="hljs-keyword">if</span> (assignStmt.getDef().isPresent()) &#123;<br>                    <span class="hljs-type">LValue</span> <span class="hljs-variable">lValue</span> <span class="hljs-operator">=</span> assignStmt.getLValue();<br>                    <span class="hljs-type">RValue</span> <span class="hljs-variable">rValue</span> <span class="hljs-operator">=</span> assignStmt.getRValue();<br><br>                    <span class="hljs-comment">// 为了检测无用赋值，我们需要预先对被检测代码施用活跃变量分析</span><br>                    SetFact&lt;Var&gt; outFact = liveVars.getOutFact(assignStmt);<br>                    <span class="hljs-keyword">if</span> (lValue <span class="hljs-keyword">instanceof</span> Var) &#123;<br>                        <span class="hljs-comment">// 如果非活跃变量，且无副作用</span><br>                        <span class="hljs-keyword">if</span> (!outFact.contains((Var) lValue)) &#123;<br>                            <span class="hljs-keyword">if</span> (hasNoSideEffect(rValue)) &#123;<br>                                deadCode.add(assignStmt);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>如何从分支不可达当中剔除掉死循环的部分？</p>
<blockquote>
<p>形如<code>while(true)</code>的语句死循环之后其后面的所有语句包括return等就不可达了，但是exit节点仍然应当被加入进来，所以初始化的时候应该是entry和exit都加入</p>
</blockquote>
<p>按照前面的写逻辑会有问题，感觉逻辑上是分开的，先筛一遍控制不可达再晒一边分支不可达最后筛无用赋值，这样会导致类似死循环问题由于分支不可达的判断直接抛掉后续的语句，应该是所有分析结果结束之后再做筛选</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Set&lt;Stmt&gt; <span class="hljs-title function_">analyze</span><span class="hljs-params">(IR ir)</span> &#123;<br>        <span class="hljs-comment">// obtain CFG</span><br>        CFG&lt;Stmt&gt; cfg = ir.getResult(CFGBuilder.ID);<br>        <span class="hljs-comment">// obtain result of constant propagation</span><br>        DataflowResult&lt;Stmt, CPFact&gt; constants =<br>                ir.getResult(ConstantPropagation.ID);<br>        <span class="hljs-comment">// obtain result of live variable analysis</span><br>        DataflowResult&lt;Stmt, SetFact&lt;Var&gt;&gt; liveVars =<br>                ir.getResult(LiveVariableAnalysis.ID);<br>        <span class="hljs-comment">// keep statements (dead code) sorted in the resulting set</span><br>        Set&lt;Stmt&gt; deadCode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(Comparator.comparing(Stmt::getIndex));<br>        <span class="hljs-comment">// TODO - finish me</span><br>        <span class="hljs-comment">// Your task is to recognize dead code in ir and add it to deadCode</span><br><br>        <span class="hljs-comment">// 最终可达及活跃代码</span><br>        Set&lt;Stmt&gt; liveCode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-comment">// workList</span><br>        Queue&lt;Stmt&gt; liveStmts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 防止死循环问题导致的后续语句不会被遍历到，所以加入exit</span><br>        liveStmts.add(cfg.getEntry());<br>        liveStmts.add(cfg.getExit());<br><br>        <span class="hljs-keyword">while</span> (!liveStmts.isEmpty()) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">addAll</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">Stmt</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> liveStmts.poll();<br><br>            <span class="hljs-keyword">if</span> (liveCode.contains(stmt)) &#123;<br>                <span class="hljs-comment">// 已经分析过该语句</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// workList的肯定是活跃stmt</span><br>                liveCode.add(stmt);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (stmt <span class="hljs-keyword">instanceof</span> AssignStmt&lt;?, ?&gt;) &#123;<br>                <span class="hljs-type">LValue</span> <span class="hljs-variable">lValue</span> <span class="hljs-operator">=</span> ((AssignStmt&lt;?, ?&gt;) stmt).getLValue();<br>                <span class="hljs-type">RValue</span> <span class="hljs-variable">rValue</span> <span class="hljs-operator">=</span> ((AssignStmt&lt;?, ?&gt;) stmt).getRValue();<br>                <span class="hljs-comment">// 获得活跃分析结果</span><br>                SetFact&lt;Var&gt; outFact = liveVars.getOutFact(stmt);<br><br>                <span class="hljs-keyword">if</span> (lValue <span class="hljs-keyword">instanceof</span>  Var &amp;&amp; !outFact.contains((Var) lValue) &amp;&amp; hasNoSideEffect(rValue)) &#123;<br>                    <span class="hljs-comment">// 死代码</span><br>                    deadCode.add(stmt);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stmt <span class="hljs-keyword">instanceof</span> If) &#123;<br>                <span class="hljs-type">ConditionExp</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> ((If) stmt).getCondition();<br>                <span class="hljs-keyword">if</span> (ConstantPropagation.canHoldInt(condition.getOperand1()) &amp;&amp; ConstantPropagation.canHoldInt(condition.getOperand2())) &#123;<br>                    <span class="hljs-type">Value</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> ConstantPropagation.evaluate(condition, constants.getInFact(stmt));<br><br>                    <span class="hljs-comment">// 逐个分支判断</span><br>                    <span class="hljs-keyword">for</span> (Edge&lt;Stmt&gt; edge : cfg.getOutEdgesOf(stmt)) &#123;<br>                        <span class="hljs-keyword">switch</span> (edge.getKind()) &#123;<br>                            <span class="hljs-keyword">case</span> IF_TRUE -&gt; &#123;<br>                                <span class="hljs-keyword">if</span> (value.isConstant() &amp;&amp; value.getConstant()!=<span class="hljs-number">0</span>) &#123;<br>                                    liveStmts.add(edge.getTarget());<br>                                    addAll = <span class="hljs-literal">false</span>;<br>                                &#125;<br>                            &#125;<br>                            <span class="hljs-keyword">case</span> IF_FALSE -&gt; &#123;<br>                                <span class="hljs-keyword">if</span> (value.isConstant() &amp;&amp; value.getConstant()==<span class="hljs-number">0</span>) &#123;<br>                                    liveStmts.add(edge.getTarget());<br>                                    addAll = <span class="hljs-literal">false</span>;<br>                                &#125;<br>                            &#125;<br>                            <span class="hljs-keyword">default</span> -&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnalysisException</span>(<span class="hljs-string">&quot;unknown Kind&quot;</span>);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stmt <span class="hljs-keyword">instanceof</span> SwitchStmt) &#123;<br>                <span class="hljs-type">Var</span> <span class="hljs-variable">var</span> <span class="hljs-operator">=</span> ((SwitchStmt) stmt).getVar();<br>                <span class="hljs-keyword">if</span> (ConstantPropagation.canHoldInt(<span class="hljs-keyword">var</span>)) &#123;<br>                    <span class="hljs-comment">// 同 ConstantPropagation.evaluate</span><br>                    <span class="hljs-type">CPFact</span> <span class="hljs-variable">inFact</span> <span class="hljs-operator">=</span> constants.getInFact(stmt);<br>                    <span class="hljs-type">Value</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> inFact.get(<span class="hljs-keyword">var</span>);<br><br>                    <span class="hljs-keyword">for</span> (Edge&lt;Stmt&gt; edge : cfg.getOutEdgesOf(stmt)) &#123;<br>                        <span class="hljs-keyword">switch</span> (edge.getKind()) &#123;<br>                            <span class="hljs-keyword">case</span> SWITCH_CASE -&gt; &#123;<br>                                <span class="hljs-keyword">if</span> (value.isConstant() &amp;&amp; value.getConstant() == edge.getCaseValue()) &#123;<br>                                    liveStmts.add(edge.getTarget());<br>                                    addAll = <span class="hljs-literal">false</span>;<br>                                &#125;<br>                            &#125;<br>                            <span class="hljs-keyword">case</span> SWITCH_DEFAULT -&gt; &#123;<br>                                <span class="hljs-comment">// 如果是默认值则要判断分支值不属于 getCaseValues</span><br>                                List&lt;Integer&gt; caseValues = ((SwitchStmt) stmt).getCaseValues();<br>                                <span class="hljs-keyword">if</span> (value.isConstant() &amp;&amp; !caseValues.contains(value.getConstant())) &#123;<br>                                    liveStmts.add(edge.getTarget());<br>                                    addAll = <span class="hljs-literal">false</span>;<br>                                &#125;<br>                            &#125;<br>                            <span class="hljs-keyword">default</span> -&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnalysisException</span>(<span class="hljs-string">&quot;unknown Kind&quot;</span>);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (addAll) &#123;<br>                <span class="hljs-comment">// 如果是活跃变量或者赋值语句，或者分支条件值（case）值非常数</span><br>                liveStmts.addAll(cfg.getSuccsOf(stmt));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Stmt stmt : cfg.getNodes()) &#123;<br>            <span class="hljs-keyword">if</span> (!liveCode.contains(stmt)) &#123;<br>                deadCode.add(stmt);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> deadCode;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h5 id="作业5-非上下文敏感指针分析"><a href="#作业5-非上下文敏感指针分析" class="headerlink" title="作业5 非上下文敏感指针分析"></a>作业5 非上下文敏感指针分析</h5><ul>
<li><p>新的分析规则</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226174521559.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226174521559.png" alt="image-20221226174521559"></p>
<p>对于数组的索引，无视下标，均视作field字段</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226174654466.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226174654466.png" alt="image-20221226174654466"></p>
<p>假设 $o_i$ 代表一个数组对象，那么我们用表示一个指向数组中所有对象的指针（无论保存在数组的什么位置）。</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226175744694.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226175744694.png" alt="image-20221226175744694"></p>
<p><strong><em>静态方法</em></strong>. 静态方法的处理与实例方法大体相同，除了1）我们不需要在 receiver object 上进行 dispatch 以解析（resolve）出被调用的方法，2）我们不需要传 receiver object。因为静态方法的处理不需要考虑 receiver object(静态方法中是没有this变量的)，因此它的处理规则也比实例方法更简单。所以相当于只需要传参数和返回值即可</p>
</li>
<li><p>需要了解的类</p>
<ul>
<li><p>pascal.taie.ir.stmt.DefinitionStmt</p>
<p>表示程序中所有的定义语句，（包括方法调用的）。在本次作业中，所有影响指针的语句都是这个类的子类</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226180200609.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226180200609.png" alt="image-20221226180200609"></p>
<p>注意 <code>isStatic()</code>可以检查语句调用的对象时实例还是静态字段</p>
</li>
<li><p>pascal.taie.ir.exp.Var</p>
<p>它表示 Tai-e IR 中的变量。对于所有实例字段 loads/stores、数组 loads/stores 或实例调用的 base 变量，这个类提供了一些方便的 API 来<strong>查找相关语句</strong>。</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226181114559.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226181114559.png" alt="image-20221226181114559"></p>
</li>
<li><p>pascal.taie.language.classes.JField</p>
<p>这个类表示程序中的各个字段</p>
</li>
<li><p>pascal.taie.analysis.pta.core.heap.Obj</p>
<p>这个类表示指针分析中的抽象对象，即指针集（points-to sets）中的对象</p>
</li>
<li><p>pascal.taie.analysis.pta.core.heap.HeapModel</p>
<p>这个类表示堆模型（即堆抽象），它用来对堆对象进行建模。你可以使用 <code>HeapModel</code> 的 <code>getObj(New)</code> 方法来获得与它对应的抽象对象（即 <code>Obj</code>）</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226181650439.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226181650439.png" alt="image-20221226181650439"></p>
<p>堆抽象返回值唯一</p>
</li>
<li><p>pascal.taie.analysis.pta.ci.PointsToSet</p>
<p>这个类表示指针集，即指针分析中的 <code>Obj</code> 集合</p>
</li>
<li><p>pascal.taie.analysis.pta.ci.Pointer</p>
<p>这个类表示分析中的指针，即 <strong>PFG（指针流图，pointer flow grpah）中的节点</strong>。每个指针都与一个指针集相关联，你可以调用 <code>getPointsToSet()</code> 来获得这个指针集</p>
<p><strong>该类存在4个子类</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226182046634.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226182046634.png" alt="image-20221226182046634"></p>
<p>与下图对应</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226182108962.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226182108962.png" alt="image-20221226182108962"></p>
</li>
<li><p>pascal.taie.analysis.pta.ci.PointerFlowGraph</p>
<p>还维护着从变量、静态字段、实例字段、数组索引到相应指针（即 PFG 节点）的映射，因此你可以利用这个类的 API 获得各种指针</p>
</li>
<li><p>pascal.taie.analysis.pta.ci.WorkList</p>
<p>这个类表示指针分析算法中的 worklist</p>
</li>
<li><p>pascal.taie.analysis.pta.ci.Solver</p>
<p>可以使用前面作业中介绍的 <code>DefaultCallGraph</code> 的 API 来修改调用图</p>
</li>
</ul>
</li>
<li><p>需要实现的API</p>
<ul>
<li><p>void addReachable(JMethod)</p>
<p>这里学习一种新的设计模式：<strong>访问者模式<a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/visitor">https://refactoringguru.cn/design-patterns/visitor</a></strong></p>
<p>对于不同种类的语句，你需要使用不同的逻辑来处理。</p>
<blockquote>
<p>Tai-e 的 IR 天然支持访问者模式。具体来说，Tai-e 提供了 <code>pascal.taie.ir.stmt.StmtVisitor</code> 类，这是所有 <code>Stmt</code> 访问者的通用接口，它为<strong>所有种类的语句</strong>都声明了访问操作。另外，<code>Stmt</code> 的非抽象子类都实现了 <code>accept(StmtVisitor)</code> 方法，因此它们可以<strong>回调来自具体访问者</strong>的访问操作。</p>
<p>出于方便，我们提供了 <code>Solver.resolveCallee(Obj,Invoke)</code> 来解析 Java 中静态调用、虚调用、接口调用和特殊调用（static, virtual, interface, and special invocations）的<strong>被调用者</strong>。</p>
</blockquote>
<p>原理如图</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226202114830.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226202114830.png" alt="image-20221226202114830"></p>
<p>先说一下底下的全局数组值都对应哪个变量，RM位于<code>DefaultCallGraph</code>类中，可以通过<code>addReachableMethod</code>方法进行添加；而对于变量S，实验框架为了方便存储和处理，直接关联到了每一个Var上，即内部类RelevantStmts。对于我们想要寻找的语句只需调用对应类型的API即可</p>
<blockquote>
<p>在框架里面，因为每个方法都生成了 IR，相应地也会为每个变量添加好 <code>RelevantStmts</code>。这会导致一些空间的消耗，但是因为变量都是局部的，当你访问到一个变量时，其相关语句必然也是 <code>reachable</code> 的</p>
</blockquote>
<p>因此我们可以忽略 $S_m$ 的添加，在遍历时即已经添加完成。接下来只需对New<code>,</code>Copy<code>, 以及静态的</code>Inoke<code>,</code>StoreField<code>,</code>LoadField按照对应的规则进行处理即可。</p>
</li>
</ul>
</li>
</ul>
<pre><code>这里特别说明静态方法调用的处理，相比于实例方法调用，少了传递receiver obj 和dispatch的操作，但仍需要找到对应的目标方法。这里可以利用`resolveCallee()`，参考ProcessCall

![image-20221226213615543](静态分析/image-20221226213615543.png)

![image-20221226212915744](静态分析/image-20221226212915744.png)
</code></pre><ul>
<li><p>void addPFGEdge(Pointer,Pointer)</p>
<p>原理如下</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226214552955.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226214552955.png" alt="image-20221226214552955"></p>
</li>
<li><p>void analyze()</p>
<p>这个方法实现了 <code>Solve</code> 函数的主要部分，即while循环部分</p>
<p>不要忘记在这个方法中处理数组 loads/stores。</p>
<p>这里第一个细节在于遍历 $\triangle$ 应为propagate的返回值，即对所有变动的指针集中的对象进行分析处理，这里注意一下该函数的返回值即可留意到</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226222742938.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226222742938.png" alt="image-20221226222742938"></p>
<p>接下来在处理实例变量的load和store语句，要辨析<code>x.f = y</code>和<code>y = x.f</code>中对应变量的关系，充分利用指针提供的API</p>
<p>对于数组的store和load，<code>pointerFlowGraph.getArrayIndex(obj)</code>即可得到数组的下标属性指向的对象</p>
</li>
<li><p>PointsToSet propagate(Pointer,PointsToSet)</p>
<p>该算法合并了算法中的两个步骤，它首先计算差集（<img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226223515243.png" alt="image-20221226223515243">)，然后将 $pts$ 传播到 $pt(p)$ 中。它返回 $\triangle$作为调用的结果。</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226223629023.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226223629023.png" alt="image-20221226223629023"></p>
</li>
<li><p>void processCall(Var,Obj)</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226225223591.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221226225223591.png" alt="image-20221226225223591"></p>
<blockquote>
<p>为了保证 soundness，你应该将一个方法中<strong>由返回变量</strong>（即返回语句中出现的变量）所指向的所有对象传播给其调用点等号左侧的变量。你可以通过相关的 <code>IR</code> 对象获得一个方法的<strong>所有返回变量</strong></p>
</blockquote>
</li>
</ul>
<h5 id="10-Pointer-Analysis-Foundations-II"><a href="#10-Pointer-Analysis-Foundations-II" class="headerlink" title="10 - Pointer Analysis - Foundations II"></a>10 - Pointer Analysis - Foundations II</h5><ul>
<li><p>如何处理方法调用</p>
<p>相对于CHA，指针分析根据实际所指的对象来计算指针集（不光只看声明类型）</p>
<ul>
<li><p>实际方法调用时JVM出现的变化</p>
<p>dispatch实际方法</p>
<p>传 resolve object</p>
<p>传参数</p>
<p>传返回值</p>
</li>
</ul>
<p><strong>规则</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221222114210334.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221222114210334.png" alt="image-20221222114210334"></p>
<p>k即调用点方法的签名，传Receiver object给$m_{this}$，即将实际调用方法的对象传给方法中的this变量。然后进行实参传给形参，为了方便传参都会建立PFG边。最后返回值从目标方法返回返回值变量用$m_{ret}$表示</p>
<p>为什么this不建边呢？</p>
<p>Receiver object只会流向它实际调用方法的this变量当中去，但是PFG边的构建是会将所有指向对象都连上，这样会引入很多假的调用关系</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221222114719178.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221222114719178.png" alt="image-20221222114719178"></p>
<p>那为什么参数和返回值可以连？</p>
<p>参数无法决定实际调用哪个方法，所以采取保守手段。但是this更精确就不用连</p>
</li>
<li><p>过程间指针分析方法处理</p>
<p>与CHA类似，指针分析的调用方法处理也是与CALL Graph互相依赖。但后者会从一个入口方法开始，慢慢去探寻可达的方法，最终建立Reachable World，仅在可达方法上作分析</p>
<p> <strong>算法</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221222115952662.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221222115952662.png" alt="image-20221222115952662"></p>
<p>entry方法可以理解为程序的入口方法（如main）</p>
<p><code>AddReachable()</code> 扩展Reachable World</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221222121013955.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221222121013955.png" alt="image-20221222121013955"></p>
<p>这里看到在新方法加入时只处理new 和 赋值语句。load和store需要根据指针信息的内容来处理，但前两者不需要所以这里在刚加入时只做这两个处理</p>
<p><code>ProcessCall(x, o_i)</code> 过程调用，实际就是对上面Rule的实现。x的receiver object的变量，$o_i$就是表示流向x的新对象</p>
<p> 这里注意在dispatch的时候，虽然引入了新的对象，但是实际寻找的调用目标方法到m的边之前可能已经连过（存在其他的指向对象但是调用的相同的目标方法）</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221222125155370.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221222125155370.png" alt="image-20221222125155370"></p>
<p>整个算法输出：指针集以及Call Graph</p>
<p>exp</p>
<p>初始化</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221222130440031.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221222130440031.png" alt="image-20221222130440031"></p>
<p>大循环</p>
<p>处理b的ProcessCall</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221222131043316.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221222131043316.png" alt="image-20221222131043316"></p>
<p>与CHA 处理的对比</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221222131322243.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221222131322243.png" alt="image-20221222131322243"></p>
<p>foo方法内的变化 AddReachable 传参 传返回值</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221222131709207.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221222131709207.png" alt="image-20221222131709207"></p>
<p>处理剩下的WL中的指向关系</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221222131934777.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221222131934777.png" alt="image-20221222131934777"></p>
</li>
</ul>
<h5 id="11-Pointer-Analysis-Context-Sensitivity-I"><a href="#11-Pointer-Analysis-Context-Sensitivity-I" class="headerlink" title="11 - Pointer Analysis - Context Sensitivity I"></a>11 - Pointer Analysis - Context Sensitivity I</h5><p>上下文不敏感指针分析引起的精度下降的问题</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223155240822.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223155240822.png" alt="image-20221223155240822"></p>
<ul>
<li><p>上下文不敏感不准确的本质</p>
<p>动态执行时，一个方法可以调用多次，每次调用的上下文均不同（参数 返回点），导致指向不同的对象</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223160938020.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223160938020.png" alt="image-20221223160938020"></p>
<p>上下文敏感模型建模就是能区分不同上下文之间的数据流</p>
</li>
<li><p>最早的策略采用调用栈抽象的方式</p>
<p>把一系列call sites（调用方法的位置）串起来</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223161813155.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223161813155.png" alt="image-20221223161813155"></p>
<p>通过给予不同方法不同上下文前提，也就标记了方法中的变量也在不同上下文中，指向不同的对象。每个上下文对应一份方法和其中变量的克隆副本</p>
</li>
<li><p>上下文敏感 Heap</p>
<p>给抽象的堆当中加入上下文，得到粒度更细的堆抽象</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223162724354.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223162724354.png" alt="image-20221223162724354"></p>
<p>为什么会有用？</p>
<p>每一个创建出的对象会根据不同的数据流给予不同操作</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223163111155.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223163111155.png" alt="image-20221223163111155"></p>
<p>exp</p>
<p>没有上下文敏感堆抽象的分析，实际上x1和x2是指向两个对象的，因此导致最后newX方法的结果合并到一个对象中去了</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223163718914.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223163718914.png" alt="image-20221223163718914"></p>
<p>有上下文敏感堆抽象的分析</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223170711730.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223170711730.png" alt="image-20221223170711730"></p>
<p>但是如果只给heap加上下文，不给变量加上下文</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223170955255.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223170955255.png" alt="image-20221223170955255"></p>
<p>也就是说两者需要共同作用才能更好提升精度</p>
</li>
<li><p>规则</p>
<p>Domains and Notations </p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223171413498.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223171413498.png" alt="image-20221223171413498"></p>
<p><strong>Rules</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223171651151.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223171651151.png" alt="image-20221223171651151"></p>
<p>New语句，变量在上下文c之下，指向在上下文C之下创建的对象$o_i$(堆抽象也加上下文)</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223171843191.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223171843191.png" alt="image-20221223171843191"></p>
<p>Assign赋值语句，x和y在同一上下文中</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223172007420.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223172007420.png" alt="image-20221223172007420"></p>
<p>Store语句，分别取x和y在上下文c中所指向的对象</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223172159230.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223172159230.png" alt="image-20221223172159230"></p>
<p>Load语句，先去找x在上下文c中指向的对象，在找x.f指向的对象</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223172341965.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223172341965.png" alt="image-20221223172341965"></p>
<p>Call语句，首先找到receiver object x在上下文c中指向的对象。然后dispatch出对应的方法（根据方法签名和receiver object），其次要去选择对应上下文中的方法，定义Select方法，根据调用点l拿到的所有信息来选择上下文</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223173634598.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223173634598.png" alt="image-20221223173634598"></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223174221246.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223174221246.png" alt="image-20221223174221246"></p>
<p>exp</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223173940174.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221223173940174.png" alt="image-20221223173940174"></p>
<p>之后传receiver object 给指定$c^t$上下文中的方法m，然后传参数也是如此。最后传返回值，返回给指定上下文的变量（这个调用点和目标上下文方法是关联的，知道数据流的流动来源）</p>
</li>
</ul>
<h5 id="12-Pointer-Analysis-Context-Sensitivity-II"><a href="#12-Pointer-Analysis-Context-Sensitivity-II" class="headerlink" title="12 - Pointer Analysis - Context Sensitivity II"></a>12 - Pointer Analysis - Context Sensitivity II</h5><ul>
<li><p>上下文敏感指针分析算法</p>
<p>Pointer Flow Graph with C.S.</p>
<p>结点：程序当中上下敏感的指针（变量或者对象的field），每个结点都带有上下文信息</p>
<p>边：指针流向关系</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225154351498.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225154351498.png" alt="image-20221225154351498"></p>
<p> 对于调用方法的规则，主要传参和返回值时上下文的选择</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225161756579.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225161756579.png" alt="image-20221225161756579"></p>
<p>算法</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225161903063.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225161903063.png" alt="image-20221225161903063"></p>
<p>RM代表已经可达的带有上下文信息的方法</p>
<p>call site和 callee都要有上下文（更准确）</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225162349177.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225162349177.png" alt="image-20221225162349177"></p>
<p><strong>AddReachable</strong></p>
<p>入口方法给一个空的上下文</p>
<p>对于new语句，堆抽象的上下文来自方法传进来的上下文</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225162619351.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225162619351.png" alt="image-20221225162619351"></p>
<p><strong>Propagate</strong>方法和<strong>AddEdge</strong>方法和CI一样</p>
<p>这里x和y的上下文是一样的，这样保证了不同方法分析时是出于不同上下文下</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225163213057.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225163213057.png" alt="image-20221225163213057"></p>
<p><strong>ProcessCall</strong></p>
<p>这里最关键的一步是选出上下文Select函数</p>
<p>c就是调用点所在上下文，l代表调用点 c’ 代表receiver object所在上下文</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225163801247.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225163801247.png" alt="image-20221225163801247"></p>
</li>
<li><p>Select函数如何选择</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225164649682.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225164649682.png" alt="image-20221225164649682"></p>
<p>仅考虑其中一两个参数作为上下文的选择</p>
<p>上下文敏感 Varints</p>
<ol>
<li><p>调用点敏感</p>
<p>每个上下文由一系列调用点构成一个call chain. 本质上就是对调用栈的抽象</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225164910121.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225164910121.png" alt="image-20221225164910121"></p>
<p>exp</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225165305754.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225165305754.png" alt="image-20221225165305754"></p>
<p>对于递归调用，则将会有无穷个上下文。因此需要保证算法能够终止，采用k-Limiting Context Abstraction，限制调用链长度</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225165628940.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225165628940.png" alt="image-20221225165628940"></p>
<p>假设k取1</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225165821016.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225165821016.png" alt="image-20221225165821016"></p>
<p>一般k取2 保留最后一个上下文</p>
<p>exp</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225172314775.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225172314775.png" alt="image-20221225172314775"></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225172606527.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225172606527.png" alt="image-20221225172606527"></p>
<p>处理方法m中的<strong>AddReachable</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225172739344.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225172739344.png" alt="image-20221225172739344"></p>
<p>处理worklist剩余指针对，调用id方法 传参 传返回值</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225173055993.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225173055993.png" alt="image-20221225173055993"></p>
<p>与15行调用的对比</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225173221527.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225173221527.png" alt="image-20221225173221527"></p>
<p>继续处理worklist</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225173435521.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225173435521.png" alt="image-20221225173435521"></p>
<p>与上下文不敏感对比，前者则会将数据流混在一起，x和y一定会有误报出现</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225173622849.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225173622849.png" alt="image-20221225173622849"></p>
</li>
<li><p>对象敏感</p>
<p>对于OO语言，对receiver object作为上下文策略</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225173822520.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225173822520.png" alt="image-20221225173822520"></p>
<p>exp</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225174516014.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225174516014.png" alt="image-20221225174516014"></p>
<p>a1.get()调用时即可很容易得到this来自上下文o1 this.f即o1.f也就是指向o3</p>
<p>每个this变量一定是<strong>上下文本身</strong></p>
<p>与 1-call-site作对比，前者是不能够分开的，就是因为在doSet方法这里有一个数据流汇合</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225174956980.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225174956980.png" alt="image-20221225174956980"></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225175116318.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225175116318.png" alt="image-20221225175116318"></p>
<p>但是对于刚才的程序，1-object就不行，因为这里this是一样的</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225175508317.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225175508317.png" alt="image-20221225175508317"></p>
</li>
<li><p>类型敏感</p>
<p>基于对象敏感技术的进一步抽象</p>
<p>调用点 receiver object 所在的类型作为上下文</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225175956573.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225175956573.png" alt="image-20221225175956573"></p>
<p>对象敏感粗粒度的抽象</p>
<p>exp</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225180214730.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221225180214730.png" alt="image-20221225180214730"></p>
</li>
</ol>
</li>
</ul>
<h5 id="实验6-上下文敏感的指针分析"><a href="#实验6-上下文敏感的指针分析" class="headerlink" title="实验6 上下文敏感的指针分析"></a>实验6 上下文敏感的指针分析</h5><ul>
<li><p>新处理规则</p>
<ol>
<li><p>静态字段</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228212612160.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228212612160.png" alt="image-20221228212612160"></p>
</li>
<li><p>数组索引</p>
<p>常规的指针分析不区别对针对同一数组不同位置的 store 和 load</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228212737336.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228212737336.png" alt="image-20221228212737336"></p>
</li>
<li><p>静态方法</p>
<blockquote>
<p>1）不需要在 receiver object 上通过 dispatch 来解析出被调用方法。2）不需要传递 receiver object</p>
</blockquote>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228212825150.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228212825150.png" alt="image-20221228212825150"></p>
</li>
</ol>
</li>
<li><p>需要了解的类</p>
<p><code>IR</code>、<code>Var</code>、<code>InvokeExp</code> 以及 <code>DefinitionStmt</code>的子类 JMethod<code>、</code>JField<code>、</code>Obj<code>和</code>HeapModel</p>
<ol>
<li><p>pascal.taie.analysis.pta.core.cs.context.Context</p>
<p>该类表示上下文敏感的指针分析中的上下文</p>
</li>
<li><p>pascal.taie.analysis.pta.core.cs.element.CSElement</p>
<p>该类表示指针分析中需要用到上下文的元素，每个这样的元素都和一个上下文相关联。四个子类如下</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228213226078.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228213226078.png" alt="image-20221228213226078"></p>
</li>
<li><p>pascal.taie.analysis.pta.core.cs.element.Pointer</p>
<p>该类表示上下文敏感指针分析中的指针，每个 <code>Pointer</code> 和一个 <code>PointsToSet</code> 相关联，通过调用getPointsToSet()取得</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228213414056.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228213414056.png" alt="image-20221228213414056"></p>
</li>
<li><p>pascal.taie.analysis.pta.core.cs.element.CSManager</p>
<p>该类管理所有需要用到上下文的元素和所有上下文敏感的指针。</p>
</li>
<li><p>pascal.taie.analysis.pta.core.cs.selector.ContextSelector</p>
<blockquote>
<p>该类是上下文敏感指针分析框架和<strong>具体的上下文敏感策略</strong>（如调用点敏感、对象敏感等）之间的接口。</p>
<p>该类有 4 个 API，其中一个 API 返回空上下文，另外三个 API 分别为静态方法、实例方法和堆对象（heap object）选择上下文。</p>
<p>当你在上下文敏感指针分析中处理 <code>Invoke</code> 和 <code>New</code> 语句时，你需要使用本类的各个子类中的方法来<strong>生成目标方法</strong>（<code>Invoke</code> 语句）和<strong>新创建对象</strong>（<code>new</code> 语句）的上下文。</p>
</blockquote>
</li>
<li><p>pascal.taie.analysis.pta.core.cs.CSCallGraph</p>
<p>该类表示上下文敏感的调用图.你需要使用其中的 <code>addReachableMethod(CSMethod)</code> 以及 <code>addEdge(Edge)</code> 这两个 API 来修改调用图。</p>
</li>
<li><p>pascal.taie.analysis.pta.pts.PointsToSet</p>
<p>可迭代</p>
</li>
<li><p>pascal.taie.analysis.pta.pts.PointsToSetFactory</p>
<p>该类提供创建 <code>PointsToSet</code> 的静态工厂方法。</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228214101683.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228214101683.png" alt="image-20221228214101683"></p>
</li>
<li><p>pascal.taie.analysis.pta.cs.PointerFlowGraph</p>
<p>该类表示程序的指针流图 PFG</p>
</li>
<li><p>pascal.taie.analysis.pta.cs.WorkList</p>
<p>该类表示指针分析算法中的 WorkList。</p>
</li>
<li><p>pascal.taie.analysis.pta.cs.Solver</p>
<p><strong>API1: </strong>void addReachable(CSMethod)</p>
<p>原理如下</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228214457985.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228214457985.png" alt="image-20221228214457985"></p>
<blockquote>
<p>方法 <code>Solver.resolveCallee(CSObj,Invoke)</code> 用于解析各种方法调用的被调用方法</p>
</blockquote>
<p>这里依然采用访问者模式来处理方法中的不同类型语句，不同点在于这里加上了上下文，因此不能再用同一个StmtProcessor，在用的时候创建即可；其次，我们需要注意对于New 和 Invoke语句要ContextSelector类生成上下文</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228221441158.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228221441158.png" alt="image-20221228221441158"></p>
<p>然后利用csManager，来获得带有上下文的指针</p>
<p>对于静态方法调用，不需要dispatch和传this变量，其他参考</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228230101004.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228230101004.png" alt="image-20221228230101004"></p>
<p>依然记得resolveCallee对于静态方法来说，其recv设为null即可。同时，要分清调用点方法的上下文以及调用者所在上下文之间的关系。</p>
<p><strong>API2:</strong> void addPFGEdge(Pointer,Pointer)</p>
<p>原理如下</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228233438434.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228233438434.png" alt="image-20221228233438434"></p>
<p><strong>API3: </strong> void analyze()</p>
<p>实现  Solve方法中<em>while</em> 循环的部分</p>
<p>基本不变，指针获取方式改一下就行</p>
<p><strong>API4： </strong>PointsToSet propagate(Pointer,PointsToSet)</p>
<p>和上次作业一样先算差集</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228234857856.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228234857856.png" alt="image-20221228234857856"></p>
<p><strong>API5：</strong>void processCall(CSVar,CSObj) </p>
<p>把处理静态方法的改一下就好</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228235500297.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221228235500297.png" alt="image-20221228235500297"></p>
</li>
</ol>
</li>
<li><p>实现常见的上下文敏感策略</p>
<p>需要了解的类</p>
<ul>
<li><p>pascal.taie.analysis.pta.core.cs.selector.ContextSelector</p>
<p>实现另外6个子类</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221229000425337.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221229000425337.png" alt="image-20221229000425337"></p>
<p>分别对应即调用点敏感（call-site sensitivity）、对象敏感（object sensitivity）和类型敏感（type sensitivity）。对每个策略，你需要分别实现两个 selector（分别针对 k-limiting 的上下文中的k=1 和 k=2）</p>
</li>
<li><p>pascal.taie.analysis.pta.core.cs.context.ListContext</p>
<blockquote>
<p>该类实现了 <code>Context</code> 接口，它将每个上下文表示为一个由若干同类型元素组成的有序列表（对三种上下文敏感策略，该列表分别采用不同的元素来表示上下文：调用点敏感使用的元素为 <code>Invoke</code>，对象敏感使用的元素为 <code>Obj</code>，类型敏感使用的元素为 <code>Type</code>）。</p>
<p>该类提供一系列静态工厂方法，即 <code>make(...)</code> 方法来创建上下文。</p>
<p>对每个k 层的 context selector，其堆上下文（heap context）的层数为 k-1</p>
</blockquote>
<p>首先是调用点敏感上下文</p>
<p>对于1层的实现，其堆上下文的层数为0层，因此直接返回一个空集即可；对于静态方法的调用点上下文和实例方法，由于只有一层，因此直接返回调用点的上下文即可。对于两层的实现，其堆上下文的层数为1。细节在于其堆上下文继承于调用方法的上下文，因此直接选取调用方法的上下文并作筛选层数即可。我们要注意，调用点敏感使用的元素为 <code>Invoke</code>，对象敏感使用的元素为 <code>Obj</code>，类型敏感使用的元素为 <code>Type</code>），这个也就是<code>ListContext</code>类修改上下文时所操作的元素，对于调用实例方法，我们只需要将调用点的上下文与调用者组合在一起即成为被调用方法的上下文；而对于静态方法调用，由于调用者本身并没有上下文，所以只需要传递调用点上下文即可</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221229093144466.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221229093144466.png" alt="image-20221229093144466"></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221229091402650.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221229091402650.png" alt="image-20221229091402650"></p>
<p>其次是对象敏感上下文，对象敏感使用的元素为 <code>Obj</code>。对于静态方法调用，直接地使用调用者方法的上下文作为被调用方法的上下文。对于堆上下文的选择，是不用创建新的上下文的，因为其是基于对象进行的选择，这里并没有新的recv object，只是需要降为k-1层堆上下文即可</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221229101632627.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221229101632627.png" alt="image-20221229101632627"></p>
</li>
</ul>
</li>
</ul>
<pre><code>最后是类型敏感，其是对象敏感的进一步抽象，取调用点所在类的类型作为上下文的元素

![image-20221229102933241](静态分析/image-20221229102933241.png)
</code></pre><h5 id="13-Static-Analysis-for-Security"><a href="#13-Static-Analysis-for-Security" class="headerlink" title="13 - Static Analysis for Security"></a>13 - Static Analysis for Security</h5><ul>
<li><p>信息流安全</p>
<p>本质目标：<strong>保护信息安全，阻止危险的信息流</strong></p>
<p><strong>常见手段：</strong>访问控制但是不足，无法获知拿到信息之后的情况</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227192813636.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227192813636.png" alt="image-20221227192813636"></p>
<p><strong>信息流的定义</strong> </p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227193007191.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227193007191.png" alt="image-20221227193007191"></p>
<p><strong>信息流如何与安全进行结合？</strong></p>
<p>为程序中的变量设定等级，且规定不同等级之间的信息如何进行流动（指定策略）</p>
<p><strong>安全等级</strong></p>
<p>基本模型采取两级策略</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227193413786.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227193413786.png" alt="image-20221227193413786"></p>
<p>分级也可以用格的概念来表示，因为之间具有偏序关系</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227193441406.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227193441406.png" alt="image-20221227193441406"></p>
<p><strong>信息流策略</strong></p>
<p>非干涉策略</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227193810557.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227193810557.png" alt="image-20221227193810557"></p>
<p>public的内容可以被外界观测到的，也就是说不能通过外界观测到的public中的信息反推测出secret中的信息</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227194250132.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227194250132.png" alt="image-20221227194250132"></p>
<p>高密级信息不能流向低密级，从格的角度来看，信息流只能往上流动</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227194349378.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227194349378.png" alt="image-20221227194349378"></p>
</li>
<li><p>保密性和完整性</p>
<p>组织隐私信息被观测到 -&gt; <strong>保密性</strong></p>
<p><strong>完整性</strong>：阻止的是不可信任的信息，防止它们污染我们关键的信息</p>
<p>也就是说完整性阻止的信息流是反向的</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227195327248.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227195327248.png" alt="image-20221227195327248"></p>
</li>
<li><p>显式流和隐藏信道（程序中信息流动的方式）</p>
<p>直接通过copy方式的叫做显式流</p>
<p><strong>隐式流：</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227201429928.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227201429928.png" alt="image-20221227201429928"></p>
<p>当然，这种由密码信息泄露的控制带来的副作用要可以被观测到</p>
<p>这里如果能观测到异常的话比如数组越界，仍然能推断出秘密的信息</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227202123934.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227202123934.png" alt="image-20221227202123934"></p>
<p>这一类信息称为隐藏信道，其本身机制的目的并不是为了信息传递</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227202256715.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227202256715.png" alt="image-20221227202256715"></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227202351129.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227202351129.png" alt="image-20221227202351129"></p>
<p>通常情况下显式流携带的隐藏信息更多，隐藏信道携带的隐藏信息有限，因此我们更多关注显式流</p>
</li>
<li><p>污点分析</p>
<p>将数据分为两类，污点数据是我们所关注的数据，打上标记方便追踪</p>
<p>其他数据即不关心数据</p>
<p>污点数据的源头称为source，污点分析关心数据流是否会流动到特定的位置（sinks）</p>
<p>两类应用：保密性和完整性</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227203856452.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227203856452.png" alt="image-20221227203856452"></p>
<p>指针分析与污点分析的关系</p>
<p>一个污点数据是否能流到sinks? -&gt; 调用sink方法的指针是否可以指向一个污点数据？</p>
<p>把污点数据视为一类特殊的object，把source视作allocation sites，也就是调用source时产生的污点数据</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227204932676.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227204932676.png" alt="image-20221227204932676"></p>
<p>如何借助指针分析实现污点分析</p>
<p>首先需要拓展域（上下文不敏感指针分析为例）</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227205122941.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227205122941.png" alt="image-20221227205122941"></p>
<p>规定输入和输出</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227211542864.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227211542864.png" alt="image-20221227211542864"></p>
<p>规则</p>
<ol>
<li><p>处理source</p>
<p>产生污点数据</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227211720549.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227211720549.png" alt="image-20221227211720549"></p>
<p>传播污点数据</p>
<p>规则与指针分析是一样的</p>
</li>
<li><p>处理sinks</p>
<p>如果方法为sinks方法，则遍历方法参数的指针集，若其中发现了污点数据，则会产生一个taintflows输出当中</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227211849105.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227211849105.png" alt="image-20221227211849105"></p>
</li>
</ol>
<p>exp</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227212531481.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227212531481.png" alt="image-20221227212531481"></p>
</li>
</ul>
<h5 id="14-Datalog-Based-Program-Analysis"><a href="#14-Datalog-Based-Program-Analysis" class="headerlink" title="14 - Datalog-Based Program Analysis"></a>14 - Datalog-Based Program Analysis</h5><ul>
<li><p>Datalog</p>
<p>本身是一个声明式逻辑语言</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230114629649.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230114629649.png" alt="image-20221230114629649"></p>
<p>Data部分：以谓词的形式表示</p>
<p>什么是谓词？<strong>一系列陈述的集合，陈述了不同客体之间的事实，可以看作是一张表</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230114906670.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230114906670.png" alt="image-20221230114906670"></p>
<p>fact可以看作表中的一行，由值构成的元组是表中的一行</p>
<p>基本元素 <strong>Atoms</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230115520104.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230115520104.png" alt="image-20221230115520104"></p>
<p>$P(X1, X2, \dots, Xn)$ 也叫作关系型谓词，Datalog也有算术型谓词 如 $age \geq 18$</p>
</li>
<li><p>Datalog Rules (Logic)</p>
<p>如何根据已有的谓词推导出新的谓词</p>
<p><strong>推导式形式：</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230120056080.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230120056080.png" alt="image-20221230120056080"></p>
<p>逗号可以看作逻辑与</p>
<p>如何去解读规则？枚举所有可能的谓词组合，当所有子目标为真时，head也为真，即可推导出一个新的谓词</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230120340321.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230120340321.png" alt="image-20221230120340321"></p>
<p>exp</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230120732536.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230120732536.png" alt="image-20221230120732536"></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230120958666.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230120958666.png" alt="image-20221230120958666"></p>
<p>最开始的Facts从哪来的呢？</p>
<p>Datalog的谓词划分为两类</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230125509123.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230125509123.png" alt="image-20221230125509123"></p>
<p><strong>逻辑或关系的表示</strong></p>
<ol>
<li><p>写多条rules</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230125645208.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230125645208.png" alt="image-20221230125645208"></p>
</li>
<li><p>使用分号逻辑运算符</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230125706807.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230125706807.png" alt="image-20221230125706807"></p>
</li>
</ol>
<p><strong>逻辑非的表示</strong></p>
<p>可以是原子目标的取反</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230125845658.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230125845658.png" alt="image-20221230125845658"></p>
<p><strong>支持递归Recursion规则</strong></p>
<p>IDB可以直接或间接从自身推导出来</p>
<p>例如图的可达性</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230130237018.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230130237018.png" alt="image-20221230130237018"></p>
<p><strong>规则的安全性</strong></p>
<p>对于第一个，如果y属于B且是EDB类型的，那么就会存在无穷多个x，也就推导无穷个谓词来；右边同理</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230133238534.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230133238534.png" alt="image-20221230133238534"></p>
<p>因此为了避免这种情况，变量必须出现在谓词当中且无非逻辑出现，这样相当于变量是有限的，因为表是有限的</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230133438243.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230133438243.png" alt="image-20221230133438243"></p>
<p><strong>还有一种可能出现问题的情况：Recursion and Negation</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230133842371.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230133842371.png" alt="image-20221230133842371"></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230133902898.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230133902898.png" alt="image-20221230133902898"></p>
<p>原子如果能递归的推导出它的非是没有意义的，会出现环的情况</p>
<p>因此Datalog的fact是单调的，且一定是有限的（为了满足规则的安全性）</p>
</li>
<li><p><strong>实现指针分析</strong></p>
<p>EDB：从程序语法上可以直接提取的指针信息</p>
<p>Datalog下谓词表示</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230134810426.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230134810426.png" alt="image-20221230134810426"></p>
<p>exp</p>
<p>EDB输入</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230135345578.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230135345578.png" alt="image-20221230135345578"></p>
<p><strong>规则的定义</strong>（流不敏感）</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230140010067.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230140010067.png" alt="image-20221230140010067"></p>
<p><strong>实际处理过程</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230140701229.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230140701229.png" alt="image-20221230140701229"></p>
</li>
</ul>
<p><strong>方法调用如何处理</strong></p>
<p>规则如下</p>
<p>规则1</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230144613634.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230144613634.png" alt="image-20221230144613634"></p>
<p>规则2，传参数</p>
<p>调用点l第i个参数对应的变量a</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230144313582.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230144313582.png" alt="image-20221230144313582"></p>
<p>规则3 传返回值</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230144512492.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230144512492.png" alt="image-20221230144512492"></p>
<p>全程序指针分析Datalog实现</p>
<p>加一条入口方法的规则；处理New的时候也加一个限定，表示allocation site在哪个 Reachable方法当中，而对于其他条件都依赖于指向关系，当没有时都不会触发</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230144719020.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230144719020.png" alt="image-20221230144719020"></p>
<ul>
<li><p><strong>Datalog实现污点分析</strong></p>
<p>EDB和IDB谓词声明</p>
<p>Taint谓词把每个call site关联其产生的污点数据</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230145216638.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230145216638.png" alt="image-20221230145216638"></p>
<p>如果t污点数据流到sinks方法，而t也跟call site关联</p>
<p><strong>规则描述</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230145605992.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221230145605992.png" alt="image-20221230145605992"></p>
<p>sinks的call中不关心参数的下标</p>
</li>
</ul>
<h5 id="实验7-Alias-Aware的常量传播"><a href="#实验7-Alias-Aware的常量传播" class="headerlink" title="实验7 Alias-Aware的常量传播"></a>实验7 Alias-Aware的常量传播</h5><ul>
<li><p>别名 </p>
<blockquote>
<p>指向内存中的同一位置的不同符号互为别名</p>
<p>在别名存在的情况下，通过对一个字段/数组的访问来修改一个<strong>实例字段/数组</strong>将会同时修改与这一访问相关的<strong>所有别名值</strong>。</p>
<p>Java 中的静态字段不能拥有别名</p>
</blockquote>
</li>
<li><p>分析实例字段</p>
<blockquote>
<p>我们找到所有对这一<strong>实例字段（以及其别名</strong>）进行修改的 <strong>store 语句</strong>，并将这些语句要 store 的值 meet 之后赋给 L 等号左侧的变量。</p>
</blockquote>
<p>那么别名信息是怎么计算的呢？</p>
<blockquote>
<p>对任意两个<strong>实例字段</strong>的访问（设为 <code>x.f</code> 和 <code>y.f</code>），如果它们的 base 变量的指针集（points-to set）有交集（即 <code>x</code> 和 <code>y</code> 的指针集有交集），那么我们认为对这两个实例字段的访问（<code>x.f</code> 和 <code>y.f</code>）互为别名</p>
</blockquote>
</li>
<li><p>分析静态字段</p>
<blockquote>
<p>当处理一个静态字段的 load 语句时（假设为 <code>x = T.f;</code>），你只需要找到对<strong>同一个字段</strong>（<code>T.f</code>）的 store 语句，并将这些保存进字段的值进行 meet 后赋给 load 语句等号左侧的变量（<code>x</code>）</p>
</blockquote>
</li>
<li><p>分析数组</p>
<p>与之前处理实例字段的方式类似。</p>
<blockquote>
<p>当你判断两个对数组的访问 <code>a[i]</code> 和 <code>b[j]</code> 是否互为别名时，你不仅需要考虑它们的 <strong>base 变量</strong>（<code>a</code> 和 <code>b</code>）的指针集是否有交集，还需要考虑<strong>索引值 <code>i</code> 和 <code>j</code> 的关系</strong>。</p>
</blockquote>
<p>索引关系也可以通过常量分析来得到</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221231094051163.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221231094051163.png" alt="image-20221231094051163"></p>
<p><strong>特别说明：在 Java 中，和局部变量不同，字段（包括实例字段和静态字段）和数组即使没有被显式地初始化过也能被 load，这是因为 Java 会隐式地给 <code>int</code> 类型赋初始值为 0</strong></p>
<p>这样会导致所有对字段和数组的处理都将无意义，因为load的值由于meet操作全变成了NAC(一旦有显示的store情况出现)，因此需要<strong>作出假设：假设所有程序中的字段和数组都在被 load 之前通过 store 语句显式地初始化了，忽略隐式初始化带来的影响</strong></p>
</li>
<li><p>需要了解的类</p>
<ol>
<li><p>pascal.taie.analysis.pta.PointerAnalysisResult</p>
<p>提供了一系列查询指针分析结果的 API</p>
</li>
<li><p>pascal.taie.ir.exp.ArrayAccess</p>
<p>数组访问表达式</p>
<blockquote>
<p>该类的实例在类 <code>StoreArray</code> 和 <code>LoadArray</code> 的实例中出现</p>
</blockquote>
</li>
</ol>
</li>
<li><p>实验</p>
<p>更加精确地处理实例字段、静态字段和数组</p>
<p>我们实际上需要做的工作，首先就是维护一个别名关系。对于实例而言，当进行load/store操作时，先查找到其所有与对象关联的别名变量，进而收集所有的store/load语句，再运用meet操作计算最终的常量值。如何查找关联别名变量，就需要利用指针分析结果，这里利用到了Java中的一个特殊数据结构collection：<code>MultiMap</code>，该map支持相同的重复的键，便于我们通过一个变量查找到所有关联的别名变量</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221231112020089.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221231112020089.png" alt="image-20221231112020089"></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221231105641581.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221231105641581.png" alt="image-20221231105641581"></p>
<p>对于常数传播，我们实际上只需额外的考虑实例/静态的load/store和数组的load/array即可，其他情况均与之前的一样。对于实例变量，我们需要找到关联的别名变量的相关语句进行meet值操作；而对于静态变量，由于其没有相关语句的关联，因此一种办法就是遍历icfg上的所有stmt，进一步判断是否为静态变量</p>
<p>这里也需要针对store语句说明一下，因为一条语句的set操作需要同样对其关联的所有别名变量也作set操作</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221231134720939.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221231134720939.png" alt="image-20221231134720939"></p>
<blockquote>
<p>对于store语句，则需要把所有的<strong>别名的load</strong>加入到<strong>worklist中再次进行更新</strong>。这是因为有时候对象的field是通过getter和setter更新的，而如果在分析时先分析了getter再分析setter就会出现setter中赋的值在getter中拿不到的问题，所以setter更新时将别名的所有<strong>load语句加入worklist</strong>，就和<strong>输出变化后将后继节点加入更新传递</strong>一样</p>
</blockquote>
</li>
</ul>
<h5 id="15-CFL-Reachability-and-IFDS"><a href="#15-CFL-Reachability-and-IFDS" class="headerlink" title="15 - CFL-Reachability and IFDS"></a>15 - CFL-Reachability and IFDS</h5><p>如何用图可达的方式来表示程序分析？</p>
<p>我们希望尽可能误报少，也就是污点数据仅可能的少流动。尽可能的避免不合理的路径出现，但是如何避免呢？</p>
<ul>
<li><p><strong>Realizable Paths:</strong> 通过上下文敏感指针分析识别？</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101181903114.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101181903114.png" alt="image-20230101181903114"></p>
</li>
</ul>
<p>  一种简单的识别方式利用括号匹配</p>
<p>  系统的识别方式：<strong>CFL-Reachability</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101182109484.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101182109484.png" alt="image-20230101182109484"></p>
<p>  只要A和B之间有边构成，且各个边上的label构成的单词必须是规定的合法单词(上下文无关文法产生的单词)</p>
<p>  <strong>context-free grammer (CFG)</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101182454944.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101182454944.png" alt="image-20230101182454944"></p>
<p>  <strong>通过CFL实现部分括号匹配问题</strong></p>
<p>  可以有左括号但是没有括号的情况，代表有call但没return</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101195458996.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101195458996.png" alt="image-20230101195458996"></p>
<p>  exp</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101200211358.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101200211358.png" alt="image-20230101200211358"></p>
<ul>
<li><p><strong>IFDS</strong></p>
<p>直接把程序分析过程用图可达性来表达，而没有按照之前传播的方式</p>
<p>IFDS满足在有限域上，且flow functions 要求是distributive的（类似分配律？）</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101200912682.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101200912682.png" alt="image-20230101200912682"></p>
<p><strong>meet-over-all-realizable-paths(MRP)</strong></p>
<p>只对realizable paths 应用path function</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101201739442.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101201739442.png" alt="image-20230101201739442"></p>
<p>IFDS大致轮廓</p>
<p>前提</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101202256270.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101202256270.png" alt="image-20230101202256270"></p>
<p>将superGraph分解，在其上遍历通过Tabulation algorithm来解决问题</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101202507925.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101202507925.png" alt="image-20230101202507925"></p>
<p><strong>实现目标</strong></p>
<p>Supergraph 里面存在的特征元素</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101202937637.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101202937637.png" alt="image-20230101202937637"></p>
<p>三类特殊的边 call-to-return-site call-to-start exit-to-return-site</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101203103975.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101203103975.png" alt="image-20230101203103975"></p>
<p><strong>设计 flow functions</strong></p>
<p>lambda expression</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101203541609.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101203541609.png" alt="image-20230101203541609"></p>
<p>找出程序中哪些变量还没有被初始化</p>
<p>括号中输出值为未初始化变量</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101204230442.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101204230442.png" alt="image-20230101204230442"></p>
<p>call与ret之间的边要有kill操作，为了精度提高的问题（实际上call-ret是没有这条边的），g有无真正初始化取决于右边的cfg</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101204514144.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101204514144.png" alt="image-20230101204514144"></p>
<p>返回边把形参kill掉，符合作用域生命周期</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101204953004.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101204953004.png" alt="image-20230101204953004"></p>
<p>如何分解supergraph，通过flow functions转换成representation relations，fact中要加个0并复制一倍，边的条数为 $(D+1)^2$ </p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101205235650.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101205235650.png" alt="image-20230101205235650"></p>
<p>flow function转化成一种映射关系</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101205505555.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101205505555.png" alt="image-20230101205505555"></p>
<p>最后两个关系表示 如果有非0 node到y的边，那么就不存在0到y的边</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101210218148.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101210218148.png" alt="image-20230101210218148"></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101210324469.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101210324469.png" alt="image-20230101210324469"></p>
<p><strong>为什么需要0边？</strong></p>
<p>data facts的真正传播是通过一系列flow function调用起来的；对于IFDS，0到0的边实际上就是将一个个representation relation(flow functions)连接起来，这样才能表达出来图的可达性</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101211357332.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101211357332.png" alt="image-20230101211357332"></p>
<p>下面开始构建分解的flow graph，实际上就是flow function到representation relation的映射表示</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101212010074.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101212010074.png" alt="image-20230101212010074"></p>
<p>如果能够reach到最后的结点g，则是可达的</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101212146369.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101212146369.png" alt="image-20230101212146369"></p>
<p>怎么样把最终的可达性结点找出来呢？<strong>Tabulation algorithm</strong></p>
<p><strong>定义</strong> </p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101212743408.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101212743408.png" alt="image-20230101212743408"></p>
<p><strong>算法的核心工作机理</strong></p>
<p>如果只关注一个 data fact，就是一点点去探索可达边，并标记可达结点。对于call边，先标记入口方法的结点 data fact，当在处理每个程序的 exit node时，开始进行括号匹配（call-to-return 匹配）。其中还会加一个summary edge，表示到 call 到 ret也是间接可达的，因为其中可能还有其他call方法未处理（相同的调用过程），这时就可以直接通过summary edge连接上就可以，减少重复的处理过程</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101214400473.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230101214400473.png" alt="image-20230101214400473"></p>
<p>如何理解IFDS的distributivity，也就是什么样的程序可以用它来分析？</p>
<p>   IFD的分析框架是一次处理一个数据，等所有数据处理完之后再作meet处理</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104171349741.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104171349741.png" alt="image-20230104171349741"></p>
<p>因此如何判断是否可以使用IFDS来解决，取决于问题是否需要考虑多个输入才能产出一个输出，也就是输入之间是否独立</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104171504340.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104171504340.png" alt="image-20230104171504340"></p>
<p>对于指针分析，由于为了满足sound条件，需要考虑别名传播的话则需要多重输入同时关联，也就不满足IFDS独立性要求</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104172548023.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104172548023.png" alt="image-20230104172548023"></p>
</li>
</ul>
<h5 id="作业8-污点分析"><a href="#作业8-污点分析" class="headerlink" title="作业8 污点分析"></a>作业8 污点分析</h5><ul>
<li><p>实现污点分析</p>
<p>taint sources：特定的方法（通常是产生数据的 API）</p>
<p>taint sinks：特定方法的某些参数</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230102234534689.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230102234534689.png" alt="image-20230102234534689"></p>
<blockquote>
<p>Sources 二元组 $<m,u>$ 的集合，其中 m 表示一个被视作 source 的<strong>方法的签名</strong>，而 u 是该方法返回的<strong>污点对象的类型</strong>.</m,u></p>
<p>我们用 $t_l^u$ 来表示一个污点对象，其中 u 是这个<strong>对象的类型</strong>，l 表示创建<strong>这个对象的调用点</strong>（<strong>call site</strong>）。你只需要使用<strong>空上下文</strong>作为污点对象的堆上下文（<strong>heap context</strong>）</p>
</blockquote>
<p>什么是污点传播？</p>
<blockquote>
<p>污点分析中的污点是一个更加抽象的概念——它与数据的<strong>内容</strong>相关联，因此它可以在不同的对象之间<strong>传播</strong></p>
</blockquote>
<p>污点传播过程碰到各种API该如何处理其语义？</p>
<p>告诉污点分析哪些<strong>方法</strong>会引发污点传播以及它们是如何传播污点的</p>
<p>有三种污点传播的模式：</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230102235746744.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230102235746744.png" alt="image-20230102235746744"></p>
<ol>
<li><strong>Base-to-result</strong>：如果 <code>receiver object</code>（由 <code>base</code> 指向）被污染了，那么该方法调用的返回值也会被污染。<code>StringBuilder.toString()</code> 是这样一类方法。</li>
<li><strong>Arg-to-base</strong>：如果某个特定的参数被污染了，那么 <code>receiver object</code>（由 <code>base</code> 指向）也会被污染。<code>StringBuilder.append(String)</code> 是这样一类方法。</li>
<li><strong>Arg-to-result</strong>：如果某个特定的参数被污染了，那么该方法调用的返回值也会被污染。<code>String.concat(String)</code> 是这样一类方法。</li>
</ol>
<p>静态方法由于没有base变量，所以<strong>不会</strong>引起 base-to-result 和 arg-to-base 的污点传播；此外，一些方法会引起多种污点传播，例如返回值中同时包含了参数和 receiver object 的内容的情况</p>
<p><strong>TaintTransfers</strong></p>
<p>由四元组 $<m, from, to, u>$ 所构成的集合，其中 m 表示会引发污点传播的方法，而污点会从 from 所表示的变量中传播到 所表示的变量中。u 表示传播后的污点（由 to 指向）的类型</m,></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230103103312871.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230103103312871.png" alt="image-20230103103312871"></p>
<p><strong>污点分析规则：</strong></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230103103336974.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230103103336974.png" alt="image-20230103103336974"></p>
</li>
<li><p>需要了解的类</p>
<p>pascal.taie.analysis.pta.plugin.taint.Source</p>
<p>表示 sources</p>
<p>pascal.taie.analysis.pta.plugin.taint.Sink</p>
<p>表示 sinks</p>
<p>pascal.taie.analysis.pta.plugin.taint.TaintTransfer</p>
<p>在这个类中，我们用整数来表示污点传播被对应方法引发时的 from 变量和 to 变量。具体来说，<strong>一个大于等于 0 的整数 i 表示调用点上被调用方法的第 i 个参数</strong>；<strong>-1 表示 base 变量</strong>；<strong>-2 表示接收结果的变量</strong></p>
<p>pascal.taie.analysis.pta.plugin.taint.TaintConfig</p>
<p>解析配置文件以及获取 sources、sinks 和污点传播信息的 API</p>
<p>pascal.taie.analysis.pta.plugin.taint.TaintManager</p>
<p>管理污点分析中的污点对象</p>
<p>pascal.taie.analysis.pta.plugin.taint.TaintFlow</p>
<p>分析算法检测到的 taint flows（由 source 的调用点和 sink 的调用点组成），也就是污点分析算法的结果</p>
<p>pascal.taie.analysis.pta.plugin.taint.TaintAnalysiss</p>
<p>本次实验的关键在于在什么地方处理source sinks 和transfer规则。sinks好说，因为它依赖于最终指针分析的结果，我需要去遍历所有callsite提取出所有invoke方法，然后判断配置文件sinks方法中的污点参数是否出现在callsite参数当中</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230103115030805.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230103115030805.png" alt="image-20230103115030805"></p>
<p>对于source和transfer的处理，我们只需关注所有invoke语句即可，source本质是从方法中产生污点对象。我们需要考虑静态调用和实例调用两种情况。这里细节就在source的处理是在出现新的调用边加入到edge时进行的判断，而transfer只要污点对象发生变化时，我就需要对其进行处理将变化的值加入到worklist当中随指针分析进行传播。污点对象的变化分为参数和base两种情况，对于base的处理是在process call当中，对于参数的变化需要自己去加</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230103121122926.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230103121122926.png" alt="image-20230103121122926"></p>
</li>
</ul>
<h5 id="16-Soundness-and-Soundiness"><a href="#16-Soundness-and-Soundiness" class="headerlink" title="16 - Soundness and Soundiness"></a>16 - Soundness and Soundiness</h5><ul>
<li><p>Hard Language Features for Static Analysis</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104173512742.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104173512742.png" alt="image-20230104173512742"></p>
<p>这样会导致由于对某些hard language features不分析而对分析结果产生很大影响</p>
</li>
<li><p>Soundiness</p>
<p>直觉上是sound但是没有证据支撑</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104174845985.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104174845985.png" alt="image-20230104174845985"></p>
<p>well-identified 清楚的挑出来并说明是如何处理的</p>
</li>
<li><p>Java Reflection</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104180227946.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104180227946.png" alt="image-20230104180227946"></p>
<p>如何去分析反射？</p>
<ul>
<li><p>String Constant analysis + Pointer Analysis</p>
<p>但是如果字符串无法被静态解析出来的话就无法处理解析</p>
</li>
<li><p>Type Inference + String analysis + Pointer Analysis</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104185558699.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104185558699.png" alt="image-20230104185558699"></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104190810267.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104190810267.png" alt="image-20230104190810267"></p>
<p>使用的时候推导出反射的参数</p>
<p>结合Java语言类型系统</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104190704298.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104190704298.png" alt="image-20230104190704298"></p>
</li>
</ul>
</li>
<li><p>Native Code</p>
<p>JNI </p>
<p>JVM提供的一种工作机制，可以使得JAVA和C/C++之间进行交互</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104191550190.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104191550190.png" alt="image-20230104191550190"></p>
<p>为啥难分析？</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104192248977.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104192248977.png" alt="image-20230104192248977"></p>
<p>难分析点在于JAVA分析器如何去处理C代码部分</p>
<p>如何处理？</p>
<p>对关键的native code进行手动建模</p>
<p>exp</p>
<p>一种常见的建模方式</p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104192823280.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104192823280.png" alt="image-20230104192823280"></p>
</li>
</ul>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a target="_blank" rel="noopener" href="https://github.com/RicoloveFeng/SPA-Freestyle-Guidance/blob/main/assignments">https://github.com/RicoloveFeng/SPA-Freestyle-Guidance/blob/main/assignments</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1GQ4y1T7zm/?spm_id_from=333.788&amp;vd_source=b30bb93cb7d2b1714731de06a0d0cab9">https://www.bilibili.com/video/BV1GQ4y1T7zm/?spm_id_from=333.788&amp;vd_source=b30bb93cb7d2b1714731de06a0d0cab9</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.z3ratu1.cn/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0.html">https://blog.z3ratu1.cn/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0.html</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Z3ratu1/Tai-e-assignments/blob/main/A3/tai-e/src/main/java/pascal/taie/analysis/dataflow/analysis/DeadCodeDetection.java">https://github.com/Z3ratu1/Tai-e-assignments/blob/main/A3/tai-e/src/main/java/pascal/taie/analysis/dataflow/analysis/DeadCodeDetection.java</a></p>
<h4 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h4><p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227204724185.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20221227204724185.png" alt="image-20221227204724185"></p>
<p>与动态分析结合 </p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104190916789.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104190916789.png" alt="image-20230104190916789"></p>
<p class='item-img' data-src='/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104192858623.png'><img src="/2023/01/04/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20230104192858623.png" alt="image-20230104192858623"></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/01/04/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%BA%8C/">← Next 内网渗透——信息收集—凭证信息获取&amp;&amp;本地历史信息获取</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/01/02/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">内网渗透——信息收集—利用MSF进行信息收集 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">RacerZ</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/RacerZ-fighting"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" href="qiyizhang2002@foxmail.com"><i class="fa fa-envelope" alt="E-Mail"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#01-Introduction"><span class="toc-number">2.</span> <span class="toc-text">01-Introduction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#02-Intermediate-Representation"><span class="toc-number">3.</span> <span class="toc-text">02-Intermediate Representation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#03-Data-Flow-Analysis-I"><span class="toc-number">4.</span> <span class="toc-text">03-Data Flow Analysis I</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#04-Data-Flow-Analysis-II"><span class="toc-number">4.1.</span> <span class="toc-text">04-Data Flow Analysis II</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#05-Data-Flow-Analysis-Foundations-I"><span class="toc-number">4.2.</span> <span class="toc-text">05-Data Flow Analysis - Foundations I</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#06-Data-Flow-Analysis-Foundation"><span class="toc-number">4.3.</span> <span class="toc-text">06 - Data Flow Analysis - Foundation</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C2-%E5%B8%B8%E9%87%8F%E4%BC%A0%E6%92%AD%E5%92%8C-Worklist-%E6%B1%82%E8%A7%A3%E5%99%A8"><span class="toc-number">4.4.</span> <span class="toc-text">实验2 常量传播和 Worklist 求解器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#07-Interprocedural-Analysis"><span class="toc-number">4.5.</span> <span class="toc-text">07- Interprocedural Analysis</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C4-%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90%E4%B8%8E%E8%BF%87%E7%A8%8B%E9%97%B4%E5%B8%B8%E9%87%8F%E4%BC%A0%E6%92%AD"><span class="toc-number">4.6.</span> <span class="toc-text">实验4 类层次结构分析与过程间常量传播</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#08-Pointer-Analysis"><span class="toc-number">4.7.</span> <span class="toc-text">08 - Pointer Analysis</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#09-Pointer-Analysis-Foundations-I"><span class="toc-number">4.8.</span> <span class="toc-text">09 - Pointer Analysis Foundations(I)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#09-Pointer-Analysis-Foundations-I-1"><span class="toc-number">4.9.</span> <span class="toc-text">09 - Pointer Analysis - Foundations I</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C3-%E6%AD%BB%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B"><span class="toc-number">4.10.</span> <span class="toc-text">实验3 死代码检测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A5-%E9%9D%9E%E4%B8%8A%E4%B8%8B%E6%96%87%E6%95%8F%E6%84%9F%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90"><span class="toc-number">4.11.</span> <span class="toc-text">作业5 非上下文敏感指针分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-Pointer-Analysis-Foundations-II"><span class="toc-number">4.12.</span> <span class="toc-text">10 - Pointer Analysis - Foundations II</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-Pointer-Analysis-Context-Sensitivity-I"><span class="toc-number">4.13.</span> <span class="toc-text">11 - Pointer Analysis - Context Sensitivity I</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-Pointer-Analysis-Context-Sensitivity-II"><span class="toc-number">4.14.</span> <span class="toc-text">12 - Pointer Analysis - Context Sensitivity II</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C6-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%95%8F%E6%84%9F%E7%9A%84%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90"><span class="toc-number">4.15.</span> <span class="toc-text">实验6 上下文敏感的指针分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-Static-Analysis-for-Security"><span class="toc-number">4.16.</span> <span class="toc-text">13 - Static Analysis for Security</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-Datalog-Based-Program-Analysis"><span class="toc-number">4.17.</span> <span class="toc-text">14 - Datalog-Based Program Analysis</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C7-Alias-Aware%E7%9A%84%E5%B8%B8%E9%87%8F%E4%BC%A0%E6%92%AD"><span class="toc-number">4.18.</span> <span class="toc-text">实验7 Alias-Aware的常量传播</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-CFL-Reachability-and-IFDS"><span class="toc-number">4.19.</span> <span class="toc-text">15 - CFL-Reachability and IFDS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A8-%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90"><span class="toc-number">4.20.</span> <span class="toc-text">作业8 污点分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-Soundness-and-Soundiness"><span class="toc-number">4.21.</span> <span class="toc-text">16 - Soundness and Soundiness</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">5.</span> <span class="toc-text">参考链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E4%BC%B8"><span class="toc-number">6.</span> <span class="toc-text">延伸</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside><div id="shadow-aside"></div></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>