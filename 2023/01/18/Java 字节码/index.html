<!DOCTYPE html><html lang="en" theme-mode="auto"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>ASM字节码学习 | RacerZ</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light' || window.matchMedia('(prefers-color-scheme:light)').matches) document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark' || window.matchMedia('(prefers-color-scheme:dark)').matches) document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><div id="shadow-header"></div><article><div id="post-bg"><div id="post-title"><h1>ASM字节码学习</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-01-17T16:00:00.000Z" id="date"> 2023-01-18</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-01-22T08:07:59.562Z" id="updated"> 2023-01-22</time></div></span></div></div><hr><div id="post-content"><h4 id="Java-字节码"><a href="#Java-字节码" class="headerlink" title="Java 字节码"></a>Java 字节码</h4><h5 id="Java-class文件格式"><a href="#Java-class文件格式" class="headerlink" title="Java class文件格式"></a>Java class文件格式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">ClassFile &#123;<br>    u4 magic;<br>    u2 minor_version;<br>    u2 major_version;<br>    u2 constant_pool_count;<br>    cp_info constant_pool[constant_pool_count-1];<br>    u2 access_flags;<br>    u2 this_class;<br>    u2 super_class;<br>    u2 interfaces_count;<br>    u2 interfaces[interfaces_count];<br>    u2 fields_count;<br>    field_info fields[fields_count];<br>    u2 methods_count;<br>    method_info methods[methods_count];<br>    u2 attributes_count;<br>    attribute_info attributes[attributes_count];<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p><code>u1</code> 、<code>u2</code>、 <code>u4</code> 分别表示1、2、4个字节的无符号数。<br>x即代表字节无符号数、其余info类型是复合结构</p>
<p>可使用<code>java.io.DataInputStream</code>类中的对应方法：<code>readUnsignedByte</code>、<code>readUnsignedShort</code>、<code>readInt</code>方法读取。</p>
</li>
<li><p>魔数 Magic </p>
<p>固定值 <code>0xCAFEBABE</code></p>
<p class='item-img' data-src='/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230115172830015.png'><img src="/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230115172830015.png" alt="image-20230115172830015"></p>
<blockquote>
<p>JVM加载class文件时会先读取4字节（<code>u4 magic;</code>）的魔数信息校验是否是一个class文件</p>
</blockquote>
<p class='item-img' data-src='/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230115172915362.png'><img src="/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230115172915362.png" alt="image-20230115172915362"></p>
</li>
<li><p><strong>版本号</strong> Minor/Major Version</p>
<p>class文件的版本号由两个<code>u2</code>组成（<code>u2 minor_version; u2 major_version;</code>），分别表示的是<code>minor_version</code>（副版本号）、<code>major_version</code> （主版本号），我们常说的<code>JDK1.8</code>、<code>Java9</code>等说的就是主版本号。</p>
<p class='item-img' data-src='/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230115173100707.png'><img src="/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230115173100707.png" alt="image-20230115173100707"></p>
<p>| JDK版本 | <strong>十进制</strong> | <strong>十六进制</strong> | 发布时间 |<br>| ———- | ————— | —————— | ———— |<br>| JDK1.1  | 45         | 2D           | 1996-05  |<br>| JDK1.2  | 46         | 2E           | 1998-12  |<br>| JDK1.3  | 47         | 2F           | 2000-05  |<br>| JDK1.4  | 48         | 30           | 2002-02  |<br>| JDK1.5  | 49         | 31           | 2004-09  |<br>| JDK1.6  | 50         | 32           | 2006-12  |<br>| JDK1.7  | 51         | 33           | 2011-07  |<br>| JDK1.8  | 52         | 34           | 2014-03  |<br>| Java9   | 53         | 35           | 2017-09  |<br>| Java10  | 54         | 36           | 2018-03  |<br>| Java11  | 55         | 37           | 2018-09  |<br>| Java12  | 56         | 38           | 2019-03  |<br>| Java13  | 57         | 39           | 2019-09  |<br>| Java14  | 58         | 3A           | 2020-03  |<br>| Java15  | 59         | 3B           | 2020-09  |</p>
</li>
<li><p>constant_pool_count <strong>常量池计数器</strong></p>
<p>表示常量池中的数量，数值上等于 <code>常量池的数量+1</code></p>
<p>需要特别注意的是<code>long</code>和<code>double</code>类型的常量池对象占用两个常量位</p>
</li>
<li><p>constant_pool <strong>常量池</strong></p>
<p>表结构 <code>cp_info constant_pool[constant_pool_count-1];</code></p>
<p>常量池对象 <code>cp_info</code> 数据结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">cp_info &#123;<br>   u1 tag;<br>   u1 info[];<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>u1 tag;</code>表示的是常量池中的<strong>存储类型</strong>，每一种<code>tag</code>都对应了不同的数据结构。</p>
</li>
<li><p>access_flags <strong>访问标志</strong></p>
<p>表示的是某个类或者接口的<strong>访问权限及属性</strong>。</p>
<blockquote>
<p>| 标志名         | 十六进制值 | 描述                                                   |<br>| ——————— | ————— | ——————————————————————————— |<br>| ACC_PUBLIC     | 0x0001     | 声明为public                                           |<br>| ACC_FINAL      | 0x0010     | 声明为final                                            |<br>| ACC_SUPER      | 0x0020     | 废弃/仅JDK1.0.2前使用                                  |<br>| ACC_INTERFACE  | 0x0200     | 声明为接口                                             |<br>| ACC_ABSTRACT   | 0x0400     | 声明为abstract                                         |<br>| ACC_SYNTHETIC  | 0x1000     | 声明为synthetic，表示该class文件并非由Java源代码所生成 |<br>| ACC_ANNOTATION | 0x2000     | 标识注解类型                                           |<br>| ACC_ENUM       | 0x4000     | 标识枚举类型                                           |</p>
</blockquote>
</li>
<li><p>this_class <strong>当前类名称</strong></p>
<p>当前class文件的类名所在<strong>常量池中的索引位置</strong></p>
</li>
<li><p>super_class <strong>当前类的父类</strong></p>
<p>当前class文件的父类类名所在常量池中的索引位置。</p>
<p><code>java/lang/Object</code>类的<code>super_class</code>的为0，其他任何类的<code>super_class</code><strong>都必须是一个常量池中存在的索引位置</strong>。</p>
</li>
<li><p>interfaces_count <strong>当前类继承或实现的接口数</strong></p>
<p>表示的是当前类继承或实现的接口数</p>
</li>
<li><p>interfaces[] <strong>接口名称数组</strong></p>
<p>表示所有接口数组</p>
</li>
<li><p>fields_count <strong>当前类的成员变量数</strong></p>
<p>当前class中的成员变量个数</p>
</li>
<li><p>fields[] <strong>成员变量数组</strong></p>
<p>field_info 成员变量的数据结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">field_info &#123;<br>   u2 access_flags;<br>   u2 name_index;<br>   u2 descriptor_index;<br>   u2 attributes_count;<br>   attribute_info attributes[attributes_count];<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>access_flags 表示的是成员变量的修饰符</p>
<p>| Flag Name       | Value  | Interpretation                                               |<br>| ———————- | ——— | —————————————————————————————— |<br>| <code>ACC_PUBLIC</code>    | 0x0001 | Declared <code>public</code>; may be accessed from outside its package. |<br>| <code>ACC_PRIVATE</code>   | 0x0002 | Declared <code>private</code>; accessible only within the defining class and other classes belonging to the same nest (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-5.html#jvms-5.4.4">§5.4.4</a>). |<br>| <code>ACC_PROTECTED</code> | 0x0004 | Declared <code>protected</code>; may be accessed within subclasses.     |<br>| <code>ACC_STATIC</code>    | 0x0008 | Declared <code>static</code>.                                           |<br>| <code>ACC_FINAL</code>     | 0x0010 | Declared <code>final</code>; never directly assigned to after object construction (JLS §17.5). |<br>| <code>ACC_VOLATILE</code>  | 0x0040 | Declared <code>volatile</code>; cannot be cached.                       |<br>| <code>ACC_TRANSIENT</code> | 0x0080 | Declared <code>transient</code>; not written or read by a persistent object manager. |<br>| <code>ACC_SYNTHETIC</code> | 0x1000 | Declared synthetic; not present in the source code.          |<br>| <code>ACC_ENUM</code>      | 0x4000 | Declared as an element of an <code>enum</code>.                         |</p>
</li>
<li><p>name_index 表示的是成员变量的名称</p>
</li>
<li><p>descriptor_index 表示的是成员变量的描述符</p>
</li>
<li><p>attributes_count 表示的是成员变量的属性数量</p>
</li>
<li><p>attribute_info attributes[attributes_count] 表示的成员变量的属性信息</p>
</li>
</ul>
</li>
<li><p>methods_count <strong>当前类的成员方法数</strong></p>
<p>表示的是当前class中的成员方法个数</p>
</li>
<li><p>methods 成员方法数组</p>
<p>method_info 成员方法对象数据结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">method_info &#123;<br>   u2 access_flags;<br>   u2 name_index;<br>   u2 descriptor_index;<br>   u2 attributes_count;<br>   attribute_info attributes[attributes_count];<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>access_flags 成员方法的修饰符</p>
<p>| Flag Name          | Value  | Interpretation                                               |<br>| ————————— | ——— | —————————————————————————————— |<br>| <code>ACC_PUBLIC</code>       | 0x0001 | Declared <code>public</code>; may be accessed from outside its package. |<br>| <code>ACC_PRIVATE</code>      | 0x0002 | Declared <code>private</code>; accessible only within the defining class and other classes belonging to the same nest (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-5.html#jvms-5.4.4">§5.4.4</a>). |<br>| <code>ACC_PROTECTED</code>    | 0x0004 | Declared <code>protected</code>; may be accessed within subclasses.     |<br>| <code>ACC_STATIC</code>       | 0x0008 | Declared <code>static</code>.                                           |<br>| <code>ACC_FINAL</code>        | 0x0010 | Declared <code>final</code>; must not be overridden (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-5.html#jvms-5.4.5">§5.4.5</a>). |<br>| <code>ACC_SYNCHRONIZED</code> | 0x0020 | Declared <code>synchronized</code>; invocation is wrapped by a monitor use. |<br>| <code>ACC_BRIDGE</code>       | 0x0040 | A bridge method, generated by the compiler.                  |<br>| <code>ACC_VARARGS</code>      | 0x0080 | Declared with variable number of arguments.                  |<br>| <code>ACC_NATIVE</code>       | 0x0100 | Declared <code>native</code>; implemented in a language other than the Java programming language. |<br>| <code>ACC_ABSTRACT</code>     | 0x0400 | Declared <code>abstract</code>; no implementation is provided.          |<br>| <code>ACC_STRICT</code>       | 0x0800 | Declared <code>strictfp</code>; floating-point mode is FP-strict.       |<br>| <code>ACC_SYNTHETIC</code>    | 0x1000 | Declared synthetic; not present in the source code.          |</p>
</li>
<li><p>name_index 成员方法的名称</p>
</li>
<li><p>descriptor_index 成员方法的描述符</p>
</li>
<li><p>attributes_count 成员方法的属性数量</p>
</li>
<li><p>attributes 成员方法的属性信息</p>
</li>
</ul>
</li>
<li><p>attributes_count <strong>当前类的属性数</strong></p>
<p>当前class文件属性表的成员个数</p>
</li>
<li><p>attributes[] <strong>属性数组</strong></p>
<p>attribute_info 属性信息数据结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">attribute_info &#123;<br>   u2 attribute_name_index;<br>   u4 attribute_length;<br>   u1 info[attribute_length];<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>attribute_name_index 属性名称索引</p>
<p>读取<code>attribute_name_index</code>值所在<strong>常量池中的名称</strong>可以得到属性名称</p>
</li>
</ul>
</li>
<li><p><strong>属性对象</strong></p>
<p>属性表是动态的，新的JDK版本可能会添加新的属性值。每一种属性的数据结构都不相同，所以读取到<strong>属性名称后还需要根据属性的类型解析不同属性表中的值</strong>。比如<code>Code Attribute</code>中存储了类方法的异常表、字节码指令集、属性信息等重要信息。</p>
<p class='item-img' data-src='https://github.com/Y4tacker/JavaSec/raw/main/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ASM%E5%AD%A6%E4%B9%A0/img/1.jpeg'><img src="https://github.com/Y4tacker/JavaSec/raw/main/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ASM%E5%AD%A6%E4%B9%A0/img/1.jpeg" alt="img"></p>
</li>
</ul>
<h5 id="Java-Class-文件解析"><a href="#Java-Class-文件解析" class="headerlink" title="Java Class 文件解析"></a>Java Class 文件解析</h5><ul>
<li><p>解析流程</p>
<p>首先是魔术头和版本，调用 <code>DataInputStream()</code>正常获取即可</p>
<p>然后是常量池的解析：</p>
<blockquote>
<ol>
<li>读取常量池数量（<code>u2 constant_pool_count;</code>）；</li>
<li>读取<code>tag</code>；</li>
<li>根据不同的<code>tag</code>类型解析常量池对象；</li>
<li>解析常量池中的对象；</li>
<li><strong>链接常量池中的索引引用</strong>；</li>
</ol>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 解析常量池数据</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException 数据读取异常</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseConstantPool</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// u2 constant_pool_count;</span><br>    <span class="hljs-built_in">this</span>.poolCount = dis.readUnsignedShort();<br><br>    <span class="hljs-comment">// cp_info constant_pool[constant_pool_count-1];</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= poolCount - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-comment">//            cp_info &#123;</span><br>        <span class="hljs-comment">//                u1 tag;</span><br>        <span class="hljs-comment">//                u1 info[];</span><br>        <span class="hljs-comment">//            &#125;</span><br>        <span class="hljs-type">int</span>      <span class="hljs-variable">tag</span>      <span class="hljs-operator">=</span> dis.readUnsignedByte();<br>        <span class="hljs-type">Constant</span> <span class="hljs-variable">constant</span> <span class="hljs-operator">=</span> Constant.getConstant(tag);<br><br>        <span class="hljs-keyword">if</span> (constant == <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;解析常量池异常，无法识别的常量池类型：&quot;</span> + tag);<br>        &#125;<br><br>        <span class="hljs-comment">// 解析常量池对象</span><br>        parseConstantItems(constant, i);<br><br>        <span class="hljs-comment">// Long和Double是宽类型，占两位</span><br>        <span class="hljs-keyword">if</span> (CONSTANT_LONG == constant || CONSTANT_DOUBLE == constant) &#123;<br>              i++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 链接常量池中的引用</span><br>    linkConstantPool();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有很多对象的数据结构中又引用了其他对象，为了能够直观的看到常量池ID为1的对象信息我们就必须要将所有使用<strong>索引方式链接的映射关系改成直接字符串引用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 链接常量池中的引用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkConstantPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (Integer id : constantPoolMap.keySet()) &#123;<br>        Map&lt;String, Object&gt; valueMap = constantPoolMap.get(id);<br><br>        <span class="hljs-keyword">if</span> (!valueMap.containsKey(<span class="hljs-string">&quot;value&quot;</span>)) &#123;<br>            Map&lt;String, Object&gt; newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br><br>            <span class="hljs-keyword">for</span> (String key : valueMap.keySet()) &#123;<br>                <span class="hljs-keyword">if</span> (key.endsWith(<span class="hljs-string">&quot;Index&quot;</span>)) &#123;<br>                      <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> recursionValue((Integer) valueMap.get(key));<br><br>                    <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">newKey</span> <span class="hljs-operator">=</span> key.substring(<span class="hljs-number">0</span>, key.indexOf(<span class="hljs-string">&quot;Index&quot;</span>));<br><br>                        newMap.put(newKey + <span class="hljs-string">&quot;Value&quot;</span>, value);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            valueMap.putAll(newMap);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 递归查找ID对应的常量池中的值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id 常量池ID</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 常量池中存储的值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">recursionValue</span><span class="hljs-params">(Integer id)</span> &#123;<br>    Map&lt;String, Object&gt; map = constantPoolMap.get(id);<br><br>    <span class="hljs-keyword">if</span> (map.containsKey(<span class="hljs-string">&quot;value&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> map.get(<span class="hljs-string">&quot;value&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (String key : map.keySet()) &#123;<br>        <span class="hljs-keyword">if</span> (key.endsWith(<span class="hljs-string">&quot;Index&quot;</span>)) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (Integer) map.get(key);<br><br>            <span class="hljs-keyword">return</span> recursionValue(value);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>访问标志解析</strong>：</p>
<p><code>u2 access_flags</code></p>
<p>直接 readUnsignedShort()</p>
<p><strong>当前类名称解析：</strong></p>
<p><code>dis.readUnsignedShort()</code>获取到类名所在的常量池中的索引位置，然后根据常量池ID读取常量池中的字符串内容即可解析出类名</p>
<p><strong>当前类的父类名称解析：</strong></p>
<p>当解析<code>java.lang.Object</code>时<code>super_class</code>的值为0，常量池中不包含索引为0的对象，所以需要直接将父类名称设置为<code>java/lang/Object</code></p>
<p><strong>接口解析：</strong></p>
<p>和上面一样，先获取接口数量，然后遍历获取所有接口名称的索引值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// u2 interfaces_count;</span><br><span class="hljs-built_in">this</span>.interfacesCount = dis.readUnsignedShort();<br><br><span class="hljs-comment">// 创建接口Index数组</span><br><span class="hljs-built_in">this</span>.interfaces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[interfacesCount];<br><br><span class="hljs-comment">// u2 interfaces[interfaces_count];</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; interfacesCount; i++) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> dis.readUnsignedShort();<br><br>    <span class="hljs-comment">// 设置接口名称</span><br>    <span class="hljs-built_in">this</span>.interfaces[i] = (String) getConstantPoolValue(index);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>成员变量/成员方法解析：</strong></p>
<p>两者数据结构一致，所以按照相同的处理逻辑。先解析出变量/方法的总数，然后遍历解析对象的数据结构中的所有信息</p>
<p>这里还有一个 <code>attribute_info attribute[attributes_count]</code> 需要解析</p>
<p><strong>Java class 文件属性解析</strong></p>
<p>属性信息表数据结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">u2 attributes_count;<br>attribute_info attributes[attributes_count];<br><br>attribute_info &#123;<br>   u2 attribute_name_index;<br>   u4 attribute_length;<br>   u1 info[attribute_length];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>解析前面几个的流程类似，先解析属性表长度，然后遍历对attribute_info进行解析，前面 attribute_name_index 和 attribute_length 为固定长度值，直接 DataInstream 调用即可</p>
<p>接下来解析出属性名称后（在常量池中查找）按照 JVM虚拟机规范-属性<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jvms-4.7">https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jvms-4.7</a> 来解析</p>
<p>对于 <strong>ConstantValue：</strong> </p>
<p>用于表示<code>field_info</code>中的静态变量的初始值</p>
<p>数据结构如下: 只需要读取解析最后一个字段即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">ConstantValue_attribute &#123;<br>    u2 attribute_name_index;<br>    u4 attribute_length;<br>    u2 constantvalue_index;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于 <strong>Code：</strong></p>
<p><code>Code</code>属性用于表示<strong>成员方法</strong>的代码部分，<code>Code</code>中包含了指令集（<code>byte数组</code>），JVM调用成员方法时实际上就是执行的<code>Code</code>中的指令，而反编译工具则是把<code>Code</code>中的指令翻译成了Java代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Code_attribute &#123;<br>    u2 attribute_name_index;<br>    u4 attribute_length;<br>    u2 max_stack;<br>    u2 max_locals;<br>    u4 code_length;<br>    u1 code[code_length];<br>    u2 exception_table_length;<br>    &#123;   u2 start_pc;<br>        u2 end_pc;<br>        u2 handler_pc;<br>        u2 catch_type;<br>    &#125; exception_table[exception_table_length];<br>    u2 attributes_count;<br>    attribute_info attributes[attributes_count];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在解析<code>Code</code>属性时<code>code_length</code>表示的是<code>Code</code>的字节长度，<code>max_stack</code>和<code>max_locals</code>是一个固定值，表示的是最大操作数栈和最大局部变量数，这两个值是在编译类方法时自动计算出来的，如果通过<code>ASM</code>修改了类方法可能会需要重新计算<code>max_stack</code>和<code>max_locals</code>。</p>
<p>解析<code>Code</code>的指令集时需要对照<strong>指令集映射表</strong>，然后根据不同的指令实现不一样的指令处理逻辑 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-6.html#jvms-6.5</a></p>
<p>可视化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">javap -verbose xxx.class<br></code></pre></td></tr></table></figure>
<h5 id="Java虚拟机指令集"><a href="#Java虚拟机指令集" class="headerlink" title="Java虚拟机指令集"></a>Java虚拟机指令集</h5><ul>
<li><p><strong>Jvm</strong></p>
<p>首先要了解<strong>栈帧</strong>的概念</p>
<blockquote>
<p>栈帧是用来存储数据和部分过程结果的数据结构，同时也用来处理动态连接、方法返回值和异常分派。 栈帧随着<strong>方法调用而创建，随着方法结束而销毁</strong>——无论方法正常完成还是异常完成都算作方法结束。 栈帧的存储空间由创建它的线程分配在Java虚拟机栈之中，每一个栈帧都有自己的本地变量表(局部变量表)、操作数栈和指向当前方法所属的类的运行时常量池的引用。</p>
</blockquote>
<p class='item-img' data-src='https://github.com/Y4tacker/JavaSec/raw/main/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ASM%E5%AD%A6%E4%B9%A0/img/2.png'><img src="https://github.com/Y4tacker/JavaSec/raw/main/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ASM%E5%AD%A6%E4%B9%A0/img/2.png" alt="img"></p>
<ul>
<li><p><strong>局部变量表</strong></p>
<p>Local Variable Table 是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。单位规范以变量槽（Slot）为最小单位，一个槽应该可以存放一个32位以内的数据类型。</p>
<p>虚拟机通过索引定位的方法查找相应的局部变量，索引的范围是从0~局部变量表最大容量。如果Slot是32位的，则遇到一个64位数据类型的变量(如long或double型)，则会<strong>连续使用两个连续的Slot来存储</strong>。</p>
</li>
<li><p><strong>操作数栈</strong></p>
<p>Operand Stack LIFO数据结构，其最大深度在编译时写入到方法的Code属性的<code>max_stacks</code>数据项中</p>
<p>操作数栈的每一个元素可以是任意Java数据类型，32位的数据类型占一个栈容量，64位的数据类型占2个栈容量,且在方法执行的任意时刻，<strong>操作数栈的深度都不会超过max_stacks中设置的最大值</strong>。</p>
</li>
<li><p><strong>动态链接</strong></p>
<p>在class文件中，方法调用需要将目标方法的<strong>符号引用</strong>转换为其在内存地址中的直接引用，符号引用存在于<strong>方法区中的运行时常量池</strong>。</p>
<p>Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的<strong>动态连接(Dynamic Linking)</strong>。</p>
</li>
<li><p><strong>方法返回</strong></p>
<p>分为正常完成和异常完成两种</p>
</li>
</ul>
</li>
<li><p>类型/方法描述符</p>
<p>| 描述符   | Java类型           | 示例                     |<br>| ———— | ————————— | ———————————— |<br>| <code>B</code>      | <code>byte</code>             | <code>B</code>                      |<br>| <code>C</code>      | <code>char</code>             | <code>C</code>                      |<br>| <code>D</code>      | <code>double</code>           | <code>D</code>                      |<br>| <code>F</code>      | <code>float</code>            | <code>F</code>                      |<br>| <code>I</code>      | <code>int</code>              | <code>I</code>                      |<br>| <code>J</code>      | <code>long</code>             | <code>J</code>                      |<br>| <code>S</code>      | <code>short</code>            | <code>S</code>                      |<br>| <code>Z</code>      | <code>boolean</code>          | <code>Z</code>                      |<br>| <code>[</code>      | <code>数组</code>             | <code>[IJ</code>                    |<br>| <code>L类名;</code> | <code>引用类型对象**</code><strong> | </strong><code>Ljava/lang/Object;</code>** |</p>
<p><strong>方法描述符实例：</strong></p>
<p>| 方法示例                            | 描述符                                   | 描述                          |<br>| —————————————————- | ———————————————————— | ——————————————- |<br>| <code>static&#123;...&#125;</code>，<code>static int id = 1;</code> | 方法名：<code>&lt;clinit&gt;</code>                       | <strong>静态语句块/静态变量初始化</strong> |<br>| <code>public Test ()&#123;...&#125;</code>               | 方法名：<code>&lt;init&gt;</code>，描述符<code>()V</code>            | 构造方法                      |<br>| <code>void hello()&#123;...&#125;</code>                 | <code>()V</code>                                    | <code>V</code>表示<code>void</code>，无返回值       |<br>| <code>Object login(String str) &#123;...&#125;</code>    | <code>(Ljava/lang/String;)Ljava/lang/Object;</code> | 普通方法，返回Object类型      |<br>| <code>void login(String str) &#123;...&#125;</code>      | <code>(Ljava/lang/String;)V</code>                  | 普通方法，无返回值            |</p>
</li>
<li><p>Java 虚拟机指令</p>
<p><strong>详情：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-6.html#jvms-6.5</a></strong></p>
<p><strong>速查表：</strong></p>
<p>| 十六进制 | 助记符          | 指令说明                                                     |<br>| ———— | ———————- | —————————————————————————————— |<br>| 0x00     | nop             | 什么都不做                                                   |<br>| 0x01     | aconst_null     | 将null推送至栈顶                                             |<br>| 0x02     | iconst_m1       | 将int型-1推送至栈顶                                          |<br>| 0x03     | iconst_0        | 将int型0推送至栈顶                                           |<br>| 0x04     | iconst_1        | 将int型1推送至栈顶                                           |<br>| 0x05     | iconst_2        | 将int型2推送至栈顶                                           |<br>| 0x06     | iconst_3        | 将int型3推送至栈顶                                           |<br>| 0x07     | iconst_4        | 将int型4推送至栈顶                                           |<br>| 0x08     | iconst_5        | 将int型5推送至栈顶                                           |<br>| 0x09     | lconst_0        | 将long型0推送至栈顶                                          |<br>| 0x0a     | lconst_1        | 将long型1推送至栈顶                                          |<br>| 0x0b     | fconst_0        | 将float型0推送至栈顶                                         |<br>| 0x0c     | fconst_1        | 将float型1推送至栈顶                                         |<br>| 0x0d     | fconst_2        | 将float型2推送至栈顶                                         |<br>| 0x0e     | dconst_0        | 将double型0推送至栈顶                                        |<br>| 0x0f     | dconst_1        | 将double型1推送至栈顶                                        |<br>| 0x10     | bipush          | 将单字节的常量值(-128~127)推送至栈顶                         |<br>| 0x11     | sipush          | 将一个短整型常量值(-32768~32767)推送至栈顶                   |<br>| 0x12     | ldc             | 将int, float或String型常量值从常量池中推送至栈顶             |<br>| 0x13     | ldc_w           | 将int, float或String型常量值从常量池中推送至栈顶（宽索引）   |<br>| 0x14     | ldc2_w          | 将long或double型常量值从常量池中推送至栈顶（宽索引）         |<br>| 0x15     | iload           | 将指定的int型本地变量推送至栈顶                              |<br>| 0x16     | lload           | 将指定的long型本地变量推送至栈顶                             |<br>| 0x17     | fload           | 将指定的float型本地变量推送至栈顶                            |<br>| 0x18     | dload           | 将指定的double型本地变量推送至栈顶                           |<br>| 0x19     | aload           | 将指定的引用类型本地变量推送至栈顶                           |<br>| 0x1a     | iload_0         | 将第一个int型本地变量推送至栈顶                              |<br>| 0x1b     | iload_1         | 将第二个int型本地变量推送至栈顶                              |<br>| 0x1c     | iload_2         | 将第三个int型本地变量推送至栈顶                              |<br>| 0x1d     | iload_3         | 将第四个int型本地变量推送至栈顶                              |<br>| 0x1e     | lload_0         | 将第一个long型本地变量推送至栈顶                             |<br>| 0x1f     | lload_1         | 将第二个long型本地变量推送至栈顶                             |<br>| 0x20     | lload_2         | 将第三个long型本地变量推送至栈顶                             |<br>| 0x21     | lload_3         | 将第四个long型本地变量推送至栈顶                             |<br>| 0x22     | fload_0         | 将第一个float型本地变量推送至栈顶                            |<br>| 0x23     | fload_1         | 将第二个float型本地变量推送至栈顶                            |<br>| 0x24     | fload_2         | 将第三个float型本地变量推送至栈顶                            |<br>| 0x25     | fload_3         | 将第四个float型本地变量推送至栈顶                            |<br>| 0x26     | dload_0         | 将第一个double型本地变量推送至栈顶                           |<br>| 0x27     | dload_1         | 将第二个double型本地变量推送至栈顶                           |<br>| 0x28     | dload_2         | 将第三个double型本地变量推送至栈顶                           |<br>| 0x29     | dload_3         | 将第四个double型本地变量推送至栈顶                           |<br>| 0x2a     | aload_0         | 将第一个引用类型本地变量推送至栈顶                           |<br>| 0x2b     | aload_1         | 将第二个引用类型本地变量推送至栈顶                           |<br>| 0x2c     | aload_2         | 将第三个引用类型本地变量推送至栈顶                           |<br>| 0x2d     | aload_3         | 将第四个引用类型本地变量推送至栈顶                           |<br>| 0x2e     | iaload          | 将int型数组指定索引的值推送至栈顶                            |<br>| 0x2f     | laload          | 将long型数组指定索引的值推送至栈顶                           |<br>| 0x30     | faload          | 将float型数组指定索引的值推送至栈顶                          |<br>| 0x31     | daload          | 将double型数组指定索引的值推送至栈顶                         |<br>| 0x32     | aaload          | 将引用型数组指定索引的值推送至栈顶                           |<br>| 0x33     | baload          | 将boolean或byte型数组指定索引的值推送至栈顶                  |<br>| 0x34     | caload          | 将char型数组指定索引的值推送至栈顶                           |<br>| 0x35     | saload          | 将short型数组指定索引的值推送至栈顶                          |<br>| 0x36     | istore          | 将栈顶int型数值存入指定本地变量                              |<br>| 0x37     | lstore          | 将栈顶long型数值存入指定本地变量                             |<br>| 0x38     | fstore          | 将栈顶float型数值存入指定本地变量                            |<br>| 0x39     | dstore          | 将栈顶double型数值存入指定本地变量                           |<br>| 0x3a     | astore          | 将栈顶引用型数值存入指定本地变量                             |<br>| 0x3b     | istore_0        | 将栈顶int型数值存入第一个本地变量                            |<br>| 0x3c     | istore_1        | 将栈顶int型数值存入第二个本地变量                            |<br>| 0x3d     | istore_2        | 将栈顶int型数值存入第三个本地变量                            |<br>| 0x3e     | istore_3        | 将栈顶int型数值存入第四个本地变量                            |<br>| 0x3f     | lstore_0        | 将栈顶long型数值存入第一个本地变量                           |<br>| 0x40     | lstore_1        | 将栈顶long型数值存入第二个本地变量                           |<br>| 0x41     | lstore_2        | 将栈顶long型数值存入第三个本地变量                           |<br>| 0x42     | lstore_3        | 将栈顶long型数值存入第四个本地变量                           |<br>| 0x43     | fstore_0        | 将栈顶float型数值存入第一个本地变量                          |<br>| 0x44     | fstore_1        | 将栈顶float型数值存入第二个本地变量                          |<br>| 0x45     | fstore_2        | 将栈顶float型数值存入第三个本地变量                          |<br>| 0x46     | fstore_3        | 将栈顶float型数值存入第四个本地变量                          |<br>| 0x47     | dstore_0        | 将栈顶double型数值存入第一个本地变量                         |<br>| 0x48     | dstore_1        | 将栈顶double型数值存入第二个本地变量                         |<br>| 0x49     | dstore_2        | 将栈顶double型数值存入第三个本地变量                         |<br>| 0x4a     | dstore_3        | 将栈顶double型数值存入第四个本地变量                         |<br>| 0x4b     | astore_0        | 将栈顶引用型数值存入第一个本地变量                           |<br>| 0x4c     | astore_1        | 将栈顶引用型数值存入第二个本地变量                           |<br>| 0x4d     | astore_2        | 将栈顶引用型数值存入第三个本地变量                           |<br>| 0x4e     | astore_3        | 将栈顶引用型数值存入第四个本地变量                           |<br>| 0x4f     | iastore         | 将栈顶int型数值存入指定数组的指定索引位置                    |<br>| 0x50     | lastore         | 将栈顶long型数值存入指定数组的指定索引位置                   |<br>| 0x51     | fastore         | 将栈顶float型数值存入指定数组的指定索引位置                  |<br>| 0x52     | dastore         | 将栈顶double型数值存入指定数组的指定索引位置                 |<br>| 0x53     | aastore         | 将栈顶引用型数值存入指定数组的指定索引位置                   |<br>| 0x54     | bastore         | 将栈顶boolean或byte型数值存入指定数组的指定索引位置          |<br>| 0x55     | castore         | 将栈顶char型数值存入指定数组的指定索引位置                   |<br>| 0x56     | sastore         | 将栈顶short型数值存入指定数组的指定索引位置                  |<br>| 0x57     | pop             | 将栈顶数值弹出 (数值不能是long或double类型的)                |<br>| 0x58     | pop2            | 将栈顶的一个（long或double类型的)或两个数值弹出（其它）      |<br>| 0x59     | dup             | 复制栈顶数值并将复制值压入栈顶                               |<br>| 0x5a     | dup_x1          | 复制栈顶数值并将两个复制值压入栈顶                           |<br>| 0x5b     | dup_x2          | 复制栈顶数值并将三个（或两个）复制值压入栈顶                 |<br>| 0x5c     | dup2            | 复制栈顶一个（long或double类型的)或两个（其它）数值并将复制值压入栈顶 |<br>| 0x5d     | dup2_x1         | &lt;待补充&gt;                                                     |<br>| 0x5e     | dup2_x2         | &lt;待补充&gt;                                                     |<br>| 0x5f     | swap            | 将栈最顶端的两个数值互换(数值不能是long或double类型的)       |<br>| 0x60     | iadd            | 将栈顶两int型数值相加并将结果压入栈顶                        |<br>| 0x61     | ladd            | 将栈顶两long型数值相加并将结果压入栈顶                       |<br>| 0x62     | fadd            | 将栈顶两float型数值相加并将结果压入栈顶                      |<br>| 0x63     | dadd            | 将栈顶两double型数值相加并将结果压入栈顶                     |<br>| 0x64     | isub            | 将栈顶两int型数值相减并将结果压入栈顶                        |<br>| 0x65     | lsub            | 将栈顶两long型数值相减并将结果压入栈顶                       |<br>| 0x66     | fsub            | 将栈顶两float型数值相减并将结果压入栈顶                      |<br>| 0x67     | dsub            | 将栈顶两double型数值相减并将结果压入栈顶                     |<br>| 0x68     | imul            | 将栈顶两int型数值相乘并将结果压入栈顶                        |<br>| 0x69     | lmul            | 将栈顶两long型数值相乘并将结果压入栈顶                       |<br>| 0x6a     | fmul            | 将栈顶两float型数值相乘并将结果压入栈顶                      |<br>| 0x6b     | dmul            | 将栈顶两double型数值相乘并将结果压入栈顶                     |<br>| 0x6c     | idiv            | 将栈顶两int型数值相除并将结果压入栈顶                        |<br>| 0x6d     | ldiv            | 将栈顶两long型数值相除并将结果压入栈顶                       |<br>| 0x6e     | fdiv            | 将栈顶两float型数值相除并将结果压入栈顶                      |<br>| 0x6f     | ddiv            | 将栈顶两double型数值相除并将结果压入栈顶                     |<br>| 0x70     | irem            | 将栈顶两int型数值作取模运算并将结果压入栈顶                  |<br>| 0x71     | lrem            | 将栈顶两long型数值作取模运算并将结果压入栈顶                 |<br>| 0x72     | frem            | 将栈顶两float型数值作取模运算并将结果压入栈顶                |<br>| 0x73     | drem            | 将栈顶两double型数值作取模运算并将结果压入栈顶               |<br>| 0x74     | ineg            | 将栈顶int型数值取负并将结果压入栈顶                          |<br>| 0x75     | lneg            | 将栈顶long型数值取负并将结果压入栈顶                         |<br>| 0x76     | fneg            | 将栈顶float型数值取负并将结果压入栈顶                        |<br>| 0x77     | dneg            | 将栈顶double型数值取负并将结果压入栈顶                       |<br>| 0x78     | ishl            | 将int型数值左移位指定位数并将结果压入栈顶                    |<br>| 0x79     | lshl            | 将long型数值左移位指定位数并将结果压入栈顶                   |<br>| 0x7a     | ishr            | 将int型数值右（符号）移位指定位数并将结果压入栈顶            |<br>| 0x7b     | lshr            | 将long型数值右（符号）移位指定位数并将结果压入栈顶           |<br>| 0x7c     | iushr           | 将int型数值右（无符号）移位指定位数并将结果压入栈顶          |<br>| 0x7d     | lushr           | 将long型数值右（无符号）移位指定位数并将结果压入栈顶         |<br>| 0x7e     | iand            | 将栈顶两int型数值作“按位与”并将结果压入栈顶                  |<br>| 0x7f     | land            | 将栈顶两long型数值作“按位与”并将结果压入栈顶                 |<br>| 0x80     | ior             | 将栈顶两int型数值作“按位或”并将结果压入栈顶                  |<br>| 0x81     | lor             | 将栈顶两long型数值作“按位或”并将结果压入栈顶                 |<br>| 0x82     | ixor            | 将栈顶两int型数值作“按位异或”并将结果压入栈顶                |<br>| 0x83     | lxor            | 将栈顶两long型数值作“按位异或”并将结果压入栈顶               |<br>| 0x84     | iinc            | 将指定int型变量增加指定值（i++, i—, i+=2）                  |<br>| 0x85     | i2l             | 将栈顶int型数值强制转换成long型数值并将结果压入栈顶          |<br>| 0x86     | i2f             | 将栈顶int型数值强制转换成float型数值并将结果压入栈顶         |<br>| 0x87     | i2d             | 将栈顶int型数值强制转换成double型数值并将结果压入栈顶        |<br>| 0x88     | l2i             | 将栈顶long型数值强制转换成int型数值并将结果压入栈顶          |<br>| 0x89     | l2f             | 将栈顶long型数值强制转换成float型数值并将结果压入栈顶        |<br>| 0x8a     | l2d             | 将栈顶long型数值强制转换成double型数值并将结果压入栈顶       |<br>| 0x8b     | f2i             | 将栈顶float型数值强制转换成int型数值并将结果压入栈顶         |<br>| 0x8c     | f2l             | 将栈顶float型数值强制转换成long型数值并将结果压入栈顶        |<br>| 0x8d     | f2d             | 将栈顶float型数值强制转换成double型数值并将结果压入栈顶      |<br>| 0x8e     | d2i             | 将栈顶double型数值强制转换成int型数值并将结果压入栈顶        |<br>| 0x8f     | d2l             | 将栈顶double型数值强制转换成long型数值并将结果压入栈顶       |<br>| 0x90     | d2f             | 将栈顶double型数值强制转换成float型数值并将结果压入栈顶      |<br>| 0x91     | i2b             | 将栈顶int型数值强制转换成byte型数值并将结果压入栈顶          |<br>| 0x92     | i2c             | 将栈顶int型数值强制转换成char型数值并将结果压入栈顶          |<br>| 0x93     | i2s             | 将栈顶int型数值强制转换成short型数值并将结果压入栈顶         |<br>| 0x94     | lcmp            | 比较栈顶两long型数值大小，并将结果（1，0，-1）压入栈顶       |<br>| 0x95     | fcmpl           | 比较栈顶两float型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将-1压入栈顶 |<br>| 0x96     | fcmpg           | 比较栈顶两float型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将1压入栈顶 |<br>| 0x97     | dcmpl           | 比较栈顶两double型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将-1压入栈顶 |<br>| 0x98     | dcmpg           | 比较栈顶两double型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将1压入栈顶 |<br>| 0x99     | ifeq            | 当栈顶int型数值等于0时跳转                                   |<br>| 0x9a     | ifne            | 当栈顶int型数值不等于0时跳转                                 |<br>| 0x9b     | iflt            | 当栈顶int型数值小于0时跳转                                   |<br>| 0x9c     | ifge            | 当栈顶int型数值大于等于0时跳转                               |<br>| 0x9d     | ifgt            | 当栈顶int型数值大于0时跳转                                   |<br>| 0x9e     | ifle            | 当栈顶int型数值小于等于0时跳转                               |<br>| 0x9f     | if_icmpeq       | 比较栈顶两int型数值大小，当结果等于0时跳转                   |<br>| 0xa0     | if_icmpne       | 比较栈顶两int型数值大小，当结果不等于0时跳转                 |<br>| 0xa1     | if_icmplt       | 比较栈顶两int型数值大小，当结果小于0时跳转                   |<br>| 0xa2     | if_icmpge       | 比较栈顶两int型数值大小，当结果大于等于0时跳转               |<br>| 0xa3     | if_icmpgt       | 比较栈顶两int型数值大小，当结果大于0时跳转                   |<br>| 0xa4     | if_icmple       | 比较栈顶两int型数值大小，当结果小于等于0时跳转               |<br>| 0xa5     | if_acmpeq       | 比较栈顶两引用型数值，当结果相等时跳转                       |<br>| 0xa6     | if_acmpne       | 比较栈顶两引用型数值，当结果不相等时跳转                     |<br>| 0xa7     | goto            | 无条件跳转                                                   |<br>| 0xa8     | jsr             | 跳转至指定16位offset位置，并将jsr下一条指令地址压入栈顶      |<br>| 0xa9     | ret             | 返回至本地变量指定的index的指令位置（一般与jsr, jsr_w联合使用） |<br>| 0xaa     | tableswitch     | 用于switch条件跳转，case值连续（可变长度指令）               |<br>| 0xab     | lookupswitch    | 用于switch条件跳转，case值不连续（可变长度指令）             |<br>| 0xac     | ireturn         | 从当前方法返回int                                            |<br>| 0xad     | lreturn         | 从当前方法返回long                                           |<br>| 0xae     | freturn         | 从当前方法返回float                                          |<br>| 0xaf     | dreturn         | 从当前方法返回double                                         |<br>| 0xb0     | areturn         | 从当前方法返回对象引用                                       |<br>| 0xb1     | return          | 从当前方法返回void                                           |<br>| 0xb2     | getstatic       | 获取指定类的静态域，并将其值压入栈顶                         |<br>| 0xb3     | putstatic       | 为指定的类的静态域赋值                                       |<br>| 0xb4     | getfield        | 获取指定类的实例域，并将其值压入栈顶                         |<br>| 0xb5     | putfield        | 为指定的类的实例域赋值                                       |<br>| 0xb6     | invokevirtual   | 调用实例方法                                                 |<br>| 0xb7     | invokespecial   | 调用超类构造方法，实例初始化方法，私有方法                   |<br>| 0xb8     | invokestatic    | 调用静态方法                                                 |<br>| 0xb9     | invokeinterface | 调用接口方法                                                 |<br>| 0xba     | —              |                                                              |<br>| 0xbb     | new             | 创建一个对象，并将其引用值压入栈顶                           |<br>| 0xbc     | newarray        | 创建一个指定原始类型（如int, float, char…）的数组，并将其引用值压入栈顶 |<br>| 0xbd     | anewarray       | 创建一个引用型（如类，接口，数组）的数组，并将其引用值压入栈顶 |<br>| 0xbe     | arraylength     | 获得数组的长度值并压入栈顶                                   |<br>| 0xbf     | athrow          | 将栈顶的异常抛出                                             |<br>| 0xc0     | checkcast       | 检验类型转换，检验未通过将抛出ClassCastException             |<br>| 0xc1     | instanceof      | 检验对象是否是指定的类的实例，如果是将1压入栈顶，否则将0压入栈顶 |<br>| 0xc2     | monitorenter    | 获得对象的锁，用于同步方法或同步块                           |<br>| 0xc3     | monitorexit     | 释放对象的锁，用于同步方法或同步块                           |<br>| 0xc4     | wide            | &lt;待补充&gt;                                                     |<br>| 0xc5     | multianewarray  | 创建指定类型和指定维度的多维数组（执行该指令时，操作栈中必须包含各维度的长度值），并将其引用值压入栈顶 |<br>| 0xc6     | ifnull          | 为null时跳转                                                 |<br>| 0xc7     | ifnonnull       | 不为null时跳转                                               |<br>| 0xc8     | goto_w          | 无条件跳转（宽索引）                                         |<br>| 0xc9     | jsr_w           | 跳转至指定32位offset位置，并将jsr_w下一条指令地址压入栈顶    |</p>
</li>
</ul>
<p><strong>TODO dup的作用？</strong></p>
<p>看下栈帧的变化，dup在里面的效果</p>
<p class='item-img' data-src='/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230118111219258.png'><img src="/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230118111219258.png" alt="image-20230118111219258"></p>
<p>可以看到 new 完之后一定会接一个 invokespecial 指令，其会调用实例初始化方法<init>:()V，注意这个方法是一个实例方法，所以需要从操作数栈顶弹出一个this引用，也就是说这一步会弹出一个之前入栈的对象地址。那么第二个我就可以直接拿来用了，因为他已经是实例化好的对象。如果我们不用，<strong>那编译器也会生成dup指令，在初始化方法调用完成后再从栈顶pop出来</strong>，如果要用的话需要我们手动从局部变量表里取</init></p>
<h5 id="Java-类字节码编辑-ASM"><a href="#Java-类字节码编辑-ASM" class="headerlink" title="Java 类字节码编辑 - ASM"></a>Java 类字节码编辑 - ASM</h5><p class='item-img' data-src='https://github.com/Y4tacker/JavaSec/raw/main/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ASM%E5%AD%A6%E4%B9%A0/img/asm-core-classes.png'><img src="https://github.com/Y4tacker/JavaSec/raw/main/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ASM%E5%AD%A6%E4%B9%A0/img/asm-core-classes.png" alt="img"></p>
<p>ASM提供了三个基于<code>ClassVisitor API</code>的核心API，用于生成和转换类</p>
<ol>
<li><code>ClassReader</code>类用于解析class文件或二进制流；</li>
<li><code>ClassWriter</code>类是<code>ClassVisitor</code>的子类，用于生成类二进制；</li>
<li><code>ClassVisitor</code>是一个抽象类，自定义<code>ClassVisitor</code>重写<code>visitXXX</code>方法，可获取捕获ASM类结构访问的所有事件；</li>
</ol>
<p><strong>ClassReader和ClassVistor</strong></p>
<ul>
<li><p>ClassReader</p>
<p>用于解析类字节码，提供三种创建方式：<strong>类名、类字节码数组、类输入流对象</strong></p>
<p class='item-img' data-src='/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230115225203475.png'><img src="/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230115225203475.png" alt="image-20230115225203475"></p>
</li>
<li><p>ClassVisitor</p>
<p>两个重要字段：api 指出了 ASM api 版本；cv 是一个 ClassVisitor 类型的数据，它的作用是将多个 ClassVisitor 串连起来</p>
<p class='item-img' data-src='/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230116173506490.png'><img src="/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230116173506490.png" alt="image-20230116173506490"></p>
<p>其通常作为访问者模式中的访问者来根据顺序执行访问类结构中的不同部分，重点关注<code>visit()、visitField()、visitMethod()和visitEnd()</code></p>
<p>有一个signature参数需要注意，它与<code>泛型</code>密切先关，例子如下：无泛型的情况下设置为null即可</p>
<p class='item-img' data-src='/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230116174308989.png'><img src="/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230116174308989.png" alt="image-20230116174308989"></p>
<p><strong>常用的 Visitor 回调事件 注意参数！</strong></p>
<p>| 方法名              | 说明                                                         |<br>| —————————- | —————————————————————————————— |<br>| visit               | 访问class的头部信息时，version为class版本（<strong>编译版本</strong>），access为访问修饰符，name为类名称，signature为class的签名，<strong>可能是null</strong>，superName为超类名称，interfaces为接口的名称 |<br>| visitAnnotation     | 访问class的<strong>注解信息</strong>时，descriptor为签名描述信息，visible为是否运行时可见 |<br>| visitAttribute      | 访问该类的属性                                               |<br>| visitInnerClass     | 访问class中内部类的信息，而且这个内部类不一定是被访问类的成员（有可能是一段方法中的匿名内部类或者声明在一个方法中的类等等）。name为内部类的名称，outerName为内部类所在类的名称，innerName为内部类的名称 |<br>| visitOuterClass     | 访问该类的外部类，仅当类具有封闭类时，才必须调用此方法。owner为拥有该类的class名称，name为包含该类的方法的名称，如果该类未包含在其封闭类的方法中，则返回null，descriptor为签名描述信息 |<br>| visitEnd            | <strong>结束访问class时调用</strong>                                      |<br>| visitField          | 访问class中字段的信息，返回一个<strong>FieldVisitor</strong>用于操作字段相关的信息，access为访问修饰符，name为类名称，signature为class的签名，可能是null，descriptor为描述信息 |<br>| visitMethod         | 访问class中方法的信息，返回一个MethodVisitor用于操作字段相关的信息，access为访问修饰符，name为方法名称，signature为方法的签名，可能是null，descriptor为描述信息，exceptions为异常 |<br>| visitModule         | 访问对应的模块                                               |<br>| visitTypeAnnotation | 访问类的签名的注解                                           |<br>| visitNestHost       | 访问类的nest host；(nest 指的一个共享私有成员变量的包名相同的class集合，nest中有一个host(主类)和多个members(成员类)，jdk11为了提供更大，更广泛的嵌套类型，并且为了补足访问控制检测不足，引进了两个新的class文件属性，nest host 和nest member,nest host中包含了一个nest members列表，用来确定其他静态nest members;nest member中包含了一个nest host属性用来确定它的nesthost;) |<br>| visitNestMember     | 访问嵌套类的nest member，只有host class被visited时才能调用该方法 |</p>
<p class='item-img' data-src='/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230117203859698.png'><img src="/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230117203859698.png" alt="image-20230117203859698"></p>
<p>参数说明：</p>
<blockquote>
<ul>
<li><code>visitField (access, name, descriptor, signature, value)</code></li>
<li><p><code>visitMethod(access, name, descriptor, signature, exceptions)</code></p>
</li>
<li><p><code>access</code>参数：表示当前字段或方法带有的访问标识（access flag）信息，例如<code>ACC_PUBLIC</code>、<code>ACC_STATIC</code>和<code>ACC_FINAL</code>等。</p>
</li>
<li><code>name</code>参数：表示当前字段或方法的名字。</li>
<li><code>descriptor</code>参数：表示当前字段或方法的描述符。这些描述符，与我们平时使用的Java类型是有区别的。</li>
<li><code>signature</code>参数：表示当前字段或方法是否带有泛型信息。换句话说，如果不带有泛型信息，提供一个<code>null</code>就可以了；如果带有泛型信息，就需要给它提供某一个具体的值。</li>
<li><code>value</code>参数：是<code>visitField()</code>方法的第5个参数。这个参数的取值，与当前字段是否为常量有关系。如果当前字段是一个常量，就需要给<code>value</code>参数提供某一个具体的值；如果当前字段不是常量，那么使用<code>null</code>就可以了。</li>
<li><code>exceptions</code>参数：是<code>visitMethod()</code>方法的第5个参数。这个参数的取值，与当前方法头（Method Header）中是否具有<code>throws XxxException</code>相关。</li>
</ul>
</blockquote>
</li>
<li><p><strong>FieldVisitor类</strong></p>
<p>通过 ClassVisitor类的 visitField方法返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> FieldVisitor <span class="hljs-title function_">visitField</span><span class="hljs-params">(<span class="hljs-type">int</span> access, String name, String descriptor, String signature, Object value)</span>;<br><span class="hljs-comment">//示例</span><br>&#123;<br>fieldVisitor = classWriter.visitField(ACC_PUBLIC | ACC_STATIC, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>fieldVisitor.visitEnd();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同样也支持一系列 visitxxx的回调</p>
<p>这里的方法只需要关注一个<code>visitEnd()</code> 即可</p>
</li>
<li><p>ClassWriter 类</p>
<p>构造函数中的参数</p>
<p class='item-img' data-src='/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230116175440576.png'><img src="/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230116175440576.png" alt="image-20230116175440576"></p>
<p>使用该类生成一个 Class 文件，可以分成三个步骤：</p>
<blockquote>
<ul>
<li>第一步，创建<code>ClassWriter</code>对象。</li>
<li>第二步，调用<code>ClassWriter</code>对象的<code>visitXxx()</code>方法。</li>
<li>第三步，调用<code>ClassWriter</code>对象的<code>toByteArray()</code>方法。</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>MethodVisitor和AdviceAdapter</strong></p>
<p><code>MethodVisitor</code> 同 <code>ClassVisitor</code>，<strong>重写</strong><code>MethodVisitor</code>类方法可获取捕获到对应的<code>visit</code>事件</p>
<p>顺序如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">( visitParameter )* [ visitAnnotationDefault ] <br>  ( visitAnnotation | visitAnnotableParameterCount | visitParameterAnnotation visitTypeAnnotation | visitAttribute )* <br>  [ visitCode <br>   ( visitFrame | visit&lt;i&gt;X&lt;/i&gt;Insn | visitLabel | visitInsnAnnotation | visitTryCatchBlock | visitTryCatchAnnotation | visitLocalVariable | visitLocalVariableAnnotation | visitLineNumber )* <br>   visitMaxs <br>  ] <br>visitEnd<br></code></pre></td></tr></table></figure>
<p>AdviceAdapter 的父类是 <code>GeneratorAdapter</code>和<code>LocalVariablesSorter</code></p>
<p><code>AdviceAdapter</code>类实现了一些非常有价值的方法，如：<code>onMethodEnter</code>（方法进入时回调方法）、<code>onMethodExit</code>（方法退出时回调方法），如果我们自己实现很容易掉进坑里面，因为这两个方法都是根据条件推算出来的。比如我们如果在构造方法的第一行直接插入了我们自己的字节码就可能会发现程序一运行就会崩溃，因为Java语法中限制我们第一行代码必须是<code>super(xxx)</code>。</p>
<p>使用<code>AdviceAdapter</code>可以直接调用<code>newLocal(type)</code>计算出<strong>本地变量存储的位置</strong>，为我们省去了许多不必要的麻烦</p>
<p><code>GeneratorAdapter</code>封装了一些栈指令操作的方法，如<code>loadArgArray</code>方法可以直接获取方法所有参数数组、<code>invokeStatic</code>方法可以直接调用类方法、<code>push</code>、<code>storeLocal</code>方法可压入各种类型的对象等。</p>
<p><strong>MethodVisitor 常用API</strong></p>
<ul>
<li><p><code>visitFieldInsn</code></p>
<blockquote>
<p>Visits a field instruction. A field instruction is an instruction that loads or stores the value of a field of an object</p>
</blockquote>
<p>支持 GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD操作</p>
</li>
<li><p><code>visitFrame</code></p>
<blockquote>
<p>Visits the current state of the local variables and operand stack elements</p>
</blockquote>
<p>参数就是局部变量表和操作数栈的内容</p>
</li>
<li><p><code>visitIincInsn</code></p>
<p>处理 IINC指令：将指定int型变量增加指定值</p>
</li>
<li><p><code>visitVarInsn</code></p>
<blockquote>
<p>Visits a local variable instruction. A local variable instruction is an instruction that loads or stores the value of a local variable</p>
</blockquote>
<p>就是取局部变量变的值放入操作数栈</p>
</li>
<li><p><code>visitMethodInsn</code></p>
<blockquote>
<p>visits a method instruction. A method instruction is an instruction that invokes a method</p>
</blockquote>
<p>支持INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE。也就是调用某个方法</p>
</li>
<li><p><code>visitInsn</code> </p>
<blockquote>
<p>Visits a zero operand instruction</p>
</blockquote>
<p>参数就是操作码op</p>
</li>
<li><p><code>visitTypeInsn</code></p>
<blockquote>
<p>Visits a type instruction. A type instruction is an instruction that takes the <strong>internal name of a class</strong> as parameter</p>
</blockquote>
<p>将一个类的全限定名作为参数然后new一个对象压入操作数栈中</p>
</li>
<li><p><code>visitCode/End</code></p>
<p>访问的开始/结束</p>
</li>
<li><p><code>visitLdcInsn</code></p>
<blockquote>
<p>the constant to be loaded on the stack</p>
</blockquote>
<p>访问常量池索引</p>
<p>在<code>&lt;init&gt;</code>初始化函数的构造中，this变量也需要经过一个初始化的操作，其位于局部变量表索引为0的位置</p>
<p class='item-img' data-src='/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230118105514531.png'><img src="/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230118105514531.png" alt="image-20230118105514531"></p>
<p>这里说明一下构造函数方法的创建，就以最基本的空构造函数为例，由于前面说了刚开始的this变量是处于未初始化的状态，因此需要进行初始化，那么用什么方法呢。这里实际就是用的父类的构造函数，对于一般的对象，就调用父类 Object 类的构造函数即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// &lt;init&gt;<br>public A() &#123;<br>	super();<br>&#125;<br><br>// asm<br>MethodVisitor mv1 = cw.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);<br>            mv1.visitCode();<br>            mv1.visitVarInsn(ALOAD, 0);<br>            mv1.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false);<br>            mv1.visitInsn(RETURN);<br>            mv1.visitMaxs(1, 1);<br>            mv1.visitEnd();<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>Label类</strong></p>
<blockquote>
<ul>
<li>A position in the bytecode of a method.</li>
<li>Labels are used for jump, goto, and switch instructions, and for try catch blocks.</li>
<li>A label <strong>designates the instruction that is just after</strong>. Note however that there can be other elements between a label and the instruction it designates (such as other labels, stack map frames, line numbers, etc.).</li>
</ul>
</blockquote>
<p>Label类中存在一个属性 <code>bytecodeOffset</code> 它用于计算相对偏移量。由于指令是索引值位置可变，我们想要固定一个跳转位置的话则需要 Label 的参与，当asm转换成byte[] 时，将通过Label与待跳转位置相减来计算出相对偏移量。</p>
<p class='item-img' data-src='/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230118114237744.png'><img src="/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230118114237744.png" alt="image-20230118114237744"></p>
<p>如果要添加一个跳转位置的话，调用 <code>MethodVisitor.visitLabel(Label)</code></p>
<p>可以用于实现选择、循环、try-catch语句</p>
<p>生成if语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">if (value == 0) &#123;<br>  System.out.println(&quot;0&quot;);<br>&#125;<br>else &#123;<br>  System.out.println(&quot;not 0&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123;<br>     methodVisitor = classWriter.visitMethod(ACC_PUBLIC, &quot;test&quot;, &quot;(I)V&quot;, null, null);<br>     methodVisitor.visitCode();<br>     methodVisitor.visitVarInsn(ILOAD, 1);<br>     Label label0 = new Label();<br>     methodVisitor.visitJumpInsn(IFNE, label0);<br>     methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);<br>     methodVisitor.visitLdcInsn(&quot;0&quot;);<br>     methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);<br>     Label label1 = new Label();<br>     methodVisitor.visitJumpInsn(GOTO, label1);<br>  <br>     methodVisitor.visitLabel(label0);<br>     methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);<br>     methodVisitor.visitLdcInsn(&quot;not 0&quot;);<br>     methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);<br>     methodVisitor.visitLabel(label1);<br>     methodVisitor.visitInsn(RETURN);<br>     methodVisitor.visitMaxs(2, 2);<br>     methodVisitor.visitEnd();<br> &#125;<br></code></pre></td></tr></table></figure>
<p>生成switch语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">switch (val) &#123;<br>  case 1:<br>    System.out.println(&quot;1&quot;);<br>    break;<br>  case 2:<br>    System.out.println(&quot;2&quot;);<br>    break;<br>  case 3:<br>    System.out.println(&quot;3&quot;);<br>    break;<br>  case 9:<br>    System.out.println(&quot;9&quot;);<br>    break;<br>  default:<br>    System.out.println(&quot;unknown&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123;<br>            methodVisitor = classWriter.visitMethod(ACC_PUBLIC, &quot;test&quot;, &quot;(I)V&quot;, null, null);<br>            methodVisitor.visitCode();<br>            methodVisitor.visitVarInsn(ILOAD, 1);<br>            Label label0 = new Label();<br>            Label label1 = new Label();<br>            Label label2 = new Label();<br>            Label label3 = new Label();<br>            Label label4 = new Label();<br>            methodVisitor.visitTableSwitchInsn(1, 9, label3, new Label[] &#123; label0, label1, label2, label3, label3, label3, label3, label3, label4 &#125;);<br>            methodVisitor.visitLabel(label0);<br>            methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);<br>            methodVisitor.visitLdcInsn(&quot;1&quot;);<br>            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);<br>            Label label5 = new Label();<br>            methodVisitor.visitJumpInsn(GOTO, label5);<br>            methodVisitor.visitLabel(label1);<br>            methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);<br>            methodVisitor.visitLdcInsn(&quot;2&quot;);<br>            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);<br>            methodVisitor.visitJumpInsn(GOTO, label5);<br>            methodVisitor.visitLabel(label2);<br>            methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);<br>            methodVisitor.visitLdcInsn(&quot;3&quot;);<br>            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);<br>            methodVisitor.visitJumpInsn(GOTO, label5);<br>            methodVisitor.visitLabel(label4);<br>            methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);<br>            methodVisitor.visitLdcInsn(&quot;9&quot;);<br>            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);<br>            methodVisitor.visitJumpInsn(GOTO, label5);<br>            methodVisitor.visitLabel(label3);<br>            methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);<br>            methodVisitor.visitLdcInsn(&quot;unknown&quot;);<br>            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);<br>            methodVisitor.visitLabel(label5);<br>            methodVisitor.visitInsn(RETURN);<br>            methodVisitor.visitMaxs(2, 2);<br>            methodVisitor.visitEnd();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>生成for语句</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123;<br>  methodVisitor = classWriter.visitMethod(ACC_PUBLIC, &quot;test&quot;, &quot;()V&quot;, null, null);<br>  methodVisitor.visitCode();<br>  methodVisitor.visitInsn(ICONST_0);<br>  methodVisitor.visitVarInsn(ISTORE, 1);<br>  <br>  Label label0 = new Label();<br>  methodVisitor.visitLabel(label0);<br>  methodVisitor.visitVarInsn(ILOAD, 1);<br>  methodVisitor.visitIntInsn(BIPUSH, 10);<br>  <br>  Label label1 = new Label();<br>  methodVisitor.visitJumpInsn(IF_ICMPGE, label1);<br>  methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);<br>  methodVisitor.visitVarInsn(ILOAD, 1);<br>  methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(I)V&quot;, false);<br>  methodVisitor.visitIincInsn(1, 1);<br>  methodVisitor.visitJumpInsn(GOTO, label0);<br>  methodVisitor.visitLabel(label1);<br>  methodVisitor.visitInsn(RETURN);<br>  methodVisitor.visitMaxs(2, 2);<br>  methodVisitor.visitEnd();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>生成try catch语句</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>  System.out.println(<span class="hljs-string">&quot;try&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>  System.out.println(<span class="hljs-string">&quot;catch&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123;<br>            methodVisitor = classWriter.visitMethod(ACC_PUBLIC, &quot;test&quot;, &quot;(I)V&quot;, null, null);<br>            methodVisitor.visitCode();<br>            Label label0 = new Label();<br>            Label label1 = new Label();<br>            Label label2 = new Label();<br>            methodVisitor.visitTryCatchBlock(label0, label1, label2, &quot;java/lang/Exception&quot;);<br>            methodVisitor.visitLabel(label0);<br>            methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);<br>            methodVisitor.visitLdcInsn(&quot;try&quot;);<br>            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);<br>            methodVisitor.visitLabel(label1);<br>            Label label3 = new Label();<br>            methodVisitor.visitJumpInsn(GOTO, label3);<br>            methodVisitor.visitLabel(label2);<br>            methodVisitor.visitVarInsn(ASTORE, 2);<br>            methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);<br>            methodVisitor.visitLdcInsn(&quot;catch&quot;);<br>            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);<br>            methodVisitor.visitLabel(label3);<br>            methodVisitor.visitInsn(RETURN);<br>            methodVisitor.visitMaxs(2, 3);<br>            methodVisitor.visitEnd();<br>        &#125;<br></code></pre></td></tr></table></figure>
<p><strong>生成while语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">while (true)&#123;<br>  System.out.println(&quot;23333&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123;<br>methodVisitor = classWriter.visitMethod(ACC_PUBLIC, &quot;test&quot;, &quot;(I)V&quot;, null, null);<br>methodVisitor.visitCode();<br>Label label0 = new Label();<br>methodVisitor.visitLabel(label0);<br>methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);<br>methodVisitor.visitLdcInsn(&quot;23333&quot;);<br>methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);<br>methodVisitor.visitJumpInsn(GOTO, label0);<br>methodVisitor.visitMaxs(2, 2);<br>methodVisitor.visitEnd();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>TODO 待解决：visitMaxs() 参数如何确定？</strong></p>
<p>实际上并不需要注意计算，只需要当成一个占位符即可。通常情况下在创建<code>ClassWriter</code> 都会传入 flag <code>COMPUTE_FRAMES</code> 来自动帮我们计算 max_stack 和 max_local</p>
<p>demo：遍历一个类的基本信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Test&quot;</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ClassReader</span> <span class="hljs-variable">cr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassReader</span>(className);<br><br>            System.out.println(<br>                    <span class="hljs-string">&quot;解析类名：&quot;</span> + cr.getClassName() + <span class="hljs-string">&quot;,父类：&quot;</span> + cr.getSuperName() +<br>                            <span class="hljs-string">&quot;,实现接口：&quot;</span> + Arrays.toString(cr.getInterfaces()));<br><br>            System.out.println(<span class="hljs-string">&quot;-----------------------------------------------------------------------------&quot;</span>);<br>            <span class="hljs-comment">// 使用自定义的ClassVisitor访问者对象，访问该类文件的结构</span><br><br>            cr.accept(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassVisitor</span>(ASM9) &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> version, <span class="hljs-type">int</span> access, String name, String signature, String superName, String[] interfaces)</span> &#123;<br>                    System.out.println(<br>                            <span class="hljs-string">&quot;变量修饰符：&quot;</span> + access + <span class="hljs-string">&quot;\t 类名：&quot;</span> + name + <span class="hljs-string">&quot;\t 父类名：&quot;</span> + superName +<br>                                    <span class="hljs-string">&quot;\t 实现的接口：&quot;</span> + Arrays.toString(interfaces)<br>                    );<br>                    System.out.println(<span class="hljs-string">&quot;-----------------------------------------------------------------------------&quot;</span>);<br><br>                    <span class="hljs-built_in">super</span>.visit(version, access, name, signature, superName, interfaces);<br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> FieldVisitor <span class="hljs-title function_">visitField</span><span class="hljs-params">(<span class="hljs-type">int</span> access, String name, String desc, String signature, Object value)</span> &#123;<br>                    System.out.println(<br>                            <span class="hljs-string">&quot;变量修饰符：&quot;</span> + access + <span class="hljs-string">&quot;\t 变量名称：&quot;</span> + name + <span class="hljs-string">&quot;\t 描述符：&quot;</span> + desc + <span class="hljs-string">&quot;\t 默认值：&quot;</span> + value<br>                    );<br><br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.visitField(access, name, desc, signature, value);<br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> MethodVisitor <span class="hljs-title function_">visitMethod</span><span class="hljs-params">(<span class="hljs-type">int</span> access, String name, String desc, String signature, String[] exceptions)</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;方法修饰符：&quot;</span> + access + <span class="hljs-string">&quot;\t 方法名称：&quot;</span> + name + <span class="hljs-string">&quot;\t 描述符：&quot;</span> + desc +<br>                            <span class="hljs-string">&quot;\t 抛出的异常：&quot;</span> + Arrays.toString(exceptions));<br><br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.visitMethod(access, name, desc, signature, exceptions);<br>                &#125;<br>            &#125;, EXPAND_FRAMES);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230116001201930.png'><img src="/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/image-20230116001201930.png" alt="image-20230116001201930"></p>
<p>demo：修改类名/方法名/方法修饰符</p>
<p>利用<code>ClassWriter</code>可以实现类修改功能，如果插入了新的局部变量、字节码，需要重新计算<code>max_stack</code> 和 <code>max_locals</code>ASM为我们提供了内置的自动计算方式，只需在创建<code>ClassWriter</code>的时候传入<code>COMPUTE_FRAMES</code>即可：<code>new ClassWriter(cr, ClassWriter.COMPUTE_FRAMES);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;asm.HelloWorld&quot;</span>;<br><br>        <span class="hljs-comment">// 定义修改后的类名</span><br><span class="hljs-comment">//        final String newClassName = &quot;JavaSecTestHelloWorld&quot;;</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ClassReader</span> <span class="hljs-variable">cr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassReader</span>(className);<br><br>            <span class="hljs-comment">// 创建ClassWriter对象，COMPUTE_FRAMES会自动计算 max_stack 和 max_locals</span><br>            <span class="hljs-type">ClassWriter</span> <span class="hljs-variable">cw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(cr, ClassWriter.COMPUTE_FRAMES);<br><br>            System.out.println(<span class="hljs-string">&quot;-----------------------------------------------------------------------------&quot;</span>);<br>            <span class="hljs-comment">// 使用自定义的ClassVisitor访问者对象，访问该类文件的结构</span><br><br>            cr.accept(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassVisitor</span>(ASM9, cw) &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> version, <span class="hljs-type">int</span> access, String name, String signature, String superName, String[] interfaces)</span> &#123;<br>                    <span class="hljs-built_in">super</span>.visit(version, access, name, signature, superName, interfaces);<br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> MethodVisitor <span class="hljs-title function_">visitMethod</span><span class="hljs-params">(<span class="hljs-type">int</span> access, String name, String descriptor, String signature, String[] exceptions)</span> &#123;<br>                    <span class="hljs-comment">// 将 hello 方法名修改为 hi</span><br>                    <span class="hljs-keyword">if</span> (name.equals(<span class="hljs-string">&quot;setTest&quot;</span>)) &#123;<br>                        <span class="hljs-comment">// 修改方法访问修饰符，移除 public 属性，修改为 private</span><br>                        access = access &amp; ~ACC_PUBLIC | ACC_PRIVATE;<br>                    &#125;<br><br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.visitMethod(access, <span class="hljs-string">&quot;hi&quot;</span>, descriptor, signature, exceptions);<br>                &#125;<br>            &#125;, EXPAND_FRAMES);<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\ctf\\JNDI\\tool\\JNDIEXP\\src\\test\\java\\asm\\HelloWorld.class&quot;</span>;<br>            <span class="hljs-type">byte</span>[] bytes = cw.toByteArray();<br>            <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath);<br>            outputStream.write(bytes);<br>            outputStream.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure>
<p>demo3 修改类方法字节码：</p>
<p>以 <code>HelloWorld#hello()</code>方法为例，在原业务逻辑执行前打印出该方法的参数值；修改该方法的返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;asm.HelloWorld&quot;</span>;<br><br>        <span class="hljs-comment">// 定义修改后的类名</span><br><span class="hljs-comment">//        final String newClassName = &quot;JavaSecTestHelloWorld&quot;;</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ClassReader</span> <span class="hljs-variable">cr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassReader</span>(className);<br><br>            <span class="hljs-comment">// 创建ClassWriter对象，COMPUTE_FRAMES会自动计算 max_stack 和 max_locals</span><br>            <span class="hljs-type">ClassWriter</span> <span class="hljs-variable">cw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(cr, ClassWriter.COMPUTE_FRAMES);<br><br>            System.out.println(<span class="hljs-string">&quot;-----------------------------------------------------------------------------&quot;</span>);<br>            <span class="hljs-comment">// 使用自定义的ClassVisitor访问者对象，访问该类文件的结构</span><br><br>            cr.accept(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassVisitor</span>(ASM9, cw) &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> version, <span class="hljs-type">int</span> access, String name, String signature, String superName, String[] interfaces)</span> &#123;<br>                    <span class="hljs-built_in">super</span>.visit(version, access, name, signature, superName, interfaces);<br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> MethodVisitor <span class="hljs-title function_">visitMethod</span><span class="hljs-params">(<span class="hljs-type">int</span> access, String name, String descriptor, String signature, String[] exceptions)</span> &#123;<br>                    <span class="hljs-keyword">if</span> (name.equals(<span class="hljs-string">&quot;hello&quot;</span>)) &#123;<br>                        <span class="hljs-type">MethodVisitor</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.visitMethod(access, name, descriptor, signature, exceptions);<br><br>                        <span class="hljs-comment">// 创建自定义的MethodVisitor，修改原方法的字节码</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AdviceAdapter</span>(api, mv, access, name, descriptor) &#123;<br><br>                            <span class="hljs-comment">// 获取 String的ASM Type对象</span><br>                            <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Type</span> <span class="hljs-variable">stringType</span> <span class="hljs-operator">=</span> Type.getType(String.class);<br><br>                            <span class="hljs-type">int</span> newArgIndex;<br><br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMethodEnter</span><span class="hljs-params">()</span> &#123;<br>                                <span class="hljs-comment">// 输出 hello 方法的第一个参数，因为 hello 是非 static 方法，所以 0 是 this，第一个参数的下标应该是 1</span><br>                                mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);<br>                                mv.visitVarInsn(ALOAD, <span class="hljs-number">1</span>);<br>                                mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>);<br><br>                                <span class="hljs-comment">// 创建一个新的局部变量，newLocal会计算出这个新局部对象的索引位置</span><br>                                newArgIndex = newLocal(stringType);<br>                                <span class="hljs-comment">// 将int, float或String型常量值从常量池中推送至栈顶</span><br>                                mv.visitLdcInsn(<span class="hljs-string">&quot;fuck you!&quot;</span>);<br>                                <span class="hljs-comment">// Generates the instruction to store the top stack value in the given local variable</span><br>                                storeLocal(newArgIndex, stringType);<br>                            &#125;<br><br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMethodExit</span><span class="hljs-params">(<span class="hljs-type">int</span> opcode)</span> &#123;<br>                                dup();  <span class="hljs-comment">// 复制栈顶的返回值</span><br><br>                                <span class="hljs-comment">// 创建一个新的局部变量，并获取索引位置</span><br>                                <span class="hljs-type">int</span> <span class="hljs-variable">returnValueIndex</span> <span class="hljs-operator">=</span> newLocal(stringType);<br><br>                                <span class="hljs-comment">// 将栈顶的返回值压入新生成的局部变量中</span><br>                                storeLocal(returnValueIndex, stringType);<br><br>                                <span class="hljs-comment">// 输出 hello 方法的返回值</span><br>                                <span class="hljs-comment">// 获取指定类的静态域，并将其值压入栈顶</span><br>                                mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);<br>                                mv.visitVarInsn(ALOAD, returnValueIndex);<br>                                mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>);<br><br>                                <span class="hljs-comment">// 压入方法进入 (onMethodEnter) 存入到局部变量的 var2值 到栈顶</span><br>                                loadLocal(newArgIndex);<br><br>                                <span class="hljs-comment">// 返回一个引用类型，即栈顶的var2字符串，return var2;</span><br>                                <span class="hljs-comment">// 需要特别注意的是不同数据类型应当使用不同的RETURN指令</span><br>                                mv.visitInsn(ARETURN);<br>                            &#125;<br>                        &#125;;<br>                    &#125;<br><br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.visitMethod(access, <span class="hljs-string">&quot;hi&quot;</span>, descriptor, signature, exceptions);<br>                &#125;<br>            &#125;, EXPAND_FRAMES);<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\ctf\\JNDI\\tool\\JNDIEXP\\src\\test\\java\\asm\\HelloWorld.class&quot;</span>;<br>            <span class="hljs-type">byte</span>[] bytes = cw.toByteArray();<br>            <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath);<br>            outputStream.write(bytes);<br>            outputStream.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br></code></pre></td></tr></table></figure>
<p>demo4：动态创建Java类二进制</p>
<p>可以使用<code>ClassWriter</code>来动态创建出一个Java类的二进制文件，然后通过<strong>自定义的类加载器</strong>就可以将我们动态生成的类加载到JVM中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ASM2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Opcodes</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CLASS_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;asm.TestASMHelloWorld&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CLASS_NAME_ASM</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;asm/TestASMHelloWorld&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] dump() <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建 ClassWriter，用于生成类字节码</span><br>        <span class="hljs-type">ClassWriter</span> <span class="hljs-variable">cw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 创建 MethodVisitor</span><br>        MethodVisitor mv;<br><br>        <span class="hljs-comment">// 创建一个字节码版本为 JDK1.7 的目标类</span><br>        cw.visit(V1_7, ACC_PUBLIC + ACC_SUPER, CLASS_NAME_ASM, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">// 设置源码文件名</span><br>       	 cw.visitSource(<span class="hljs-string">&quot;TestHelloWorld.java&quot;</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">// 创建一个空的构造方法，</span><br>        <span class="hljs-comment">// public TestASMHelloWorld() &#123;</span><br>        <span class="hljs-comment">// &#125;</span><br>        &#123;<br>            mv = cw.visitMethod(ACC_PUBLIC, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>            mv.visitCode();<br>            <span class="hljs-type">Label</span> <span class="hljs-variable">l0</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Label</span>();<br>            mv.visitLabel(l0);<br>            mv.visitLineNumber(<span class="hljs-number">5</span>, l0);<br>            mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>);<br>            mv.visitMethodInsn(INVOKESPECIAL, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-literal">false</span>);<br>            mv.visitInsn(RETURN);<br>            <span class="hljs-type">Label</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Label</span>();<br>            mv.visitLabel(l1);<br>            mv.visitLocalVariable(<span class="hljs-string">&quot;this&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>+CLASS_NAME_ASM+<span class="hljs-string">&quot;;&quot;</span>, <span class="hljs-literal">null</span>, l0, l1, <span class="hljs-number">0</span>);<br>            mv.visitMaxs(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>            mv.visitEnd();<br>        &#125;<br><br>        <span class="hljs-comment">// 创建一个hello方法，</span><br>        <span class="hljs-comment">// public static String hello() &#123;</span><br>        <span class="hljs-comment">//     return &quot;Hello World~&quot;;</span><br>        <span class="hljs-comment">// &#125;</span><br>        &#123;<br>            mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>            mv.visitCode();<br>            <span class="hljs-type">Label</span> <span class="hljs-variable">l0</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Label</span>();<br>            mv.visitLabel(l0);<br>            mv.visitLineNumber(<span class="hljs-number">8</span>, l0);<br>            mv.visitLdcInsn(<span class="hljs-string">&quot;Hello World~&quot;</span>);<br>            mv.visitInsn(ARETURN);<br>            mv.visitMaxs(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>            mv.visitEnd();<br>        &#125;<br><br>        cw.visitEnd();<br><br>        <span class="hljs-keyword">return</span> cw.toByteArray();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] classBytes = dump();<br><br>        <span class="hljs-comment">// 创建自定义类加载器，加载 ASM 创建的类字节码到 JVM</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassLoader</span>(ASM2.class.getClassLoader()) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.findClass(name);<br>                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                    <span class="hljs-keyword">return</span> defineClass(CLASS_NAME, classBytes, <span class="hljs-number">0</span>, classBytes.length);<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        System.out.println(<span class="hljs-string">&quot;hello方法执行结果：&quot;</span> + classLoader.loadClass(CLASS_NAME).getMethod(<span class="hljs-string">&quot;hello&quot;</span>).invoke(<span class="hljs-literal">null</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>AdviceAdapter 用法：</p>
<ul>
<li><code>onMethodEnter()</code>方法：在“方法进入”的时候，添加一些代码逻辑。</li>
<li><code>onMethodExit()</code>方法：在“方法退出”的时候，添加一些代码逻辑。</li>
</ul>
<p>注意事项：</p>
<blockquote>
<ul>
<li>第一点，对于<code>onMethodEnter()</code>和<code>onMethodExit()</code>这两个方法，都要注意Subclasses can use or change all the local variables, but <strong>should not change state of the stack</strong>。也就是说，要保持 <strong>operand stack</strong> 在修改前和修改后是一致的。</li>
<li>第二点，对于<code>onMethodExit()</code>方法，要注意The top element on the stack <strong>contains the return value or the exception instance</strong>。也就是说，“方法退出”的时候，operand stack上有返回值或异常对象，不要忘记处理，不要弄丢了它们。</li>
</ul>
</blockquote>
<p>demo：打印方法参数和返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Analysis</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Analysis</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">long</span> idCard, Object obj)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hashCode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        hashCode += name.hashCode();<br>        hashCode += age;<br>        hashCode += (<span class="hljs-type">int</span>) (idCard % Integer.MAX_VALUE);<br>        hashCode += obj.hashCode();<br>        hashCode = Math.abs(hashCode);<br>        System.out.println(<span class="hljs-string">&quot;Hash Code is &quot;</span> + hashCode);<br>        <span class="hljs-keyword">if</span> (hashCode % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;illegal&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>工具类 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParameterUtils</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">DateFormat</span> <span class="hljs-variable">fm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printValueOnStack</span><span class="hljs-params">(Object value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;    &quot;</span> + value);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> String) &#123;<br>            System.out.println(<span class="hljs-string">&quot;    &quot;</span> + value);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> Date) &#123;<br>            System.out.println(<span class="hljs-string">&quot;    &quot;</span> + fm.format(value));<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-type">char</span>[]) &#123;<br>            System.out.println(<span class="hljs-string">&quot;    &quot;</span> + Arrays.toString((<span class="hljs-type">char</span>[]) value));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;    &quot;</span> + value.getClass() + <span class="hljs-string">&quot;: &quot;</span> + value.toString());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printText</span><span class="hljs-params">(String text)</span> &#123;<br>        System.out.println(text);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassPrintParameterVisitor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassVisitor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassPrintParameterVisitor</span><span class="hljs-params">(<span class="hljs-type">int</span> api, ClassVisitor classVisitor)</span> &#123;<br>        <span class="hljs-built_in">super</span>(api, classVisitor);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> MethodVisitor <span class="hljs-title function_">visitMethod</span><span class="hljs-params">(<span class="hljs-type">int</span> access, String name, String descriptor, String signature, String[] exceptions)</span> &#123;<br>        <span class="hljs-type">MethodVisitor</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.visitMethod(access, name, descriptor, signature, exceptions);<br>        <span class="hljs-keyword">if</span> (mv != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isAbstractMethod</span> <span class="hljs-operator">=</span> (access &amp; Opcodes.ACC_ABSTRACT) != <span class="hljs-number">0</span>;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isNativeMethod</span> <span class="hljs-operator">=</span> (access &amp; Opcodes.ACC_NATIVE) != <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (!isAbstractMethod &amp;&amp; !isNativeMethod) &#123;<br><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodPrintParameterAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AdviceAdapter</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MethodPrintParameterAdapter</span><span class="hljs-params">(<span class="hljs-type">int</span> api, MethodVisitor methodVisitor, <span class="hljs-type">int</span> access, String name, String descriptor)</span> &#123;<br>            <span class="hljs-comment">// AdviceAdapter 为 protected 类型的构造方法，因此只能子类访问</span><br>            <span class="hljs-built_in">super</span>(api, methodVisitor, access, name, descriptor);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMethodEnter</span><span class="hljs-params">()</span> &#123;<br>            printMessage(<span class="hljs-string">&quot;Method Enter: &quot;</span> + getName() + methodDesc);<br><br>            Type[] argumentTypes = getArgumentTypes();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; argumentTypes.length; i++) &#123;<br>                <span class="hljs-type">Type</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> argumentTypes[i];<br>                loadArg(i);<br>                box(t);<br>                printValueOnStack(<span class="hljs-string">&quot;(Ljava/lang/Object;)V&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMethodExit</span><span class="hljs-params">(<span class="hljs-type">int</span> opcode)</span> &#123;<br>            printMessage(<span class="hljs-string">&quot;Method Exit: &quot;</span> + getName() + methodDesc);<br><br>            <span class="hljs-keyword">if</span> (opcode == ATHROW) &#123;<br>                <span class="hljs-built_in">super</span>.visitLdcInsn(<span class="hljs-string">&quot;abnormal return&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opcode == RETURN) &#123;<br>                <span class="hljs-built_in">super</span>.visitLdcInsn(<span class="hljs-string">&quot;return void&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opcode == ARETURN) &#123;<br>                dup();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (opcode == LRETURN || opcode == DRETURN) &#123;<br>                    dup2();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dup();<br>                &#125;<br>                box(getReturnType());<br>            &#125;<br>            printValueOnStack(<span class="hljs-string">&quot;(Ljava/lang/Object;)V&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printMessage</span><span class="hljs-params">(String str)</span> &#123;<br>            <span class="hljs-built_in">super</span>.visitLdcInsn(str);<br>            <span class="hljs-built_in">super</span>.visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;asm/ParameterUtils&quot;</span>, <span class="hljs-string">&quot;printText&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-literal">false</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printValueOnStack</span><span class="hljs-params">(String descriptor)</span> &#123;<br>            <span class="hljs-built_in">super</span>.visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;asm/ParameterUtils&quot;</span>, <span class="hljs-string">&quot;printValueOnStack&quot;</span>, descriptor, <span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>实现转换</strong></p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a target="_blank" rel="noopener" href="https://github.com/Y4tacker/JavaSec/blob/main/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ASM%E5%AD%A6%E4%B9%A0/index.md">https://github.com/Y4tacker/JavaSec/blob/main/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ASM%E5%AD%A6%E4%B9%A0/index.md</a></p>
<p><a target="_blank" rel="noopener" href="https://javasec.org/javase/JavaByteCode/">https://javasec.org/javase/JavaByteCode/</a></p>
<p><a target="_blank" rel="noopener" href="https://lsieun.github.io/java-asm-01/advice-adapter-intro.html">https://lsieun.github.io/java-asm-01/advice-adapter-intro.html</a></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/01/22/%E5%9B%9E%E6%98%BE%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">← Next 初识回显</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/">Soot文档学习（1） Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">RacerZ</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/RacerZ-fighting"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" href="qiyizhang2002@foxmail.com"><i class="fa fa-envelope" alt="E-Mail"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">1.</span> <span class="toc-text">Java 字节码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Java-class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">Java class文件格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java-Class-%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">Java Class 文件解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">1.3.</span> <span class="toc-text">Java虚拟机指令集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java-%E7%B1%BB%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E8%BE%91-ASM"><span class="toc-number">1.4.</span> <span class="toc-text">Java 类字节码编辑 - ASM</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">2.</span> <span class="toc-text">参考链接</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside><div id="shadow-aside"></div></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>