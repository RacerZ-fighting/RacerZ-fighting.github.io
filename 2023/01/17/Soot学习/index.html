<!DOCTYPE html><html lang="en" theme-mode="auto"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Soot文档学习（1） | RacerZ</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light' || window.matchMedia('(prefers-color-scheme:light)').matches) document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark' || window.matchMedia('(prefers-color-scheme:dark)').matches) document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><div id="shadow-header"></div><article><div id="post-bg"><div id="post-title"><h1>Soot文档学习（1）</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2023-01-16T16:00:00.000Z" id="date"> 2023-01-17</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2023-02-21T14:58:49.144Z" id="updated"> 2023-02-21</time></div></span></div></div><hr><div id="post-content"><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>有了静态分析基础，开始看看这个Soot，一定得实践与理论结合着来，把文档看一遍</p>
<h4 id="A-Survivor’s-Guide-to-Java-Program-Analysis-with-Soot"><a href="#A-Survivor’s-Guide-to-Java-Program-Analysis-with-Soot" class="headerlink" title="A Survivor’s Guide to Java Program Analysis with Soot"></a>A Survivor’s Guide to Java Program Analysis with Soot</h4><h5 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h5><p>Soot研发出来的目的是为了提供一种更好、更快的理解Java程序执行的工具。</p>
<p>Soot主要的优势之一在于它提供了四种不同的中间表示（IR）用作分析。每一种IR都是不同水平的抽象，使得分析时带来不同方面的便利。分别是 Baf, Grimp, Jimple和Shimple</p>
<p>Soot构建了如下几种数据结构表示：</p>
<ol>
<li><p>Scene</p>
<p>该类表示程序分析时涉及到的完整环境。通过它，你可以设置例如，应用类（提供给Soot用于分析的类）、主类（包含 main 方法的类）和关于过程间分析的访问信息（例如，指向信息和调用图）</p>
</li>
<li><p>SootClass </p>
<p>代表一个装入到Soot当中或者使用Soot创建的类</p>
</li>
<li><p>SootMethod</p>
<p>代表一个类中的方法</p>
</li>
<li><p>SootField</p>
<p>代表方法中的成员属性</p>
</li>
<li><p>Body</p>
<p>代表方法体。根据不同的IR表示，有不同的方法体格式</p>
</li>
</ol>
<h5 id="1-1-安装Soot"><a href="#1-1-安装Soot" class="headerlink" title="1.1 安装Soot"></a>1.1 安装Soot</h5><p>这里需要注意在下载soot时分为两种类型，<code>soot-&lt;RELEASE&gt;-jar-with-dependencies.jar</code>是包含了所有所需库的文件；而<code>soot-&lt;RELEASE&gt;.jar</code>仅仅包含Soot本身，需要手动选择需要分析的依赖。</p>
<h5 id="1-2-Road-map-to-this-guide-路线图"><a href="#1-2-Road-map-to-this-guide-路线图" class="headerlink" title="1.2 Road-map to this guide(路线图)"></a>1.2 Road-map to this guide(路线图)</h5><ul>
<li>内部表示 详细描述Soot中的四种中间表示</li>
<li>基本的Soot框架 简述了构成方法体的基础对象</li>
<li><p>Soot作为独立的工具 描述了如何使用Soot作为独立的工具。为此，本节介绍了Soot的内部工作原理、在命令行使用Soot及其接收的不同参数、Soot提供的一些内置分析框架以及如何使用用户自定义分析框架来扩展该工具</p>
</li>
<li><p>数据流框架 细致地描述了如何利用Soot内置数据流框架，伴随一个复杂表示分析的完整实例实现。这部分还讲述了标记Eclipse插件的代码以可视化地显示结果</p>
</li>
<li><p>调用图构建 介绍如何在整个程序分析期间获取调用图，并使用它提取各种信息</p>
</li>
<li><p>指针分析 介绍了两种高级指针分析框架 SPARK and Paddle</p>
</li>
<li>抽象控制流图的提取 描述了如何使用Soot来提取抽象控制流图的定制IR，以用作分析的起点，该分析可能受益于在抽象过程中所做的简化，如Java字符串分析</li>
</ul>
<h5 id="2-Basic-Soot-Constructs"><a href="#2-Basic-Soot-Constructs" class="headerlink" title="2 Basic Soot Constructs"></a>2 Basic Soot Constructs</h5><p>在这一节我们描述贯穿在Soot使用当中的常用基础对象。具体来讲，我们关注那些组成方法中代码的对象。由于这些都是非常简单的构造，因此这些描述相当简短</p>
<h5 id="2-1-Method-bodies"><a href="#2-1-Method-bodies" class="headerlink" title="2.1 Method bodies"></a>2.1 Method bodies</h5><p>Soot类<code>Body</code>代表一个方法体，它表示代码的风格取决于使用的IR，分别有：</p>
<ul>
<li>BafBody</li>
<li>GrimpBody</li>
<li>ShimpleBody</li>
<li>JimpleBody</li>
</ul>
<p>我们可以使用Body来访问各种信息，特别是我们可以检索局部声明（<code>getLocals()</code>）的 Collection 类变量（Soot使用它自己的Collection实现，称为 Chain），构成方法体中的语句（<code>getUnits()</code>）和方法体中的异常处理（<code>getTraps()</code>）</p>
<h5 id="2-2-Statements"><a href="#2-2-Statements" class="headerlink" title="2.2 Statements"></a>2.2 Statements</h5><p>Soot中的语句由接口<code>Unit</code>来表示，其中对于不同的IR存在不同的实现方式-例如，Jimple使用<code>Stmt</code>，而Grimp使用<code>Inst</code></p>
<p>通过<code>Unit</code>类，我们可以获取到所有变量值（<code>getUseBoxes()</code>）, 值定义的地方<code>getDefBoxes()</code>以及两者都取<code>getUseAndDefBoxes()</code>. 另外，我们可以获取跳转到当前<code>unit</code>的所有<code>unit</code>（<code>getBoxedPointingToThis()</code>）以及当前<code>unit</code>要跳转到的所有<code>unit</code>（<code>getUnitBoxs()</code>）. 这里的跳转指的是控制流而非顺序执行。Unit类也提供不同的方法来查询分支行为，如<code>fallsThrough()</code> 和 <code>branches()</code>. </p>
<ul>
<li><p>对于 <code>getDefBoxes()</code> 的解释</p>
<p>返回一个 valueBox 的列表，对应 unit（语句）中所有已被定义的变量</p>
</li>
<li><p><code>fallsThrough()</code></p>
<p>如果执行可以顺利流到紧挨着的下一条语句，就会返回True</p>
</li>
<li><p><code>branches()</code></p>
<p>如果执行可以继续流下去，但是并不会流到紧挨着的下一条语句，返回True</p>
</li>
<li><p><code>redirectJumpsToThisTo()</code></p>
<p>改变所有曾经指向这个Unit的跳转，让他们都指向这个新的<code>newLocation</code></p>
</li>
</ul>
<h5 id="Values"><a href="#Values" class="headerlink" title="Values"></a>Values</h5><p>Value表示一个数据。Value的表示可以是局部变量（<code>Local</code>），常量（<code>Jimple Constant</code>），表达式（<code>Jimple Expr</code>）等等.  Expr 表达式又拥有不同的实现，比如<code>BinopExpr</code> 和 <code>InvokeExpr</code>，通常可视为对一个或多个值执行某些操作并返回另一个值</p>
<p>其中一些常用的类型：</p>
<ul>
<li><p>Local </p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230219224911520.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230219224911520.png" alt="image-20230219224911520" style="zoom:80%;"></p>
</li>
<li><p>Constant </p>
<p><strong>StringConstant </strong>和 <strong>NumericConstant</strong></p>
</li>
</ul>
<p><strong>stmt 与 Expr 的区别：</strong></p>
<p>前者无返回值，后者有返回值</p>
<p>实现 stmt 接口：<code>AbstractStmt</code></p>
<p><code>AbstractStmt</code> 子类说明：</p>
<ul>
<li><p><code>AbstractDefinitionStmt</code></p>
<p>子类 1：<code>JAssignStmt</code></p>
<p>复制语句</p>
<p>子类2：<code>JIdentityStmt</code></p>
<p>显式或隐式赋值给变量</p>
<ol>
<li><p>函数传参</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">r1 := <span class="hljs-meta">@parameter0</span>: java.lang.String<br></code></pre></td></tr></table></figure>
</li>
<li><p>this 传参</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">r0 := <span class="hljs-meta">@this</span>: com.spring.Controller<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>两者区别：</strong></p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230219234245575.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230219234245575.png" alt="image-20230219234245575"></p>
</li>
<li><p><code>AbstractSwitchStmt</code></p>
<p>switch语句主要由于JVM对于不同的Switch语句，会生成不同的操作指令</p>
<p>子类1：<code>JLookupSwitchStmt</code></p>
<p>子类2：<code>JTableSwitchStmt</code></p>
</li>
<li><p><code>AbstractOpStmt</code></p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230219235251349.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230219235251349.png" alt="image-20230219235251349"></p>
</li>
</ul>
<p>表达式 Expr 部分</p>
<ul>
<li><p><code>AbstractInvokeExpr</code></p>
<p><strong>调用的表达式</strong></p>
<p>具体类型如下：</p>
<p>| 类型                | soot                     | 具体用途                                                     |<br>| :————————— | :———————————- | :—————————————————————————————- |<br>| <strong>invokestatic</strong>    | <strong>JStaticInvokeExpr</strong>    | 调用static静态方法                                           |<br>| <strong>invokevirtual</strong>   | <strong>JVirtualInvokeExpr</strong>   | 调用虚方法、final方法                                        |<br>| <strong>invokeinterface</strong> | <strong>JInterfaceInvokeExpr</strong> | 调用接口方法，在运行时搜索实现了这个方法的对象，进行合适的调用 |<br>| <strong>invokespecial</strong>   | <strong>JSpecialInvokeExpr</strong>   | 调用实例方法，init构造方法、private、父类方法                |<br>| <strong>invokedynamic</strong>   | <strong>JDynamicInvokeExpr</strong>   | 动态解析出需要调用的方法，然后执行 invoke lambda             |</p>
</li>
<li><p><code>AbstractBinopExpr</code></p>
<p>数学运算操作</p>
</li>
</ul>
<h5 id="References"><a href="#References" class="headerlink" title="References"></a>References</h5><p>当Unit包含另一个Unit的时候，需要通过Box来访问</p>
<p>引用在Soot中被称作 boxes，其中有两种不同的类型：</p>
<ul>
<li>UnitBoxes 针对Units类，当一个unit类存在多个后继时使用，比如分支语句的情况</li>
<li>ValueBoxes 针对Values类，如前所述,每个unit都有一个value使用和定义的标识，当替换成use或者def boxes在units中将会很有用，比如在执行常量传播时</li>
</ul>
<h5 id="3-Intermediate-Representations"><a href="#3-Intermediate-Representations" class="headerlink" title="3 Intermediate Representations"></a>3 Intermediate Representations</h5><p>Soot框架为代码提供了四种中间表示形式：Baf, Jimple, Shimple和Grimp. 这些表示针对不同的用途为代码提供了不同的抽象级别. 比如，baf是一种字节码标识，类似Java字节码；而Jimple是一个<strong>无堆栈的</strong>、<strong>类型化</strong>的3地址代码，适用于大多数分析。这节详细描述一下Jimple表示，简述一下其他几种</p>
<h5 id="3-1-Baf"><a href="#3-1-Baf" class="headerlink" title="3.1 Baf"></a>3.1 Baf</h5><p>Baf是一种基于堆栈的线性字节码表示。用于将Java字节码作为堆栈代码进行检查，但将<strong>常量池抽象</strong>出来，并将<strong>指令的类型相关变体</strong>抽象为单个指令（例如，在Java字节码中，有许多用于添加整数、长整数等的指令，在Baf中，它们都被抽象为单个加法指令）。Baf中的指令对应Soot的<code>Units</code>类，因此所有指令的实现都实现了<code>Inst</code>接口，后者又实现了<code>Unit</code>和<code>Switchable</code>接口。</p>
<p>Baf表示的实现存放在<code>soot.baf</code>和<code>soot.baf.internal</code>包中。</p>
<p>Baf对于基于字节码的分析、优化和转换（如peephole）非常有用</p>
<p>作为基于Baf表示的Soot框架的一部分提供的优化可以在<code>soot.baf.toolkits.base</code>包中找到</p>
<h5 id="3-2-Jimple"><a href="#3-2-Jimple" class="headerlink" title="3.2 Jimple"></a>3.2 Jimple</h5><p>Jimple是Soot中的主要表示。其是类型化的、3地址码的、基于语句的中间表示。</p>
<p>Jimple表示可以直接由Soot创建，或者基于Java源代码、字节码或者class文件创建。</p>
<p>从字节码到Jimple的转换通过从字节码到无类型Jimple的naive转换，具体通过为隐式堆栈位置引入新的局部变量并使用子例程移除JSR指令。从无类型的Jimple当中推断出<strong>局部变量的类型</strong>并添加进来。其还会清除Jimple代码中的冗余代码，如未使用的变量或赋值。转换到Jimple的一个重要步骤是表达式的<strong>线性化</strong>（和命名），使得一个语句最多只能引用3个局部变量或常数。从而为执行优化提供了更规则、更方便的表示。在Jimple表示下，分析只需要处理15种语句，而Java字节码中可能有200多种指令。</p>
<p>在Jimple中，语句对应Soot中的Units类并且可以如此使用。其拥有15种语句，<strong>核心</strong>的有：<code>NopStmt, IdentityStmt</code>  和 <code>AssignStmt</code>。<strong>过程内控制流语句</strong>有<code>IfStmt, GotoStmt, TableSwitchStmt(对应JVM的tableswitch指令)</code> 和 <code>LookupSwitchStmt(对应JVM的lookupswitch指令)</code>. <strong>过程间分析语句</strong>有<code>InvokeStmt, ReturnStmt,ReturnVoidStmt</code>. <strong>监控语句</strong>有<code>EnterMonitorStmt</code> 和 <code>ExitMonitorStmt</code>，最后两个是<code>ThrowStmt</code> 和 <code>RetStmt</code>(从JSR中返回，如果是从字节码中生成Jimple语句则不创建)</p>
<p>将下面的例子生成Jimple语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Foo</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">14</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (f.bar(<span class="hljs-number">21</span>) + a) * b;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bar</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> n + <span class="hljs-number">42</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>执行下列命令用于生成Jimple文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java -cp .\soot-<span class="hljs-number">4.4</span><span class="hljs-number">.0</span>-<span class="hljs-number">20220321.130129</span>-<span class="hljs-number">1</span>-jar-with-dependencies.jar soot.Main -pp -f J -cp .  Foo<br></code></pre></td></tr></table></figure>
<p>Jimple文件如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs jimple">public static void main(java.lang.String[])<br>  &#123;<br>      Foo f, temp$0;<br>      java.lang.String[] args;<br>      int a, b, x, temp$1, temp$2, temp$3, temp$4;<br><br>args := @parameter0: java.lang.String[];<br>temp$0 = new Foo;<br>specialinvoke temp$0.&lt;Foo: void &lt;init&gt;()&gt;();<br>f = temp$0;<br>a = 7;<br>b = 14;<br>// InvokeStmt<br>      temp$1 = virtualinvoke f.&lt;Foo: int bar(int)&gt;(21);<br>temp$2 = temp$1;<br>temp$3 = temp$2 + a;<br>temp$4 = temp$3 * b;<br>x = temp$4;<br>return;<br>  &#125;<br><br>  public int bar(int)<br>  &#123;<br>      Foo this;<br>      int n, temp$0, temp$1;<br>this := @this: Foo;<br>n := @parameter0: int;<br>temp$0 = n;<br>temp$1 = temp$0 + 42;<br>return temp$1;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>上述代码片段为main和bar方法生成的Jimple语句。Jimple是Java源代码和Java字节码的混合体。Jimple中拥有类似Java的语句结构那样的局部变量的声明和赋值，但是对于控制流和方法调用，风格又和Java字节码类似。以<script type="math/tex">`开头的局部变量表示堆栈位置，而不是原始程序中的局部变量，而不带`</script>的变量表示真实的局部变量。</p>
<p>线性化过程将语句<code>int x = (f.bar(21) + a) * b</code>分解成三地址码的形式<code>temp$3 = temp$2 + a;
        temp$4 = temp$3 * b;</code></p>
<p>在Jimple中，参数值和this引用使用<code>IdentityStmt</code>进行赋值，例如bar方法中的语句<code>n := @parameter0: int;</code>以及<code>this := @this: Foo;</code> 。通过使用<code>IdentityStmt</code>，确保所有局部变量至少有一个定义点，因此this变量在哪里被定义就很清晰了。</p>
<p>所有局部变量都是类型化的。在分析过程中使用类型信息很有帮助</p>
<p>请注意，Jimple不是Java源代码，特别是当您将Java源代码与生成的Jimple代码进行比较时，引入新的唯一变量可能会导致结果与预期之间的巨大差异</p>
<p>Jimple中间表示在以下依赖中提供<code>soot.jimple</code>和<code>soot.jimple.internal</code>，在<code>soot.jimple.toolkits.*</code>特别是 <code>soot.jimple.toolkits.scalar</code>和<code>soot.jimple.-
toolkits.annotation.*</code>中有很多优化的集合类可以使用</p>
<h5 id="3-3-Shimple"><a href="#3-3-Shimple" class="headerlink" title="3.3 Shimple"></a>3.3 Shimple</h5><p>Shimple中间表示是Jimple表示的<strong>静态单赋值形式</strong>，SSA-form保证每个局部变量都有<strong>一个静态定义点</strong>，这大大简化了许多分析。</p>
<p>除了单静态定义点和所谓的<code>phi-nodes</code>比较特殊，其他形式均与Jimple一样，因此两者几乎可以同等对待</p>
<p>下面实例类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShimpleExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">while</span> (as_long_as_it_takes) &#123;<br>            <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">200</span>) &#123;<br>                x = <span class="hljs-number">100</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                x = <span class="hljs-number">200</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>利用下面的指令生成Shimple文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java -cp .\soot-4.4.0-20220321.130129-1-jar-with-dependencies.jar soot.Main -pp -f S -cp . ShimpleExample<br></code></pre></td></tr></table></figure>
<p>(我自己生成的更复杂，先看paper上的样例)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Shimple">public int test() &#123;<br>	ShimpleExample r0;<br>	int i0, i0_1, i0_2, i0_3;<br>	boolean $z0;<br>	<br>	r0 := @this: ShimpleExample;<br>(0) i0 = 100;<br><br>label0:<br>	i0_1 = Phi(i0 #0, i0_2 #1, i0_3 #2);<br>	$z0 = r0.&lt;ShimpleExample: boolean as_long_as_it_takes&gt;;<br>	if $z0 == 0 goto label2;<br><br>	if i0_1 &gt;= 200 goto label1;<br><br>	i0_2 = 100;<br>(1) goto label0;<br><br>label1:<br>	i0_3 = 200;<br>(2) goto label0;<br><br>	label2:<br>		return i0_1;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>相比于Jimple结构，这里有两点不同。新引入的Phi-node以及i0变量被拆分成了4个变量<code>i0,i0_1,i0_2,i0_3</code></p>
<p>在SSA形式下，<code>i0_1</code>的值依赖于控制流图中涉及的路径，其与Phi-nodes相关。该值可能来自（0）、（1）或（2）。Phi-node可以被看作是一个函数，如果流从（0）到达则返回<code>i0</code>的值，如果流从（1）到达则返回<code>i0_2</code>的值，或者如果流从（2）到达则返回<code>i0_3</code>的值。</p>
<p>Simple对控制流进行了<strong>显式编码</strong>，因此可以方便地对Simple代码进行控制流敏感分析</p>
<p>实际上，在上面的示例中x是常量，因此<code>test</code>方法可以是常量传播并合并到单个return语句中，大多数控制结构都是不必要的</p>
<p>为了说明Shimple和Jimple表示之间的差异，我们基于每种表示优化程序并比较结果</p>
<p>Soot提供这样一种优化参数 <code>-O</code></p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230106232252628.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230106232252628.png" alt="image-20230106232252628"></p>
<p>在这里将会运行常量传播并作合并处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java -cp .\soot-4.4.0-20220321.130129-1-jar-with-dependencies.jar soot.Main -pp -f J -O -cp . ShimpleExample<br></code></pre></td></tr></table></figure>
<p>基于Jimple处理的结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public int test() &#123;<br>	ShimpleExample r0;<br>	int i0;<br>	boolean $z0;<br><br>	r0 := @this: ShimpleExample;<br>	i0 = 100;<br><br>label0:<br>	$z0 = r0.&lt;ShimpleExample: boolean as_long_as_it_takes&gt;;<br>	if $z0 == 0 goto label2;<br><br>	if i0 &gt;= 200 goto label1;<br><br>	i0 = 100;<br>	goto label0;<br><br>label1:<br>	i0 = 200;<br>	goto label0;<br><br>	label2:<br>		return i0;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这与我们之前看到的输出完全相同，即运行未经优化的Soot时的输出！基于Jimple表示，优化不能推导出x是常数</p>
<p>利用Shimple进行分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java -cp .\soot-4.4.0-20220321.130129-1-jar-with-dependencies.jar soot.Main -pp -f J -O -via-shimple -cp . ShimpleExample<br></code></pre></td></tr></table></figure>
<p>基于Shimple的结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public int test() &#123;<br>	ShimpleExample r0;<br>	boolean $z0;<br><br>	r0 := @this: ShimpleExample;<br><br>label0:<br>	$z0 = r0.&lt;ShimpleExample: boolean as_long_as_it_takes&gt;;<br>	if $z0 == 0 goto label1;<br><br>	goto label0;<br><br>label1:<br>	return 100;<br>&#125;<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230106233548096.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230106233548096.png" alt="image-20230106233548096"></p>
<p>这与预期一致。因为成员变量<code>as_long_as_it_takes</code>非静态的，因此还是得保留while循环，但是优化器推断出了x是个常量，因此phi-node在三个相同的值之间作了选择并且优化掉了。</p>
<p><strong>结论：Shimple显式地暴露了控制结构，并且变量只有静态的单个赋值</strong></p>
<p>Shimple中间表示可在依赖 <code>soot.shimple / soot.shimple.internal</code>，并且<code>soot.shimple.
toolkits.scalar</code>可以获得<code>constant-folder</code>（常量合并这个功能？）</p>
<h4 id="3-4-Grimp"><a href="#3-4-Grimp" class="headerlink" title="3.4 Grimp"></a>3.4 Grimp</h4><p>Grimp类似于Jimple，但允许表达式树与<code>New</code>操作符一起使用。在这方面，Grimp比Jimple更接近于Java源代码，因此更容易阅读，因此是人类读者检查反汇编代码的最佳中间表示</p>
<p>下面用指令运行一下Foo类的例子生成Grimp中间表示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java -cp .\soot-4.4.0-20220321.130129-1-jar-with-dependencies.jar soot.Main -pp -f G -cp . Fooxxxxxxxxxx c java -cp .\soot-4.4.0-20220321.130129-1-jar-with-dependencies.jar soot.Main -pp -f G -cp . Foo<br></code></pre></td></tr></table></figure>
<p>结果如下：</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230106234602432.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230106234602432.png" alt="image-20230106234602432"></p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230106234616066.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230106234616066.png" alt="image-20230106234616066"></p>
<p>这两个<code>main</code>方法之间(Jimple 和 Grimple生成的)有三个非常明显的区别</p>
<ol>
<li>表达式树未线性化</li>
<li>对象实例化和构造函数调用合并为new操作符</li>
<li>由于表达式树不是线性化的，所以不会创建新的临时局部变量（以$开头的局部变量），但是我们确实需要新的临时局部变量例如在while中</li>
</ol>
<p>Grimple表示适用于某些类型的分析，如available expressions（如果既需要复杂表达式，也需要简单表达式）。Grimp也是一个很好的反编译起点</p>
<p>Grimple中间表示位于依赖<code>soot.grimp / soot.grimp.internal</code>，一些优化可以在<code>soot.grimp.toolkits.base</code>中得到</p>
<h5 id="4-Soot-as-a-stand-alone-tool"><a href="#4-Soot-as-a-stand-alone-tool" class="headerlink" title="4 Soot as a stand-alone tool"></a>4 Soot as a stand-alone tool</h5><p>完整内容可在 <a target="_blank" rel="noopener" href="https://github.com/soot-oss/soot/wiki/Tutorials">https://github.com/soot-oss/soot/wiki/Tutorials</a></p>
<p>Soot可以作为一个独立的工具用于许多不同的目的，例如对代码做一些内置分析或转化。本节将介绍如何将Soot用作独立工具、如何根据其用途对选项进行分组，并详细介绍一些最常用的选项</p>
<p>如果类路径中包含Soot，则可以按如下所示从命令行调用Soot</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java [javaOptions] soot.Main [sootOptions] classname<br></code></pre></td></tr></table></figure>
<p>其中[sootOptions]表示Soot接受的各种选项，classname表示待分析的类</p>
<p>获取Soot支持的选项列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java soot.Main -h<br>java -jar  .\soot-4.4.0-20220321.130129-1-jar-with-dependencies.jar --help<br></code></pre></td></tr></table></figure>
<p><strong>类划分：</strong>在Soot中，我们区分三种类：参数类、应用程序类和库类</p>
<p>参数类是指定给Soot的类。使用命令行工具时，这些类是显式列出的类（直接给出的），也可以是在<code>-process-dir</code>选项指定的目录下的类</p>
<p>应用程序类是要由Soot分析或转换并转换为输出的类</p>
<p>库类相当于应用程序中所要依赖的类，会被用于分析和转换但本身不会转换输出</p>
<p>还有两种模式会影响类的分类方式：应用模式和非应用模式</p>
<p>在应用程序模式下，参数类引用的所有类除了JRK中的一些类之外本身也都是应用程序类。在非应用程序模式下，这些类将是库类</p>
<p>Soot提供了更多选项来偏向哪些类是应用程序模式下的应用程序类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">-i PKG -include PKG 		包中名称以PKG开始的类将被视为应用程序类<br>-x PKG, -exclude PKG 		包中名称以PKG开始的那些类将被视为库类<br>-include-all 			参数类引用的所有类都将被视为应用程序类<br><br>Soot提供几个选项来控制输入处理<br>Input options <br>-cp PATH, -soot-class-path PATH 	将PATH设置为搜索类的类路径<br>-process-dir DIR 	将DIR下的所有类设置为参数类<br>-src-prec FORMAT  设置要使用的源文件的优先级，格式如：c（或class）表示类文件（默认值）; J（或jimple）					 表示Jimple文件; java则表示java文件<br><br>Output options <br>-f J -f jimple      指定输出格式 （应用程序类默认输出格式为class文件）<br>-d DIR, -output-dir DIR 	指定用于存储输出文件的文件夹DIR（默认为sootOutput）<br>-outjar, -output-jar		将所有输出保存在JAR文件中，而不是目录中<br></code></pre></td></tr></table></figure>
<h5 id="4-1-Soot-phases"><a href="#4-1-Soot-phases" class="headerlink" title="4.1 Soot phases"></a>4.1 Soot phases</h5><p>Soot的执行分为几个阶段，称为 <strong>packs</strong>。第一步是生成Jimple代码，然后分配到不同包中，这是通过解析类、jimple或java文件，然后将其结果传递给 <code>jimpleBody（jb）</code>包来完成的。</p>
<p>包的命名格式很简单，第一个字母表示包接受哪个IR表示，比如s代表Shimple，j代表Jimple，b代表Baf，以及g代表Grimp。第二个字母指定包的职责，<strong>B用于方法体创建，t用于用户定义的转换，o用于优化，a用于属性生成（注释）</strong>，包名结尾的p代表“包” 。</p>
<p>允许用户定义转换的包如jtp（Jimple转换包）和stp（Shimple转环包）比较特殊。任何用户定义的转换（例如，来自分析的标记信息）都可以注入到这些包中，然后它们将包含在Soot的执行中</p>
<p>包的执行流图如下所示：（程序内分析）</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230107004202308.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230107004202308.png" alt="image-20230107004202308"></p>
<p>每个应用程序类都通过此执行流中的路径进行处理，但它们无权访问处理其他应用程序类时生成的任何信息</p>
<p>注意这里的 t 类似插件的作用，可以在其中执行自定义的转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">PackManager.v().getPack(<span class="hljs-string">&quot;jtp&quot;</span>).add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Transform</span>(<span class="hljs-string">&quot;jtp.myTransform&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BodyTransformer</span>()&#123;<br> <br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">internalTransform</span><span class="hljs-params">(Body b, String phaseName,</span><br><span class="hljs-params">			Map options)</span> &#123;<br>			<span class="hljs-comment">// TODO Auto-generated method stub</span><br>			...<br>			<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>程序间分析：</strong>对于过程间分析，执行流稍有不同。我们需要通过指定选项 <code>-w</code> 将Soot设置为<code>Whole-program</code>模式。在此模式下，Soot在执行周期中将包含三个其他程序包：cg（调用图生成）、wjtp（完整Jimple转换包）和wjap（完成Jimple注释包）。此外，为了添加整个程序优化（例如静态内联）功能，我们指定选项 <code>-W</code> 进一步向包中添加 wjop（完整Jimple优化包)。这些包与程序内分析使用的包之间的区别在于，这些包中生成的信息可通过<code>Scene</code> 供Soot的其余部分使用</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230107005146700.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230107005146700.png" alt="image-20230107005146700"></p>
<p><strong>Phase options:</strong></p>
<p>要生成Soot中所有可用包的列表，请执行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java soot.Main -pl<br></code></pre></td></tr></table></figure>
<p>此信息可用于获取有关不同包及其包含的操作（例如，内置分析）可用选项</p>
<p>要列出包的帮助信息和可用选项，可用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java soot.Main -ph PACK<br></code></pre></td></tr></table></figure>
<p>要为包设置选项，需要指定<code>-p</code>选项，后接包名和<code>OPT:VAL</code>形式的键值对。OPT是想设置的选项，VAL是对应的值。</p>
<h5 id="4-2-Off-The-Shelf-Analysis"><a href="#4-2-Off-The-Shelf-Analysis" class="headerlink" title="4.2 Off-The-Shelf Analysis"></a>4.2 Off-The-Shelf Analysis</h5><p>Soot包括几个示例分析来演示其功能</p>
<p><strong>Null Pointer Analysis</strong>：内置的空指针分析位于jap包中，并进一步分为两个单独的实体：空指针检查器和空指针着色器。前者查找有可能抛出NullPointerException的指令，而后者使用该信息为Eclipse插件添加标记信息，要运行空指针着色器以在程序中生成空值的可视化效果，可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java soot.Main -xml-attributes -f J -p jap.npcolorer on MyClass<br></code></pre></td></tr></table></figure>
<p>这将产生一个Jimple文件，当在Eclipse中查看此文件时，引用类型将根据其是否为null进行颜色编码（绿色表示肯定不为空，蓝色表示未知，红色表示肯定为空）</p>
<p><strong>Array Bounds Analysis</strong>：内置分析的另一个很好的例子是数组边界检查器，分析器会去检查数组是否越界。这种分析可以使编译器通过不在字节码中插入显式数组边界检查来达到优化效果。此分析也位于jap.abc下的jap包中。运行它以生成可视化效果的最简单方法是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java soot.Main -xml-attributes -f J -p jap.abc on -p jap.abc<br>add-color-tags:true MyClass<br></code></pre></td></tr></table></figure>
<p>分析结果说明了对于上界和下界，是否存在不安全的访问</p>
<p><strong>Liveness Analysis</strong>：内置的活动性分析会对语句中确定存在的变量进行着色。它只有一个选项，即是否启用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java soot.Main -xml-attributes -f J -p jap.lvtagger on MyClass<br></code></pre></td></tr></table></figure>
<p>结果指出了语句中的所有活跃变量</p>
<h5 id="4-3-Extending-Soot’s-Main-class"><a href="#4-3-Extending-Soot’s-Main-class" class="headerlink" title="4.3 Extending Soot’s Main class"></a>4.3 Extending Soot’s Main class</h5><p>设计和实现一个分析后，我们还希望能够从Soot中配合其他特征（比如内置分析）来使用。为此，我们需要扩展Soot的Main类以包含我们自己的分析。请注意，这不是Java意义上的扩展，而是一个中间步骤的注入，在这个步骤中，我们的分析被放入Soot。换句话说，我们希望Soot运行我们的分析，并且仍然处理我们传递给它的所有其他选项。</p>
<p>如何完成取决于注入的分析是否为程序间分析或程序内分析。前者需要注入到<code>wjtp</code>阶段，而后者进入<code>jtp</code>阶段。下面的代码示例演示如何将类<code>MyAnalysisTagger</code>（执行某些过程内分析）的实例注入到Soot中。</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109000305596.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109000305596.png" alt="image-20230109000305596"></p>
<h5 id="5-The-Data-Flow-Framework"><a href="#5-The-Data-Flow-Framework" class="headerlink" title="5 The Data-Flow Framework"></a>5 The Data-Flow Framework</h5><p>一般来说，我们可以将流分析设计为四个步骤：</p>
<ol>
<li>确定分析的性质。它是一个前向还是后向分析？我们是否需要特别考虑分支？</li>
<li>确定预期的approximation。这是一个may还是一个must的分析？实际上，这个在决定合并流经节点的信息时是并集还是交集</li>
<li>执行实际流，本质上是为中间表示中的每种语句编写等式，比如如何处理赋值语句</li>
<li>确定入口节点（如果是反向流，则为出口节点）和内部节点的初始状态或近似值，通常是空集empty或全集top，取决于分析的保守程度</li>
</ol>
<p>执行数据流分析时，我们需要某种结构来表示数据如何在程序中流动，例如控制流图（cfg）。Soot数据流框架旨在处理任何形式的cfg实现接口<code>soot.toolkits.graph.DirectedGraph</code></p>
<h5 id="5-1-Step-1-Nature-of-the-analysis"><a href="#5-1-Step-1-Nature-of-the-analysis" class="headerlink" title="5.1 Step 1: Nature of the analysis"></a>5.1 Step 1: Nature of the analysis</h5><p>Soot提供了三种不同的分析实现：<code>ForwardFlowAnalysis, BackwardFlowAnalysis</code> 和<code>ForwardBranchedFlowAnalysis</code>。前两个图除了流向不同外都是相同的，其结果是两个maps：节点到IN集合以及节点到OUT集合。最后一个分析实现提供通过分支节点的每个分支传播不同信息的能力，比如：从包含语句<code>if(x&gt;0)</code>的结点流出的信息，可以是<code>x&gt;0</code>到一个分支或者$x\leq 0$到另一个分支。因此，该分析的结果是三个maps：节点到IN集合、节点到满足fallthrough 的OUT集合以及节点到分支OUT集合。所有这些的实现基于了不动点原理的worklist算法。如果您想以其他方式实现它，可以扩展其中一个抽象超类：<code>AbstractFlowAnalysis (the top one), FlowAnalysis</code>或<code>BranchedFlowAnalysis</code>，否则，将特定分析插入框架的方法是<strong>扩展前三个类中的一个</strong></p>
<p>对于上述非常复杂的表达式的例子，我们需要使用反向分析，因此我们的类签名将是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class VeryBusyExpressionAnalysis extends BackwardFlowAnalysis<br></code></pre></td></tr></table></figure>
<p>现在，为了利用框架的功能，我们需要提供一个构造函数。在这个构造函数中，我们需要做两件事：</p>
<ol>
<li>调用父类构造函数</li>
<li>调用不动点机制实现分析</li>
</ol>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109002442100.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109002442100.png" alt="image-20230109002442100"></p>
<h5 id="5-2-Step-2-Approximation-level"><a href="#5-2-Step-2-Approximation-level" class="headerlink" title="5.2 Step 2: Approximation level"></a>5.2 Step 2: Approximation level</h5><p>分析的approximation程度取决于分析如何执行lattice元素的JOINs操作。通常分析要么是may analysis，要么是must analysis.。在may分析中，我们使用union连接元素，而在must分析中，我们使用intersection连接元素。在流分析框架中，连接是在merge方法中执行的。在非常复杂的表达式分析例子是must analysis，因此我们使用交集来连接：</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109002930043.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109002930043.png" alt="image-20230109002930043"></p>
<p>从这里可以看出，流分析框架被设计成具有这样的抽象，即它不关心如何表示格。这个例子中我们使用了<code>FlowSet</code>类。由于这种抽象，我们还需要提供一种将一个lattice的内容复制到另一个lattice的方法</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109110153394.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109110153394.png" alt="image-20230109110153394"></p>
<h5 id="5-3-Step-3-Performing-flow"><a href="#5-3-Step-3-Performing-flow" class="headerlink" title="5.3 Step 3: Performing flow"></a>5.3 Step 3: Performing flow</h5><p>这是分析的真实工作发生的地方，信息通过cfg中的节点流动。所涉及的框架方法是<code>flowThrough</code>，我们可以将此过程视为包含两个部分：</p>
<ol>
<li><p>我们需要将信息从IN集合复制到OUT集合，同时排除掉节点删除的信息</p>
</li>
<li><p>我们需要向节点生成的OUT集合添加信息</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109110702237.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109110702237.png" alt="image-20230109110702237"></p>
</li>
</ol>
<p>在表达式复杂的例子中，节点将删除那些引用的已经被定义过的<strong>表达式</strong></p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109112033223.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109112033223.png" alt="image-20230109112033223"></p>
<p>kill和gen方法不是框架的一部分，而是用户定义的方法。</p>
<h5 id="5-4-Step-4-Initial-state"><a href="#5-4-Step-4-Initial-state" class="headerlink" title="5.4 Step 4: Initial state"></a>5.4 Step 4: Initial state</h5><p>这一步包括决定入口点的lattice元素和其他lattice元素的初始内容，在流分析框架中，这是通过重写两个方法来实现的：<code>entryInitialFlow</code> 和<code>newInitialFlow</code>。对于复杂表达式分析的例子，入口点是最后一条语句（出口点），我们用空集初始化。至于其他格点，我们也用空集初始化。</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109112551714.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109112551714.png" alt="image-20230109112551714"></p>
<p>这里注意<code>ValueArraySparseSet</code>的构造是我们自己对于<code>ArraySparseSet</code>类的特殊化实现。</p>
<h5 id="5-5-Limitations"><a href="#5-5-Limitations" class="headerlink" title="5.5 Limitations"></a>5.5 Limitations</h5><p>对于像复杂表达式分析这样的例子，我们需要记住实际分析的是什么。在我们的例子中，我们正在分析Jimple代码，作为一个三地址代码，复合表达式将被分解为中间部分（比如 <code>a+b+c</code>将变为<code>temp = a+b</code>以及<code>temp + c</code>）。这使我们认识到，我们的特定分析如果没有修改，只能分析原始源代码中可能表达式的一小部分。在这种特殊情况下，我们可以分析Grimp代码，并特别考虑复合表达式。</p>
<h5 id="5-6-Flow-sets"><a href="#5-6-Flow-sets" class="headerlink" title="5.6 Flow sets"></a>5.6 Flow sets</h5><p>在 Soot中，flow sets (tai-e中叫 data-sets) 表示在控制流图中结点关联的数据（比如对于活跃表达式来说，结点的flow set就是一系列活跃的表达式）</p>
<p>flow set有两种不同的概念，有界（<code>BoundedFlowSet</code>接口）和无界（<code>FlowSet</code>接口），有界set是一个知道其可能值的全域的集合，无界set相反</p>
<p>实现FlowSet接口的类需要实现以下方法（以及其他方法）：</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109115928783.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109115928783.png" alt="image-20230109115928783"></p>
<p>这些操作足以使流集合成为有效的格元素。</p>
<p>另外当实现<code>BoundedFlowSet</code>时，需要提供生成该集合的补集以及top集</p>
<p>Soot提供了四种<code>flow sets</code>的四种实现：<code>ArraySparseSet</code>, <code>ArrayPackedSet</code> ,<code>ToppedSet</code>和<code>DavaFlowSet</code>。</p>
<p><strong>ArraySparseSet</strong> 是一个无界flow set，集合表示为引用数组。请注意，在比较元素是否相等时，它使用从Object继承的方法equals。这里的问题是soot元素（表示某些代码结构）不会重写此方法，相反，它们实现了接口<code>soot.EquivTo</code>。因此，如果您需要一个包含例如二元运算表达式的流集，您应该使用equivTo方法来比较是否相等</p>
<p><strong>ArrayPackedSet</strong> 是一个有界flow set，这里要求提供<code>FlowUniverse</code>对象，其只是某种集合或数组的包装，并且它应该包含可以放入集合中的<strong>所有可能值</strong>。集合由整数和对象之间的双向映射表示，以及指示<strong>全域的哪些元素包含在该集合内的位向量</strong>（如果设置了索引0处的位，则该集合包含整数0在映射中的元素）。这个实现同样也有<code>ArraySparseSet</code>关于元素相等的限制</p>
<p><strong>ToppedSet</strong>：包装另一个流集合（有界或无界），添加关于它是否是格的top集合的信息</p>
<p>在我们活跃表达式示例中，我们需要包含表达式的流集合，因此我们希望比较它们的等价性。a + B的两次不同出现将是实现<code>BinopExpr</code>接口的某个类的不同实例化，因此它们永远不会相等。为了解决这个问题，我们使用<code>ArraySparseSet</code>的修改版本，其中我们更改了<code>contains</code>方法的实现：</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109125110938.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109125110938.png" alt="image-20230109125110938"></p>
<h5 id="5-7-Control-flow-graphs"><a href="#5-7-Control-flow-graphs" class="headerlink" title="5.7 Control flow graphs"></a>5.7 Control flow graphs</h5><p>Soot在<code>soot.toolkits.graph</code>包中提供了几种不同的控制流图（CFG）。这些图的基础是接口 <code>DirectedGraph</code>。它定义了用于获取以下内容的方法：图的入口点和出口点、给定节点的后继节点和前驱节点、以某种未定义的顺序迭代图的迭代器以及图的大小（节点数）</p>
<p>这里给出 API</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230220233617787.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230220233617787.png" alt="image-20230220233617787"></p>
<p>我们将在这里描述的实现是表示CFG的实现，其中节点是Soot单元。此外，我们将只描述表示过程内分析流</p>
<p>这类图的基类是 <code>UnitGraph</code>，它是提供构建CFG工具的抽象类。它有三种不同的实现方式：<code>BriefUnitGraph</code>, <code>ExceptionalUnitGraph</code> 和 <code>TrapUnitGraph</code>.</p>
<p><strong>BriefUnitGraph</strong> 是非常简单的，因为它没有表示由于抛出异常而产生的控制流的边</p>
<p><strong>ExceptionalUnitGraph</strong> 包含从throw子句到其处理程序（catch块，在Soot中称为Trap）的边，前提是 trap 是方法体中的局部变量。此外，此图还考虑了j计算语句可能隐式抛出的异常（例如<code>ArrayIndexOutOfBoundsException</code>）. 对于每个可能抛出隐式异常的单元，从每个单元的<strong>前导到相应陷阱处理程序的第一个单元</strong>之间都有一条边。此外，如果异常单元包含副作用，则还将从异常单元向陷阱处理程序添加边（这里指的异常单元中出现异常的情况吧）。如果它没有副作用，则可以利用传递给图构造器之一的参数来选择性地添加或不添加该边，这是执行控制流分析时通常使用的CFG。</p>
<p><strong>TrapUnitGraph</strong> 类似 <code>ExceptionalUnitGraph</code>，也需要考虑抛出的异常。这里有三个主要区别：</p>
<ol>
<li>从每个 trap 单元添加边（即，在try块内）到陷阱处理程序</li>
<li>不存在可能向陷阱处理程序抛出隐式异常的单元的<strong>前趋项</strong>的边（除非它们也被陷阱捕获）</li>
<li>单元中总是有<strong>可能会向陷阱处理程序抛出隐式异常</strong>的一条边</li>
</ol>
<p>要为给定的方法体构建CFG，只需将方法体传递给CFG构造函数之一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">UnitGraph</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionalUnitGraph</span>(body);<br></code></pre></td></tr></table></figure>
<h5 id="5-8-Wrapping-the-results-of-the-analysis"><a href="#5-8-Wrapping-the-results-of-the-analysis" class="headerlink" title="5.8 Wrapping the results of the analysis"></a>5.8 Wrapping the results of the analysis</h5><p>特定分析的结果可通过 <code>AbstractFlowAnalysis#getFlowBefore</code> 方法，<code>FlowAnalysis#getFlowAfter</code>方法，<code>BranchedFlowAnalysis#getBranchFlowAfter</code>和<code>getFallFlowAfter</code>方法。这些方法都只是返回表示lattice元素的对象. 为了更加稳固，通过给分析提供一个接口，屏蔽掉结果？而返回一个以lattice作为元素的不可修改的列表。</p>
<p>对于活跃表达式分析示例，我们选择遵循内置Soot分析中使用的约定—提供通用接口及其一种可能的实现。接口非常简单，只是提供相关数据的访问器</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109153957662.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109153957662.png" alt="image-20230109153957662"></p>
<p>这个接口的实现（我们将其命名为SimpleVeryBusyExpressions）执行实际的分析，并将数据收集到它自己的maps中，内含单元映射到不可修改的表达式列表</p>
<p>下面实例如何手动运行活跃表达式分析：</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109154201035.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109154201035.png" alt="image-20230109154201035"></p>
<h5 id="6-Annotating-code"><a href="#6-Annotating-code" class="headerlink" title="6 Annotating code"></a>6 Annotating code</h5><p>Soot中的注释框架最初设计用于支持使用Java类文件属性优化Java程序，其思想是将信息标记到代码的相关位上，然后虚拟机可以使用这些标记来执行某些优化，比如排除不必要的数组边界检查。这个框架(位于<code>soot.tagkit</code>)由四个主要的概念：<code>Hosts</code>, <code>Tags</code>, <code>Attributes</code> 和 <code>TagAggregators</code></p>
<p><strong>Hosts</strong> 是可以保存和管理标记的任何对象，在 Soot中 <code>SootClass,SootField, SootMethod, Body, Unit, Value</code> 和 <code>ValueBox</code>均实现了这个接口</p>
<p><strong>Tags</strong> 是可以标记到hosts的任何对象，这是将名称-值对连接到hosts的一种非常通用的机制</p>
<p><strong>Attributes</strong> 是标记概念的扩展。任何属性都可以输出到类文件中，特别是任何对类、字段、方法或主体的标记都应该实现此接口。属性应该映射到类文件属性中，并且因为Soot使用一个名为<code>Jasmin</code>的工具来输出字节码，所以任何应该输出到类文件的内容都必须继承<code>JasminAttribute</code>,Soot中的一个此类实现是<code>CodeAttribute</code></p>
<p><strong>TagAggregators</strong> 是<code>BodyTransformers</code>（参见第6.1节），它收集某种类型的标记，并生成一个新的属性以输出到类文件。聚合器必须决定在哪里标记相关信息—例如，一个单元可能被转换成几个字节码指令，因此聚合器必须决定该单元上的注释应该引用哪一个。Soot为其内置标记提供了几个聚合器—比如<code>FirstTagAggregator</code>将标记与用其标记的第一条指令相关联. 一般来说，如果我们只使用内置标签，就不需要关注聚合器</p>
<h5 id="6-1-Transformers"><a href="#6-1-Transformers" class="headerlink" title="6.1 Transformers"></a>6.1 Transformers</h5><p>Transformers实际上并不是标记框架的一部分，但用于注释代码。一般来说，Transformers是将某个代码块转换为另一个代码块的对象。在Soot中有两种不同的Transformers：<code>BodyTransformers</code> 和 <code>SceneTransformer</code> 。它们被分别设计为在单个方法体上（即过程内）和整个应用（即过程间）作transformations。要实现一个transformer，需要继承其中一个上述的Transformers并提供<code>internalTransform</code>方法的实现</p>
<p>一个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java">PackManager.v().getPack(<span class="hljs-string">&quot;jtp&quot;</span>).add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Transform</span>(<span class="hljs-string">&quot;jtp.myAnalysis&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyAnalysis</span>()));<br>PackManager.v().runPacks();<br>System.out.println(Scene.v().getCallGraph().size());<br>PackManager.v().writeOutput();<br><br><br><br><span class="hljs-comment">//MyAnalysis.java文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAnalysis</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BodyTransformer</span>&#123;<br><br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">internalTransform</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Body body,String phase, <span class="hljs-meta">@SuppressWarnings(&quot;rawtypes&quot;)</span>Map options)</span>&#123;      <br>      <span class="hljs-keyword">for</span> (SootClass c:Scene.v().getApplicationClasses()) &#123;<br>          System.out.println(<span class="hljs-string">&quot;[sootClass]&quot;</span>+c);<br>        <span class="hljs-keyword">for</span>(SootMethod m:c.getMethods())<br>        &#123;<br>              System.out.println(<span class="hljs-string">&quot;[sootMethod]&quot;</span>+m);<br><br>            <span class="hljs-keyword">if</span>(m.isConcrete())<br>            &#123;<br>                Body b=m.retrieveActiveBody();<br>                  System.out.println(<span class="hljs-string">&quot;[body]&quot;</span>+b);<br><br>                Iterator&lt;Unit&gt; i=b.getUnits().snapshotIterator();<br>                <span class="hljs-keyword">while</span>(i.hasNext())<br>                &#123;<br>                    Unit u=i.next();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="6-2-Annotating-very-busy-expressions"><a href="#6-2-Annotating-very-busy-expressions" class="headerlink" title="6.2 Annotating very-busy expressions"></a>6.2 Annotating very-busy expressions</h5><p>让我们看看如何使用这种标记机制将运行活跃表达式分析的结果可视化地传达给用户。由于我们的示例是过程内分析，为了使用结果标记代码，我们继承BodyTransformer并实现了它的internalTransform方法。我们要做的就是为每个流出活跃表达式的单元作<code>StringTags</code>标记。此外，我们还希望对持续保持活跃的表达式作<code>ColorTag</code>标记。有了这些信息，用户可以很容易地看到活跃表达式通过他的方法，并快速识别到哪里可以优化。此过程的伪代码如下所示（有关完整详细信息，请参阅示例源代码）：</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109161736171.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230109161736171.png" alt="image-20230109161736171"></p>
<p>为了将分析插入到Soot中，我们重写Soot的<code>Main</code>类，将我们的标签插入到Jimple转换包中（如第4节所述）。</p>
<h5 id="7-Call-Graph-Construction"><a href="#7-Call-Graph-Construction" class="headerlink" title="7 Call Graph Construction"></a>7 Call Graph Construction</h5><p><strong>CallGraph构建</strong></p>
<p><strong>前提：开启全局模式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Options.v().set_whole_program(<span class="hljs-literal">true</span>);<br>PackManager.v().runPacks();<br></code></pre></td></tr></table></figure>
<p>在执行过程间分析时，应用程序的调用图是一个基本实体. 调用图可用时(仅在whole-program 模式)，它可以通过环境类（<code>Scene</code>）使用<code>getCallGraph</code>方法进行访问。CallGraph类和其他相关的构造类位于<code>soot.jimple.toolkits.callgraph</code>包中。最简单的调用图是通过 <strong>类层次分析（CHA）</strong>获得的，不需要进行设置。CHA很简单，因为它假设所有引用变量都可以指向正确类型的对象。以下是使用CHA获取调用图的示例：</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230111232854697.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230111232854697.png" alt="image-20230111232854697"></p>
<h5 id="7-1-Call-Graph-Representation"><a href="#7-1-Call-Graph-Representation" class="headerlink" title="7.1 Call Graph Representation"></a>7.1 Call Graph Representation</h5><p>Soot中的调用图是表示所有<strong>已知方法调用边</strong>的集合，这里包括：</p>
<ul>
<li>显式方法调用</li>
<li>静态初始值的隐式调用</li>
<li><code>Thread.run()</code>的隐式调用</li>
<li>常量类对象的隐式调用</li>
<li>AccessController的隐式调用</li>
</ul>
<p>调用图中的每条边包含四个元素：源方法、源语句（如果适用）、目标方法和边的类型。不同种类的边例如用于静态调用、虚拟调用和接口调用。</p>
<p>调用图具有查询进入函数边的方法，出函数边的方法以及来自特定语句的边的方法（分别对应<code>edgesInto(method), edgesOutOf(method), edgesOutOf(statement)</code>）。每一种方法都返回一个基于构建边的迭代器。Soot提供了三个所谓的适配器，用于在边的特定位置上迭代：</p>
<ul>
<li><p>Sources 迭代源方法边</p>
</li>
<li><p>Units 迭代源语句边</p>
</li>
<li><p>Targets 迭代目标方法边</p>
<p>因此，为了遍历特定方法的所有可能调用它的方法，可以：</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230111235614552.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230111235614552.png" alt="image-20230111235614552"></p>
</li>
</ul>
<h5 id="7-2-More-specific-information"><a href="#7-2-More-specific-information" class="headerlink" title="7.2 More specific information"></a>7.2 More specific information</h5><p>Soot还提供了另外两种构建，以更详细的方式查询调用图：<code>ReachableMethods</code>和<code>TransitiveTargets</code></p>
<ul>
<li><strong>ReachableMethods</strong>：此对象跟踪哪些方法可从入口点访问，其中<code>contains(method)</code>测试指定方法是否可达，<code>listener()</code>方法返回一个迭代器遍历所有可访问的方法</li>
<li><strong>TransitiveTargets</strong>：对于迭代所有从特定方法调用的函数或者其调用的其他函数（遍历调用链）是很有用的，构造函数接收（除了调用图之外）一个可选的过滤器参数<code>Filter</code>，过滤器表示调用图中满足给定<code>EdgePredicate</code>（一个简单接口，有两个具体实现：<code>ExplicitEdgesPred</code>与<code>InstanceInvokeEdgesPred</code>）谓词的边集合</li>
</ul>
<h5 id="8-Points-To-Analysis"><a href="#8-Points-To-Analysis" class="headerlink" title="8 Points-To Analysis"></a>8 Points-To Analysis</h5><p>在本节中，我们将介绍在Soot中进行指针分析的两个框架：<code>SPARK</code>和<code>Paddle</code>框架</p>
<p>指针分析的目标是计算一个函数，该函数在给定变量的情况下返回可能的目标集，为了进行许多其它种类的分析，如别名分析，或者为了提高例如调用图的精度，从指向分析得到的集合是很有用的。</p>
<p>Soot提供了<code>PointsToAnalysis</code>和<code>PointsToSet</code>接口，任何指针分析都应该实现这些接口。<code>PointsToAnalysis</code>接口包含<code>reachingObjects（Local l）</code>方法，该方法将<code>l</code>所指向的对象集作为<code>PointsToSet</code>返回。<code>PointsToSet</code>包含用于测试与其他<code>PointsToSet</code>的<strong>非空交集</strong>的方法，以及一个用于返回集合中对象的所有<strong>可能运行时类型</strong>的集合的方法。这些方法对于实现别名分析和virtual method调度非常有用。当前的 points-to 集合可以通过<code>Scene.v().getPointsToAnalysis()</code>方法获得。至于如何创建取决于所使用的接口实现。</p>
<p>Soot提供了<code>points-to</code>接口的三种实现：CHA（dumb版本）、SPARK和Paddle。dumb版本只是假设每个变量都可能指向其他变量，这是保守合理的，但不是非常准确。然而，dump版的指针分析实现可能具有一些价值，例如创建不精确的调用图，该调用图可以用作例如指针分析的起始点，从该点分析可以构造更精确的调用图</p>
<p>SPARK和Paddle框架以更复杂的设置和速度为代价提供更准确的分析，这两种算法都是基于子集的，如Anderson算法，而不是基于等价的Steensgaard算法。</p>
<h5 id="8-1-SPARK"><a href="#8-1-SPARK" class="headerlink" title="8.1 SPARK"></a>8.1 SPARK</h5><p>SPARK是一个用于在Java中试验指向分析的框架，它支持基于子集和基于等价的指向分析，以及介于两者之间的任何分析。SPARK是非常模块化的，这使得它非常适合于对不同的技术进行基准测试，以实现指针分析的各个部分。</p>
<p>在本节中，我们将展示如何使用SPARK来设置和试验SPARK提供的基本指针分析。</p>
<p>SPARK作为Soot框架的一部分提供，位于<code>soot.jimple.spark中。*</code>包中。作为SPARK的一部分，提供了一个指针分析，并且可以使用选项控制分析的细节。例如，传播算法可以是一个简单的迭代算法，也可以是一个更有效的worklist算法。</p>
<h5 id="Using-SPARK"><a href="#Using-SPARK" class="headerlink" title="Using SPARK"></a>Using SPARK</h5><p>SPARK强大的模块性提供了一组丰富的选项，使得为任何对象设置SPARK都变得不那么容易。为了能够使用SPARK，我们建议使用Eclipse从示例源代码加载示例代码，或者创建一个新项目并将<code>Jasmin</code>、<code>Polyglot</code>和<code>Soot jar</code>文件添加到类路径中，在设置运行配置时，应该向JVM添加参数<code>-Xmx512m</code>来增加虚拟内存。</p>
<p>接下来介绍一下待分析的实例方法，方法用到了<code>Container</code>类和它的内部类<code>Item</code>。Container类有一个私有属性和一对get/set方法，Item类有一个object类型的私有属性data。</p>
<p><code>go</code>方法创建了两个Container类实例，并分别设置了<code>Item</code>类实例属性。此外第三个<code>Container</code>对象声明并被第二个<code>Container</code>对象的引用所赋值。</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230112182359252.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230112182359252.png" alt="image-20230112182359252"></p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230112181614666.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230112181614666.png" alt="image-20230112181614666"></p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230112181624821.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230112181624821.png" alt="image-20230112181624821"></p>
<p>我们希望在此示例上运行SPARK，并期望它发现c1的指针集不与c2或c3的指针集相交，而c2和c3应该共享相同的指针集。此外，我们期望在（1）和（2）处分配的<code>Container</code>对象的<code>Item</code>字段指向不同的对象<code>i1</code>和<code>i2</code>（上下文敏感）</p>
<p>要运行SPARK，我们设置<code>Soot Scene</code>以加载<code>Container</code>和I<code>tem</code>类以及包含go方法的类。使用<code>Scene.v().loadClassAndSupport(name);</code> 和<code>c.setApplicationClass();</code></p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230112182957396.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230112182957396.png" alt="image-20230112182957396"></p>
<p>设置SPARK的代码如下，其中我们列出了最有趣的选项，并展示了如何使用<code>SparkTransformer</code>类的<code>transform</code>方法，将选项maps作为参数来运行SPARK分析</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230112183123556.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230112183123556.png" alt="image-20230112183123556"></p>
<p>参数信息如下：</p>
<ul>
<li><strong>verbose</strong> SPARK分析时输出日志信息</li>
<li><strong>propagator</strong> SPARK支持两种指针集传播算法，一种简单的迭代算法和一种更有效的基于worklist的算法</li>
<li><strong>simple-edges-bidirectional</strong> 如果为真，此选项将使所有边双向，从而允许基于等效的指针分析，如<code>Steensgaard</code>算法</li>
<li><strong>on-fly-cg</strong> 如果调用图是即时创建的，这通常给出更精确的分析点和生成的调用图</li>
<li><strong>set-impl</strong> 描述了指针集的实现，可能的值为散列、位、混合、数组和Double。散列的实现基于Java hash set。位是使用位向量实现的。Hybrid是一个集合，它保存最多16个元素的显式列表，并在集合变大时切换为位向量。数组是使用始终保持排序顺序的数组实现的。Double使用两个集合实现，一个用于尚未传播的新指向对象集合，另一个用于已传播且需要重新考虑的旧指向对象集合。</li>
<li><strong>double-set-old</strong> 和 <strong>double-set-new</strong> 描述了double实现中新的和旧的指向对象集的实现，并且<code>double-set-old</code>和<code>double-set-new</code>仅在double是<code>set-impl</code>的值时有效</li>
</ul>
<p>使用示例代码运行SPARK，得到的输出如下所示：</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230112204428831.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230112204428831.png" alt="image-20230112204428831"></p>
<p>左列中的数字表示变量初始化点，比如<code>[4,8] Container intersect? false</code> 指的是在第4行初始化的变量c1和在第8行初始化的变量c2。右列说明两个变量的指向集是否有空交集（true表示有）</p>
<p>首先，作为一个简单的一致性检查，我们看到每个变量都有一个指针集-与自身的交集，正如预期的那样，指向变量集c1和c2以及c1和c3的指针集不相交，而c2和c3的指向集合相交。</p>
<p>至于item字段，我们看到所有指向集合都彼此相交，即使它们属于不同的<code>Container</code>对象。结果与我们的期望之间的这种不匹配的原因是我们期望中的错误。我们希望SPARK能够区分两次<code>setItem</code>调用，但是SPARK对上下文不敏感，因此只分析一次setItem方法，并合并每次调用setItem方法时的指向集。</p>
<p>SPARK是一个大而健壮的框架，用于试验<strong>上下文不敏感</strong>指向分析的许多不同方面。我们只介绍了许多选项中的一小部分，还有更多的组合可用，您应该使用源代码示例来熟悉SPARK，并尝试一些此处未介绍的其他选项组合。</p>
<h5 id="8-2-Paddle"><a href="#8-2-Paddle" class="headerlink" title="8.2 Paddle"></a>8.2 Paddle</h5><p>Paddle是Soot的上下文敏感指向分析和调用图构造框架，使用二元决策图（BDD）实现。Paddle在上下文不敏感分析中的准确度与SPARK相当，但当前的实现非常缓慢，主要是由于组成实现的不同程序的拼凑在上下文敏感分析中也提供了非常好的准确度。BDD的使用保证了时间和空间方面的效率，特别是在大型程序上。因为BDD提供了比SPARK和其他框架中更紧凑的集合表示，<strong>当前的实现非常缓慢，主要是由于组成实现的不同程序的拼凑</strong></p>
<p><strong>Obtaining and setup of Paddle</strong></p>
<p>Paddle前端沿着Soot框架分发，为了避免在编译Soot时需要<strong>Jedd</strong>，“后端”是单独分发的。Paddle需要<code>BDD</code>实现和<code>Jedd</code>运行时环境才能运行，而这又需要<code>Polyglot</code>和<code>SAT</code>求解器。Jedd运行时提供了两个BDD实现：<code>BuDDy</code>（缺省）和<code>CUDD BDD</code>实现；也可以使用其他BDD实现，如<code>JavaBDD</code>和<code>SableJBDD</code></p>
<p>所有这些条件使得正确安装Paddle比较复杂，所以我们现在给予了一个彻底的展示如何安装Paddle</p>
<ol>
<li>下载最新的Paddle发行版，您应该使用夜间版本获取最新的更新和错误修复，夜间构建可从以下位置获得<a target="_blank" rel="noopener" href="http://www.sable.mcgill.ca/~olhota/build/">http://www.sable.mcgill.ca/~olhota/build/</a> </li>
<li>下载<code>zChaf SAT</code>解算器 <a target="_blank" rel="noopener" href="http://www.princeton.edu/~chaff/zchaff.html">http://www.princeton.edu/~chaff/zchaff.html</a> ，通过<code>make all</code>安装，确保程序<code>zchaff</code>和<code>zverify df</code>可由您执行</li>
</ol>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230112214123246.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230112214123246.png" alt="image-20230112214123246"></p>
<h5 id="Using-Paddle"><a href="#Using-Paddle" class="headerlink" title="Using Paddle"></a>Using Paddle</h5><p>Paddle是一个用于上下文敏感指针分析的模块化框架，它允许对分析的各个组件进行基准测试，比如以上下文敏感的变化进行基准测试，使其成为一个非常有趣的工具。Paddle也是一种早期α-release，因此请注意Paddle的稳健性较差。</p>
<p>Paddle配备了大量选项，可根据您的特定需求配置分析。使用Soot命令行工具可以获得选项的完整说明，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java soot.Main -phase-help cg.paddle<br></code></pre></td></tr></table></figure>
<p>Paddle选项的指定类似于SPARK中使用选项名称和值的map，选项<code>verbose</code>、<code>set-impl</code>、<code>double-set-new</code>和<code>double-set-old</code>与SPARK中的相同。<code>q</code>选项确定队列的实现方式，并且<code>enabled</code>必须为<code>true</code>才能运行分析。<code>propagator</code>控制在将指针集进行传播时使用哪种传播算法，我们将其留给Paddle来选择并设置为<code>auto</code>。<code>conf</code>控制是即时还是提前创建调用图。Paddle的实现是基于子集的，但可通过将<code>simple-edges-bidirectional</code>选项设置为<code>true</code>来模拟基于等效的分析。最后四个选项是最重要的，所以我们描述一些细节：</p>
<ul>
<li><strong>bdd</strong>：控制BDD是否启用</li>
<li><strong>backend：</strong>控制BDD后端选项 (BuDDy), cudd (CUDD), sable (SableJBDD), javabdd(JavaBDD) or none</li>
<li><strong>context：</strong>控制分析中使用的上下文敏感程度。如果值设置为<code>insens</code>，则它的执行与SPARK框架执行上下文不敏感分析一样。1cfa Paddle执行1-cfa上下文相关分析。kcfa Paddle k-cfa执行上下文相关的，其中k是使用k选项指定的(这里的k应该指的是上下文调用深度)。<code>objsens</code>和<code>kobjsens</code>使Paddle分别执行<code>1-object-sensitive</code>分析和<code>k-object-sensitive</code>敏感分析。<code>uniqkobjsens</code>使Paddle执行<code>unique-k-object-sensitive</code>分析。默认为<code>insens</code></li>
<li><strong>k</strong> k选项指定用作上下文的调用链或<code>receiver Object</code>的最大长度当上下文选项的值是<code>kcfa</code>、<code>kobjsens</code>或<code>uniqkobjsens</code>之一时</li>
</ul>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230116225115072.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230116225115072.png" alt="image-20230116225115072"></p>
<p>k-CFA上下文敏感分析基于作为上下文的调用点串，并且k描述的是调用串的最大长度。正常情况下调用点敏感分析运行良好，但如果添加了额外的间接层，例如同样的函数在<code>setItem()</code>方法中调用了，则仅依赖于调用点的上下文敏感分析将会合并对setItem方法的两个调用的 points-to-sets 集合，因为他们对同样的函数调用点一样。例如如下这种情况：</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230116224816633.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230116224816633.png" alt="image-20230116224816633"></p>
<p>通过使用一串调用点，我们能够区分对相同函数的两个调用，从而使 points-to-sets 集保持分离。程序中的调用链长度可以是任意大的，因此我们需要将长度固定为k —因此使用了 k-cfa</p>
<p>下面测试一下利用 Paddle 的上下文敏感分析是否能推断出作为第4行声明的Container变量创建的item字段不与任何其他item字段共享 points-to 集。当设置选项为 1-cfa 时，Container.item变量的信息也与SPARK示例相同，这不是我们所期望的。</p>
<p>出现此意外行为的原因是以下行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">private Item item = new Item();<br></code></pre></td></tr></table></figure>
<p>这条语句位于 Container 类中，Paddle默认不使用上下文敏感的堆抽象，因此每个容器对象的item字段都使用相同的堆抽象表示的。如果我们将这行语句改成<code>private Item item;</code> 则容器的item字段不指向同一个抽象对象，并且在新的Container类上运行Paddle会产生预期的结果(如下所示)</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230116230810507.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230116230810507.png" alt="image-20230116230810507"></p>
<p>获得正确结果的另一种方法是启动上下文相关的堆抽象选项 <code>opt.put(&quot;context-heap&quot;,&quot;true&quot;);</code> 这使得 Paddle 能够区分分配给不同 Container 类的 Items 字段。</p>
<h5 id="8-3-What-to-do-with-the-points-to-sets"><a href="#8-3-What-to-do-with-the-points-to-sets" class="headerlink" title="8.3 What to do with the points-to sets?"></a>8.3 What to do with the points-to sets?</h5><p>在最后两个小节中，我们详细描述了如何使用SPARK和Paddle指向分析框架，通过上下文不敏感或上下文敏感分析获得给定程序中变量的指向集。我们看到设置这两个框架相当复杂，因此这里需要阐明一下原因。</p>
<p>为了在许多分析和变换中获得精度，指向（或别名）信息是必需的。例如，精确的指向分析可用于获得精确的空指针分析结果或更精确的调用图，这又可导致其它分析中的更精确。精确的指向信息对于以下各项的准确性也至关重要，比如命令式和面向对象语言的部分求值。</p>
<h5 id="9-Extracting-Abstract-Control-Flow-Graphs"><a href="#9-Extracting-Abstract-Control-Flow-Graphs" class="headerlink" title="9 Extracting Abstract Control-Flow Graphs !!"></a>9 Extracting Abstract Control-Flow Graphs !!</h5><p>在本节中，我们将展示如何使用Soot提取抽象控制流图的自定义中间表示IR，该中间表示可用作您自己的分析和转换的起点</p>
<p>抽象控制流图捕获控制流的相关部分，并抽象掉不相关的部分。为了获得易于处理但又足够的表示来实施分析，通常需要去除不相关的部分。</p>
<p>一个很好的例子是Java字符串分析（JSA），其中跟踪和分析了Java字符串上的各种操作，如拼接。在 JSA 中，只有与控制流相关的字符串是待分析的部分，因此，在抽象期间控制流的其他部分被移除。同时分析基于抽象表示。</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230116235220548.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230116235220548.png" alt="image-20230116235220548"></p>
<p>我们将使用上图所示的Foo类，它有一个操作对象状态的方法foo方法（可以是java.lang.String 的连接方法）。我们希望能够跟踪Foo对象在程序执行过程中是如何演变的，因此我们需要一个抽象的控制流图，它只关心与Foo对象有关的控制流部分。</p>
<h5 id="9-1-The-Abstract-Foo-Control-flow-Graph"><a href="#9-1-The-Abstract-Foo-Control-flow-Graph" class="headerlink" title="9.1 The Abstract Foo Control-flow Graph"></a>9.1 The Abstract Foo Control-flow Graph</h5><p>抽象Foo控制流图是对与Foo程序相关的控制流的描述。我们将控制流图表示为Java的一个非常小的子集，称之为Foo中间表示，如下图中的BNF所述。Foo中间表示仅包含六种不同的语句和三种类型，因此非常紧凑和易于管理。Foo 程序的中间表示是由一系列方法构成，其中包含图示中由 BNF 描述的语句，其中f的范围是<strong>Foo类型的标识符</strong>，m的范围是<strong>方法名</strong>，int是Java<strong>整数类型</strong>，τ是<strong>Foo类型或任何其他类型</strong>。</p>
<p class='item-img' data-src='/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230116235604762.png'><img src="/2023/01/17/Soot%E5%AD%A6%E4%B9%A0/image-20230116235604762.png" alt="image-20230116235604762"></p>
<p>这六种语句为：Foo对象的初始化、对Foo类的foo方法的方法调用、调用其他方法并返回其他类型、方法调用foo以外的其他方法，返回类型等于Foo，最后是 nop 语句。</p>
<p>图中可以看到语句与执行行为的映射，与预期一致。Foo对象的实例化映射到Foo初始化。对foo方法的方法调用映射到Foo方法调用，Foo类型的赋值语句转换为Foo赋值语句。foo方法以外的方法调用分别转换为具有或不具有Foo返回类型的方法调用。在中间表示中，<strong>我们将非Foo对象实例化视为某个方法调用</strong>，它恰好是对构造函数方法的调用，我们将<strong>对Foo的强制转换视为某个方法调用，Foo作为返回类型</strong>。为了简洁起见，我们完全忽略了控制结构和异常，任何基于这种抽象表示的分析对于抛出异常的程序都是非sound的，因为异常可能会影响Foo对象的值</p>
<h5 id="9-2-Implementation"><a href="#9-2-Implementation" class="headerlink" title="9.2 Implementation"></a>9.2 Implementation</h5><p>实现从Java到Foo中间表示的转换包括两个步骤：首先实现Foo中间表示，然后实现Java和中间表示之间的转换。</p>
<p>Foo中间表示的实现非常直接，每种语句都继承了Statement类，该类提供了成为控制流图中的节点所需的一些常规功能，比如：存储前导语句和后继语句的集合。</p>
<p>代码被组织在 <code>dk.brics.soot.intermediate</code> 包的五个子包中。main子包包含主程序（Main.java），它使用转换来显示 foo 子包中的测试程序 FooTest.java 抽象控制流图的文本表示，这将作为运行或检查代码时的起点。在foo子包中，可以找到如上所述的Foo类。在表示子包中，可以找到中间表示的实现以及一些用于变量和方法的附加类。此外，还提供了一个访问者（StatementProcessor.java）来遍历语句（访问者模式）。在子包 foonalasys 中，可以找到类Foonalasys，它是基于中间表示上执行分析的表示，因此 Foonalasys 首先需要实例化并运行从Java到Foo中间表示的转换。 translation 类位于 <code>translation</code> 子包中。在这里，您将找到负责translation 的三个类：<code>JavaTranslator</code>, <code>StmtTranslator</code>, and <code>ExprTranslator</code>。</p>
<p>从 Java 的转换是通过 Jimple 完成的，因此转换需要理解清 Jimple 以及各种 Java 构造是如何映射到 Jimple 的，以便在从 Jimple 转换到 Foo 中间表示时识别它们。比如对象创建和初始化是在Java中的一个 new 表达式中完成的，但是在 Jimple 中已经像在Java字节码那样被分离成了两个构造，因此在从Jimple到Foo中间表示的转换中必须小心处理这一点。</p>
<p>Soot为 translation 提供了基础架构，特别是 <code>AbstractStmtSwitch</code> 和<code>soot.jimple.AbstractJimpleValueSwitch</code> 类非常有用。AbstractStmtSwitch 是一个抽象访问器，它为 Java（Soot）中可用的不同类型的语句提供方法（操作）。类似地，soot.jimple.AbstractJimpleValueSwitch 是一个抽象访问器，它为不同的 Jimple 值（如virtualInvoke、specialInvoke 和 add 表达式）提供方法（操作）。</p>
<p>translation 由三个类来实现：<code>JavaTranslator</code>、<code>StmtTranslator</code> 和 <code>ExprTranslator</code>。JavaTranslator 类负责翻译给定 Java 程序的各种方法，并将翻译后的语句连接在一起。JavaTranslator维护一个在 makeMethod 方法中初始化的方法数组。translate方法主要来完成实际翻译和已翻译语句的链接。</p>
<p>使用继承 AbstractStmtSwitch 类的 StmtTranslator 类转换各个语句。根据我们的经验，我们在StmtTranslator中使用的子集应该足以满足大多数用途。StmtTranslator的主要方法是<code>translateStmt</code> 方法，它将 StmtTranslator 应用于语句，并维护从 Soot 语句到 Foo 表示中相应代码的<strong>第一个语句</strong>的映射。这个 map 便于报告错误。此外，StmtTranslator还有一个方法<code>addStatement</code>，它将给定的 Foo 语句添加到正确的方法中，并维护对第一个语句的引用。addStatement 方法用于在翻译期间添加语句。</p>
<p>子表达式使用 ExprTranslator 进行转换，ExprTranslator 是<code>soot.jimple.AbstractJimpleValueSwitch</code> 类的扩展，因此会覆盖许多方法以实现转换。入口点是 translateExpr 方法，该方法基本上将 ExprTranslator 应用于给定的 <code>ValueBox</code>。我们只实现了运行示例所需的方法，因为我们的目标只是介绍如何创建抽象控制流图。指的注意的方法是caseSpecialInvokeExpr 和 handleCall 方法。caseSpecialInvokeExpr 方法检验我们是否正在处理 Foo 对象的初始化操作，如果是的话则创建一个 Foo 初始化语句，否则则它只是某个其他方法调用，执行 handleCall 方法。在这一点上，源代码与上面描述的表示不同，在源代码中，我们不区分这两种其他方法调用。</p>
<p><strong>Concluding</strong></p>
<p>Soot为创建自己的抽象控制流图提供了一些支持，但是Java是一种大型语言，在实现从Jimple到自己的表示的转换时，必须考虑许多不同的方面。此外，您必须弄清楚Java构造如何映射到Jimple，然后Jimple构造应该如何映射到您的表示。但是除此之外，两个抽象类<code>AbstractStmtSwitch</code>和<code>soot.jimple.AbstractJimpleValueSwitch</code>为翻译提供了很好的起点，并且工作得很好。</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/01/18/Java%20%E5%AD%97%E8%8A%82%E7%A0%81/">← 下一篇 ASM字节码学习</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/01/12/Yakit/">Yakit单兵作战武器文档速查 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧</a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">RacerZ</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/RacerZ-fighting"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" href="qiyizhang2002@foxmail.com"><i class="fa fa-envelope" alt="E-Mail"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#A-Survivor%E2%80%99s-Guide-to-Java-Program-Analysis-with-Soot"><span class="toc-number">2.</span> <span class="toc-text">A Survivor’s Guide to Java Program Analysis with Soot</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Introduction"><span class="toc-number">2.1.</span> <span class="toc-text">1 Introduction</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E5%AE%89%E8%A3%85Soot"><span class="toc-number">2.2.</span> <span class="toc-text">1.1 安装Soot</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-Road-map-to-this-guide-%E8%B7%AF%E7%BA%BF%E5%9B%BE"><span class="toc-number">2.3.</span> <span class="toc-text">1.2 Road-map to this guide(路线图)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Basic-Soot-Constructs"><span class="toc-number">2.4.</span> <span class="toc-text">2 Basic Soot Constructs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-Method-bodies"><span class="toc-number">2.5.</span> <span class="toc-text">2.1 Method bodies</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-Statements"><span class="toc-number">2.6.</span> <span class="toc-text">2.2 Statements</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Values"><span class="toc-number">2.7.</span> <span class="toc-text">Values</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#References"><span class="toc-number">2.8.</span> <span class="toc-text">References</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Intermediate-Representations"><span class="toc-number">2.9.</span> <span class="toc-text">3 Intermediate Representations</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-Baf"><span class="toc-number">2.10.</span> <span class="toc-text">3.1 Baf</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-Jimple"><span class="toc-number">2.11.</span> <span class="toc-text">3.2 Jimple</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-Shimple"><span class="toc-number">2.12.</span> <span class="toc-text">3.3 Shimple</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-Grimp"><span class="toc-number">3.</span> <span class="toc-text">3.4 Grimp</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Soot-as-a-stand-alone-tool"><span class="toc-number">3.1.</span> <span class="toc-text">4 Soot as a stand-alone tool</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-Soot-phases"><span class="toc-number">3.2.</span> <span class="toc-text">4.1 Soot phases</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-Off-The-Shelf-Analysis"><span class="toc-number">3.3.</span> <span class="toc-text">4.2 Off-The-Shelf Analysis</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-Extending-Soot%E2%80%99s-Main-class"><span class="toc-number">3.4.</span> <span class="toc-text">4.3 Extending Soot’s Main class</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-The-Data-Flow-Framework"><span class="toc-number">3.5.</span> <span class="toc-text">5 The Data-Flow Framework</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-Step-1-Nature-of-the-analysis"><span class="toc-number">3.6.</span> <span class="toc-text">5.1 Step 1: Nature of the analysis</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-Step-2-Approximation-level"><span class="toc-number">3.7.</span> <span class="toc-text">5.2 Step 2: Approximation level</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-Step-3-Performing-flow"><span class="toc-number">3.8.</span> <span class="toc-text">5.3 Step 3: Performing flow</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-Step-4-Initial-state"><span class="toc-number">3.9.</span> <span class="toc-text">5.4 Step 4: Initial state</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-5-Limitations"><span class="toc-number">3.10.</span> <span class="toc-text">5.5 Limitations</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-6-Flow-sets"><span class="toc-number">3.11.</span> <span class="toc-text">5.6 Flow sets</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-7-Control-flow-graphs"><span class="toc-number">3.12.</span> <span class="toc-text">5.7 Control flow graphs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-8-Wrapping-the-results-of-the-analysis"><span class="toc-number">3.13.</span> <span class="toc-text">5.8 Wrapping the results of the analysis</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-Annotating-code"><span class="toc-number">3.14.</span> <span class="toc-text">6 Annotating code</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-Transformers"><span class="toc-number">3.15.</span> <span class="toc-text">6.1 Transformers</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-Annotating-very-busy-expressions"><span class="toc-number">3.16.</span> <span class="toc-text">6.2 Annotating very-busy expressions</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-Call-Graph-Construction"><span class="toc-number">3.17.</span> <span class="toc-text">7 Call Graph Construction</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-Call-Graph-Representation"><span class="toc-number">3.18.</span> <span class="toc-text">7.1 Call Graph Representation</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-More-specific-information"><span class="toc-number">3.19.</span> <span class="toc-text">7.2 More specific information</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-Points-To-Analysis"><span class="toc-number">3.20.</span> <span class="toc-text">8 Points-To Analysis</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-SPARK"><span class="toc-number">3.21.</span> <span class="toc-text">8.1 SPARK</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Using-SPARK"><span class="toc-number">3.22.</span> <span class="toc-text">Using SPARK</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-Paddle"><span class="toc-number">3.23.</span> <span class="toc-text">8.2 Paddle</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Using-Paddle"><span class="toc-number">3.24.</span> <span class="toc-text">Using Paddle</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-3-What-to-do-with-the-points-to-sets"><span class="toc-number">3.25.</span> <span class="toc-text">8.3 What to do with the points-to sets?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-Extracting-Abstract-Control-Flow-Graphs"><span class="toc-number">3.26.</span> <span class="toc-text">9 Extracting Abstract Control-Flow Graphs !!</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-The-Abstract-Foo-Control-flow-Graph"><span class="toc-number">3.27.</span> <span class="toc-text">9.1 The Abstract Foo Control-flow Graph</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-2-Implementation"><span class="toc-number">3.28.</span> <span class="toc-text">9.2 Implementation</span></a></li></ol></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside><div id="shadow-aside"></div></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>