<!DOCTYPE html><html lang="en" theme-mode="auto"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Java Sec —— RMI | RacerZ</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light' || window.matchMedia('(prefers-color-scheme:light)').matches) document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark' || window.matchMedia('(prefers-color-scheme:dark)').matches) document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><div id="shadow-header"></div><article><div id="post-bg"><div id="post-title"><h1>Java Sec —— RMI</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-09-15T16:00:00.000Z" id="date"> 2023-09-16</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-09-17T10:34:13.360Z" id="updated"> 2023-09-17</time></div></span></div></div><hr><div id="post-content"><h1 id="Java-学习笔记——RMI"><a href="#Java-学习笔记——RMI" class="headerlink" title="Java 学习笔记——RMI"></a>Java 学习笔记——RMI</h1><h2 id="0x00-BackGround"><a href="#0x00-BackGround" class="headerlink" title="0x00. BackGround"></a>0x00. BackGround</h2><p>RMI (Remote Method Invocation) 远程方法调用</p>
<blockquote>
<p>RMI 引入了两个概念，分别是 Stubs（客户端存根） 以及 Skeletons（服务端骨架），当客户端（Client）试    图调用一个在远端的 Object 时，实际调用的是客户端本地的一个代理类（Proxy），这个代理类就称为 Stub，而在调用远端（Server）的目标类之前，也会经过一个对应的远端代理类，就是 Skeleton，它从 Stub 中接收远程方法调用并传递给真实的目标类。</p>
</blockquote>
<p>可以看到，RMI 整个通信方式与邮件发送与接收所经过的协议流程类似</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled.png" alt="Untitled"></p>
<ul>
<li><p>RMI 所支持的特性：</p>
<ol>
<li><p>动态类加载</p>
<p> RMI 支持动态类加载，如果设置了 <code>java.rmi.server.codebase</code>，则会尝试从其中的地址获取 <code>.class</code> 并加载及反序列化</p>
<p> <kbd><strong>设置方法</strong>：</kbd></p>
<p> 开启 RMI 安全策略管理并配置对应的策略文件</p>
<p> <code>System.setProperty(&quot;java.rmi.server.codebase&quot;,&quot;[http://127.0.0.1:9999/](http://127.0.0.1:9999/)&quot;);</code></p>
<p> 使用启动参数 <code>-Djava.rmi.server.codebase=&quot;http://127.0.0.1:9999/&quot;</code> 进行指定</p>
</li>
</ol>
</li>
</ul>
<h2 id="0x01-源码解析"><a href="#0x01-源码解析" class="headerlink" title="0x01. 源码解析"></a>0x01. 源码解析</h2><ul>
<li><p>测试 demo</p>
<ul>
<li><p>Java code for Server side</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RemoteException, MalformedURLException, AlreadyBoundException, InterruptedException &#123;<br>        startReg();<br><br>        <span class="hljs-comment">// 创建远程对象</span><br>        <span class="hljs-type">RemoteInterface</span> <span class="hljs-variable">remoteObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteObject</span>();<br>        <span class="hljs-comment">// 绑定</span><br>        Naming.bind(<span class="hljs-string">&quot;rmi://localhost:1099/Hello&quot;</span>, remoteObject);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startReg</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br>            System.out.println(<span class="hljs-string">&quot;Server Start&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>Java code for Client side</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RemoteException, NotBoundException &#123;<br><br>        <span class="hljs-comment">// sun.rmi.registry.RegistryImpl_Stub</span><br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.getRegistry(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">1099</span>);<br><br>        System.out.println(Arrays.toString(registry.list()));<br><br>        <span class="hljs-comment">// lookup and call</span><br>        <span class="hljs-type">RemoteInterface</span> <span class="hljs-variable">stub</span> <span class="hljs-operator">=</span> (RemoteInterface) registry.lookup(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        System.out.println(stub.sayHello());<br>        System.out.println(stub.sayGoodbye());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>Java code for Remote object Interface</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RemoteInterface</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Remote</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Object name)</span> <span class="hljs-keyword">throws</span> RemoteException;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayGoodbye</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>Java code for Remote object Implementation</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteObject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnicastRemoteObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RemoteInterface</span> &#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">RemoteObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello My Friend&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Object name)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        <span class="hljs-keyword">return</span> name.getClass().getName();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayGoodbye</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Bye&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>流程分析</p>
</li>
</ul>
<h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><h3 id="1-远程对象创建"><a href="#1-远程对象创建" class="headerlink" title="1. 远程对象创建"></a>1. <strong>远程对象创建</strong></h3><p>起始于：<code>RemoteInterface remoteObject = new RemoteObject();</code></p>
<p>其继承于父类 <code>UnicastRemoteObject</code> 因此初始化时会调用其构造函数, port 默认为 0，并继续调用 <code>exportObject</code> 方法</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%201.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%201.png" alt="Untitled"></p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%202.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%202.png" alt="Untitled"></p>
<p>这里可以看到在 export 自身的同时，还会新建 UnicastServerRef 实例，这个东西内部会进一步创建一个 LiveRef 对象，由随机数+端口进行标识</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%203.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%203.png" alt="Untitled"></p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%204.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%204.png" alt="Untitled"></p>
<p>跟进发现，它还会继续调用 <code>TCPEndpoint.getLocalEndpoint(var2)</code></p>
<p>其中会初始化网络通信所需的 host port 等信息</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%205.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%205.png" alt="Untitled"></p>
<p>最终将 TCPEndpoint 实例赋值到 LiveRef 的 ep 字段中</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%206.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%206.png" alt="Untitled"></p>
<p>回到主线，Remote 对象会进一步通过 UnicastServerRef 实例进行 export</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%207.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%207.png" alt="Untitled"></p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%208.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%208.png" alt="Untitled"></p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%209.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%209.png" alt="Untitled"></p>
<p>可以看到该 <code>UnicastRef</code> 实例所存的就是之前保存了网络通信信息的 <code>LiveRef</code></p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2010.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2010.png" alt="Untitled"></p>
<p>跟进可以看到，首先创建了一个以 “_Stub” 为后缀的类实例（构造函数参数为包含已初始化<code>LiveRef</code> 的 <code>UnicastRef</code> 实例）</p>
<p>其次为 Remote 对象创建了动态代理（利用 <code>RemoteObjectInvocationHandler</code>）</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2011.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2011.png" alt="Untitled"></p>
<p>对于 <code>RemoteObjectInvocationHandler</code> 其 invoke 方法，当待调用代理方法非 Object 声明，并且方法名不是 finalize 时，会调用 <code>invokeRemoteMethod</code></p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2012.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2012.png" alt="Untitled"></p>
<p>这里可以看到实际上真正调用的是 <code>sun.rmi.server.UnicastRef#invoke(java.rmi.Remote, java.lang.reflect.Method, java.lang.Object[], long)</code></p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2013.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2013.png" alt="Untitled"></p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2014.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2014.png" alt="Untitled"></p>
<p>该方法会获取 LiveRef 当中的网络通信信息，创建连接，执行调用，并获取结果执行 <code>unmarshalValue</code> 进一步执行原生反序列化</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2015.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2015.png" alt="Untitled"></p>
<p>回到 createProxy 方法，，将动态代理和 Remote 实例封装到 Target 类当中之后调用 <code>sun.rmi.transport.LiveRef#exportObject</code> 方法，其会进一步调用 <code>TCPTransport#exportObject</code> 来监听端口</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2016.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2016.png" alt="Untitled"></p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2017.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2017.png" alt="Untitled"></p>
<p>注意到之后会将 Target 实例通过 <code>sun.rmi.transport.Transport#exportObject</code> 放到 ObjectTable 中</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2018.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2018.png" alt="Untitled"></p>
<p>该 ObjectTable 内部通过 HashMap 管理所有 Target 实例，支持通过 ObjectEndpoint 和 WeakRef 进行索引</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2019.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2019.png" alt="Untitled"></p>
<h3 id="2-注册中心创建"><a href="#2-注册中心创建" class="headerlink" title="2. 注册中心创建"></a>2. <strong>注册中心创建</strong></h3><p>起始于 <code>LocateRegistry.createRegistry(1099);</code></p>
<p>首先调用 RegistryImpl 构造函数，根据端口是否指定 1099 进入不同控制分支，但都会创建 LiveRef 通讯实例以及 UnicastServerRef 对象。接下来调用 setup 方法</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2020.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2020.png" alt="Untitled"></p>
<p>后者跟进 <code>UnicastServerRef#exportObject</code> 第一个参数为当前类实例 RegistryImpl</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2021.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2021.png" alt="Untitled"></p>
<p>后续流程同样走到 <code>sun.rmi.server.Util#createProxy</code> 不同点在于这里 stubClassExists 方法 <em><code>withoutStubs</code></em> map 是空的，因此会成功创建 <code>RegistryImpl_Stub</code> 实例并返回，不再进一步向下创建动态代理</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2022.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2022.png" alt="Untitled"></p>
<p><code>RegistryImpl_Stub</code> 类继承于 <code>RemoteStub</code> 并实现了一系列 bind list lookup 等服务操作 API</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2023.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2023.png" alt="Untitled"></p>
<p>与服务注册时使用的 <code>RemoteObjectInvocationHandler</code> 类似，其通信时数据传输也是通过直接序列化实现</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2024.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2024.png" alt="Untitled"></p>
<p>后续注册中心就会调用 <code>setSkeleton</code> 方法设置服务端 skeleton，可以看到实际会通过反射创建 <code>RegistryImpl_Skel</code> 实例，设置到 UnicastServerRef 的 <code>skel</code> 字段上</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2025.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2025.png" alt="Untitled"></p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2026.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2026.png" alt="Untitled"></p>
<p>后续流程与创建远程服务对象一致，创建 Target，并设置到 ObjectTable 中</p>
<h3 id="3-服务注册"><a href="#3-服务注册" class="headerlink" title="3. 服务注册"></a>3. <strong>服务注册</strong></h3><p>通用方法是 <code>registry.bind</code> </p>
<h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><h3 id="请求注册中心"><a href="#请求注册中心" class="headerlink" title="请求注册中心"></a>请求注册中心</h3><p>体现在 <code>LocateRegistry.getRegistry()</code></p>
<p><strong>「服务端行为」</strong>：</p>
<p>首先创建了一个包含注册中心通信地址的 RegistryImpl_Stub 对象；</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2027.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2027.png" alt="Untitled"></p>
<p>接下来调用 bind 方法进行服务对象和命名绑定时实际会调用 <code>sun.rmi.registry.RegistryImpl_Stub#bind</code> 方法，首先通过父类 UnicastRef 上设置好通讯地址的 ref 字段来调用 <code>sun.rmi.server.UnicastRef#newCall</code></p>
<p>这里就是简单通过 UnicastRef#newCall 与注册中心建立连接，后续直接写入输出流，写入方法名和远程实例</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2028.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2028.png" alt="Untitled"></p>
<p><aside><br>💡 这里存在疑问点：与 su18 师傅提到的调用方法存在出入，实际写入的应该是服务端之前已经保存在 ObjectTable 当中的 <code>RemoteObjectInvocationHandler</code> 动态代理（根据 Remote 实例来索引）<br>「可能的解释」：Registry 端与服务端在同一位置上，两者之前的通讯信息并非通过TCPTransport ，无法复现出 su18 师傅的信息，这里仔细看他的内容解释</aside></p>
<h2 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h2><p>以客户端获取到注册中心后，调用 lookup 寻找指定命名的 RMI 服务为例</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2029.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2029.png" alt="Untitled"></p>
<p>过程很简单，建立连接、序列化服务名称并写入输出流、获取到输入流并执行反序列化</p>
<p>Registry 端/服务端表现位于 <code>RegistryImpl_Skel</code> 的 dispatch 方法</p>
<h2 id="整体流程框架"><a href="#整体流程框架" class="headerlink" title="整体流程框架"></a>整体流程框架</h2><p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2030.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2030.png" alt="Untitled"></p>
<h2 id="0x02-Attack"><a href="#0x02-Attack" class="headerlink" title="0x02. Attack"></a>0x02. Attack</h2><h3 id="1-攻击-Server-端"><a href="#1-攻击-Server-端" class="headerlink" title="1. 攻击 Server 端"></a>1. <strong>攻击 Server 端</strong></h3><ul>
<li><p>恶意服务参数</p>
<p>  发生在客户端调用远程服务对象的方法时，通过获取到的远程代理，传输序列化的方法名（<em>SHA1 based hash</em>）及参数</p>
<p>  一般情况下，<strong>若远程服务接口对应的方法参数类型为 Object</strong>，则可以直接构造任意的序列化数据造成 RCE Attack</p>
<p>  但是若不知道方法参数具体类型，仍想要传输任意类型的序列化数据，该怎么办？</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2031.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2031.png" alt="Untitled"></p>
<p>  <strong>TODO</strong> 📭</p>
<p>  基本思路就是利用 agent 等方式，hook 住 RemoteObjectInvocationHandler 的 <code>invokeRemoteMethod</code> 方法方法，也就是客户端在利用代理，调用服务端对象方法时，参数类型传递时动态修改为指定要求的类型即可</p>
</li>
<li><p>动态类加载</p>
<p>  ==「适用版本」==6u45/7u21</p>
<p>  <strong>条件</strong>：SecurityManager + <code>java.rmi.server.useCodebaseOnly=false</code></p>
<p>  <strong>position</strong>: 反序列化操作发生在服务端接收响应客户端发来的网络请求时，调用的 <code>sun.rmi.server.UnicastServerRef#dispatch</code> 方法，序列化输入流由 <code>MarshalInputStream</code> 封装，期间执行 resolveClass 检查序列化数据</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2032.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2032.png" alt="Untitled"></p>
<p>  其 var5 反序列化得到指定 codebase url 地址，同时想要真正执行类加载，还需要满足 useCodebaseOnly 为 false，这也是为什么存在版本限制（6u45/7u21 默认为 false)</p>
<p>  重点在于 codebase 地址可以被双方控制</p>
</li>
</ul>
<h3 id="2-攻击-Registry-端"><a href="#2-攻击-Registry-端" class="headerlink" title="2. 攻击 Registry 端"></a>2. 攻击 Registry 端</h3><p>以 bind 为例，注册端知道会使用 <code>sun.rmi.registry.RegistryImpl_Skel#dispatch</code> 来接收服务端发来的序列化的服务名称以及远程代理对象，并通过 <code>RegistryImpl</code> 的 bind 方法保存在 bindings HashTable 中</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2033.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2033.png" alt="Untitled"></p>
<p>因此这里可以直接传递恶意的序列化远程代理类，在注册端反序列化时 RCE</p>
<p>具体的实践：yso_RMIRegistryExploit</p>
<p>yso 中以 CC1 为例，获取到 CC1 恶意 gadget 后，创建 Remote 代理(利用的 handler 是 AnnotationInvocationHandler，将 payload 设置到 handler 的 map 中，反序列化时伴随着触发)，之后通过 bind 序列化传递</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2034.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2034.png" alt="Untitled"></p>
<h3 id="3-攻击-DGC"><a href="#3-攻击-DGC" class="headerlink" title="3. 攻击 DGC"></a>3. 攻击 DGC</h3><blockquote>
<p>Server 端启动 DGCImpl，在 Registry 端注册 DGCImpl_Stub ，Client 端获取到 DGCImpl_Stub，通过其与 Server 端通信，Server 端使用 RegistryImpl_Skel 来处理。</p>
</blockquote>
<p>DGC 在客户端接收服务端返回的远程对象调用同时，会创建 DGCImpl_Stub 以及 DCGImpl_Skel 来维护远程对象的引用</p>
<p>==「DCGImpl_Skel#dispatch」==：监听请求</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2035.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2035.png" alt="Untitled"></p>
<p>==「DGCImpl_Stub#dirty/clean 更新/回收引用对象」==：</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2036.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2036.png" alt="Untitled"></p>
<h3 id="武器化Exploit-ysoserial-——-JRMP"><a href="#武器化Exploit-ysoserial-——-JRMP" class="headerlink" title="武器化Exploit: ysoserial —— JRMP"></a>武器化Exploit: ysoserial —— JRMP</h3><ul>
<li><p>JRMP Listener module</p>
<p>  本质是一条反序列化 Gadget ，可以达到在本地指定端口开启 JRMP 协议的效果</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Gadget chain:</span><br><span class="hljs-comment"> * UnicastRemoteObject.readObject(ObjectInputStream) line: 235</span><br><span class="hljs-comment"> * UnicastRemoteObject.reexport() line: 266</span><br><span class="hljs-comment"> * UnicastRemoteObject.exportObject(Remote, int) line: 320</span><br><span class="hljs-comment"> * UnicastRemoteObject.exportObject(Remote, UnicastServerRef) line: 383</span><br><span class="hljs-comment"> * UnicastServerRef.exportObject(Remote, Object, boolean) line: 208</span><br><span class="hljs-comment"> * LiveRef.exportObject(Target) line: 147</span><br><span class="hljs-comment"> * TCPEndpoint.exportObject(Target) line: 411</span><br><span class="hljs-comment"> * TCPTransport.exportObject(Target) line: 249</span><br><span class="hljs-comment"> * TCPTransport.listen() line: 319</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Requires:</span><br><span class="hljs-comment"> * - JavaSE</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Argument:</span><br><span class="hljs-comment"> * - Port number to open listener to</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p>  作用大致就是类似反连平台，可以自动响应连接请求，并返回指定的序列化数据</p>
<p>  ==「Gadget 构造」==：</p>
<p>  首先看下用到的类，首先拿到 <code>RemoteObject</code> 的构造函数（参数类型为<code>RemoteRef</code>, 参数实例传递子类 UnicastServerRef，并指定端口）</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2037.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2037.png" alt="Untitled"></p>
<p>  之后会调用 <code>sun.reflect.ReflectionFactory#newConstructorForSerialization</code> 传入 var1 代表 <code>ActivationGroupImpl</code> class，var2 代表指定 <code>RemoteObject</code> 构造器，当 var2 的声明类非 var1 时，会去创建序列化构造函数（<code>ActivationGroupImpl</code> 类）</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2038.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2038.png" alt="Untitled"></p>
<p>  这里的作用实际创建一个序列化构造函数，允许在反序列化时调用构造函数来创建新的对象实例</p>
<blockquote>
<p>如果想在反序列化时执行一些特殊的初始化或处理步骤，可以在类中定义一个特殊的构造函数，然后在该构造函数中执行这些操作。但请确保这个构造函数是 <strong><code>public</code></strong> 的且没有参数。</p>
</blockquote>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2039.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2039.png" alt="Untitled"></p>
<p>  最终返回的是 <code>ActivationGroupImpl</code> 实例，向上转型为 <code>UnicastRemoteObject</code>（好神奇</p>
<p>  最后反射设置字段 <code>port</code> 为指定端口</p>
<p>  ==「Gadget 反序列化分析」==：</p>
<p>  回忆 <code>UnicastRemoteObject</code> 的作用</p>
<blockquote>
<p><code>java.rmi.server.UnicastRemoteObject</code> 类通常是远程调用接口实现类的父类，或直接使用其静态方法 <code>exportObject</code> 来创建动态代理并随机监听本机端口以提供服务。</p>
</blockquote>
<p>  也就是我们在创建远程服务对象时声明其为父类的那个</p>
<p>  readObject 方法中会执行 reexport() </p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2040.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2040.png" alt="Untitled"></p>
<p>  之后指定端口 exportObject</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2041.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2041.png" alt="Untitled"></p>
<p>  export 过程中创建 UnicastServerRef 网络通信实例</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2042.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2042.png" alt="Untitled"></p>
<p>  之后的分析与前面一致了就，势必会打开指定端口的 JRMP 协议，监听请求，期间的网络传输数据采用序列化格式</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2043.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2043.png" alt="Untitled"></p>
<p>  那么 <code>ActivationGroupImpl</code> 在这里的作用是什么？</p>
<p>  这里不是很懂，应该是父类 UnicastRemoteObject 构造函数无法直接构造，或者使用 UnSafe 来构造也可以</p>
</li>
<li><p>JRMP JRMPClient(payload)</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * UnicastRef.newCall(RemoteObject, Operation[], int, long)</span><br><span class="hljs-comment"> * DGCImpl_Stub.dirty(ObjID[], long, Lease)</span><br><span class="hljs-comment"> * DGCClient$EndpointEntry.makeDirtyCall(Set&lt;RefEntry&gt;, long)</span><br><span class="hljs-comment"> * DGCClient$EndpointEntry.registerRefs(List&lt;LiveRef&gt;)</span><br><span class="hljs-comment"> * DGCClient.registerRefs(Endpoint, List&lt;LiveRef&gt;)</span><br><span class="hljs-comment"> * LiveRef.read(ObjectInput, boolean)</span><br><span class="hljs-comment"> * UnicastRef.readExternal(ObjectInput)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Thread.start()</span><br><span class="hljs-comment"> * DGCClient$EndpointEntry.&lt;init&gt;(Endpoint)</span><br><span class="hljs-comment"> * DGCClient$EndpointEntry.lookup(Endpoint)</span><br><span class="hljs-comment"> * DGCClient.registerRefs(Endpoint, List&lt;LiveRef&gt;)</span><br><span class="hljs-comment"> * LiveRef.read(ObjectInput, boolean)</span><br><span class="hljs-comment"> * UnicastRef.readExternal(ObjectInput)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Requires:</span><br><span class="hljs-comment"> * - JavaSE</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Argument:</span><br><span class="hljs-comment"> * - host:port to connect to, host only chooses random port (DOS if repeated many times)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Yields:</span><br><span class="hljs-comment"> * * an established JRMP connection to the endpoint (if reachable)</span><br><span class="hljs-comment"> * * a connected RMI Registry proxy</span><br><span class="hljs-comment"> * * one system thread per endpoint (DOS)</span><br></code></pre></td></tr></table></figure>
<p>  入口点从任意一个继承父类 RemoteObject 的对象开始，父类的 readObject 方法会进一步调用 ref 字段的 readExternal 方法</p>
<p>  <code>sun.rmi.server.UnicastRef#readExternal</code> 这里会调用 <code>[LiveRef.*read](http://LiveRef.read)</code>* 来恢复创建 ref 字段的通信实例</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2044.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2044.png" alt="Untitled"></p>
<p>  创建 TCPEndpoint 之后，会进一步调用 <code>DGCClient.*registerRefs*</code></p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2045.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2045.png" alt="Untitled"></p>
<p>  其中会循环获取所有通信节点，调用 <code>EndpointEntry#registerRefs</code> 最后调用 <code>makeDirtyCall</code></p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2046.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2046.png" alt="Untitled"></p>
<p>  最后触发 DGC 的 dirty 操作</p>
<blockquote>
<p>因此可以看出，在 UnicastRef 进行反序列化时，会触发 DGC 通信及 dirty 方法调用，此时如果与一个恶意服务通信，返回恶意数据流，则会造成反序列化漏洞。</p>
</blockquote>
<p>  yso 项目中使用的是 <code>RemoteObjectInvocationHandler</code> 作为 handler，封装成 <code>Registry</code> 的代理类</p>
<p>  利用：利用<code>JRMPClient</code>这个Gadget去调用<code>JRMPListener</code>,然后<code>JRMPListener</code>利用<code>CommonsCollections</code>这个Gadget来实现RCE。</p>
</li>
<li><p>精简版</p>
<p>  因为 <code>RemoteObjectInvocationHandler</code> 动态代理 <code>Registry</code> 接口形成的这个 Registry 已经后续被列入黑名单了，因此需要绕过。</p>
<ul>
<li><p>缩短链子</p>
<p>  我们知道上一条链子中 <code>UnicastRef</code> 实现了 <code>Externalizable</code> 接口，因此可以直接反序列化并调用重写 <code>readExternal</code> 方法，进而触发和前述一样的利用链</p>
<ul>
<li><p>Java Poc</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">(String command)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        String host;<br>        <span class="hljs-type">int</span> port;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sep</span> <span class="hljs-operator">=</span> command.indexOf(<span class="hljs-string">&#x27;:&#x27;</span>);<br>        <span class="hljs-keyword">if</span> ( sep &lt; <span class="hljs-number">0</span> ) &#123;<br>            port = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">65535</span>);<br>            host = command;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            host = command.substring(<span class="hljs-number">0</span>, sep);<br>            port = Integer.valueOf(command.substring(sep + <span class="hljs-number">1</span>));<br>        &#125;<br><br>        <span class="hljs-type">ObjID</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjID</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt()); <span class="hljs-comment">// RMI registry</span><br>        <span class="hljs-type">TCPEndpoint</span> <span class="hljs-variable">te</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TCPEndpoint</span>(host, port);<br>        <span class="hljs-type">UnicastRef</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnicastRef</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LiveRef</span>(id, te, <span class="hljs-literal">false</span>));<br><br>        <span class="hljs-keyword">return</span> ref;<br>    &#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>更换代理接口</p>
</li>
</ul>
</li>
</ul>
<h2 id="0x03-JEP-290"><a href="#0x03-JEP-290" class="headerlink" title="0x03. JEP 290"></a>0x03. JEP 290</h2><hr>
<p>提供的机制如下：</p>
<blockquote>
<p>(1) 提供一个限制反序列化类的机制，白名单或者黑名单</p>
<p>(2) 限制反序列化的深度和复杂度</p>
<p>(3) 为 RMI 远程调用对象(exportObject)提供了一个<strong>验证类</strong>的机制</p>
<p>(4) 定义一个可配置的<strong>过滤机制</strong>，比如可以通过配置 properties 文件的形式来定义过滤器</p>
</blockquote>
<p>版本：</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2047.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2047.png" alt="Untitled"></p>
<blockquote>
<p>JEP 290 主要是在 <code>ObjectInputStream</code> 类中增加了一个<code>serialFilter</code>属性和一个 <code>filterChcek</code> 函数，其中 <code>serialFilter</code>就可以理解为过滤器。<br>在 <code>ObjectInputStream</code> 对象进行 <code>readObject</code> 的时候，内部会调用 <code>filterChcek</code> 方法进行检查，<code>filterCheck</code>方法中会对 <code>`serialFilter</code>属性进行判断，如果不是 <code>null</code> ,就会调用 <code>serialFilter.checkInput</code> 方法进行过滤。<br>设置过滤器本质就是设置 <code>ObjectInputStream</code> 的 <code>serialFilter</code> 字段值，设置过滤器可以分为设置全局过滤器和设置局部过滤器：</p>
<ol>
<li>设置全局过滤器是指，通过修改 <code>Config.serialFilter</code>这个静态字段的值来达到设置所有 <code>ObjectInputStream</code>对象的 <code>serialFilter</code>值 。具体原因是因为 <code>ObjectInputStream</code> 的构造函数会读取<code>Config.serialFilter</code>的值赋值到自己的<code>serialFilter</code>字段上，所有就会导致所有 <code>new</code> 出来的 <code>ObjectInputStream</code>对象的 <code>serailFilter</code> 都为<code>Config.serialFilter</code>的值。</li>
<li>设置局部过滤器是指，在 <code>new</code> <code>ObjectInputStream</code> 的之后，再修改单个 <code>ObjectInputStream</code> 对象的 <code>serialFilter</code> 字段值</li>
</ol>
</blockquote>
<p>JEP290 机制，实际可以通过 JVM 穿参数或者配置文件的方式来设置防御规则，RMI 可采用默认白名单的防御规则。规则传入为字符串形式，在 <code>Global</code> 类的构造函数中进行解析，具体解析逻辑如下所示</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2048.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2048.png" alt="Untitled"></p>
<p>解析之后返回并设置到 ObjectInputFilter 类的 <em><code>configuredFilter</code></em> 字段上，当 ObjectInputStream 在初始化时，便会获取到 <em><code>configuredFilter</code></em> 字段上的实例，并设置到输入流的 serialFilter 字段之上。当进行 readObject 之前会自动触发 <code>filterCheck</code> 方法，进而 serialFilter 非空时调用 <code>serialFilter.checkInput</code> 枚举输入流中的类与规则进行匹配，进行合法性校验</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2049.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2049.png" alt="Untitled"></p>
<p><strong>「RMI 中 JEP290 机制的实现」</strong>：</p>
<p>RegistryImpl 在构造函数中，伴随着 <code>UnicastServerRef2</code> 的初始化，会通过 lambda 表达式以及方法引用的方式设置 RMI 的默认 JEP290 防御规则</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2050.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2050.png" alt="Untitled"></p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2051.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2051.png" alt="Untitled"></p>
<p>上图是 RegistryImpl 的 <em><code>registryFilter</code></em> 这个静态常量字段通过 JVM 传参或者配置文件的方式来设置过滤器</p>
<p>下图可以看到如果 <em><code>registryFilter</code></em> 为空，或者 checkInput 方法返回 Status.UNDECIDED 字面量的话则会采用 RMI 默认的 JEP 防御规则。</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2052.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2052.png" alt="Untitled"></p>
<p>在服务端后续处理序列化数据请求（匹配 RegistryImpl 对应的 ObjID）时，可以看到 RMI 通过 Config.setObjectInputFilter 的方式设置 RMI 局部过滤器，</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2053.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2053.png" alt="Untitled"></p>
<p>DGCImpl 与 RegistryImpl 设置过滤器的方式基本一致</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2054.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2054.png" alt="Untitled"></p>
<ul>
<li><p>RMI JEP290 绕过</p>
<p>  case1: <strong>如果服务端”绑定”了一个对象，他的方法参数类型是<code>Object</code> 类型的方法时，则可以绕过 JEP 290</strong></p>
<p>  本质：普通对象在 exportRemoteObject 时，不会像 RegistryImpl 和 DGCImpl 一样，注册带有初始化好的 filter 到 UnicastServerRef 上，进而在导出并封装到 Target 的过程中， disp 实际时 filter 字段为 null 的 UnicastServerRef。</p>
<p>  因此，后续在根据 ObjId 从 ObjectTable 中获取 Target 后 disp 后，再进行 dispatch 过程，上述的 unmarshalCustomCallData 方法由于 filter 为 null 因此会直接返回 null, 进而调用 unmarshalValue 方法触发原生反序列化的 source，不再进行 filterChcek 等类检查操作，绕过了 JEP 290 限制</p>
<p>  case2: 对于方法参数类型是由 Object 类型引申类型（如 String），可如下操作：</p>
<blockquote>
<ol>
<li><p>将 java.rmi 软件包的代码复制到新软件包，然后在其中更改代码</p>
</li>
<li><p>将调试器附加到正在运行的客户端，并在序列化对象之前替换对象</p>
</li>
<li><strong>使用 Javassist 之类的工具更改字节码</strong></li>
<li>通过实现代理来替换网络流上已经序列化的对象</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="0x04-Extension"><a href="#0x04-Extension" class="headerlink" title="0x04. Extension"></a>0x04. Extension</h2><ul>
<li><p>Pentest</p>
<ul>
<li><p>Discovery</p>
<p>  nmap 服务发现，支持 RMI 注册端口探测、接口探测以及具体代理实现的位置探测</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2055.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2055.png" alt="Untitled"></p>
</li>
</ul>
</li>
<li><p>easycve</p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2056.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2056.png" alt="Untitled"></p>
<p class='item-img' data-src='/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2057.png'><img src="/2023/09/16/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI%203ca75d88fc8d4a1b9988a56475a5b265/Untitled%2057.png" alt="Untitled"></p>
</li>
</ul>
<p>我们在远程复现时会遇到一个 trick：RMI 默认获取的 IP 地址为主机网卡的地址，而非浏览器上显示的公网地址，因此可能会出现服务端对象无法调用的情况，可以利用 debugger 或者反射修改一下 LiveRef 字段 ep 属性中的 host 值</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[1] <a target="_blank" rel="noopener" href="https://su18.org/post/rmi-attack/">https://su18.org/post/rmi-attack/</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://boogipop.com/2023/03/02/%E6%B5%85%E5%AD%A6RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/#Step4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF">浅学RMI反序列化 | Boogiepop Doesn’t Laugh (boogipop.com</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://github.com/mogwailabs/rmi-deserialization">mogwailabs/rmi-deserialization: Slides/Demos from the BSides Munich 2019 talk “Attacking Java RMI in 2019” (github.com)</a></p>
<p>[4] <a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/5392">JRMP安全问题分析-从CVE到CTF - 先知社区 (aliyun.com)</a></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2077/07/07/paper/">← Next paper梳理</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/08/10/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20cf32e5b66f974fa48c4a25d75639abd2/">Java Sec —— 原生反序列化 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">RacerZ</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/RacerZ-fighting"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" href="qiyizhang2002@foxmail.com"><i class="fa fa-envelope" alt="E-Mail"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RMI"><span class="toc-number">1.</span> <span class="toc-text">Java 学习笔记——RMI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-BackGround"><span class="toc-number">1.1.</span> <span class="toc-text">0x00. BackGround</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">0x01. 源码解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C"><span class="toc-number">1.3.</span> <span class="toc-text">服务注册</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 远程对象创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%88%9B%E5%BB%BA"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 注册中心创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. 服务注册</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">服务发现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">1.4.1.</span> <span class="toc-text">请求注册中心</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8"><span class="toc-number">1.5.</span> <span class="toc-text">服务调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E6%A1%86%E6%9E%B6"><span class="toc-number">1.6.</span> <span class="toc-text">整体流程框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-Attack"><span class="toc-number">1.7.</span> <span class="toc-text">0x02. Attack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%94%BB%E5%87%BB-Server-%E7%AB%AF"><span class="toc-number">1.7.1.</span> <span class="toc-text">1. 攻击 Server 端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%94%BB%E5%87%BB-Registry-%E7%AB%AF"><span class="toc-number">1.7.2.</span> <span class="toc-text">2. 攻击 Registry 端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%94%BB%E5%87%BB-DGC"><span class="toc-number">1.7.3.</span> <span class="toc-text">3. 攻击 DGC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A6%E5%99%A8%E5%8C%96Exploit-ysoserial-%E2%80%94%E2%80%94-JRMP"><span class="toc-number">1.7.4.</span> <span class="toc-text">武器化Exploit: ysoserial —— JRMP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-JEP-290"><span class="toc-number">1.8.</span> <span class="toc-text">0x03. JEP 290</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-Extension"><span class="toc-number">1.9.</span> <span class="toc-text">0x04. Extension</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">1.10.</span> <span class="toc-text">参考链接</span></a></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside><div id="shadow-aside"></div></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>